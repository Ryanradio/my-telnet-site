<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>âš”ï¸ DUNGEON QUEST  âš”ï¸</title>
   
   
   <style>

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ GLOBAL LAYOUT FIX (PUT THIS FIRST) â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
*,
*::before,
*::after {
    box-sizing: border-box;
}

html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden; /* prevents whole-page scrolling */
}

body {
    -webkit-user-select: none;
    user-select: none;
    touch-action: manipulation;
}

#gameWrapper {
    height: 100vh;
    height: 100dvh;   /* dynamic viewport height (fixes iOS) */
    display: flex;
    flex-direction: column;
    overflow: hidden;
    width: 100%;
}

#actionBar button {
    min-width: 64px;
    min-height: 44px;
    padding: 10px 14px;
    font-size: 16px;
    border-radius: 10px;
}

        @import url('https://fonts.googleapis.com/css2?family=VT323&family=Press+Start+2P&display=swap');

        :root {
            --primary-bg: #000080;
            --secondary-bg: #000000;
            --text-color: #00FF00;
            --highlight-color: #FFFF00;
            --error-color: #FF0000;
            --border-color: #00FFFF;
            --menu-color: #FFFFFF;
        }

        body {
            background: var(--primary-bg);
            color: var(--text-color);
            font-family: 'VT323', monospace;
            font-size: 20px;
            line-height: 1.4;
        }

        .scanline {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                transparent 50%,
                rgba(0, 0, 0, 0.25) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 1000;
            animation: flicker 0.15s infinite;
        }

        @keyframes flicker {
            0% { opacity: 0.95; }
            50% { opacity: 1; }
            100% { opacity: 0.95; }
        }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }

        @keyframes flashOrange {
            0%, 100% { color: #FF8C00; text-shadow: 0 0 6px #FF8C00; }
            50%      { color: #FFD700; text-shadow: 0 0 14px #FFD700; }
        }

        @keyframes flashRed {
            0%, 100% { color: #FF0000; text-shadow: 0 0 6px #FF0000; }
            50%      { color: #FF4444; text-shadow: 0 0 14px #FF4444; }
        }

        .dmg-player {
            animation: flashOrange 0.6s ease-in-out infinite;
            font-weight: bold;
        }

        .dmg-enemy {
            animation: flashRed 0.6s ease-in-out infinite;
            font-weight: bold;
        }

     .container {
    height: 100%;
    max-width: 900px;
    margin: 0 auto;
    padding: 0;
    display: flex;
    flex-direction: column;
    overflow: hidden; /* prevent container overflow */
}


        .header {
            flex-shrink: 0; /* prevent header from shrinking */
            text-align: center;
            border: 3px double var(--border-color);
            padding: 8px;
            margin-bottom: 8px;
            background: var(--secondary-bg);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .header h1 {
            font-family: 'Press Start 2P', monospace;
            font-size: 20px;
            color: var(--highlight-color);
            text-shadow: 2px 2px var(--error-color);
            margin-bottom: 5px;
            animation: titlePulse 2s infinite;
        }
        
        .header p {
            margin: 0;
            font-size: 16px;
        }

        @keyframes titlePulse {
            0%, 100% { text-shadow: 2px 2px var(--error-color); }
            50% { text-shadow: 2px 2px var(--error-color), 0 0 10px var(--highlight-color); }
        }

        /* â”€â”€â”€ main screen used by town / shop / menus â”€â”€â”€ */
        .screen {
            flex: 1 1 auto; /* allow screen to grow/shrink */
            min-height: 0; /* critical for flex scrolling */
            overflow-y: auto; /* enable scrolling */
            -webkit-overflow-scrolling: touch; /* smooth scrolling on iOS */
            
            background: var(--secondary-bg);
            border: 2px solid var(--border-color);
            padding: 12px;
            margin-bottom: 8px;
            box-shadow: inset 0 0 50px rgba(0, 255, 0, 0.1);
        }
        
        .menu-option {
            color: var(--menu-color);
            cursor: pointer;
            padding: 8px;
            margin: 5px 0;
            transition: all 0.1s;
        }
        .menu-option:hover {
            background: var(--primary-bg);
            color: var(--highlight-color);
            padding-left: 20px;
        }
        .menu-option.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            color: #666;
        }
        .menu-option.disabled:hover {
            background: transparent;
            padding-left: 8px;
        }

        /* â”€â”€â”€ static HUD â”€â”€â”€ */
#hud {
    display: none; /* JS controls visibility */
    flex-shrink: 0; /* prevent HUD from shrinking */
    
    background: var(--secondary-bg);
    border: 2px solid var(--border-color);
    border-bottom: none;
    padding: 6px 10px;
    box-shadow: inset 0 0 30px rgba(0,255,0,0.08);
}


        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 4px;
        }
        .hud-top .hud-name { color: var(--highlight-color); font-size: 18px; }
        .hud-top .hud-gold { color: #FFD700; font-size: 16px; }
        .hud-bars {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }
        .hud-bar-group label {
            color: var(--highlight-color);
            font-size: 14px;
            display: block;
            margin-bottom: 2px;
        }
        .hud-bar-group .bar-nums { color: var(--text-color); font-size: 14px; }
        .progress-bar {
            width: 100%;
            height: 12px;
            background: #111;
            border: 1px solid var(--border-color);
            margin-top: 2px;
        }
        .progress-fill { height: 100%; transition: width 0.35s ease; }
        .hp-bar { background: var(--error-color); }
        .mp-bar { background: #4488ff; }
        .xp-bar { background: var(--text-color); }

        /* â”€â”€â”€ scrolling terminal â”€â”€â”€ */
#terminalWindow {
    display: none;
    flex: 1 1 auto;
    min-height: 0; /* REQUIRED for flex scrolling */
    overflow-y: auto;
    -webkit-overflow-scrolling: touch; /* smooth scrolling on iOS */
    
    background: var(--secondary-bg);
    border: 2px solid var(--border-color);
    border-top: 1px solid #333;
    padding: 8px 10px;
    box-shadow: inset 0 0 40px rgba(0,255,0,0.07);
    scroll-behavior: smooth;
}

        .term-line {
            padding: 2px 0;
            font-size: 16px;
            color: var(--text-color);
            line-height: 1.3;
        }
        .term-line.term-dim       { color: #3a7a3a; }
        .term-line.term-highlight { color: var(--highlight-color); }
        .term-line.term-enemy     { color: var(--border-color); font-size: 17px; }
        .term-line.term-loot      { font-size: 17px; }
        .term-line.term-system    { color: #888; font-style: italic; }
        .term-line.term-separator { margin-top: 6px; padding-top: 6px; border-top: 1px solid #2a4a2a; }

        /* â”€â”€â”€ action bar at bottom â”€â”€â”€ */
#actionBar {
    flex-shrink: 0; /* prevent action bar from shrinking */
    display: none;
    background: var(--secondary-bg);
    border: 2px solid var(--border-color);
    border-top: 1px solid #444;
    padding: 6px;
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    justify-content: center;
}

        #actionBar button {
            background: linear-gradient(180deg, #1a1a1a 0%, #0a0a0a 100%);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            padding: 8px 12px;
            font-family: 'VT323', monospace;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.15s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
            min-width: 60px;
            min-height: 40px;
        }
        
        /* Combat action buttons */
        .action-icon-btn {
            flex: 1;
            min-width: 80px !important;
            padding: 10px 8px !important;
            text-align: center;
        }
        
        /* Target selection buttons */
        .target-btn {
            flex: 1;
            min-width: 120px !important;
            padding: 10px !important;
            background: linear-gradient(180deg, #0a2a0a 0%, #051505 100%) !important;
            border-color: var(--text-color) !important;
        }
        
        .target-btn:hover:not(:disabled) {
            background: linear-gradient(180deg, #0f3f0f 0%, #0a2a0a 100%) !important;
            border-color: var(--highlight-color) !important;
            color: var(--highlight-color) !important;
        }
        
        /* Spell selection buttons */
        .spell-btn {
            flex: 1;
            min-width: 100px !important;
            padding: 10px !important;
            background: linear-gradient(180deg, #1a1a2a 0%, #0a0a15 100%) !important;
            border-color: #4488ff !important;
        }
        
        .spell-btn:hover:not(:disabled) {
            background: linear-gradient(180deg, #2a2a4a 0%, #1a1a2a 100%) !important;
            border-color: #88bbff !important;
            color: #88bbff !important;
        }
        #actionBar button:hover {
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
            color: var(--highlight-color);
            border-color: var(--highlight-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 255, 0, 0.3);
        }
        #actionBar button:active {
            transform: translateY(0);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.8);
        }
        #actionBar button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        /* Mobile adjustments */
        @media (max-width: 600px) {
            .header {
                padding: 6px;
                margin-bottom: 6px;
            }
            
            .header h1 {
                font-size: 16px;
                margin-bottom: 3px;
            }
            
            .header p {
                font-size: 14px;
            }
            
            #hud {
                padding: 4px 8px;
            }
            
            .hud-top .hud-name { font-size: 16px; }
            .hud-top .hud-gold { font-size: 14px; }
            
            .hud-bars {
                grid-template-columns: 1fr;
                gap: 4px;
            }
            
            .hud-bar-group label {
                font-size: 13px;
            }
            
            .hud-bar-group .bar-nums {
                font-size: 13px;
            }
            
            .progress-bar {
                height: 10px;
            }
            
            #terminalWindow {
                padding: 6px 8px;
            }
            
            .term-line {
                font-size: 15px;
                line-height: 1.25;
            }
            
            #actionBar {
                padding: 5px;
                gap: 5px;
            }
            
            #actionBar button {
                font-size: 14px;
                padding: 6px 10px;
                min-width: 56px;
                min-height: 38px;
            }
        }

        .term-line.term-victory   { color: var(--border-color); font-size: 22px; }
        .term-line.term-loot      { color: #FFD700; }
        .term-line.term-error     { color: var(--error-color); }
        .term-line.term-separator { border-top: 1px solid #2a5a2a; margin: 6px 0 4px; padding-top: 4px; }
        .enemy-card {
            border: 2px solid var(--error-color);
            padding: 8px 12px;
            margin: 6px 0;
            background: rgba(255,0,0,0.05);
            display: inline-block;
            min-width: 260px;
            vertical-align: top;
        }
        .enemy-card.is-target { border-color: var(--highlight-color); }
        .enemy-card .ec-name  { font-size: 21px; margin-bottom: 4px; }
        .enemy-card .ec-hp    { font-size: 18px; color: var(--text-color); }

   
   
  #actionBar {
    flex-shrink: 0;

    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;

    padding: 12px;
    background: var(--secondary-bg);
    border-top: 2px solid var(--border-color);
}



#actionbar button {
    flex: 0 0 auto;
}





        #actionBar .action-label { color: var(--highlight-color); font-size: 18px; margin-bottom: 6px; }
        #actionBar .timer-line   { color: var(--highlight-color); font-size: 19px; margin-bottom: 4px; }

        /* â”€â”€â”€ legacy helpers for shop / inventory / town â”€â”€â”€ */
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid var(--border-color);
            background: rgba(0,128,0,0.1);
        }
        .stat       { color: var(--text-color); }
        .stat-label { color: var(--highlight-color); }
        .message {
            padding: 10px;
            margin: 10px 0;
            border-left: 3px solid var(--border-color);
        }
        .combat-message  { color: var(--highlight-color); font-weight: bold; }
        .error-message   { color: var(--error-color); }
        .success-message { color: var(--border-color); }

        button {
            background: var(--secondary-bg);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            padding: 10px 20px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) {
            background: var(--primary-bg);
            color: var(--highlight-color);
            box-shadow: 0 0 10px var(--border-color);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        input {
            background: var(--secondary-bg);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            padding: 10px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            width: 100%;
            margin: 10px 0;
        }

        .character-select {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .class-card {
            border: 2px solid var(--border-color);
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--secondary-bg);
        }

        .class-card:hover {
            background: var(--primary-bg);
            box-shadow: 0 0 15px var(--border-color);
            transform: scale(1.05);
        }

        .class-card.selected {
            border-color: var(--highlight-color);
            background: var(--primary-bg);
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .item-card {
            border: 1px solid var(--border-color);
            padding: 10px;
            background: rgba(0, 128, 0, 0.05);
        }

        .equipped {
            border-color: var(--highlight-color);
            background: rgba(255, 255, 0, 0.1);
        }

        .cursor {
            display: inline-block;
            width: 10px;
            height: 20px;
            background: var(--text-color);
            animation: blink 1s infinite;
            margin-left: 5px;
        }

        .location-header {
            font-family: 'Press Start 2P', monospace;
            font-size: 16px;
            color: var(--border-color);
            text-align: center;
            padding: 10px;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: 15px;
        }

        .enemy-display {
            text-align: center;
            padding: 20px;
            border: 2px solid var(--error-color);
            margin: 15px 0;
            background: rgba(255, 0, 0, 0.05);
        }

        .ascii-art {
            font-family: monospace;
            font-size: 14px;
            line-height: 1.2;
            white-space: pre;
            color: var(--text-color);
        }

        /* SYSOP Terminal Styles */
        .terminal-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--secondary-bg);
            border-top: 3px solid var(--error-color);
            padding: 10px 20px;
            z-index: 999;
            max-height: 300px;
            overflow-y: auto;
            display: none;
            box-shadow: 0 -5px 20px rgba(255, 0, 0, 0.5);
        }

        .terminal-container.active {
            display: block;
            animation: terminalSlideUp 0.3s;
        }

        @keyframes terminalSlideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        .terminal-header {
            color: var(--error-color);
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            margin-bottom: 10px;
            text-align: center;
            border-bottom: 1px solid var(--error-color);
            padding-bottom: 5px;
        }

        .terminal-output {
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
            color: var(--text-color);
        }

        .terminal-line {
            margin: 3px 0;
        }

        .terminal-error {
            color: var(--error-color);
        }

        .terminal-success {
            color: var(--border-color);
        }

        .terminal-warning {
            color: var(--highlight-color);
        }

        .terminal-input-line {
            display: flex;
            align-items: center;
        }

        .terminal-prompt {
            color: var(--error-color);
            margin-right: 10px;
        }

        .terminal-input {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--text-color);
            font-family: 'VT323', monospace;
            font-size: 20px;
            outline: none;
        }

        .sysop-badge {
            position: fixed;
            top: 10px;
            right: 10px;
            background: var(--error-color);
            color: var(--secondary-bg);
            padding: 5px 10px;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            border: 2px solid var(--highlight-color);
            z-index: 998;
            display: none;
            animation: badgePulse 2s infinite;
        }

        .sysop-badge.active {
            display: block;
        }

        @keyframes badgePulse {
            0%, 100% { box-shadow: 0 0 5px var(--error-color); }
            50% { box-shadow: 0 0 20px var(--error-color); }
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1001;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: var(--secondary-bg);
            border: 3px solid var(--error-color);
            padding: 20px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 30px var(--error-color);
        }


        .action-icon-btn {
            width: 52px;
            height: 52px;
            font-size: 24px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 2px solid var(--border-color);
            background: var(--secondary-bg);
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .action-icon-btn:hover:not(:disabled) {
            background: var(--primary-bg);
            border-color: var(--highlight-color);
            transform: scale(1.05);
        }
        
        .action-icon-btn:active:not(:disabled) {
            transform: scale(0.95);
        }
        
        .action-icon-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RESPONSIVE MOBILE/TABLET DESIGN
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        @media (max-width: 768px) {
            body {
                font-size: 18px;
                padding: 0;
                margin: 0;
            }
            
            .container {
                max-width: 100%;
                padding: 8px;
                margin: 0;
            }
            
            .header {
                padding: 8px;
                margin-bottom: 8px;
            }
            
            .header h1 {
                font-size: 18px;
                margin-bottom: 4px;
            }
            
            .header .subtitle {
                font-size: 12px;
            }
            
            .screen {
                padding: 10px;
                min-height: 300px;
                margin-bottom: 10px;
            }
            
            .location-header {
                font-size: 20px;
                padding: 8px;
                margin-bottom: 8px;
            }
            
            .stats-bar {
                font-size: 16px;
                padding: 8px;
                margin-bottom: 8px;
            }
            
            .progress-bar {
                height: 12px;
            }
            
            .menu-option {
                padding: 10px;
                font-size: 18px;
                margin: 6px 0;
            }
            
            button {
                padding: 10px 15px;
                font-size: 16px;
                margin: 4px 2px;
            }
            
            input[type="text"] {
                font-size: 18px;
                padding: 10px;
                width: 100%;
                box-sizing: border-box;
            }
            
            /* Character select cards - stack vertically */
            .character-select {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .class-card {
                padding: 12px;
            }
            
            .class-card div {
                font-size: 16px !important;
            }
            
            /* Inventory grid - 2 columns on mobile */
            .inventory-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }
            
            .item-card {
                padding: 8px;
                font-size: 15px;
            }
            
            .item-card button {
                padding: 6px 10px;
                font-size: 14px;
            }
            
            /* HUD - compact on mobile */
            #hud > div {
                padding: 6px !important;
                font-size: 16px !important;
            }
            
            #hud > div > div {
                gap: 10px !important;
            }
            
           /* Terminal - adjust for mobile screen */
#terminalWindow {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
    font-size: 17px;
}

            
            .term-line {
                font-size: 17px;
                line-height: 1.3;
                margin: 3px 0;
            }
            
            /* Enemy cards removed - info shown in terminal only */
            
            /* Action bar - stack buttons vertically on very small screens */
            #actionBar {
                padding: 8px;
            }
            
            #actionBar button {
                margin: 3px 2px;
                padding: 8px 10px;
                font-size: 15px;
            }
            
            .action-icon-btn {
                width: 48px;
                height: 48px;
                font-size: 22px;
            }
            
            .action-label {
                font-size: 16px;
                margin: 6px 0 3px 0;
            }
            
            /* Stat allocation screen */
            #mainScreen > div[style*="max-width:520px"] {
                max-width: 100% !important;
            }
            
            /* Make tables/grids more compact */
            .message {
                padding: 10px;
                font-size: 17px;
            }
            
            .stat-label {
                font-size: 17px;
            }
            
            /* ASCII art - smaller on mobile */
            .ascii-art {
                font-size: 10px;
                line-height: 1.1;
            }
        }
        
        /* Extra small phones */
        @media (max-width: 480px) {
            body {
                font-size: 16px;
            }
            
            .container {
                padding: 4px;
            }
            
            .header h1 {
                font-size: 16px;
            }
            
            button {
                padding: 8px 12px;
                font-size: 14px;
                margin: 3px 1px;
            }
            
            .menu-option {
                padding: 8px;
                font-size: 16px;
            }
            
            #terminalWindow {
                
                padding: 8px;
                font-size: 16px;
            }
            
            .term-line {
                font-size: 16px;
            }
            
            /* Inventory - single column on very small screens */
            .inventory-grid {
                grid-template-columns: 1fr;
            }
            
            /* Action icon buttons stay as icons on small phones */
            .action-icon-btn {
                width: 44px;
                height: 44px;
                font-size: 20px;
            }
            
            /* Other action bar buttons (target selection, etc) */
            #actionBar button:not(.action-icon-btn) {
                padding: 8px 12px;
                margin: 3px 2px;
            }
            
            .location-header {
                font-size: 18px;
            }
            
            /* Enemy cards removed - info shown in terminal only */
        }
        
        /* Landscape tablets */
        @media (min-width: 769px) and (max-width: 1024px) {
            .container {
                max-width: 95%;
                padding: 15px;
            }
            
            .character-select {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .inventory-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        /* Portrait tablets */
        @media (min-width: 481px) and (max-width: 768px) and (orientation: portrait) {
            .character-select {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .inventory-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            #terminalWindow {
                }
        }
        
        /* Prevent text selection on double-tap (mobile) */
        @media (hover: none) and (pointer: coarse) {
            button, .menu-option, .class-card, .item-card, .enemy-card {
                -webkit-tap-highlight-color: rgba(0, 255, 0, 0.2);
                user-select: none;
                -webkit-user-select: none;
            }
        }

       
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   TERMINAL MODE â€“ SHOW GAMEPLAY UI
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* Hide menu when in terminal mode */
body.terminal-mode #mainScreen {
    display: none;
}

/* Hide gameplay wrapper when NOT in terminal mode */
body:not(.terminal-mode) #gameWrapper {
    display: none;
}

/* Show gameplay wrapper in terminal mode */
body.terminal-mode #gameWrapper {
    display: flex;
    flex-direction: column;
    height: 100%;
}

/* HUD and action bar should be visible */
body.terminal-mode #hud,
body.terminal-mode #actionBar {
    display: block;
}

/* Terminal should fill remaining space */
body.terminal-mode #terminalWindow {
    display: block;
    flex: 1;
    min-height: 0;   /* IMPORTANT for flex scroll */
    overflow-y: auto;
}


        
    </style>
</head>
<body>
    <div class="scanline"></div>
    
    <div class="container">
        <div class="header">
            <h1>âš”ï¸ DUNGEON QUEST âš”ï¸</h1>
            <div style="color: var(--border-color);">â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</div>
            <div style="color: var(--menu-color); font-size: 16px;">A Classic Text Adventure</div>
        </div>

  
  <div class="screen" id="mainScreen">
    <!-- Menu / town content -->
</div>

<!-- GAMEPLAY WRAPPER -->
<div id="gameWrapper">

    <!-- HUD -->
    <div id="hud">
        <div class="hud-inner">
            <div id="hudName"></div>
            <div class="hud-stats">
                <span id="hudGold"></span>
                <span id="hudHpNums"></span>
                <span id="hudMpNums"></span>
                <span id="hudXpNums"></span>
            </div>
        </div>
    </div>

    <!-- TERMINAL -->
    <div id="terminalWindow"></div>

    <!-- ACTION BAR -->
    <div id="actionBar"></div>

</div>


</div>

    </div>
</div>    

    <!-- SYSOP Terminal -->
    <div class="sysop-badge" id="sysopBadge">âš  SYSOP MODE âš </div>
    <div class="terminal-container" id="terminalContainer">
        <div class="terminal-header">â•â•â• SYSOP TERMINAL â•â•â•</div>
        <div class="terminal-output" id="terminalOutput"></div>
        <div class="terminal-input-line">
            <span class="terminal-prompt">root@dungeon:~#</span>
            <input type="text" class="terminal-input" id="terminalInput" autocomplete="off">
        </div>
    </div>

    <!-- Modal for forms -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal-content" id="modalContent"></div>
    </div>

    <!-- External Game Data Files -->
    <script src="dungeon-data.js"></script>
    <script src="monsters.js"></script>
    <script src="weapons.js"></script>
    <script src="armor.js"></script>
    <script src="items.js"></script>
    <script src="class-masters.js"></script>

    <script>

        // ğŸ”‘ Prevent UI reset after restore (mobile fix)
// gameState.hasRestoredGame = false;


function updateTerminalSafeArea() {
    const term = document.getElementById('terminalWindow');
    const bar  = document.getElementById('actionBar');
    if (!term || !bar) return;

    const barHeight = bar.offsetHeight;
    term.style.paddingBottom = barHeight + 'px';
}



// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Direction helpers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const OPPOSITE_DIR = {
    N: 'South',
    S: 'North',
    E: 'West',
    W: 'East',
    NE: 'Southwest',
    NW: 'Southeast',
    SE: 'Northwest',
    SW: 'Northeast'
};



        // Game Data Structures
        const CLASSES = {
            warrior: {
                name: 'Warrior',
                hp: 120,
                mp: 20,
                strength: 15,
                defense: 12,
                magic: 3,
                speed: 7,
                description: 'Master of melee combat with high HP and defense',
                startWeapon: 'iron_sword',
                startArmor: 'leather_armor'
            },
            rogue: {
                name: 'Rogue',
                hp: 80,
                mp: 30,
                strength: 10,
                defense: 6,
                magic: 5,
                speed: 15,
                description: 'Swift and deadly, strikes first with critical hits',
                startWeapon: 'dagger',
                startArmor: 'cloth_armor'
            },
            paladin: {
                name: 'Paladin',
                hp: 100,
                mp: 50,
                strength: 12,
                defense: 10,
                magic: 8,
                speed: 8,
                description: 'Holy warrior with healing magic and strong defense',
                startWeapon: 'mace',
                startArmor: 'chainmail'
            },
            mage: {
                name: 'Mage',
                hp: 60,
                mp: 100,
                strength: 5,
                defense: 4,
                magic: 18,
                speed: 9,
                description: 'Powerful spellcaster with devastating magic',
                startWeapon: 'staff',
                startArmor: 'robes'
            },
            cleric: {
                name: 'Cleric',
                hp: 90,
                mp: 70,
                strength: 8,
                defense: 8,
                magic: 12,
                speed: 7,
                description: 'Divine healer with support spells and moderate combat',
                startWeapon: 'mace',
                startArmor: 'leather_armor'
            },
            ranger: {
                name: 'Ranger',
                hp: 85,
                mp: 40,
                strength: 11,
                defense: 7,
                magic: 6,
                speed: 13,
                description: 'Skilled archer with nature magic and tracking',
                startWeapon: 'bow',
                startArmor: 'leather_armor'
            }
        };


        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STAT SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const STAT_BUDGET  = 30;
        const STAT_NAMES   = ['str','dex','wis','cha','con','lck'];
        const STAT_LABELS  = { str:'STR', dex:'DEX', wis:'WIS', cha:'CHA', con:'CON', lck:'LCK' };
        const STAT_DESCS   = {
            str:'Physical damage & multi-hit',
            dex:'Dodge chance & flee success',
            wis:'Spell power & magic resist',
            cha:'Shop prices & negotiation',
            con:'Max HP bonus & defense',
            lck:'Crit chance & loot luck'
        };
        // Opposed pairs: reroll engine biases against extremes in both.
        // Paladin is EXEMPT from str<->wis opposition.
        const OPPOSED_PAIRS = [['str','wis'],['dex','cha'],['con','lck']];

        const CLASS_STAT_PRESETS = {
            warrior : { str:10, dex:4, wis:2, cha:2, con:8, lck:4 },
            rogue   : { str:4,  dex:10,wis:2, cha:4, con:4, lck:6 },
            paladin : { str:7,  dex:3, wis:7, cha:4, con:6, lck:3 },
            mage    : { str:2,  dex:3, wis:10,cha:3, con:4, lck:8 },
            cleric  : { str:3,  dex:2, wis:9, cha:6, con:6, lck:4 },
            ranger  : { str:5,  dex:8, wis:3, cha:3, con:5, lck:6 }
        };
        const CLASS_AFFINITIES = {
            warrior :['str','con'],
            rogue   :['dex','lck'],
            paladin :['str','wis','cha'],
            mage    :['wis','lck'],
            cleric  :['wis','cha'],
            ranger  :['dex','lck']
        };

        // â”€â”€ derived-stat helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function calcPlayerHits(p) {
            let h = 1;
            if (p.class === 'rogue') h++;           // rogue class bonus
            h += Math.floor((p.level || 1) / 4);    // +1 every 4 levels
            h += Math.floor(Math.max(0, (p.str||0) - 8) / 6);  // STR scaling
            return h;
        }
        function calcChaDiscount(cha) { return Math.min(30, (cha||0) * 2); }   // buy %  off
        function calcChaSellBonus(cha){ return Math.min(15, (cha||0) * 1); }   // sell %  bonus
        function calcInnCost(cha)     { return Math.max(20, 50 - (cha||0)); }
        function calcCritChance(lck)  { return Math.min(30,  5 + (lck||0)); }  // %
        function calcDodgeChance(dex) { return Math.min(40, (dex||0) * 2); }   // %
        function calcLootBonus(lck)   { return Math.min(25, (lck||0) * 2); }   // extra %

        // random reroll: scatter STAT_BUDGET among 6 stats (min 1 each)
        function rerollStats(classKey) {
            const s = { str:1, dex:1, wis:1, cha:1, con:1, lck:1 };
            let rem = STAT_BUDGET - 6;
            while (rem-- > 0) s[STAT_NAMES[Math.floor(Math.random()*6)]]++;
            return s;
        }

        const SPELLS = {
            heal: { name: 'Heal', mpCost: 15, power: 30, type: 'heal', level: 1, description: 'Restore HP' },
            fireball: { name: 'Fireball', mpCost: 20, power: 35, type: 'attack', level: 2, description: 'Fiery attack' },
            lightning: { name: 'Lightning', mpCost: 25, power: 45, type: 'attack', level: 4, description: 'Electric damage' },
            greater_heal: { name: 'Greater Heal', mpCost: 30, power: 60, type: 'heal', level: 5, description: 'Major healing' },
            ice_storm: { name: 'Ice Storm', mpCost: 35, power: 55, type: 'attack', level: 6, description: 'Freezing assault' },
            holy_light: { name: 'Holy Light', mpCost: 20, power: 25, type: 'attack', level: 3, description: 'Divine damage' },
            meteor: { name: 'Meteor', mpCost: 50, power: 80, type: 'attack', level: 8, description: 'Devastating spell' }
        };

        const LOCATIONS = {
            town: {
                name: 'Silverdale Town',
                description: 'A peaceful town with shops and an inn. Your adventure begins here.',
                canRest: true,
                hasShop: true
            },
            forest: {
                name: 'Whispering Forest',
                description: 'A dark forest filled with minor creatures.',
                enemyLevelRange: [1, 3],
                encounters: ['goblin', 'wolf', 'giant_spider'],
                requiredLevel: 1,
                locked: false
            },
            plains: {
                name: 'Endless Plains',
                description: 'Open grasslands with roaming beasts.',
                enemyLevelRange: [2, 5],
                encounters: ['orc', 'dire_wolf', 'bandit'],
                requiredLevel: 3,
                locked: true,
                unlockMessage: 'Defeat your class master in the forest to unlock this area!'
            },
            cave: {
                name: 'Shadow Cavern',
                description: 'A dungeon filled with dangerous monsters.',
                enemyLevelRange: [4, 7],
                encounters: ['troll', 'skeleton_warrior', 'dark_mage'],
                requiredLevel: 6,
                locked: true,
                unlockMessage: 'Defeat your class master in the plains to unlock this area!'
            },
            crypt: {
                name: 'Ancient Crypt',
                description: 'An ancient tomb haunted by the undead.',
                enemyLevelRange: [6, 9],
                encounters: ['lich', 'death_knight', 'wraith'],
                requiredLevel: 9,
                locked: true,
                unlockMessage: 'Defeat your class master in the cave to unlock this area!'
            },
            volcano: {
                name: 'Fire Mountain',
                description: 'A volcanic peak home to fierce creatures.',
                enemyLevelRange: [8, 12],
                encounters: ['fire_elemental', 'red_dragon', 'demon'],
                requiredLevel: 12,
                locked: true,
                unlockMessage: 'Defeat your class master in the crypt to unlock this area!'
            }
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MODEM SPEED SIMULATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const MODEM_SPEEDS = {
            '56k': 7,      // ~7 characters per frame (56k modem)
            '28.8k': 4,    // ~4 characters per frame (28.8k modem)
            '14.4k': 2,    // ~2 characters per frame (14.4k modem)
            'instant': -1  // No delay
        };
        
        let currentModemSpeed = '14.4k'; // Default to 14.4k modem (authentic BBS experience)
        let isStreaming = false;
        let streamCancelled = false;
        
        function streamText(element, html, callback) {
           if (currentModemSpeed === 'instant') {
    line.innerHTML = html;

    // âœ… STEP 3A: scroll AFTER line is fully rendered
    if (shouldAutoScroll) {
        tw.scrollTop = tw.scrollHeight;
    }

    if (onDone) onDone();
    termDrain();
    return;
}

            
            isStreaming = true;
            streamCancelled = false;
            
            // Strip HTML tags for character counting but keep them for display
            const charsPerFrame = MODEM_SPEEDS[currentModemSpeed];
            let currentIndex = 0;
            
            const interval = setInterval(() => {
                if (streamCancelled) {
                    clearInterval(interval);
                    element.innerHTML = html;
                    isStreaming = false;
                    if (callback) callback();
                    return;
                }
                
                currentIndex += charsPerFrame;
                
                if (currentIndex >= html.length) {
                    clearInterval(interval);
                    element.innerHTML = html;
                    isStreaming = false;
                    if (callback) callback();
                } else {
                    // Display partial HTML up to current index
                    element.innerHTML = html.substring(0, currentIndex) + '<span style="animation: blink 1s infinite;">_</span>';
                }
            }, 16); // ~60fps
        }
        
        function cancelStream() {
            streamCancelled = true;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SAVE FILE ENCRYPTION (Anti-Cheat)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // Simple but effective encryption key (obfuscated in code)
        const SAVE_KEY = 'DQ_' + btoa('DUNGEON_QUEST_2026').split('').reverse().join('');
        
        function encryptSave(data) {
            try {
                const jsonStr = JSON.stringify(data);
                const encoded = btoa(encodeURIComponent(jsonStr));
                
                // Add checksum to detect tampering
                const checksum = generateChecksum(jsonStr);
                
                // XOR cipher with key
                let encrypted = '';
                for (let i = 0; i < encoded.length; i++) {
                    encrypted += String.fromCharCode(
                        encoded.charCodeAt(i) ^ SAVE_KEY.charCodeAt(i % SAVE_KEY.length)
                    );
                }
                
                return btoa(JSON.stringify({
                    v: 1, // version
                    d: btoa(encrypted), // data
                    c: checksum // checksum
                }));
            } catch (e) {
                console.error('Encryption failed:', e);
                return null;
            }
        }
        
        function decryptSave(encryptedData) {
            try {
                const wrapper = JSON.parse(atob(encryptedData));
                
                if (wrapper.v !== 1) {
                    throw new Error('Invalid save version');
                }
                
                const encrypted = atob(wrapper.d);
                
                // XOR decipher
                let decoded = '';
                for (let i = 0; i < encrypted.length; i++) {
                    decoded += String.fromCharCode(
                        encrypted.charCodeAt(i) ^ SAVE_KEY.charCodeAt(i % SAVE_KEY.length)
                    );
                }
                
                const jsonStr = decodeURIComponent(atob(decoded));
                
                // Verify checksum
                const calculatedChecksum = generateChecksum(jsonStr);
                if (calculatedChecksum !== wrapper.c) {
                    throw new Error('Save file has been tampered with!');
                }
                
                return JSON.parse(jsonStr);
            } catch (e) {
                console.error('Decryption failed:', e);
                throw new Error('Invalid or corrupted save file');
            }
        }
        
        function generateChecksum(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return hash.toString(36);
        }
        
        function downloadSaveFile() {
            try {
                const snapshot = buildSaveSnapshot();
                if (!snapshot) {
                    alert('No character data to save!');
                    return;
                }
                
                const encrypted = encryptSave(snapshot);
                if (!encrypted) {
                    alert('Failed to encrypt save file!');
                    return;
                }
                
                // Create filename with character name and timestamp
                const timestamp = new Date().toISOString().slice(0, 10);
                const filename = `DungeonQuest_${snapshot.characterName}_${timestamp}.dqsave`;
                
                // Create blob and download
                const blob = new Blob([encrypted], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert(`âœ… Save file downloaded: ${filename}`);
            } catch (e) {
                console.error('Download failed:', e);
                alert('Failed to download save file!');
            }
        }
        
        function loadFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.dqsave';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const encryptedData = event.target.result;
                        const data = decryptSave(encryptedData);
                        
                        // Validate the save data
                        if (!data.player || !data.characterId) {
                            throw new Error('Invalid save file structure');
                        }
                        
                        // Save to localStorage
                        const key = `dq_save_${data.characterId}`;
                        localStorage.setItem(key, JSON.stringify(data));
                        
                        // Update character list
                        updateCharacterList(data);
                        
                        alert(`âœ… Character "${data.characterName}" loaded successfully!`);
                        
                        // Load the character
                        loadCharacter(data.characterId);
                    } catch (e) {
                        console.error('Load failed:', e);
                        alert('âŒ Failed to load save file: ' + e.message);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        // Game State
        let gameState = {
            player: null,
            currentLocation: 'town',
            combatState: null,
            combatTimer: null,
            lastAction: null,
            sysop: {
                authenticated: false,
                username: null,
                terminalActive: false,
                commandHistory: []
            }
        };

        // ğŸ”‘ Prevent UI reset after restore (mobile fix)
gameState.hasRestoredGame = false;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SYSOP TERMINAL SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const SYSOP_CREDENTIALS = {
            username: 'sysop',
            password: 'Radojcsics'
        };

        // Toggle terminal with ~ key
        document.addEventListener('keydown', (e) => {
            if (e.key === '~' || e.key === '`') {
                e.preventDefault();
                toggleTerminal();
            }
            if (e.key === 'Escape' && gameState.sysop.terminalActive) {
                toggleTerminal();
            }
        });

function showActionBar() {
    const ab = document.getElementById('actionBar');
    if (ab) ab.style.display = 'block';
}

function hideActionBar() {
    const ab = document.getElementById('actionBar');
    if (ab) ab.style.display = 'none';
}


function buildSaveSnapshot() {
    if (!gameState.player) {
        console.warn('No player state to save');
        return null;
    }

    const p = gameState.player;
    
    const snapshot = {
        version: 1,
        characterId: p.id || 'default',
        characterName: p.name,
        timestamp: Date.now(),
        lastSaved: new Date().toLocaleString(),

        player: {
            // Identity
            id: p.id || 'default',
            name: p.name,
            class: p.class,
            
            // Core stats
            level: p.level,
            xp: p.xp,
            xpToNext: p.xpToNext,
            
            // Resources
            hp: p.hp,
            maxHp: p.maxHp,
            mp: p.mp,
            maxMp: p.maxMp,
            gold: p.gold,
            
            // Legacy base stats
            strength: p.strength,
            defense: p.defense,
            magic: p.magic,
            speed: p.speed,
            
            // New stat block (if exists)
            str: p.str,
            dex: p.dex,
            con: p.con,
            wis: p.wis,
            cha: p.cha,
            lck: p.lck,
            
            // Equipment
            weapon: p.weapon,
            armor: p.armor,
            
            // Inventory & spells
            inventory: [...(p.inventory || [])],
            knownSpells: [...(p.knownSpells || [])],
            
            // Progression
            defeatedMasters: [...(p.defeatedMasters || [])],
            unlockedAreas: [...(p.unlockedAreas || [])],
            
            // Special flags
            godMode: p.godMode || false
        },

        // Current location/state
        currentLocation: gameState.currentLocation,

        // Dungeon state (if in dungeon)
        dungeon: gameState.dungeon ? {
            dungeonKey: gameState.dungeon.dungeonKey,
            floor: gameState.dungeon.floor,
            currentRoom: gameState.dungeon.currentRoom,
            discoveredRooms: [...gameState.dungeon.discoveredRooms],
            activeEnemies: gameState.dungeon.activeEnemies.map(e => ({
                id: e.id,
                monsterId: e.monsterId,
                name: e.name,
                hp: e.hp,
                maxHp: e.maxHp,
                currentRoom: e.currentRoom,
                leash: e.leash
            }))
        } : null,

        meta: {
            inDungeon: !!gameState.dungeon
        }
    };

    return snapshot;
}


function saveGame() {
    try {
        const snapshot = buildSaveSnapshot();
        if (!snapshot) return;

        const key = `dq_save_${snapshot.characterId}`;
        localStorage.setItem(key, JSON.stringify(snapshot));
        
        // Also update character list
        updateCharacterList(snapshot);

        console.log(`âœ… Game saved: ${snapshot.characterName} (${snapshot.lastSaved})`);
        
        // Show brief save confirmation
        const hud = document.getElementById('hud');
        if (hud && hud.style.display !== 'none') {
            const saveMsg = document.createElement('div');
            saveMsg.style.cssText = 'position:fixed;top:10px;right:10px;background:#0a0a0a;border:2px solid var(--text-color);padding:8px 12px;color:var(--text-color);font-size:14px;z-index:9999;';
            saveMsg.textContent = 'ğŸ’¾ Game Saved';
            document.body.appendChild(saveMsg);
            setTimeout(() => saveMsg.remove(), 2000);
        }
    } catch (e) {
        console.error('Error saving game:', e);
    }
}

function updateCharacterList(snapshot) {
    try {
        let charList = JSON.parse(localStorage.getItem('dq_character_list') || '[]');
        
        // Remove old entry for this character if exists
        charList = charList.filter(c => c.id !== snapshot.characterId);
        
        // Add new entry
        charList.push({
            id: snapshot.characterId,
            name: snapshot.characterName,
            level: snapshot.player.level,
            class: snapshot.player.class,
            timestamp: snapshot.timestamp,
            lastSaved: snapshot.lastSaved
        });
        
        // Sort by most recent
        charList.sort((a, b) => b.timestamp - a.timestamp);
        
        localStorage.setItem('dq_character_list', JSON.stringify(charList));
    } catch (e) {
        console.error('Error updating character list:', e);
    }
}

function getAllCharacters() {
    try {
        return JSON.parse(localStorage.getItem('dq_character_list') || '[]');
    } catch (e) {
        console.error('Error getting character list:', e);
        return [];
    }
}

function deleteCharacter(characterId) {
    try {
        // Remove save data
        localStorage.removeItem(`dq_save_${characterId}`);
        
        // Remove from character list
        let charList = getAllCharacters();
        charList = charList.filter(c => c.id !== characterId);
        localStorage.setItem('dq_character_list', JSON.stringify(charList));
        
        console.log(`ğŸ—‘ï¸ Deleted character: ${characterId}`);
        return true;
    } catch (e) {
        console.error('Error deleting character:', e);
        return false;
    }
}

// Auto-save on page unload
window.addEventListener('beforeunload', () => {
    saveGame();
});



        function toggleTerminal() {
            const terminal = document.getElementById('terminalContainer');
            const input = document.getElementById('terminalInput');
            
            gameState.sysop.terminalActive = !gameState.sysop.terminalActive;
            
            if (gameState.sysop.terminalActive) {
                terminal.classList.add('active');
                input.focus();
                if (!gameState.sysop.authenticated) {
                    terminalPrint('Terminal activated. Type /login <username> <password> to authenticate.', 'warning');
                }
            } else {
                terminal.classList.remove('active');
            }
        }

        function terminalPrint(message, type = 'normal') {
            const output = document.getElementById('terminalOutput');
            const line = document.createElement('div');
            line.className = `terminal-line ${type === 'error' ? 'terminal-error' : ''} ${type === 'success' ? 'terminal-success' : ''} ${type === 'warning' ? 'terminal-warning' : ''}`;
            line.textContent = message;
            output.appendChild(line);
            
        }

        function clearTerminal() {
            document.getElementById('terminalOutput').innerHTML = '';
        }

        // Terminal input handler
        document.getElementById('terminalInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const input = e.target.value.trim();
                e.target.value = '';
                
                if (input) {
                    terminalPrint(`root@dungeon:~# ${input}`, 'normal');
                    gameState.sysop.commandHistory.push(input);
                    executeCommand(input);
                }
            }
        });

        function executeCommand(input) {
            const parts = input.split(' ');
            const command = parts[0].toLowerCase();
            const args = parts.slice(1);

            // Login command (always available)
            if (command === '/login') {
                handleLogin(args);
                return;
            }

            // Check authentication for all other commands
            if (!gameState.sysop.authenticated) {
                terminalPrint('ERROR: Authentication required. Use /login <username> <password>', 'error');
                return;
            }

            // Execute authenticated commands
            switch(command) {
                case '/help':
                    showHelp();
                    break;
                case '/logout':
                    handleLogout();
                    break;
                case '/clear':
                    clearTerminal();
                    break;
                case '/give':
                    handleGive(args);
                    break;
                case '/addmonster':
                    openAddMonsterForm();
                    break;
                case '/addweapon':
                    openAddWeaponForm();
                    break;
                case '/addarmor':
                    openAddArmorForm();
                    break;
                case '/additem':
                    openAddItemForm();
                    break;
                case '/listmonsters':
                    listMonsters();
                    break;
                case '/listweapons':
                    listWeapons();
                    break;
                case '/listarmor':
                    listArmor();
                    break;
                case '/listitems':
                    listItems();
                    break;
                case '/setlevel':
                    handleSetLevel(args);
                    break;
                case '/setgold':
                    handleSetGold(args);
                    break;
                case '/heal':
                    handleHeal();
                    break;
                case '/godmode':
                    handleGodMode(args);
                    break;
                case '/teleport':
                    handleTeleport(args);
                    break;
                case '/killmonster':
                    handleKillMonster();
                    break;
                case '/export':
                    handleExport(args);
                    break;
                default:
                    terminalPrint(`ERROR: Unknown command '${command}'. Type /help for available commands.`, 'error');
            }
        }

        function handleLogin(args) {
            if (args.length < 2) {
                terminalPrint('ERROR: Usage: /login <username> <password>', 'error');
                return;
            }

            const username = args[0];
            const password = args[1];

            if (username === SYSOP_CREDENTIALS.username && password === SYSOP_CREDENTIALS.password) {
                gameState.sysop.authenticated = true;
                gameState.sysop.username = username;
                document.getElementById('sysopBadge').classList.add('active');
                terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
                terminalPrint('  AUTHENTICATION SUCCESSFUL', 'success');
                terminalPrint('  Welcome, SYSOP ' + username, 'success');
                terminalPrint('  Type /help for available commands', 'success');
                terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
            } else {
                terminalPrint('ERROR: Authentication failed. Invalid credentials.', 'error');
            }
        }

        function handleLogout() {
            gameState.sysop.authenticated = false;
            gameState.sysop.username = null;
            document.getElementById('sysopBadge').classList.remove('active');
            terminalPrint('Logged out. Terminal locked.', 'warning');
        }

        function showHelp() {
            terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
            terminalPrint('SYSOP COMMANDS:', 'warning');
            terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
            terminalPrint('');
            terminalPrint('AUTHENTICATION:');
            terminalPrint('  /login <user> <pass>  - Authenticate as sysop');
            terminalPrint('  /logout               - End sysop session');
            terminalPrint('');
            terminalPrint('PLAYER COMMANDS:');
            terminalPrint('  /give <type> <id>     - Give item (weapon/armor/item/spell)');
            terminalPrint('  /setlevel <level>     - Set player level');
            terminalPrint('  /setgold <amount>     - Set gold amount');
            terminalPrint('  /heal                 - Fully heal player');
            terminalPrint('  /godmode <on/off>     - Toggle invincibility');
            terminalPrint('');
            terminalPrint('GAME CONTENT:');
            terminalPrint('  /addmonster           - Add new monster (opens form)');
            terminalPrint('  /addweapon            - Add new weapon (opens form)');
            terminalPrint('  /addarmor             - Add new armor (opens form)');
            terminalPrint('  /additem              - Add new item (opens form)');
            terminalPrint('');
            terminalPrint('LISTING:');
            terminalPrint('  /listmonsters         - Show all monsters');
            terminalPrint('  /listweapons          - Show all weapons');
            terminalPrint('  /listarmor            - Show all armor');
            terminalPrint('  /listitems            - Show all items');
            terminalPrint('');
            terminalPrint('UTILITIES:');
            terminalPrint('  /teleport <location>  - Teleport to area');
            terminalPrint('  /killmonster          - Instantly kill current enemy');
            terminalPrint('  /export <type>        - Export data (monsters/weapons/armor/items)');
            terminalPrint('  /clear                - Clear terminal output');
            terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
        }

        function handleGive(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            if (args.length < 2) {
                terminalPrint('ERROR: Usage: /give <type> <id>', 'error');
                terminalPrint('Types: weapon, armor, item, spell', 'error');
                return;
            }

            const type = args[0].toLowerCase();
            const id = args[1].toLowerCase();

            switch(type) {
                case 'weapon':
                    if (WEAPONS[id]) {
                        if (!gameState.player.inventory.includes(id)) {
                            gameState.player.inventory.push(id);
                        }
                        terminalPrint(`SUCCESS: Gave weapon '${WEAPONS[id].name}' to player`, 'success');
                    } else {
                        terminalPrint(`ERROR: Weapon '${id}' not found`, 'error');
                    }
                    break;
                case 'armor':
                    if (ARMOR[id]) {
                        if (!gameState.player.inventory.includes(id)) {
                            gameState.player.inventory.push(id);
                        }
                        terminalPrint(`SUCCESS: Gave armor '${ARMOR[id].name}' to player`, 'success');
                    } else {
                        terminalPrint(`ERROR: Armor '${id}' not found`, 'error');
                    }
                    break;
                case 'item':
                    if (ITEMS[id]) {
                        if (!gameState.player.inventory.includes(id)) {
                            gameState.player.inventory.push(id);
                        }
                        terminalPrint(`SUCCESS: Gave item '${ITEMS[id].name}' to player`, 'success');
                    } else {
                        terminalPrint(`ERROR: Item '${id}' not found`, 'error');
                    }
                    break;
                case 'spell':
                    if (SPELLS[id]) {
                        if (!gameState.player.knownSpells.includes(id)) {
                            gameState.player.knownSpells.push(id);
                        }
                        terminalPrint(`SUCCESS: Taught spell '${SPELLS[id].name}' to player`, 'success');
                    } else {
                        terminalPrint(`ERROR: Spell '${id}' not found`, 'error');
                    }
                    break;
                default:
                    terminalPrint(`ERROR: Invalid type '${type}'`, 'error');
            }
        }

        function handleSetLevel(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const level = parseInt(args[0]);
            if (isNaN(level) || level < 1 || level > 99) {
                terminalPrint('ERROR: Invalid level. Use 1-99', 'error');
                return;
            }

            gameState.player.level = level;
            gameState.player.xpToNext = Math.floor(100 * Math.pow(1.5, level - 1));
            terminalPrint(`SUCCESS: Set player level to ${level}`, 'success');
        }

        function handleSetGold(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const gold = parseInt(args[0]);
            if (isNaN(gold) || gold < 0) {
                terminalPrint('ERROR: Invalid gold amount', 'error');
                return;
            }

            gameState.player.gold = gold;
            terminalPrint(`SUCCESS: Set gold to ${gold}`, 'success');
        }

        function handleHeal() {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            gameState.player.hp = gameState.player.maxHp;
            gameState.player.mp = gameState.player.maxMp;
            terminalPrint('SUCCESS: Player fully healed', 'success');
        }

        function handleGodMode(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const mode = args[0]?.toLowerCase();
            if (mode === 'on') {
                gameState.player.godMode = true;
                terminalPrint('SUCCESS: God Mode ENABLED - Player is invincible', 'success');
            } else if (mode === 'off') {
                gameState.player.godMode = false;
                terminalPrint('SUCCESS: God Mode DISABLED', 'success');
            } else {
                terminalPrint('ERROR: Usage: /godmode <on/off>', 'error');
            }
        }

        function handleTeleport(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const location = args[0]?.toLowerCase();
            if (LOCATIONS[location]) {
                gameState.currentLocation = location;
                if (location === 'town') {
                    showTown();
                } else {
                    exploreLocation(location);
                }
                terminalPrint(`SUCCESS: Teleported to ${LOCATIONS[location].name}`, 'success');
            } else {
                terminalPrint(`ERROR: Unknown location '${location}'`, 'error');
                terminalPrint('Available: ' + Object.keys(LOCATIONS).join(', '), 'warning');
            }
        }

        function handleKillMonster() {
            if (!gameState.combatState) {
                terminalPrint('ERROR: Not in combat', 'error');
                return;
            }

            gameState.combatState.enemy.hp = 0;
            terminalPrint('SUCCESS: Enemy eliminated', 'success');
            checkCombatEnd();
        }

        function listMonsters() {
            terminalPrint('â•â•â• ALL MONSTERS â•â•â•', 'warning');
            Object.keys(ENEMIES).forEach(key => {
                const m = ENEMIES[key];
                terminalPrint(`${key}: ${m.name} (Lv${m.level}, HP:${m.hp}, DMG:${m.damage})`);
            });
        }

        function listWeapons() {
            terminalPrint('â•â•â• ALL WEAPONS â•â•â•', 'warning');
            Object.keys(WEAPONS).forEach(key => {
                const w = WEAPONS[key];
                terminalPrint(`${key}: ${w.name} (Lv${w.level}, DMG:${w.damage}, MAG:${w.magicDamage})`);
            });
        }

        function listArmor() {
            terminalPrint('â•â•â• ALL ARMOR â•â•â•', 'warning');
            Object.keys(ARMOR).forEach(key => {
                const a = ARMOR[key];
                terminalPrint(`${key}: ${a.name} (Lv${a.level}, DEF:${a.defense})`);
            });
        }

        function listItems() {
            terminalPrint('â•â•â• ALL ITEMS â•â•â•', 'warning');
            Object.keys(ITEMS).forEach(key => {
                const i = ITEMS[key];
                terminalPrint(`${key}: ${i.name} (${i.type}, Lv${i.level})`);
            });
        }

        function openAddMonsterForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW MONSTER</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Monster ID (lowercase, underscores):</label>
                    <input type="text" id="monsterId" placeholder="fire_dragon">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="monsterName" placeholder="Fire Dragon">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">HP:</label>
                    <input type="number" id="monsterHp" value="100">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Damage:</label>
                    <input type="number" id="monsterDamage" value="20">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Defense:</label>
                    <input type="number" id="monsterDefense" value="10">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">XP Reward:</label>
                    <input type="number" id="monsterXp" value="100">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Gold Reward:</label>
                    <input type="number" id="monsterGold" value="80">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level:</label>
                    <input type="number" id="monsterLevel" value="5">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="monsterDesc" placeholder="A fearsome creature">
                </div>
                <button onclick="submitAddMonster()">ADD MONSTER</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddMonster() {
            const id = document.getElementById('monsterId').value.trim().toLowerCase();
            const name = document.getElementById('monsterName').value.trim();
            const hp = parseInt(document.getElementById('monsterHp').value);
            const damage = parseInt(document.getElementById('monsterDamage').value);
            const defense = parseInt(document.getElementById('monsterDefense').value);
            const xp = parseInt(document.getElementById('monsterXp').value);
            const gold = parseInt(document.getElementById('monsterGold').value);
            const level = parseInt(document.getElementById('monsterLevel').value);
            const description = document.getElementById('monsterDesc').value.trim();

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            ENEMIES[id] = {
                name: name,
                hp: hp,
                damage: damage,
                defense: defense,
                xp: xp,
                gold: gold,
                level: level,
                description: description
            };

            closeModal();
            terminalPrint(`SUCCESS: Added monster '${name}' with ID '${id}'`, 'success');
            terminalPrint('Remember to add it to a location\'s encounter list!', 'warning');
        }

        function openAddWeaponForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW WEAPON</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Weapon ID:</label>
                    <input type="text" id="weaponId" placeholder="flame_sword">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="weaponName" placeholder="Flame Sword">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Damage:</label>
                    <input type="number" id="weaponDamage" value="30">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Magic Damage:</label>
                    <input type="number" id="weaponMagic" value="10">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Cost:</label>
                    <input type="number" id="weaponCost" value="200">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level Requirement:</label>
                    <input type="number" id="weaponLevel" value="5">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="weaponDesc" placeholder="A blazing weapon">
                </div>
                <button onclick="submitAddWeapon()">ADD WEAPON</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddWeapon() {
            const id = document.getElementById('weaponId').value.trim().toLowerCase();
            const name = document.getElementById('weaponName').value.trim();
            const damage = parseInt(document.getElementById('weaponDamage').value);
            const magicDamage = parseInt(document.getElementById('weaponMagic').value);
            const cost = parseInt(document.getElementById('weaponCost').value);
            const level = parseInt(document.getElementById('weaponLevel').value);
            const description = document.getElementById('weaponDesc').value.trim();

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            WEAPONS[id] = {
                name: name,
                damage: damage,
                magicDamage: magicDamage,
                cost: cost,
                level: level,
                description: description
            };

            closeModal();
            terminalPrint(`SUCCESS: Added weapon '${name}' with ID '${id}'`, 'success');
        }

        function openAddArmorForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW ARMOR</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Armor ID:</label>
                    <input type="text" id="armorId" placeholder="dragon_mail">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="armorName" placeholder="Dragon Mail">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Defense:</label>
                    <input type="number" id="armorDefense" value="25">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Magic Bonus:</label>
                    <input type="number" id="armorMagic" value="0">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Cost:</label>
                    <input type="number" id="armorCost" value="300">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level Requirement:</label>
                    <input type="number" id="armorLevel" value="6">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="armorDesc" placeholder="Strong protective armor">
                </div>
                <button onclick="submitAddArmor()">ADD ARMOR</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddArmor() {
            const id = document.getElementById('armorId').value.trim().toLowerCase();
            const name = document.getElementById('armorName').value.trim();
            const defense = parseInt(document.getElementById('armorDefense').value);
            const magicBonus = parseInt(document.getElementById('armorMagic').value);
            const cost = parseInt(document.getElementById('armorCost').value);
            const level = parseInt(document.getElementById('armorLevel').value);
            const description = document.getElementById('armorDesc').value.trim();

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            ARMOR[id] = {
                name: name,
                defense: defense,
                magicBonus: magicBonus,
                cost: cost,
                level: level,
                description: description
            };

            closeModal();
            terminalPrint(`SUCCESS: Added armor '${name}' with ID '${id}'`, 'success');
        }

        function openAddItemForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW ITEM</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Item ID:</label>
                    <input type="text" id="itemId" placeholder="super_potion">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="itemName" placeholder="Super Potion">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Type:</label>
                    <select id="itemType" style="width: 100%; background: var(--secondary-bg); color: var(--text-color); border: 2px solid var(--border-color); padding: 10px; font-family: 'VT323', monospace; font-size: 18px;">
                        <option value="consumable">Consumable</option>
                        <option value="quest">Quest</option>
                        <option value="permanent">Permanent</option>
                        <option value="utility">Utility</option>
                        <option value="passive">Passive</option>
                    </select>
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Subtype:</label>
                    <input type="text" id="itemSubtype" placeholder="heal_hp">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Power:</label>
                    <input type="number" id="itemPower" value="50">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Cost:</label>
                    <input type="number" id="itemCost" value="30">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level:</label>
                    <input type="number" id="itemLevel" value="1">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="itemDesc" placeholder="Restores HP">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">
                        <input type="checkbox" id="itemStackable" checked> Stackable
                    </label>
                </div>
                <button onclick="submitAddItem()">ADD ITEM</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddItem() {
            const id = document.getElementById('itemId').value.trim().toLowerCase();
            const name = document.getElementById('itemName').value.trim();
            const type = document.getElementById('itemType').value;
            const subtype = document.getElementById('itemSubtype').value.trim();
            const power = parseInt(document.getElementById('itemPower').value);
            const cost = parseInt(document.getElementById('itemCost').value);
            const level = parseInt(document.getElementById('itemLevel').value);
            const description = document.getElementById('itemDesc').value.trim();
            const stackable = document.getElementById('itemStackable').checked;

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            ITEMS[id] = {
                name: name,
                type: type,
                subtype: subtype,
                power: power,
                cost: cost,
                level: level,
                description: description,
                stackable: stackable
            };

            closeModal();
            terminalPrint(`SUCCESS: Added item '${name}' with ID '${id}'`, 'success');
        }

        function closeModal() {
            document.getElementById('modalOverlay').classList.remove('active');
        }

        function handleExport(args) {
            const type = args[0]?.toLowerCase();
            let data;
            let filename;

            switch(type) {
                case 'monsters':
                    data = JSON.stringify(ENEMIES, null, 2);
                    filename = 'monsters.json';
                    break;
                case 'weapons':
                    data = JSON.stringify(WEAPONS, null, 2);
                    filename = 'weapons.json';
                    break;
                case 'armor':
                    data = JSON.stringify(ARMOR, null, 2);
                    filename = 'armor.json';
                    break;
                case 'items':
                    data = JSON.stringify(ITEMS, null, 2);
                    filename = 'items.json';
                    break;
                default:
                    terminalPrint('ERROR: Usage: /export <monsters/weapons/armor/items>', 'error');
                    return;
            }

            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);

            terminalPrint(`SUCCESS: Exported ${type} to ${filename}`, 'success');
        }

        // Make functions global for onclick handlers
        window.submitAddMonster = submitAddMonster;
        window.submitAddWeapon = submitAddWeapon;
        window.submitAddArmor = submitAddArmor;
        window.submitAddItem = submitAddItem;
        window.closeModal = closeModal;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // END SYSOP TERMINAL SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•





        // Initialize Game
        function initGame() {
            // Try to auto-restore character (especially important for dungeons!)
            const characters = getAllCharacters();
            
            if (characters.length > 0) {
                // Check if any character is currently in a dungeon
                const dungeonChar = characters.find(char => {
                    const saveData = localStorage.getItem(`dq_save_${char.id}`);
                    if (saveData) {
                        const data = JSON.parse(saveData);
                        return data.meta?.inDungeon === true;
                    }
                    return false;
                });
                
                if (dungeonChar) {
                    // Auto-load character that was in a dungeon (prevent cheating!)
                    console.log('ğŸ° Auto-restoring dungeon session:', dungeonChar.name);
                    loadCharacter(dungeonChar.id);
                    return;
                }
                
                // If single character and not in dungeon, auto-load for convenience
                if (characters.length === 1) {
                    console.log('Auto-loading single character:', characters[0].name);
                    loadCharacter(characters[0].id);
                    return;
                }
            }
            
            // Otherwise show main menu
            showMainMenu();
            
            // Warn before leaving page without saving
            window.addEventListener('beforeunload', function(e) {
                // Only warn if player exists and has made progress
                if (gameState.player && gameState.player.level >= 1) {
                    const message = 'You have unsaved progress! Are you sure you want to leave?';
                    e.preventDefault();
                    e.returnValue = message;  // Chrome requires returnValue
                    return message;           // Some browsers use return value
                }
            });
        }

        function showMainMenu() {
            const screen = document.getElementById('mainScreen');
            const characters = getAllCharacters();
            const hasCharacters = characters.length > 0;
            
            screen.innerHTML = `
                <div class="location-header">MAIN MENU</div>
                <div style="text-align: center; margin: 30px 0;">
                    <div class="ascii-art" style="color: var(--highlight-color);">
    âš”ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• âš”ï¸
       â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
       â•‘   DUNGEON QUEST AWAITS!   â•‘
       â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    ğŸ—¡ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ—¡ï¸
                    </div>
                </div>
                <div style="max-width: 400px; margin: 0 auto;">
                    <div class="menu-option" onclick="newGame()">â–º NEW GAME</div>
                    <div class="menu-option ${!hasCharacters?'disabled':''}" onclick="${hasCharacters?'showCharacterSelect()':''}">
                        â–º CONTINUE ${hasCharacters?`(${characters.length} local save${characters.length>1?'s':''})`:' (No saves)'}
                    </div>
                    <div class="menu-option" onclick="loadFromFile()">ğŸ“ LOAD FROM FILE (.dqsave)</div>
                    <div class="menu-option" onclick="showInstructions()">â–º INSTRUCTIONS</div>
                </div>
            `;
        }

        function showCharacterSelect() {
            const characters = getAllCharacters();
            if (characters.length === 0) {
                alert('No saved characters found!');
                return;
            }
            
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">SELECT CHARACTER</div>
                <div id="characterList" style="max-width: 600px; margin: 20px auto;"></div>
                <button onclick="showMainMenu()">â† BACK TO MENU</button>
            `;
            
            const charList = document.getElementById('characterList');
            
            characters.forEach(char => {
                const card = document.createElement('div');
                card.className = 'character-card';
                card.style.cssText = `
                    background: var(--secondary-bg);
                    border: 2px solid var(--border-color);
                    padding: 15px;
                    margin-bottom: 15px;
                    cursor: pointer;
                    transition: all 0.2s;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                `;
                
                card.innerHTML = `
                    <div style="flex: 1;">
                        <div style="color: var(--highlight-color); font-size: 22px; margin-bottom: 5px;">
                            ${char.name}
                        </div>
                        <div style="color: var(--text-color); font-size: 16px;">
                            Level ${char.level} ${char.class || 'Adventurer'}
                        </div>
                        <div style="color: #8aaa8a; font-size: 14px; margin-top: 5px;">
                            Last played: ${char.lastSaved}
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="event.stopPropagation(); loadCharacter('${char.id}')" 
                                style="padding: 8px 16px; background: #0a3a0a; border: 2px solid var(--text-color);">
                            â–¶ PLAY
                        </button>
                        <button onclick="event.stopPropagation(); confirmDeleteCharacter('${char.id}', '${char.name}')" 
                                style="padding: 8px 16px; background: #3a0a0a; border: 2px solid var(--error-color); color: var(--error-color);">
                            ğŸ—‘ï¸ DELETE
                        </button>
                    </div>
                `;
                
                card.addEventListener('mouseenter', () => {
                    card.style.background = 'var(--primary-bg)';
                    card.style.borderColor = 'var(--highlight-color)';
                });
                
                card.addEventListener('mouseleave', () => {
                    card.style.background = 'var(--secondary-bg)';
                    card.style.borderColor = 'var(--border-color)';
                });
                
                charList.appendChild(card);
            });
        }

        function confirmDeleteCharacter(charId, charName) {
            if (confirm(`Are you sure you want to DELETE ${charName}? This cannot be undone!`)) {
                if (deleteCharacter(charId)) {
                    showCharacterSelect(); // Refresh the list
                } else {
                    alert('Error deleting character!');
                }
            }
        }

        function loadCharacter(characterId) {
            try {
                const saveData = localStorage.getItem(`dq_save_${characterId}`);
                if (!saveData) {
                    alert('Save file not found!');
                    return;
                }

                const data = JSON.parse(saveData);
                
                // Restore complete player state
                gameState.player = {
                    ...data.player,
                    // Ensure all arrays are properly restored
                    inventory: data.player.inventory || [],
                    knownSpells: data.player.knownSpells || [],
                    defeatedMasters: data.player.defeatedMasters || [],
                    unlockedAreas: data.player.unlockedAreas || []
                };
                
                gameState.currentLocation = data.currentLocation || 'silverdale';
                
                // Restore dungeon state if applicable
                if (data.meta?.inDungeon && data.dungeon) {
                    // Check if DUNGEONS is loaded
                    if (typeof DUNGEONS === 'undefined') {
                        console.error('âš ï¸ DUNGEONS not loaded! Check dungeon-data.js for syntax errors.');
                        alert('Error: Dungeon data failed to load. Please check the console for errors.');
                        showTown();
                        return;
                    }
                    
                    console.log('ğŸ” Loading dungeon:', data.dungeon.dungeonKey);
                    console.log('ğŸ“¦ Available dungeons:', Object.keys(DUNGEONS));
                    
                    let dungeonKey = data.dungeon.dungeonKey;
                    
                    // Migrate old dungeon keys if needed
                    if (!DUNGEONS[dungeonKey]) {
                        console.warn(`âš ï¸ Dungeon "${dungeonKey}" not found. Attempting migration...`);
                        // If there's only one dungeon available, use it
                        const availableDungeons = Object.keys(DUNGEONS);
                        if (availableDungeons.length > 0) {
                            dungeonKey = availableDungeons[0];
                            console.log(`âœ… Migrated to dungeon: ${dungeonKey}`);
                        } else {
                            console.error('âŒ No dungeons available!');
                            alert('Error: No dungeons found. Returning to town.');
                            gameState.dungeon = null;
                            showTown();
                            return;
                        }
                    }
                    
                    const dungeon = DUNGEONS[dungeonKey];
                    
                    gameState.dungeon = {
                        dungeonKey: dungeonKey,
                        floor: data.dungeon.floor,
                        currentRoom: data.dungeon.currentRoom,
                        discoveredRooms: new Set(data.dungeon.discoveredRooms),
                        activeEnemies: (data.dungeon.activeEnemies || []).map(e => ({
                            ...e,
                            isChasing: false,
                            roomsFollowed: 0
                        }))
                    };
                    
                    // Open dungeon UI
                    openTerminalView(dungeonKey);
                    
                    const floor = dungeon.floors[data.dungeon.floor];
                    if (!floor) {
                        console.error(`âš ï¸ Floor ${data.dungeon.floor} not found!`);
                        alert('Error: Invalid dungeon floor. Returning to town.');
                        gameState.dungeon = null;
                        showTown();
                        return;
                    }
                    
                    const room = floor.rooms[data.dungeon.currentRoom];
                    if (!room) {
                        console.error(`âš ï¸ Room ${data.dungeon.currentRoom} not found!`);
                        alert('Error: Invalid dungeon room. Returning to town.');
                        gameState.dungeon = null;
                        showTown();
                        return;
                    }
                    
                    termAppend('', 'term-separator');
                    termAppend(`<strong>${room.name}</strong>`);
                    termAppend(room.description, 'term-dim');
                    
                    const exits = Object.keys(room.exits).map(d => d.toUpperCase()).join(', ');
                    termAppend(`You see exits: ${exits}.`, 'term-dim');
                    
                    checkEnemiesInRoom(data.dungeon.currentRoom);
                    renderDungeonActionBar();
                } else {
                    showTown();
                }
                
                console.log(`âœ… Character loaded: ${data.characterName}`);
            } catch (e) {
                console.error('Error loading character:', e);
                alert('Error loading save file!');
            }
        }

        function showInstructions() {
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">INSTRUCTIONS</div>
                <div class="message">
                    <p><span class="stat-label">OBJECTIVE:</span> Explore dungeons, defeat monsters, level up, and become legendary!</p>
                    <br>
                    <p><span class="stat-label">COMBAT:</span> Combat is turn-based with a timer. Choose your action before time runs out!</p>
                    <br>
                    <p><span class="stat-label">EXPLORATION:</span> Travel to different locations, each with stronger monsters.</p>
                    <br>
                    <p><span class="stat-label">PROGRESSION:</span> Gain XP, level up, buy better equipment, and learn new spells.</p>
                    <br>
                    <p><span class="stat-label">SAVING:</span> Save your game at any time from the town menu.</p>
                </div>
                <button onclick="showMainMenu()">BACK TO MENU</button>
            `;
        }

        function newGame() {
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">CHARACTER CREATION</div>
                <div class="message">
                    <p>Enter your character name:</p>
                    <input type="text" id="playerName" maxlength="20" placeholder="Hero Name">
                </div>
                <div class="message">
                    <p><span class="stat-label">Choose your class:</span></p>
                </div>
                <div class="character-select" id="classSelect"></div>
                <button onclick="goToStatAlloc()" id="createBtn" disabled>ALLOCATE STATS â†’</button>
                <button onclick="showMainMenu()">CANCEL</button>
            `;

            const classSelect = document.getElementById('classSelect');
            window._selectedClass = null;

            Object.keys(CLASSES).forEach(classKey => {
                const cd   = CLASSES[classKey];
                const card = document.createElement('div');
                card.className = 'class-card';
                card.innerHTML = `
                    <div style="color:var(--highlight-color);font-size:22px;margin-bottom:8px;">${cd.name}</div>
                    <div style="font-size:16px;margin-bottom:8px;">${cd.description}</div>
                    <div class="stat">HP: ${cd.hp} | MP: ${cd.mp}</div>
                    <div class="stat" style="color:#8aaa8a;">STR/DEF/MAG/SPD set at creation</div>
                `;
                card.onclick = () => {
                    document.querySelectorAll('.class-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    window._selectedClass = classKey;
                    document.getElementById('createBtn').disabled = false;
                };
                classSelect.appendChild(card);
            });
        }

        // â”€â”€ stat allocation screen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window._pendingStats = null;
        window._pendingName  = '';

        function goToStatAlloc() {
            const name = document.getElementById('playerName').value.trim();
            if (!name)                { alert('Please enter a character name!'); return; }
            if (!window._selectedClass) { alert('Please select a class!');       return; }
            window._pendingName  = name;
            window._pendingStats = Object.assign({}, CLASS_STAT_PRESETS[window._selectedClass]);
            renderStatAllocScreen();
        }

        function renderStatAllocScreen() {
            const classKey   = window._selectedClass;
            const classData  = CLASSES[classKey];
            const stats      = window._pendingStats;
            const spent      = STAT_NAMES.reduce((a,k) => a + stats[k], 0);
            const remaining  = STAT_BUDGET - spent;
            const affinities = CLASS_AFFINITIES[classKey];
            const screen     = document.getElementById('mainScreen');

            // preview derived values
            const previewHp   = classData.hp + stats.con * 5;
            const previewHits = (function(){
                let h=1;
                if(classKey==='rogue') h++;
                h += Math.floor(Math.max(0, stats.str-8)/6);
                return h;
            })();

            let rows = '';
            STAT_NAMES.forEach(s => {
                const isAff   = affinities.includes(s);
                const canUp   = remaining > 0 && stats[s] < 15;
                const canDown = stats[s] > 1;
                rows += `
                <div style="display:flex;align-items:center;gap:6px;padding:5px 0;border-bottom:1px solid #1a4a1a;flex-wrap:wrap;">
                    <span style="min-width:36px;color:${isAff?'var(--highlight-color)':'var(--text-color)'};font-weight:bold;">${STAT_LABELS[s]}</span>
                    <span style="flex:1;min-width:120px;font-size:16px;color:#8aaa8a;">${STAT_DESCS[s]}${isAff?' â˜…':''}</span>
                    <button onclick="statAdj('${s}',-1)" ${canDown?'':'disabled'} style="width:32px;padding:4px 0;margin:0;font-size:20px;">âˆ’</button>
                    <span style="min-width:28px;text-align:center;color:var(--highlight-color);font-size:22px;">${stats[s]}</span>
                    <button onclick="statAdj('${s}',+1)" ${canUp ?'':'disabled'} style="width:32px;padding:4px 0;margin:0;font-size:20px;">+</button>
                </div>`;
            });

            screen.innerHTML = `
                <div class="location-header">ALLOCATE STATS â€“ ${classData.name}</div>
                <div class="message" style="border-color:var(--highlight-color);">
                    <span style="color:var(--highlight-color);">Points remaining: </span>
                    <span style="color:${remaining>0?'var(--text-color)':'var(--error-color)'};font-size:22px;">${remaining}</span>
                    <span style="color:#8aaa8a;font-size:15px;"> (â˜… = class affinity)</span>
                </div>
                <div style="max-width:520px;margin:0 auto;">${rows}</div>
                <div class="message" style="border-color:#005500;margin-top:12px;font-size:15px;">
                    <span style="color:#8aaa8a;">PREVIEW:</span><br>
                    <span style="color:var(--highlight-color);">HP ${previewHp}</span>
                    <span style="color:var(--border-color);"> | ATK/rd: ${previewHits}</span><br>
                    <span style="color:#8aaa8a;">Crit ${calcCritChance(stats.lck)}% | Dodge ${calcDodgeChance(stats.dex)}%</span>
                </div>
                <div style="margin-top:14px;display:flex;flex-wrap:wrap;gap:8px;">
                    <button onclick="window._pendingStats=Object.assign({},CLASS_STAT_PRESETS['${classKey}']);renderStatAllocScreen();">ğŸ“‹ CLASS PRESET</button>
                    <button onclick="window._pendingStats=rerollStats('${classKey}');renderStatAllocScreen();">ğŸ² REROLL</button>
                </div>
                <div style="margin-top:14px;">
                    <button onclick="finaliseCharacter()" ${remaining===0?'':'disabled'} style="font-size:20px;">âš”ï¸ BEGIN ADVENTURE âš”ï¸</button>
                    <button onclick="newGame()">â† BACK</button>
                </div>
            `;
        }

        window.statAdj = function(stat, dir) {
            const stats = window._pendingStats;
            const spent = STAT_NAMES.reduce((a,k) => a + stats[k], 0);
            if (dir > 0 && spent >= STAT_BUDGET) return;
            if (dir < 0 && stats[stat] <= 1)      return;
            stats[stat] += dir;
            renderStatAllocScreen();
        };

        function finaliseCharacter() {
            const classKey  = window._selectedClass;
            const classData = CLASSES[classKey];
            const stats     = window._pendingStats;

            // Generate unique character ID
            const charId = 'char_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

            gameState.player = {
                id: charId,  // Unique character ID
                name: window._pendingName,
                class: classKey,  className: classData.name,
                level: 1,  xp: 0,  xpToNext: 100,
                hp: classData.hp + stats.con * 5,
                maxHp: classData.hp + stats.con * 5,
                mp: classData.mp,  maxMp: classData.mp,
                strength: classData.strength,   // legacy weapon-calc field
                defense:  classData.defense,
                magic:    classData.magic,
                speed:    classData.speed,
                gold: 100,
                weapon: classData.startWeapon,
                armor:  classData.startArmor,
                inventory:  [classData.startWeapon, classData.startArmor],
                knownSpells: getStartingSpells(classKey),
                defeatedMasters: [],
                unlockedAreas:  ['forest'],
                // â”€â”€ new stat block â”€â”€
                str: stats.str,  dex: stats.dex,  wis: stats.wis,
                cha: stats.cha,  con: stats.con,  lck: stats.lck
            };
            gameState.currentLocation = 'town';
            
            // Auto-save new character
            saveGame();
            
            showTown();
        }

        function getStartingSpells(classKey) {
            const spellMap = {
                mage: ['fireball'],
                cleric: ['heal'],
                paladin: ['heal', 'holy_light'],
                ranger: [],
                warrior: [],
                rogue: []
            };
            return spellMap[classKey] || [];
        }

        function showTown() {
            document.body.classList.remove("terminal-mode");
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">${LOCATIONS.town.name}</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>${LOCATIONS.town.description}</p>
                    <p style="color: var(--border-color); font-size: 14px;">Modem Speed: ${currentModemSpeed}</p>
                </div>
                <div style="margin: 20px 0;">
                    <div class="menu-option" onclick="showShop()">â–º VISIT SHOP</div>
                    <div class="menu-option" onclick="enterDungeons()">ğŸ° DUNGEONS</div>
                    <div class="menu-option" onclick="restAtInn()">â–º REST AT INN (${calcInnCost(gameState.player.cha)} Gold)</div>
                    <div class="menu-option" onclick="showInventory()">â–º INVENTORY</div>
                    <div class="menu-option" onclick="showExplore()">â–º EXPLORE WORLD</div>
                    <div class="menu-option" onclick="showModemSettings()">â–º MODEM SETTINGS</div>
                    <div class="menu-option" onclick="saveGame()" style="border-color:var(--text-color);">ğŸ’¾ QUICK SAVE (auto-backup)</div>
                    <div class="menu-option" onclick="downloadSaveFile()" style="border-color:var(--highlight-color);background:rgba(255,255,0,0.05);">ğŸ“¥ DOWNLOAD SAVE FILE (backup to device)</div>
                    <div class="menu-option" onclick="showMainMenu()">â–º QUIT TO MENU</div>
                </div>
            `;
        }

        function showModemSettings() {
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">ğŸ“ MODEM SETTINGS ğŸ“</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>Select your connection speed:</p>
                    <p style="font-size: 14px; color: var(--border-color);">Current: ${currentModemSpeed}</p>
                </div>
                <div style="margin: 20px 0;">
                    <div class="menu-option ${currentModemSpeed === '14.4k' ? 'equipped' : ''}" onclick="setModemSpeed('14.4k')">
                        â–º 14.4k MODEM (Slowest - Most Authentic)
                    </div>
                    <div class="menu-option ${currentModemSpeed === '28.8k' ? 'equipped' : ''}" onclick="setModemSpeed('28.8k')">
                        â–º 28.8k MODEM (Slow - Classic BBS Feel)
                    </div>
                    <div class="menu-option ${currentModemSpeed === '56k' ? 'equipped' : ''}" onclick="setModemSpeed('56k')">
                        â–º 56k MODEM (Medium - Faster Loading)
                    </div>
                    <div class="menu-option ${currentModemSpeed === 'instant' ? 'equipped' : ''}" onclick="setModemSpeed('instant')">
                        â–º INSTANT (No Delay - Modern)
                    </div>
                </div>
                <div class="message" style="border-color: var(--highlight-color);">
                    <p style="color: var(--highlight-color);">â„¹ï¸ INFO</p>
                    <p style="font-size: 14px;">Modem speed affects how quickly text appears on screen.</p>
                    <p style="font-size: 14px;">Lower speeds = more authentic 1990s BBS experience!</p>
                    <p style="font-size: 14px;">Combat timer won't start until screen finishes loading.</p>
                </div>
                <button onclick="showTown()">BACK TO TOWN</button>
            `;
        }

        function setModemSpeed(speed) {
            currentModemSpeed = speed;
            showModemSettings();
        }

        function renderPlayerStats() {
            const p = gameState.player;
            const hpPercent = (p.hp / p.maxHp) * 100;
            const mpPercent = (p.mp / p.maxMp) * 100;
            const xpPercent = (p.xp / p.xpToNext) * 100;

            return `
                <div class="stats-bar">
                    <div>
                        <span class="stat-label">${p.name}</span> - Level ${p.level} ${p.className}
                    </div>
                    <div>
                        <span class="stat-label">Gold:</span> ${p.gold}
                    </div>
                </div>
                <div class="stats-bar">
                    <div>
                        <span class="stat-label">HP:</span> ${p.hp}/${p.maxHp}
                    </div>
                    <div>
                        <span class="stat-label">MP:</span> ${p.mp}/${p.maxMp}
                    </div>
                    <div>
                        <span class="stat-label">XP:</span> ${p.xp}/${p.xpToNext}
                    </div>
                </div>
            `;
        }

        function showShop() {
            const screen = document.getElementById('mainScreen');
            
            let shopHtml = `
                <div class="location-header">MERCHANT SHOP</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>Welcome to my shop! What can I do for you?</p>
                </div>
                <div style="margin: 20px 0;">
                    <button onclick="showShopBuy()" style="margin-right: 10px;">ğŸ’° BUY ITEMS</button>
                    <button onclick="showShopSell()">ğŸ’ SELL ITEMS</button>
                </div>
                <div id="shopContent"></div>
                <button onclick="showTown()">LEAVE SHOP</button>
            `;
            
            screen.innerHTML = shopHtml;
            showShopBuy(); // Default to buy tab
        }

        function enterDungeons() {
    termClear();
    testDungeon();
}


        function showShopBuy() {
            let shopHtml = `
                <div style="margin: 20px 0;">
                    <h3 style="color: var(--highlight-color);">WEAPONS</h3>
                    <div class="inventory-grid">
            `;

            Object.keys(WEAPONS).forEach(key => {
                const weapon = WEAPONS[key];
                if (weapon.level <= gameState.player.level + 2) {
                    const owned = gameState.player.inventory.includes(key);
                    const equipped = gameState.player.weapon === key;
                    const qualityColor = QUALITY_CONFIG[weapon.quality].color;
                    const qualityBonus = QUALITY_CONFIG[weapon.quality].bonus;
                    const totalDmg = weapon.baseDamage + qualityBonus;
                    const totalMag = weapon.baseMagicDamage + qualityBonus;
                    
                    shopHtml += `
                        <div class="item-card ${equipped ? 'equipped' : ''}">
                            <div style="color: ${qualityColor};">${weapon.name}</div>
                            <div>DMG: ${totalDmg} | MAG: ${totalMag}</div>
                            <div>Level: ${weapon.level}</div>
                            ${owned ? '<div style="color: var(--border-color);">OWNED</div>' : 
                              `<button onclick="buyItem('weapon', '${key}', ${weapon.cost})">Buy ${weapon.cost}G</button>`}
                            ${gameState.player.cha ? '<div style="color:#8aaa8a;font-size:15px;">CHA disc: ' + calcChaDiscount(gameState.player.cha) + '%</div>' : ''}
                        </div>
                    `;
                }
            });

            shopHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">ARMOR</h3>
                    <div class="inventory-grid">
            `;

            Object.keys(ARMOR).forEach(key => {
                const armor = ARMOR[key];
                if (armor.level <= gameState.player.level + 2) {
                    const owned = gameState.player.inventory.includes(key);
                    const equipped = gameState.player.armor === key;
                    const qualityColor = QUALITY_CONFIG[armor.quality].color;
                    const qualityBonus = QUALITY_CONFIG[armor.quality].bonus;
                    const totalDef = armor.baseDefense + qualityBonus;
                    const totalMag = (armor.baseMagicBonus || 0) + (qualityBonus > 0 ? Math.floor(qualityBonus / 2) : 0);
                    
                    shopHtml += `
                        <div class="item-card ${equipped ? 'equipped' : ''}">
                            <div style="color: ${qualityColor};">${armor.name}</div>
                            <div>DEF: ${totalDef}</div>
                            ${totalMag > 0 ? `<div>MAG+: ${totalMag}</div>` : ''}
                            <div>Level: ${armor.level}</div>
                            ${owned ? '<div style="color: var(--border-color);">OWNED</div>' : 
                              `<button onclick="buyItem('armor', '${key}', ${armor.cost})">Buy ${armor.cost}G</button>`}
                            ${gameState.player.cha ? '<div style="color:#8aaa8a;font-size:15px;">CHA disc: ' + calcChaDiscount(gameState.player.cha) + '%</div>' : ''}
                        </div>
                    `;
                }
            });

            shopHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">POTIONS</h3>
                    <div class="inventory-grid">
            `;

            // Add potions to shop
            const potionsForSale = ['health_potion', 'greater_health_potion', 'superior_health_potion',
                                   'mana_potion', 'greater_mana_potion', 'superior_mana_potion', 'elixir'];
            
            potionsForSale.forEach(key => {
                if (ITEMS[key]) {
                    const item = ITEMS[key];
                    shopHtml += `
                        <div class="item-card">
                            <div style="color: var(--highlight-color);">${item.name}</div>
                            <div>${item.description}</div>
                            <div>Power: ${item.power || 'Full'}</div>
                            <button onclick="buyItem('item', '${key}', ${item.cost})">Buy ${item.cost}G</button>
                            ${gameState.player.cha ? '<div style="color:#8aaa8a;font-size:15px;">CHA disc: ' + calcChaDiscount(gameState.player.cha) + '%</div>' : ''}
                        </div>
                    `;
                }
            });

            shopHtml += `
                    </div>
                </div>
            `;
            
            document.getElementById('shopContent').innerHTML = shopHtml;
        }

        function showShopSell() {
            const p = gameState.player;
            
            // Get all sellable items
            const sellableItems = p.inventory.filter(itemKey => {
                // Items with sellValue
                if (ITEMS[itemKey] && ITEMS[itemKey].sellValue > 0) return true;
                // Duplicate weapons/armor (not currently equipped)
                if (WEAPONS[itemKey] && itemKey !== p.weapon) return true;
                if (ARMOR[itemKey] && itemKey !== p.armor) return true;
                return false;
            });
            
            let sellHtml = '<h3 style="color: var(--highlight-color);">YOUR SELLABLE ITEMS</h3>';
            sellHtml += '<div class="inventory-grid">';
            
            if (sellableItems.length === 0) {
                sellHtml += '<div class="message">You have nothing to sell.</div>';
            } else {
                sellableItems.forEach(itemKey => {
                    let itemName, itemColor, sellValue, itemDesc;
                    
                    if (ITEMS[itemKey]) {
                        const item = ITEMS[itemKey];
                        itemName = item.name;
                        itemColor = '#00FF00';
                        sellValue = item.sellValue;
                        itemDesc = item.description;
                    } else if (WEAPONS[itemKey]) {
                        const weapon = WEAPONS[itemKey];
                        itemName = weapon.name;
                        itemColor = QUALITY_CONFIG[weapon.quality].color;
                        sellValue = Math.floor(weapon.cost * 0.5); // 50% of purchase price
                        const qualityBonus = QUALITY_CONFIG[weapon.quality].bonus;
                        itemDesc = `DMG: ${weapon.baseDamage + qualityBonus} | MAG: ${weapon.baseMagicDamage + qualityBonus}`;
                    } else if (ARMOR[itemKey]) {
                        const armor = ARMOR[itemKey];
                        itemName = armor.name;
                        itemColor = QUALITY_CONFIG[armor.quality].color;
                        sellValue = Math.floor(armor.cost * 0.5); // 50% of purchase price
                        const qualityBonus = QUALITY_CONFIG[armor.quality].bonus;
                        itemDesc = `DEF: ${armor.baseDefense + qualityBonus}`;
                    }
                    
                    sellHtml += `
                        <div class="item-card">
                            <div style="color: ${itemColor};">${itemName}</div>
                            <div style="font-size: 16px;">${itemDesc}</div>
                            <div style="color: var(--border-color); margin-top: 10px;">Sell for: ${sellValue}G</div>
                            <button onclick="sellItem('${itemKey}', ${sellValue})">SELL</button>
                        </div>
                    `;
                });
            }
            
            sellHtml += '</div>';
            document.getElementById('shopContent').innerHTML = sellHtml;
        }

        function sellItem(itemKey, baseValue) {
            const index = gameState.player.inventory.indexOf(itemKey);
            if (index === -1) { alert('Item not found!'); return; }
            const bonus = calcChaSellBonus(gameState.player.cha);
            const value = Math.floor(baseValue * (1 + bonus/100));
            gameState.player.inventory.splice(index, 1);
            gameState.player.gold += value;
            const itemName = getItemName(itemKey);
            alert(`Sold ${itemName} for ${value}g!` + (bonus > 0 ? ` (+${bonus}% CHA bonus)` : ''));
            
            // ğŸ’¾ AUTO-SAVE after selling
            saveGame();
            
            showShopSell();
        }

        function buyItem(type, key, baseCost) {
            const disc   = calcChaDiscount(gameState.player.cha);
            const cost   = Math.max(1, Math.floor(baseCost * (1 - disc/100)));
            if (gameState.player.gold < cost) {
                alert('Not enough gold!');
                return;
            }
            gameState.player.gold -= cost;
            gameState.player.inventory.push(key);
            let itemName;
            if (type === 'weapon') itemName = WEAPONS[key].name;
            else if (type === 'armor') itemName = ARMOR[key].name;
            else if (type === 'item') itemName = ITEMS[key].name;
            alert(`Purchased ${itemName} for ${cost}g!` + (disc > 0 ? ` (${disc}% CHA discount)` : ''));
            
            // ğŸ’¾ AUTO-SAVE after buying
            saveGame();
            
            showShopBuy();
        }

        function restAtInn() {
            const cost = calcInnCost(gameState.player.cha);
            if (gameState.player.gold < cost) {
                alert('Not enough gold!');
                return;
            }
            gameState.player.gold -= cost;
            gameState.player.hp = gameState.player.maxHp;
            gameState.player.mp = gameState.player.maxMp;
            alert('You rest at the inn and recover fully!');
            showTown();
        }

        function showInventory() {
            const p = gameState.player;
            const screen = document.getElementById('mainScreen');
            
            let invHtml = `
                <div class="location-header">INVENTORY</div>
                ${renderPlayerStats()}
                <div style="margin: 20px 0;">
                    <h3 style="color: var(--highlight-color);">WEAPONS</h3>
                    <div class="inventory-grid">
            `;

            p.inventory.filter(item => WEAPONS[item]).forEach(key => {
                const weapon = WEAPONS[key];
                const equipped = p.weapon === key;
                const qualityColor = QUALITY_CONFIG[weapon.quality].color;
                const qualityBonus = QUALITY_CONFIG[weapon.quality].bonus;
                const totalDmg = weapon.baseDamage + qualityBonus;
                const totalMag = weapon.baseMagicDamage + qualityBonus;
                
                invHtml += `
                    <div class="item-card ${equipped ? 'equipped' : ''}">
                        <div style="color: ${qualityColor};">${weapon.name}</div>
                        <div>DMG: ${totalDmg} | MAG: ${totalMag}</div>
                        ${equipped ? '<div style="color: var(--border-color);">EQUIPPED</div>' : 
                          `<button onclick="equipItem('weapon', '${key}')">EQUIP</button>`}
                    </div>
                `;
            });

            invHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">ARMOR</h3>
                    <div class="inventory-grid">
            `;

            p.inventory.filter(item => ARMOR[item]).forEach(key => {
                const armor = ARMOR[key];
                const equipped = p.armor === key;
                const qualityColor = QUALITY_CONFIG[armor.quality].color;
                const qualityBonus = QUALITY_CONFIG[armor.quality].bonus;
                const totalDef = armor.baseDefense + qualityBonus;
                const totalMag = (armor.baseMagicBonus || 0) + (qualityBonus > 0 ? Math.floor(qualityBonus / 2) : 0);
                
                invHtml += `
                    <div class="item-card ${equipped ? 'equipped' : ''}">
                        <div style="color: ${qualityColor};">${armor.name}</div>
                        <div>DEF: ${totalDef}</div>
                        ${totalMag > 0 ? `<div>MAG+: ${totalMag}</div>` : ''}
                        ${equipped ? '<div style="color: var(--border-color);">EQUIPPED</div>' : 
                          `<button onclick="equipItem('armor', '${key}')">EQUIP</button>`}
                    </div>
                `;
            });

            invHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">SPELLS</h3>
                    <div class="inventory-grid">
            `;

            if (p.knownSpells.length === 0) {
                invHtml += '<div class="message">No spells learned yet.</div>';
            } else {
                p.knownSpells.forEach(spellKey => {
                    const spell = SPELLS[spellKey];
                    invHtml += `
                        <div class="item-card">
                            <div style="color: var(--highlight-color);">${spell.name}</div>
                            <div>MP Cost: ${spell.mpCost}</div>
                            <div>Power: ${spell.power}</div>
                            <div>${spell.description}</div>
                        </div>
                    `;
                });
            }

            invHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">CONSUMABLES & ITEMS</h3>
                    <div class="inventory-grid">
            `;

            // Count and display items
            const itemCounts = {};
            p.inventory.filter(item => ITEMS[item]).forEach(key => {
                itemCounts[key] = (itemCounts[key] || 0) + 1;
            });

            if (Object.keys(itemCounts).length === 0) {
                invHtml += '<div class="message">No items.</div>';
            } else {
                Object.keys(itemCounts).forEach(itemKey => {
                    const item = ITEMS[itemKey];
                    const count = itemCounts[itemKey];
                    const color = item.type === 'sellable' ? '#FFD700' : 
                                 item.subtype === 'heal_hp' ? '#FF0000' :
                                 item.subtype === 'heal_mp' ? '#0000FF' : '#00FF00';
                    
                    invHtml += `
                        <div class="item-card">
                            <div style="color: ${color};">${item.name} x${count}</div>
                            <div style="font-size: 16px;">${item.description}</div>
                            ${item.sellValue ? `<div style="color: var(--border-color);">Value: ${item.sellValue}G</div>` : ''}
                        </div>
                    `;
                });
            }

            invHtml += `
                    </div>
                </div>
                <button onclick="showTown()">BACK</button>
            `;

            screen.innerHTML = invHtml;
        }

        function equipItem(type, key) {
            if (type === 'weapon') {
                gameState.player.weapon = key;
            } else {
                gameState.player.armor = key;
            }
            
            // ğŸ’¾ AUTO-SAVE after equipping
            saveGame();
            
            showInventory();
        }

        function showExplore() {
            const screen = document.getElementById('mainScreen');
            const p = gameState.player;
            
            let exploreHtml = `
                <div class="location-header">WORLD MAP</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>Where would you like to explore?</p>
                </div>
                <div style="margin: 20px 0;">
            `;

            Object.keys(LOCATIONS).forEach(key => {
                const loc = LOCATIONS[key];
                if (key !== 'town') {
                    const levelInfo = loc.enemyLevelRange ? 
                        ` (Lv ${loc.enemyLevelRange[0]}-${loc.enemyLevelRange[1]})` : '';
                    
                    const isUnlocked = p.unlockedAreas.includes(key);
                    const canChallengeMaster = !isUnlocked && p.level >= loc.requiredLevel;
                    
                    if (isUnlocked) {
                        // Unlocked area - can explore
                        exploreHtml += `
                            <div class="menu-option" onclick="exploreLocation('${key}')">
                                â–º ${loc.name}${levelInfo} <span style="color: var(--border-color);">âœ“ UNLOCKED</span>
                            </div>
                        `;
                        
                        // Show master challenge option if available
                        const masterKey = `${p.class}_master_${key}`;
                        if (CLASS_MASTERS[masterKey] && !p.defeatedMasters.includes(masterKey)) {
                            const master = CLASS_MASTERS[masterKey];
                            if (p.level >= master.requiredLevel) {
                                exploreHtml += `
                                    <div class="menu-option" onclick="challengeMaster('${masterKey}')" style="border-color: var(--highlight-color); background: rgba(255, 255, 0, 0.1);">
                                        âš”ï¸ CHALLENGE MASTER: ${master.name} (Lv ${master.level})
                                    </div>
                                `;
                            }
                        }
                    } else {
                        // Locked area
                        if (canChallengeMaster) {
                            // Can challenge master to unlock
                            const masterKey = getMasterKeyForArea(key);
                            const master = CLASS_MASTERS[masterKey];
                            exploreHtml += `
                                <div class="menu-option" style="opacity: 0.6; cursor: default;" onclick="alert('${loc.unlockMessage}')">
                                    ğŸ”’ ${loc.name}${levelInfo} - LOCKED
                                </div>
                                <div class="menu-option" onclick="challengeMaster('${masterKey}')" style="border-color: var(--error-color); background: rgba(255, 0, 0, 0.1);">
                                    âš”ï¸ CHALLENGE MASTER: ${master.name} (Lv ${master.level}) TO UNLOCK!
                                </div>
                            `;
                        } else {
                            // Level too low
                            exploreHtml += `
                                <div class="menu-option" style="opacity: 0.6; cursor: default;" onclick="alert('You need to reach level ${loc.requiredLevel} first!')">
                                    ğŸ”’ ${loc.name}${levelInfo} - LOCKED (Need Lv ${loc.requiredLevel})
                                </div>
                            `;
                        }
                    }
                }
            });

            exploreHtml += `
                </div>
                <button onclick="showTown()">RETURN TO TOWN</button>
            `;

            screen.innerHTML = exploreHtml;
        }

        function getMasterKeyForArea(areaKey) {
            // Find which area unlocks this one
            const areaOrder = ['forest', 'plains', 'cave', 'crypt', 'volcano'];
            const index = areaOrder.indexOf(areaKey);
            if (index > 0) {
                const previousArea = areaOrder[index - 1];
                return `${gameState.player.class}_master_${previousArea}`;
            }
            return null;
        }

        function challengeMaster(masterKey) {
            const master = CLASS_MASTERS[masterKey];
            if (!master) {
                alert('Master not found!');
                return;
            }
            
            const p = gameState.player;
            
            // Check if already defeated
            if (p.defeatedMasters.includes(masterKey)) {
                alert('You have already defeated this master!');
                return;
            }
            
            // Check level requirement
            if (p.level < master.requiredLevel) {
                alert(`You need to be level ${master.requiredLevel} to challenge this master!`);
                return;
            }
            
            // Show master challenge screen
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">âš”ï¸ MASTER CHALLENGE âš”ï¸</div>
                ${renderPlayerStats()}
                <div class="message" style="border-color: var(--error-color); background: rgba(255, 0, 0, 0.1);">
                    <p style="color: var(--highlight-color); font-size: 24px;">${master.name}</p>
                    <p style="color: var(--text-color); margin: 10px 0;">${master.description}</p>
                    <p style="color: var(--border-color);">Level: ${master.level} | HP: ${master.baseHp} | Defense: ${master.baseDefense}</p>
                    <p style="color: var(--error-color); margin-top: 15px;">âš ï¸ THIS IS A BOSS FIGHT! âš ï¸</p>
                    <p>Defeating this master will unlock: <span style="color: var(--highlight-color);">${LOCATIONS[master.unlocks].name}</span></p>
                </div>
                <div class="message" style="border-color: var(--highlight-color);">
                    <p style="color: var(--highlight-color);">GUARANTEED REWARDS:</p>
                    ${master.guaranteedDrops.map(item => `<p>â€¢ ${getItemName(item)}</p>`).join('')}
                    <p style="margin-top: 10px;">+ ${master.xp} XP and ${master.gold} Gold</p>
                </div>
                <div style="margin: 20px 0;">
                    <button onclick="startMasterBattle('${masterKey}')" style="background: var(--error-color); font-size: 22px;">âš”ï¸ BEGIN BATTLE âš”ï¸</button>
                    <button onclick="showExplore()">RETREAT</button>
                </div>
            `;
        }

        function startMasterBattle(masterKey) {
            const master = CLASS_MASTERS[masterKey];
            const masterMonster = {
                key: masterKey, name: master.name, rarity: 'epic',
                rarityColor: RARITY_CONFIG.epic.color,
                hp: master.baseHp, maxHp: master.baseHp,
                damage: master.baseDamage, defense: master.baseDefense,
                xp: master.xp, gold: master.gold, level: master.level,
                possibleDrops: master.possibleDrops, dropRates: master.dropRates,
                isMaster: true, masterKey: masterKey,
                guaranteedDrops: master.guaranteedDrops
            };
            const maxHits   = calcPlayerHits(gameState.player);
            const pipTimers = [];
            for (let i = 0; i < maxHits; i++) {
                pipTimers.push(10);
            }
            gameState.combatState = {
                monsters: [masterMonster], currentTarget: 0,
                messages: [], defeatedMonsters: [],
                pipTimers:     pipTimers,
                pipAvailable:  pipTimers.map(() => true),
                enemyTimer:    18,
                enemyDelay:    18,
                enemyHits:     3,
                enemyHitsLeft: 3
            };
            // Open the terminal view (clear it fresh for a boss)
            openTerminalView(gameState.currentLocation);
            // stream the boss-intro line; show cards + start timer only after it finishes
            termAppend(`<span style="color:${RARITY_CONFIG.epic.color}; font-size:22px;">âš”ï¸ ${master.name} challenges you to an honorable duel! âš”ï¸</span>`, 'term-highlight', () => {
                renderEnemyCards();
                renderActionBar();
                startCombatTimer();
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // HUD â€“ write once, update in place
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function initHud() {
            updateHud();
        }
        function updateHud() {
    const p = gameState.player;

    // â”€â”€ HUD may be opened before character exists â”€â”€
    if (!p) {
        const hudName = document.getElementById('hudName');
        if (!hudName) return;

        hudName.textContent = 'â€” No Adventurer â€”';
        document.getElementById('hudGold').textContent   = 'ğŸ’° 0 g';
        document.getElementById('hudHpNums').textContent = 'â¤ï¸ HP: â€”';
        document.getElementById('hudMpNums').textContent = 'âœ¨ MP: â€”';
        document.getElementById('hudXpNums').textContent = 'â­ XP: â€”';
        return;
    }

    document.getElementById('hudName').textContent =
        `${p.name} â€“ Lv ${p.level} ${p.className}`;

    document.getElementById('hudGold').textContent =
        `ğŸ’° ${p.gold} g`;

    document.getElementById('hudHpNums').textContent =
        `â¤ï¸ HP: ${p.hp} / ${p.maxHp}`;

    document.getElementById('hudMpNums').textContent =
        `âœ¨ MP: ${p.mp} / ${p.maxMp}`;

    document.getElementById('hudXpNums').textContent =
        `â­ XP: ${p.xp} / ${p.xpToNext}`;
}


        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TERMINAL VIEW helpers
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
function openTerminalView(locKey) {
    document.getElementById('mainScreen').style.display = 'none';

    const hud = document.getElementById('hud');
    const term = document.getElementById('terminalWindow');
    const ab = document.getElementById('actionBar');

    hud.style.display = 'block';
    term.style.display = 'block';

  // ğŸ”‘ RESET terminal scroll position on open
requestAnimationFrame(() => {
    const tw = document.getElementById('terminalWindow');
    tw.scrollTop = 0;
});


// Dungeon always uses the action bar for movement
ab.style.display = 'block';

    initHud();

    if (!gameState._terminalOpen) {
        term.innerHTML = '';
        term.scrollTop = 0;
       

        gameState._terminalOpen = true;
        gameState._currentExploreArea = locKey;

        if (LOCATIONS?.[locKey]) {
            termAppend(`â”€â”€ ${LOCATIONS[locKey].name} â”€â”€`, 'term-separator');
        }
    }

    updateTerminalSafeArea();

}


        function closeTerminalView() {
            document.getElementById('mainScreen').style.display    = 'block';
            document.getElementById('hud').style.display           = 'none';
            document.getElementById('terminalWindow').style.display = 'none';
            document.getElementById('actionBar').style.display     = 'none';
            gameState._terminalOpen = false;
            gameState._currentExploreArea = null;
        }
        // â”€â”€ modem-style line queue â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const termQueue   = [];          // pending { html, extraClass, onDone }
        let   termBusy    = false;       // true while a line is mid-stream

        function termAppend(html, extraClass, onDone) {
            termQueue.push({ html, extraClass, onDone: onDone || null });
            if (!termBusy) termDrain();
        }

        function scrollTerminalToBottom() {
    const tw = document.getElementById('terminalWindow');
    
}


 function termDrain() {
    if (termQueue.length === 0) {
        termBusy = false;
        return;
    }

    termBusy = true;
    const { html, extraClass, onDone } = termQueue.shift();
    const tw = document.getElementById('terminalWindow');

    // âœ… Decide ONCE whether we should auto-scroll
    const shouldAutoScroll =
        tw.scrollHeight <= tw.clientHeight + 5 ||
        tw.scrollHeight - tw.scrollTop - tw.clientHeight < 40;

    const line = document.createElement('div');
    line.className = 'term-line' + (extraClass ? ' ' + extraClass : '');
    tw.appendChild(line);

    // separator or empty lines
    if (extraClass === 'term-separator' || html === '') {
        line.innerHTML = html;
        if (shouldAutoScroll) {
            tw.scrollTop = tw.scrollHeight;
        }
        if (onDone) onDone();
        termDrain();
        return;
    }

    // instant mode
    if (currentModemSpeed === 'instant') {
        line.innerHTML = html;
        if (shouldAutoScroll) {
            tw.scrollTop = tw.scrollHeight;
        }
        if (onDone) onDone();
        termDrain();
        return;
    }

    // streaming mode
    const charsPerTick = MODEM_SPEEDS[currentModemSpeed];
    let visibleCount = 0;
    let totalVisible = 0;

    // count visible characters (ignore HTML tags)
    {
        let inTag = false;
        for (let i = 0; i < html.length; i++) {
            if (html[i] === '<') inTag = true;
            else if (html[i] === '>') inTag = false;
            else if (!inTag) totalVisible++;
        }
    }

    const ticker = setInterval(() => {
        visibleCount += charsPerTick;

        if (visibleCount >= totalVisible) {
            clearInterval(ticker);
            line.innerHTML = html;

            // âœ… scroll ONLY after line completes
            if (shouldAutoScroll) {
                tw.scrollTop = tw.scrollHeight;
            }

            if (onDone) onDone();
            termDrain();
        } else {
            line.innerHTML =
                sliceToVisible(html, visibleCount) +
                '<span style="animation:blink 1s infinite;">_</span>';
        }
    }, 16);
}



            function sliceToVisible(html, n) {
    let vis = 0;
    let inTag = false;

    for (let i = 0; i < html.length; i++) {
        if (html[i] === '<') inTag = true;
        else if (html[i] === '>') inTag = false;
        else if (!inTag) {
            vis++;
            if (vis >= n) return html.slice(0, i + 1);
        }
    }
    return html;
}


     

       function termClear() {
    const tw = document.getElementById('terminalWindow');
    tw.innerHTML = '';
    tw.scrollTop = 0;  // ğŸ”¥ RESET SCROLL TO TOP
}


        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EXPLORE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function exploreLocation(locKey) {
            document.body.classList.add("terminal-mode");

            const location = LOCATIONS[locKey];
            const p = gameState.player;
            if (!p.unlockedAreas.includes(locKey)) {
    document.body.classList.remove("terminal-mode"); // ğŸ‘ˆ ADD THIS
    alert(location.unlockMessage || 'This area is locked!');
    showExplore();
    return;
}

            gameState.currentLocation = locKey;

            // If we just arrived (from town / map), open the terminal fresh
            if (!gameState._terminalOpen || gameState._currentExploreArea !== locKey) {
                gameState._terminalOpen = false;   // force fresh open
                openTerminalView(locKey);
            } else {
                // Already in this area â€“ just add a separator
                termAppend('', 'term-separator');
            }

            if (Math.random() < 0.7) {
                const numMonsters = rollMonsterCount();
                const enemyKeys = [];
                for (let i = 0; i < numMonsters; i++) {
                    enemyKeys.push(location.encounters[Math.floor(Math.random() * location.encounters.length)]);
                }
                startCombat(enemyKeys);
            } else {
                termAppend(`You explore the areaâ€¦ but find nothing.`, 'term-dim');
                renderActionBar();   // show "Continue / Town" buttons
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COMBAT â€“ start / spawn / rarity
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function rollMonsterCount() {
            const r = Math.random() * 100;
            if (r < 70) return 1;
            if (r < 95) return 2;
            return 3;
        }
        function startCombat(enemyKeys) {
            if (!Array.isArray(enemyKeys)) enemyKeys = [enemyKeys];
            const monsters = enemyKeys.map(k => spawnMonsterWithRarity(k));

            let msg;
            if (monsters.length === 1)
                msg = `A wild <span style="color:${monsters[0].rarityColor};">${monsters[0].name}</span> appears!`;
            else {
                const names = monsters.map(m => `<span style="color:${m.rarityColor};">${m.name}</span>`).join(', ');
                msg = `${monsters.length} enemies appear: ${names}!`;
            }

            // enemy multi-hit based on rarity of first monster
            const rar0 = monsters[0].rarity;
            let eHits = 1;
            if      (rar0==='rare')      eHits = Math.random()<0.5 ? 2 : 1;
            else if (rar0==='epic')      eHits = 2;
            else if (rar0==='legendary') eHits = 2 + (Math.random()<0.5 ? 1 : 0);
            else if (rar0==='mythic')    eHits = 3;

            const enemyDelay = 15 + Math.floor(Math.random()*6);  // 15-20s, fixed for this combat
            const maxHits    = calcPlayerHits(gameState.player);
            const pipTimers  = [];
            for (let i = 0; i < maxHits; i++) {
                pipTimers.push(10);  // each pip starts at 10s
            }
            gameState.combatState = {
                monsters, currentTarget: 0,
                messages: [], defeatedMonsters: [],
                pipTimers:     pipTimers,    // array of timers, one per pip
                pipAvailable:  pipTimers.map(() => true),  // which pips are ready
                enemyTimer:    enemyDelay,
                enemyDelay:    enemyDelay,
                enemyHits:     eHits,
                enemyHitsLeft: eHits
            };
            // stream the encounter line; show cards + start timer only after it finishes
            termAppend(msg, 'term-enemy', () => {
                renderEnemyCards();
                renderActionBar();
                startCombatTimer();
            });
        }

        function spawnMonsterWithRarity(enemyKey) {
            const template = ENEMIES[enemyKey];
            const rarity   = rollRarity();
            const mult     = RARITY_CONFIG[rarity].multiplier;
            return {
                key: enemyKey, name: template.name, rarity, rarityColor: RARITY_CONFIG[rarity].color,
                hp: Math.floor(template.baseHp * mult), maxHp: Math.floor(template.baseHp * mult),
                damage: Math.floor(template.baseDamage * mult), defense: Math.floor(template.baseDefense * mult),
                xp: Math.floor(template.baseXp * mult), gold: Math.floor(template.baseGold * mult),
                level: template.level, possibleDrops: template.possibleDrops, dropRates: template.dropRates
            };
        }
        function rollRarity() {
            const roll = Math.random() * 100;
            let cum = 0;
            for (const [rarity, config] of Object.entries(RARITY_CONFIG)) {
                cum += config.spawnWeight;
                if (roll < cum) return rarity;
            }
            return 'common';
        }
        function getRarityText(rarity) {
            return `<span style="color:${RARITY_CONFIG[rarity].color}; font-weight:bold;">${RARITY_CONFIG[rarity].name}</span>`;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ENEMY CARDS â€“ rendered into terminal, updated in place
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function renderEnemyCards() {
            // Enemy info is now shown only in terminal messages - no visual cards needed
            // This function is still called for compatibility but does nothing
        }
        function updateEnemyCards() {
            // No longer needed - enemy info shown in terminal only
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ACTION BAR â€“ combat buttons / explore buttons / spell & potion menus
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
       function renderDungeonActionBar() {
    const ab = document.getElementById('actionBar');

    function updateTerminalSafeArea() {
        const term = document.getElementById('terminalWindow');
        const bar  = document.getElementById('actionBar');
        if (!term || !bar) return;

        const barHeight = bar.offsetHeight;
        term.style.paddingBottom = barHeight + 'px';
    }

    // If in combat, use the regular combat action bar
    if (gameState.combatState) {
        renderActionBar();
        return;
    }

    // Dungeon navigation owns the action bar when not in combat
    ab.innerHTML = '';
    ab.style.display = 'block';

    const ds = gameState.dungeon;
    if (!ds) return;

    // Safety check for DUNGEONS
    if (typeof DUNGEONS === 'undefined') {
        console.error('âš ï¸ DUNGEONS not loaded!');
        ab.innerHTML = '<button onclick="returnToTown()">âš ï¸ ERROR - Return to Town</button>';
        return;
    }

    const dungeon = DUNGEONS[ds.dungeonKey];
    const floor = dungeon.floors[ds.floor];
    const room = floor.rooms[ds.currentRoom];

    // Entrance-only exit
    if (ds.currentRoom === floor.startRoom) {
        const exitBtn = document.createElement('button');
        exitBtn.textContent = 'â¬… Return to Town';
        exitBtn.onclick = returnToTown;
        ab.appendChild(exitBtn);
    }

    // Directions (data-driven)
    Object.keys(room.exits).forEach(dir => {
        const btn = document.createElement('button');
        btn.textContent = dir.toUpperCase();
        btn.onclick = () => moveInDungeon(dir);
        ab.appendChild(btn);
    });
}







        
        
        function renderActionBar() {
            const ab = document.getElementById('actionBar');
            showActionBar();
            if (gameState.combatState) {
                const cs       = gameState.combatState;
                const monsters = cs.monsters;
                const p        = gameState.player;
                const maxHits  = cs.pipAvailable ? cs.pipAvailable.length : calcPlayerHits(p);
                const hitsLeft = cs.pipAvailable ? cs.pipAvailable.filter(x => x).length : maxHits;
                const canAct   = hitsLeft > 0;

                // attack-charge pips  â—â—â—‹
                const pips = 'â—'.repeat(hitsLeft) + 'â—‹'.repeat(maxHits - hitsLeft);

                // Check what menu mode we're in
                const mode = cs.actionMode || 'main';

                if (mode === 'main') {
                    // Main combat menu
                    ab.innerHTML = `
                        <div style="color:var(--highlight-color);font-size:18px;margin-bottom:6px;">
                            ATTACKS: <span style="letter-spacing:3px;">${pips}</span>
                            <span style="color:#8aaa8a;font-size:15px;"> (${hitsLeft}/${maxHits})</span>
                        </div>
                        <div style="display:flex;flex-wrap:wrap;gap:6px;">
                            <button onclick="showAttackMenu()" ${!canAct?'disabled':''} class="action-icon-btn" title="Attack">âš”ï¸ Attack</button>
                            <button onclick="showSpellMenu()"  ${!canAct?'disabled':''} class="action-icon-btn" title="Cast Spell">âœ¨ Spell</button>
                            <button onclick="showPotionMenu()" ${!canAct?'disabled':''} class="action-icon-btn" title="Use Potion">ğŸ§ª Potion</button>
                            <button onclick="playerDefend()"   ${!canAct?'disabled':''} class="action-icon-btn" title="Defend">ğŸ›¡ï¸ Defend</button>
                            <button onclick="attemptFlee()"    ${!canAct?'disabled':''} class="action-icon-btn" title="Flee">ğŸƒ Flee</button>
                        </div>
                    `;
                } else if (mode === 'attack_type') {
                    // Attack type selection menu
                    const normalCost = 1;
                    const heavyCost = 2;
                    const specialCost = hitsLeft; // Uses all pips
                    
                    ab.innerHTML = `
                        <div style="color:var(--highlight-color);font-size:18px;margin-bottom:6px;">
                            CHOOSE ATTACK TYPE:
                        </div>
                        <div style="display:flex;flex-wrap:wrap;gap:6px;">
                            <button onclick="selectAttackType('normal')" ${hitsLeft < normalCost?'disabled':''} class="action-icon-btn">
                                âš”ï¸ Normal<br><span style="font-size:12px;">(1 pip)</span>
                            </button>
                            <button onclick="selectAttackType('heavy')" ${hitsLeft < heavyCost?'disabled':''} class="action-icon-btn">
                                ğŸ’¥ Heavy<br><span style="font-size:12px;">(2 pips)</span>
                            </button>
                            <button onclick="selectAttackType('special')" ${hitsLeft < 1?'disabled':''} class="action-icon-btn">
                                â­ Special<br><span style="font-size:12px;">(All pips)</span>
                            </button>
                            <button onclick="cancelAction()" class="action-icon-btn">âŒ Back</button>
                        </div>
                    `;
                } else if (mode === 'target_attack' || mode === 'target_spell') {
                    // Target selection menu
                    const actionName = mode === 'target_spell' ? cs.pendingSpell?.name || 'Spell' : 'Attack';
                    const targetBtns = monsters.map((m, i) => {
                        return `<button onclick="executeTargetedAction(${i})" class="target-btn">
                            #${i+1} ${m.name}<br>
                            <span style="font-size:12px;">HP: ${m.hp}/${m.maxHp}</span>
                        </button>`;
                    }).join('');
                    
                    ab.innerHTML = `
                        <div style="color:var(--highlight-color);font-size:18px;margin-bottom:6px;">
                            SELECT TARGET FOR ${actionName.toUpperCase()}:
                        </div>
                        <div style="display:flex;flex-wrap:wrap;gap:6px;">
                            ${targetBtns}
                            <button onclick="cancelAction()" class="action-icon-btn">âŒ Back</button>
                        </div>
                    `;
                } else if (mode === 'spell_list') {
                    // Spell selection menu
                    const spellBtns = p.knownSpells.map(sk => {
                        const spell = SPELLS[sk];
                        const canCast = p.mp >= spell.mpCost;
                        return `<button onclick="selectSpell('${sk}')" ${!canCast?'disabled':''} class="spell-btn">
                            ${spell.name}<br>
                            <span style="font-size:12px;">${spell.mpCost} MP</span>
                        </button>`;
                    }).join('');
                    
                    ab.innerHTML = `
                        <div style="color:var(--highlight-color);font-size:18px;margin-bottom:6px;">
                            SELECT SPELL:
                        </div>
                        <div style="display:flex;flex-wrap:wrap;gap:6px;">
                            ${spellBtns}
                            <button onclick="cancelAction()" class="action-icon-btn">âŒ Back</button>
                        </div>
                    `;
                }
            } else {
                ab.innerHTML = `
                    <button onclick="exploreLocation('${gameState.currentLocation}')">ğŸ” CONTINUE EXPLORING</button>
                    <button onclick="goBackToTown()">ğŸ˜ï¸ RETURN TO TOWN</button>
                `;
            }
        }
        function goBackToTown() {
            closeTerminalView();
            showTown();
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // NEW DYNAMIC COMBAT MENU SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function showAttackMenu() {
            const cs = gameState.combatState;
            if (!cs) return;
            cs.actionMode = 'attack_type';
            renderActionBar();
        }
        
        function selectAttackType(type) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            cs.pendingAttackType = type;
            cs.actionMode = 'target_attack';
            renderActionBar();
        }
        
        function cancelAction() {
            const cs = gameState.combatState;
            if (!cs) return;
            cs.actionMode = 'main';
            cs.pendingAttackType = null;
            cs.pendingSpell = null;
            renderActionBar();
        }
        
        function executeTargetedAction(targetIndex) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            cs.currentTarget = targetIndex;
            
            if (cs.actionMode === 'target_attack') {
                executeAttack(cs.pendingAttackType);
            } else if (cs.actionMode === 'target_spell') {
                castSpellOnTarget(cs.pendingSpell);
            }
            
            // Reset to main menu
            cs.actionMode = 'main';
            cs.pendingAttackType = null;
            cs.pendingSpell = null;
        }
        
        function selectSpell(spellKey) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            cs.pendingSpell = SPELLS[spellKey];
            cs.pendingSpellKey = spellKey;
            cs.actionMode = 'target_spell';
            renderActionBar();
        }
        
        // Update showSpellMenu to use the new system
        function showSpellMenuOld() {
            const cs = gameState.combatState;
            if (!cs) return;
            
            cs.actionMode = 'spell_list';
            renderActionBar();
        }
        

        function tryExploreLocation(locKey) {
            if (!isFullyRested()) {
                termAppend('<span style="color:var(--error-color);">You are too exhausted to continue! Wait for your charges to restoreâ€¦</span>', 'term-error');
                return;
            }
            // Clear old combat state now that we're starting fresh
            gameState.combatState = null;
            exploreLocation(locKey);
        }
        
        function tryGoBackToTown() {
            if (!isFullyRested()) {
                termAppend('<span style="color:var(--error-color);">You are too exhausted to travel! Wait for your charges to restoreâ€¦</span>', 'term-error');
                return;
            }
            // Clear combat state now that we're leaving
            gameState.combatState = null;
            goBackToTown();
        }
        
        function tryViewWorldMap() {
            if (!isFullyRested()) {
                termAppend('<span style="color:var(--error-color);">You are too exhausted to travel! Wait for your charges to restoreâ€¦</span>', 'term-error');
                return;
            }
            // Clear combat state now that we're leaving
            gameState.combatState = null;
            closeTerminalView();
            showExplore();
        }
        
        function selectTarget(index) {
            const cs = gameState.combatState;
            if (!cs || !cs.monsters || index < 0 || index >= cs.monsters.length) return;
            cs.currentTarget = index;
            updateEnemyCards();
            renderActionBar();
        }

        function isFullyRested() {
            const cs = gameState.combatState;
            if (!cs || !cs.pipAvailable) return true;
            // all pips must be available
            return cs.pipAvailable.every(x => x);
        }


      function startCombatTimer() {
    if (gameState.combatTimer) clearInterval(gameState.combatTimer);

    gameState.combatTimer = setInterval(() => {
        const cs = gameState.combatState;

        // No combat state at all â†’ stop timer
        if (!cs) {
            clearInterval(gameState.combatTimer);
            gameState.combatTimer = null;
            return;
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // PIP RECOVERY (always runs)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let anyRestored = false;

        for (let i = 0; i < cs.pipTimers.length; i++) {
            if (!cs.pipAvailable[i] && cs.pipTimers[i] > 0) {
                cs.pipTimers[i]--;
                if (cs.pipTimers[i] <= 0) {
                    cs.pipAvailable[i] = true;
                    cs.pipTimers[i] = 10;
                    anyRestored = true;
                }
            }
        }

        if (anyRestored) {
            renderActionBar();
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // POST-COMBAT RECOVERY CLEANUP
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (cs.combatOver) {
            // Once ALL pips are restored, exit recovery
            if (cs.pipAvailable.every(p => p)) {
                gameState.postCombatRecovery = false;
                gameState.combatState = null;

                renderActionBar();
                clearInterval(gameState.combatTimer);
                gameState.combatTimer = null;
            }
            return; // No enemy actions during recovery
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // ENEMY TIMER + INTENT TELEGRAPHING
        // (only while combat is active)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (cs.enemyTimer > 0) cs.enemyTimer--;

        // Telegraph intent 1 second before attack
        if (cs.enemyTimer === 1 && !cs.enemyIntent) {
            const enemy = cs.monsters[cs.currentTarget];
            if (enemy) {
                cs.enemyIntent = selectEnemyIntent(enemy);
                termAppend(
                    `<span style="color:${enemy.rarityColor};">${enemy.name}</span> ${cs.enemyIntent.telegraph}`,
                    'term-dim'
                );
            }
        }

        // Execute enemy attack
        if (cs.enemyTimer <= 0) {
            clearInterval(gameState.combatTimer);
            gameState.combatTimer = null;
            enemyAttackSingle();
        }

    }, 1000);
}


 // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLAYER ACTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function checkRoomEncounter(room) {
    if (!room || !room.encounter) return;

    const ds = gameState.dungeon;
    if (!ds.activeEnemies) ds.activeEnemies = [];

    // prevent re-triggering
    if (room.encounter.resolved) return;

    const enemyDef = ENEMIES[room.encounter.monsterId];
    if (!enemyDef) {
        console.warn('Enemy not found:', room.encounter.monsterId);
        return;
    }

    const enemyInstance = {
        id: crypto.randomUUID(),
        monsterId: room.encounter.monsterId,
        name: enemyDef.name,
        currentRoom: ds.currentRoom,
        leash: enemyDef.isBoss ? 6 : 3,
        roomsFollowed: 0
    };

    ds.activeEnemies.push(enemyInstance);
    room.encounter.resolved = true;

    termAppend(
        `âš ï¸ <strong>${enemyInstance.name}</strong> steps out of the shadows!`,
        'term-warning'
    );
}


function updateDungeonEnemies() {
    const ds = gameState.dungeon;
    if (!ds || !ds.activeEnemies) return;

    const dungeon = DUNGEONS[ds.dungeonKey];
    const floor = dungeon.floors[ds.floor];

    ds.activeEnemies.forEach(enemy => {
        const enemyRoom = floor.rooms[enemy.currentRoom];
        if (!enemyRoom) return;

        // ğŸ§  START chase ONLY when player enters enemy's room
        if (!enemy.isChasing && enemy.currentRoom === ds.currentRoom) {
            enemy.isChasing = true;
            enemy.roomsFollowed = 0;

            //  IF THE ENEMY IS CHASING YOU, PRINT THIS MESSAGE
         //   termAppend(
         //       `ğŸ‘ï¸ <strong>${enemy.name}</strong> begins to pursue youâ€¦`,
         //       'term-warning'
         //   );
         //   return;
        }

        // âŒ not chasing â†’ do nothing
        if (!enemy.isChasing) return;

        // ğŸ›‘ leash exhausted â†’ STOP and STAY
        if (enemy.roomsFollowed >= enemy.leash) {
            enemy.isChasing = false;

            termAppend(
                `ğŸ›‘ <strong>${enemy.name}</strong> stops the chase.`,
                'term-dim'
            );
            return; // â›” ABSOLUTELY REQUIRED
        }

        // ğŸ‘£ follow ONLY while chasing
        const exits = enemyRoom.exits || {};
for (const dir in exits) {
    if (exits[dir] === ds.currentRoom) {
        enemy.currentRoom = ds.currentRoom;
enemy.roomsFollowed++;
enemy.justArrived = true; // ğŸ‘ˆ add this

const fromDir = OPPOSITE_DIR[dir] || dir;

termAppend(
    `âš ï¸ <strong>${enemy.name}</strong> enters from the <em>${fromDir}</em>.`,
    'term-warning'
);

return;

    }
}

    });
}




function moveInDungeon(direction) {
    // Prevent movement during combat
    if (gameState.combatState) {
        termAppend(`âš”ï¸ You are engaged in combat!`, 'term-error');
        return;
    }

    if (!gameState.dungeon) {
        console.warn('Not in a dungeon');
        return;
    }

    const ds = gameState.dungeon;
    const dungeon = DUNGEONS[ds.dungeonKey];
    const floor = dungeon.floors[ds.floor];
    const currentRoom = floor.rooms[ds.currentRoom];

    const nextRoomId = currentRoom.exits[direction];
    if (!nextRoomId) {
        termAppend(`You cannot go that way.`, 'term-dim');
        return;
    }

    const nextRoom = floor.rooms[nextRoomId];

    ds.currentRoom = nextRoomId;
    ds.discoveredRooms.add(nextRoomId);
    nextRoom.flags.discovered = true;

    termAppend('', 'term-separator');
    termAppend(`<strong>${nextRoom.name}</strong>`);
    termAppend(nextRoom.description, 'term-dim');

   // ğŸ”¥ Spawn encounter (once)
checkRoomEncounter(nextRoom);

// ğŸ‘£ Move any active enemies that can follow
updateDungeonEnemies();

// âš”ï¸ combat trigger (AFTER enemies move)
//const enemyHere = getEnemyInRoom(ds.currentRoom);
//if (enemyHere) {
//    gameState.inCombat = true; // ğŸ‘ˆ HERE

    //termAppend(
    //    `âš”ï¸ <strong>${enemyHere.name}</strong> confronts you!`,
    //    'term-warning'
    // );

    //return;
// }

// ğŸ‘ï¸ enemies already present (no combat)
checkEnemiesInRoom(nextRoomId);

    const exits = Object.keys(nextRoom.exits)
        .map(d => d.toUpperCase())
        .join(', ');

    termAppend(`You see exits: ${exits}.`, 'term-dim');

    // ğŸ’¾ AUTO-SAVE after moving in dungeon (prevent cheating!)
    saveGame();

    // ğŸ”‘ update buttons for new room
    renderDungeonActionBar();
}


function getEnemyInRoom(roomId) {
    const ds = gameState.dungeon;
    if (!ds || !ds.activeEnemies) return null;

    return ds.activeEnemies.find(enemy => enemy.currentRoom === roomId) || null;
}



function checkEnemiesInRoom(roomId) {
    const ds = gameState.dungeon;
    if (!ds || !ds.activeEnemies) return;

    // Find enemy in current room
    const enemyHere = ds.activeEnemies.find(e => e.currentRoom === roomId);
    
    if (enemyHere) {
        // AUTO-ENGAGE COMBAT!
        termAppend(
            `âš”ï¸ <strong>${enemyHere.name}</strong> confronts you!`,
            'term-warning'
        );
        
        // Start combat with this dungeon enemy
        startDungeonCombat(enemyHere);
    }
}

function startDungeonCombat(dungeonEnemy) {
    // Get the full enemy definition
    const enemyDef = ENEMIES[dungeonEnemy.monsterId];
    if (!enemyDef) {
        console.error('Enemy definition not found:', dungeonEnemy.monsterId);
        return;
    }
    
    // Create combat monster from dungeon enemy
    const monster = createMonsterInstance(enemyDef);
    
    // Restore any saved HP from dungeon enemy
    if (dungeonEnemy.hp !== undefined) {
        monster.hp = dungeonEnemy.hp;
        monster.maxHp = dungeonEnemy.maxHp || monster.hp;
    }
    
    // Start normal combat
    startCombat([dungeonEnemy.monsterId]);
    
    // Link combat to dungeon enemy for persistence
    if (gameState.combatState) {
        gameState.combatState.dungeonEnemyId = dungeonEnemy.id;
    }
    
    // ğŸ’¾ Save combat state
    saveGame();
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TEMP: DUNGEON TEST HARNESS (SAFE)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function returnToTown() {
    document.body.classList.remove("terminal-mode");

    console.log('â¬… returnToTown() called');

    gameState.dungeon = null;

    termClear();

    const ab = document.getElementById('actionBar');
    ab.innerHTML = '';
    ab.style.display = 'none';

    document.getElementById('terminalWindow').style.display = 'none';
    document.getElementById('hud').style.display = 'none';

    document.getElementById('mainScreen').style.display = 'block';

    //ALWAYS RESTORE ACTION BAR FOR WORLD/COMBAT
    document.getElementById('actionBar').style.display = 'block';


    gameState._terminalOpen = false;
    gameState._currentExploreArea = null;
}

function testDungeon() {
    document.body.classList.add("terminal-mode");
    const dungeonKey = 'whisperingCrypt';
    const dungeon = DUNGEONS[dungeonKey];
    const floor = dungeon.floors[1];

    // ğŸ” reset encounter flags for testing
Object.values(floor.rooms).forEach(r => {
    if (r.encounter) {
        delete r.encounter.resolved;
    }
});


    gameState.dungeon = {
        dungeonKey,
        floor: 1,
        currentRoom: floor.startRoom,
        discoveredRooms: new Set([floor.startRoom]),
        activeEnemies: []   // ğŸ‘ˆ THIS WAS MISSING
    };

    openTerminalView(dungeonKey);

    const room = floor.rooms[floor.startRoom];
    room.flags.discovered = true;

    termAppend('', 'term-separator');
    termAppend(`<strong>${room.name}</strong>`);
    termAppend(room.description, 'term-dim');

    const exits = Object.keys(room.exits)
        .map(d => d.toUpperCase())
        .join(', ');

    termAppend(`You see exits: ${exits}.`, 'term-dim');

    // ğŸ’¾ AUTO-SAVE when entering dungeon (track dungeon state!)
    saveGame();

    renderDungeonActionBar();
}






function selectEnemyIntent(enemy) {
    // Default / basic attack
    let intent = {
        type: 'basic',
        damageMult: 1,
        armorPiercing: 0,
        telegraph: 'prepares to strike...'
    };

    // Bosses and elites sometimes wind up a heavy hit
    if (enemy.isBoss && Math.random() < 0.4) {
        intent = {
            type: 'heavy',
            damageMult: 1.75,
            armorPiercing: 0.3,
            telegraph: 'draws in power for a devastating attack!'
        };
    }

    return intent;
}



        function calculateDamage({
  attacker,
  defender,
  base,
  type = 'physical', // 'physical' | 'magic'
  critChance = 0,
  critMult = 1.5,
  dodgeChance = 0,
  armorPiercing = 0,
  isSpecial = false
}) {
  // Dodge check
  if (Math.random() < dodgeChance) {
    return { damage: 0, dodged: true, crit: false };
  }

  // Base damage roll
  let damage = base;

  // Defense mitigation
  let defense =
    type === 'magic'
      ? (defender.magicDefense || 0)
      : (defender.defense || 0);

  defense *= (1 - armorPiercing);
  damage = Math.max(1, Math.floor(damage - defense));

  // Crit check
  let crit = false;
  if (Math.random() < critChance) {
    damage = Math.floor(damage * critMult);
    crit = true;
  }

  return { damage, dodged: false, crit };
}

        
       function executeAttack(attackType) {
    const cs = gameState.combatState;
    if (!cs) return;

    const p = gameState.player;
    const ti = cs.currentTarget;
    const enemy = cs.monsters[ti];
    const weapon = WEAPONS[p.weapon];
    const qBonus = QUALITY_CONFIG[weapon.quality].bonus;

    // Determine pip cost and damage multiplier
    let pipCost = 1;
    let damageMultiplier = 1;
    let attackName = 'attacks';
    let armorPiercing = 0;
    
    if (attackType === 'normal') {
        pipCost = 1;
        damageMultiplier = 1;
        attackName = 'attacks';
    } else if (attackType === 'heavy') {
        pipCost = 2;
        damageMultiplier = 1.75;
        attackName = 'unleashes a <span style="color:#FF8800;">HEAVY STRIKE</span>';
        armorPiercing = 0.2;
    } else if (attackType === 'special') {
        // Use all available pips
        const availablePips = cs.pipAvailable.filter(x => x).length;
        pipCost = availablePips;
        damageMultiplier = 1 + (availablePips * 0.5); // Scales with pips used
        attackName = `unleashes a <span style="color:#FFD700;">â­ SPECIAL ATTACK â­</span> (${availablePips} pips)`;
        armorPiercing = 0.3;
    }

    // Check if we have enough pips
    const availablePips = cs.pipAvailable.filter(x => x).length;
    if (availablePips < pipCost) {
        termAppend('Not enough attack charges!', 'term-error');
        return;
    }

    // Consume pips
    let consumed = 0;
    for (let i = 0; i < cs.pipAvailable.length && consumed < pipCost; i++) {
        if (cs.pipAvailable[i]) {
            cs.pipAvailable[i] = false;
            cs.pipTimers[i] = 10;
            consumed++;
        }
    }

    // Calculate base damage
    const physicalBase = (weapon.baseDamage + qBonus) + (p.strength || 0) + (p.str || 0);
    const magicBase = (weapon.baseMagicDamage + qBonus) + Math.floor((p.magic || 0) / 2);
    const totalBase = Math.floor((physicalBase + magicBase) * damageMultiplier);

    // Damage resolution
    const result = calculateDamage({
        attacker: p,
        defender: enemy,
        base: totalBase,
        type: magicBase > physicalBase ? 'magic' : 'physical',
        critChance: calcCritChance(p.lck || 0) / 100,
        dodgeChance: enemy.dodge || 0,
        armorPiercing: armorPiercing
    });

    const tName = cs.monsters.length > 1
        ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${ti+1}</span>`
        : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;

    if (result.dodged) {
        termAppend(`You ${attackName} but ${tName} <span style="color:#88ff88;">DODGES!</span>`);
    } else {
        const critTag = result.crit ? ' <span style="color:#FFD700;">â˜… CRITICAL HIT!</span>' : '';
        enemy.hp -= result.damage;
        termAppend(
            `You ${attackName} ${tName} for <span class="dmg-enemy">${result.damage} damage!</span>${critTag}`,
            null,
            () => {
                checkCombatEnd();
                updateEnemyCards();
                updateHud();
                renderActionBar();
            }
        );
    }

    updateEnemyCards();
    updateHud();
    renderActionBar();
}

       // Legacy function kept for compatibility
       function playerAttack() {
    executeAttack('normal');
}

        function showSpellMenu() {
            const cs = gameState.combatState;
            if (!cs) return;
            const anyAvail = cs.pipAvailable && cs.pipAvailable.some(x => x);
            if (!anyAvail) return;
            const p = gameState.player;
            if (p.knownSpells.length === 0) {
                termAppend('You have no spells!', 'term-error');
                renderActionBar();
                return;
            }
            
            cs.actionMode = 'spell_list';
            renderActionBar();
        }

        function castSpellOnTarget(spell) {
            const p  = gameState.player;
            const cs = gameState.combatState;
            const spellKey = cs.pendingSpellKey;
            
            if (p.mp < spell.mpCost) {
                termAppend('Not enough MP!', 'term-error');
                return;
            }
            
            p.mp -= spell.mpCost;

            if (spell.type === 'heal') {
                const heal = spell.power + Math.floor(p.magic * 1.5) + (p.wis || 0);
                p.hp = Math.min(p.maxHp, p.hp + heal);
                updateHud();
                renderActionBar();
                termAppend(`You cast ${spell.name} and restore <span style="color:#88ff88;">${heal} HP!</span>`);
            } else {
                const ti    = cs.currentTarget;
                const enemy = cs.monsters[ti];
                let   dmg   = Math.max(1, (spell.power + p.magic + (p.wis||0)) - Math.floor(enemy.defense / 2));
                let crit = false;
                if (Math.random()*100 < calcCritChance(p.lck||0)) { dmg = Math.floor(dmg*1.75); crit = true; }
                enemy.hp -= dmg;
                
                const tName = cs.monsters.length > 1
                    ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${ti+1}</span>`
                    : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;
                updateEnemyCards();
                updateHud();
                renderActionBar();
                const critTag = crit ? ' <span style="color:#FFD700;">â˜… CRIT!</span>' : '';
                const hpPct = Math.max(0, (enemy.hp / enemy.maxHp) * 100);
                let condition = 'healthy';
                if (hpPct < 75) condition = 'injured';
                if (hpPct < 50) condition = 'wounded';
                if (hpPct < 25) condition = 'severely wounded';
                if (hpPct < 10) condition = 'barely standing';
                termAppend(`You cast ${spell.name} on ${tName} for <span class="dmg-enemy">${dmg} damage!</span>${critTag}`, null, () => {
                    if (enemy.hp > 0) {
                        termAppend(`â†’ ${tName} is <span style="color:#8aaa8a;">${condition}</span>`, 'term-dim');
                    }
                    checkCombatEnd();
                });
            }
        }

        // Legacy function for backward compatibility
        function castSpell(spellKey) {
            const spell = SPELLS[spellKey];
            castSpellOnTarget(spell);
        }

        function playerDefend() {
            const cs = gameState.combatState;
            if (!cs || cs.hitsLeft <= 0) return;
            cs.defending = true;
            cs.hitsLeft  = 0;            // end player's turn
            renderActionBar();
            termAppend('You brace for impactâ€¦');  // timer keeps ticking â†’ enemy phase
        }

        function attemptFlee() {
            const cs = gameState.combatState;
            if (!cs) return;
            
            // find first available pip
            let pipIndex = -1;
            for (let i = 0; i < cs.pipAvailable.length; i++) {
                if (cs.pipAvailable[i]) {
                    pipIndex = i;
                    break;
                }
            }
            if (pipIndex === -1) return;

            clearInterval(gameState.combatTimer);
            const p        = gameState.player;
            const fleePct  = Math.min(70, 30 + (p.dex||0)*3);
            if (Math.random()*100 < fleePct) {
                gameState.combatState = null;
                termAppend('You successfully fled!', 'term-highlight', () => {
                    renderActionBar();
                });
            } else {
                cs.pipAvailable[pipIndex] = false;
                cs.pipTimers[pipIndex] = 10;
                renderActionBar();
                termAppend('Failed to escape!', 'term-error');
                startCombatTimer();
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // POTION MENU (in action bar)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function showPotionMenu() {
            const cs = gameState.combatState;
            if (!cs) return;
            const anyAvail = cs.pipAvailable && cs.pipAvailable.some(x => x);
            if (!anyAvail) return;
            const p = gameState.player;
            const potions = {};
            p.inventory.forEach(ik => {
                if (ITEMS[ik] && ['heal_hp','heal_mp','full_restore'].includes(ITEMS[ik].subtype)) {
                    if (!potions[ik]) potions[ik] = { item: ITEMS[ik], count: 0 };
                    potions[ik].count++;
                }
            });
            const keys = Object.keys(potions);
            if (keys.length === 0) {
                termAppend('You have no potions!', 'term-error');
                renderActionBar();
                return;
            }
            const ab = document.getElementById('actionBar');
            let html = '<div class="action-label">USE POTION:</div>';
            keys.forEach(pk => {
                const pd  = potions[pk];
                const col = pd.item.subtype==='heal_hp' ? '#ff4444' : pd.item.subtype==='heal_mp' ? '#4488ff' : '#FFD700';
                html += `<button onclick="usePotion('${pk}')" style="color:${col};">${pd.item.name} x${pd.count} â€“ ${pd.item.description}</button> `;
            });
            html += `<br><button onclick="renderActionBar();">â† BACK</button>`;
            ab.innerHTML = html;
        }

        function usePotion(potionKey) {
            const potion = ITEMS[potionKey];
            const p      = gameState.player;
            let msg;
            if (potion.subtype === 'heal_hp') {
                const actual = Math.min(p.maxHp - p.hp, potion.power);
                p.hp = Math.min(p.maxHp, p.hp + potion.power);
                msg = `Used ${potion.name} â€“ restored <span style="color:#88ff88;">${actual} HP!</span>`;
            } else if (potion.subtype === 'heal_mp') {
                const actual = Math.min(p.maxMp - p.mp, potion.power);
                p.mp = Math.min(p.maxMp, p.mp + potion.power);
                msg = `Used ${potion.name} â€“ restored <span style="color:#88ff88;">${actual} MP!</span>`;
            } else if (potion.subtype === 'full_restore') {
                const hpR = p.maxHp - p.hp, mpR = p.maxMp - p.mp;
                p.hp = p.maxHp; p.mp = p.maxMp;
                msg = `Used ${potion.name} â€“ fully restored <span style="color:#88ff88;">${hpR} HP & ${mpR} MP!</span>`;
            }
            const idx = p.inventory.indexOf(potionKey);
            if (idx !== -1) p.inventory.splice(idx, 1);
            updateHud();
            renderActionBar();
            termAppend(msg);   // no callback â€“ timer keeps ticking, player can still act
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ENEMY ATTACK
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       function enemyAttackSingle() {
    // Enemy uses ONE charge, attacks once, then resets its own timer
    const cs       = gameState.combatState;
    const monsters = cs.monsters;
    const p        = gameState.player;

    // Defensive stats
    const armor    = ARMOR[p.armor];
    const qBonus   = QUALITY_CONFIG[armor.quality].bonus;
    let totalDef   = p.defense + armor.baseDefense + qBonus + (p.con || 0);

    if (cs.defending) {
        totalDef *= 2;
        cs.defending = false;
    }

    // Pull intent (or fallback)
    const intent = cs.enemyIntent || {
        type: 'basic',
        damageMult: 1,
        armorPiercing: 0
    };

    // Each monster in the pack gets ONE hit
    const hits = [];

    monsters.forEach((enemy, i) => {
        const eName = monsters.length > 1
            ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${i + 1}</span>`
            : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;

        // God mode bypass
        if (p.godMode) {
            hits.push({ eName, godMode: true });
            return;
        }

        const result = calculateDamage({
            attacker: enemy,
            defender: {
                defense: totalDef,
                magicDefense: totalDef
            },
            base: Math.floor(enemy.damage * intent.damageMult),
            type: enemy.magicAttack ? 'magic' : 'physical',
            dodgeChance: calcDodgeChance(p.dex || 0) / 100,
            armorPiercing: intent.armorPiercing
        });

        if (result.dodged) {
            hits.push({ eName, dodged: true });
            return;
        }

        p.hp -= result.damage;

        // â”€â”€ Passive hooks (future-safe) â”€â”€
        // if (enemy.passives?.includes('lifedrain')) {
        //     enemy.hp = Math.min(enemy.maxHp, enemy.hp + Math.floor(result.damage * 0.3));
        // }

        hits.push({
            eName,
            dmg: result.damage,
            crit: result.crit
        });
    });

    updateHud();

    // After attack messages stream, reset enemy timer and resume
    const afterAttack = () => {
        cs.enemyIntent = null; // clear intent after execution

        if (p.hp <= 0 && !p.godMode) {
            endCombat(false);
        } else {
            cs.enemyTimer = cs.enemyDelay;
            renderActionBar();
            startCombatTimer();
        }
    };

    hits.forEach((hit, i) => {
        const isLast = (i === hits.length - 1);

        if (hit.godMode) {
            termAppend(
                `${hit.eName} attacks but you are <span class="term-highlight">INVINCIBLE!</span>`,
                null,
                isLast ? afterAttack : null
            );
        } else if (hit.dodged) {
            termAppend(
                `${hit.eName} attacksâ€¦ <span style="color:#88ff88;">DODGED!</span>`,
                null,
                isLast ? afterAttack : null
            );
        } else {
            const critTag = hit.crit
                ? ' <span style="color:#FFD700;">â˜… CRIT!</span>'
                : '';

            termAppend(
                `${hit.eName} attacks for <span class="dmg-player">${hit.dmg} damage!</span>${critTag}`,
                null,
                isLast ? afterAttack : null
            );
        }
    });
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHECK / END COMBAT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function checkCombatEnd() {
    const cs = gameState.combatState;
    if (!cs || !cs.monsters || cs.monsters.length === 0) return;

    let ti = cs.currentTarget;

    // Clamp target index (important after splicing)
    if (ti < 0 || ti >= cs.monsters.length) {
        cs.currentTarget = 0;
        ti = 0;
    }

    const target = cs.monsters[ti];
    if (!target) return;

    if (!cs.defeatedMonsters) cs.defeatedMonsters = [];

    if (target.hp <= 0) {
        const dead = target;

        cs.defeatedMonsters.push(dead);
        cs.monsters.splice(ti, 1);

        // Adjust target again after removal
        if (cs.currentTarget >= cs.monsters.length) {
            cs.currentTarget = Math.max(0, cs.monsters.length - 1);
        }

        termAppend(
            `<span style="color:${dead.rarityColor};">${dead.name}</span> has been defeated!`,
            'term-victory',
            () => {
                if (cs.monsters.length === 0) {
                    endCombat(true);
                } else {
                    renderEnemyCards();
                }
            }
        );
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// END COMBAT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function endCombat(victory) {

    // â”€â”€ defeat â”€â”€
    if (!victory) {
        clearInterval(gameState.combatTimer);
        gameState.combatTimer = null;

        gameState.player.hp   = gameState.player.maxHp;
        gameState.player.mp   = gameState.player.maxMp;
        gameState.player.gold = Math.floor(gameState.player.gold / 2);

        gameState.combatState = null;
        gameState.postCombatRecovery = false;

        updateHud();
        termAppend(
            'You have been defeatedâ€¦ You wake up in town.',
            'term-error',
            () => setTimeout(() => { closeTerminalView(); showTown(); }, 1200)
        );
        return;
    }

    // â”€â”€ victory â”€â”€
    const defeated   = gameState.combatState.defeatedMonsters || [];
    const isMaster   = defeated.some(m => m.isMaster);
    let masterData   = null;
    let unlockedArea = null;

    if (isMaster) {
        const m = defeated.find(d => d.isMaster);
        masterData   = CLASS_MASTERS[m.masterKey];
        unlockedArea = masterData.unlocks;

        if (!gameState.player.defeatedMasters.includes(m.masterKey))
            gameState.player.defeatedMasters.push(m.masterKey);

        if (!gameState.player.unlockedAreas.includes(unlockedArea))
            gameState.player.unlockedAreas.push(unlockedArea);

        masterData.guaranteedDrops.forEach(ik => {
            if (!defeated[0].possibleDrops) defeated[0].possibleDrops = [];
            if (!defeated[0].possibleDrops.includes(ik))
                defeated[0].possibleDrops.push(ik);

            if (!defeated[0].dropRates) defeated[0].dropRates = {};
            defeated[0].dropRates[
                (WEAPONS[ik] || ARMOR[ik]) ? getItemQuality(ik) : 'common'
            ] = 1.0;
        });
    }

    let totalXp = 0, totalGold = 0, allLoot = [];
    defeated.forEach(e => {
        totalXp   += e.xp;
        totalGold += e.gold;
        allLoot    = allLoot.concat(rollLoot(e));
    });

    gameState.player.xp   += totalXp;
    gameState.player.gold += totalGold;

    // â”€â”€ Remove defeated dungeon enemy â”€â”€
    if (gameState.dungeon && gameState.combatState?.dungeonEnemyId) {
        const dungeonEnemyId = gameState.combatState.dungeonEnemyId;
        gameState.dungeon.activeEnemies = gameState.dungeon.activeEnemies.filter(
            e => e.id !== dungeonEnemyId
        );
        console.log(`ğŸ—‘ï¸ Removed dungeon enemy: ${dungeonEnemyId}`);
    }

    // â”€â”€ terminal output â”€â”€
    termAppend('', 'term-separator');

    if (isMaster) {
        termAppend(`ğŸ† ${masterData.name} HAS BEEN DEFEATED! ğŸ†`, 'term-victory');
        termAppend(`âœ¨ ${LOCATIONS[unlockedArea].name} IS NOW UNLOCKED! âœ¨`, 'term-loot');
    }

    if (defeated.length === 1) {
        termAppend(
            `You defeated <span style="color:${defeated[0].rarityColor};">${defeated[0].name}</span>!`,
            'term-highlight'
        );
    } else {
        termAppend(`You defeated ${defeated.length} enemies!`, 'term-highlight');
        defeated.forEach(e =>
            termAppend(`  â€¢ <span style="color:${e.rarityColor};">${e.name}</span>`)
        );
    }

    termAppend(
        `Gained <span style="color:#FFD700;">${totalXp} XP</span> and ` +
        `<span style="color:#FFD700;">${totalGold} Gold</span>!`
    );

    if (allLoot.length > 0) {
        termAppend('âš¡ LOOT:', 'term-loot');
        allLoot.forEach(ik => {
            gameState.player.inventory.push(ik);
            termAppend(
                `  + <span style="color:${getItemColor(ik)};">${getItemName(ik)}</span>`,
                'term-loot'
            );
        });
    } else {
        termAppend('No items droppedâ€¦', 'term-dim');
    }

    if (gameState.player.xp >= gameState.player.xpToNext) {
        levelUp();
        termAppend(`â¬†ï¸ LEVEL UP! You are now level ${gameState.player.level}!`, 'term-victory');
    }

    updateHud();
    
    // ğŸ’¾ AUTO-SAVE after victory
    saveGame();

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // âœ… EXIT COMBAT, ENTER EXHAUSTION
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Mark combat as finished, but keep state for timers & UI
gameState.combatState.combatOver = true;
gameState.postCombatRecovery = true;


    const ab = document.getElementById('actionBar');
    
    // Check if we're in a dungeon
    if (gameState.dungeon) {
        ab.innerHTML = `
            <button onclick="continueDungeonExploration()">ğŸ” CONTINUE EXPLORING</button>
            <button onclick="returnToTown()">ğŸ˜ï¸ RETURN TO TOWN</button>`;
    } else if (isMaster) {
        ab.innerHTML = `
            <button onclick="tryViewWorldMap()">ğŸ—ºï¸ VIEW WORLD MAP</button>
            <button onclick="tryGoBackToTown()">ğŸ˜ï¸ RETURN TO TOWN</button>`;
    } else {
        ab.innerHTML = `
            <button onclick="tryExploreLocation('${gameState.currentLocation}')">ğŸ” CONTINUE EXPLORING</button>
            <button onclick="tryGoBackToTown()">ğŸ˜ï¸ RETURN TO TOWN</button>`;
    }

    renderActionBar();

    if (!gameState.combatTimer) {
        startCombatTimer();
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POST-COMBAT EXHAUSTION CHECK
// (used by navigation actions)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function continueDungeonExploration() {
    if (!isFullyRested()) {
        termAppend('<span style="color:var(--error-color);">You are too exhausted to continue! Wait for your charges to restoreâ€¦</span>', 'term-error');
        return;
    }
    // Clear combat state and return to dungeon navigation
    gameState.combatState = null;
    gameState.postCombatRecovery = false;
    renderDungeonActionBar();
}

function playerIsExhausted() {
    if (!gameState.postCombatRecovery) return false;

    const cs = gameState.combatState;
    if (!cs || !cs.pipAvailable) return false;

    return cs.pipAvailable.some(p => !p);
}
        function levelUp() {
            const p = gameState.player;
            p.level++;
            p.xp -= p.xpToNext;
            p.xpToNext = Math.floor(p.xpToNext * 1.5);

            // legacy base stats
            p.maxHp += 15 + (p.con||0);   // CON scales HP gain
            p.hp     = p.maxHp;
            p.maxMp += 10;
            p.mp     = p.maxMp;
            p.strength += 2;
            p.defense  += 2;
            p.magic    += 2;
            p.speed    += 1;

            // new stat-block: +1 each
            if (p.str !== undefined) {
                p.str++; p.dex++; p.wis++; p.cha++; p.con++; p.lck++;
                // paladin bonus: extra +1 to both STR and WIS
                if (p.class === 'paladin') { p.str++; p.wis++; }
            }

            // Learn new spells
            const spellLevels = {
                2: ['fireball', 'heal'],
                3: ['holy_light'],
                4: ['lightning'],
                5: ['greater_heal'],
                6: ['ice_storm'],
                8: ['meteor']
            };

            if (spellLevels[p.level]) {
                spellLevels[p.level].forEach(spellKey => {
                    if (!p.knownSpells.includes(spellKey)) {
                        p.knownSpells.push(spellKey);
                    }
                });
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // LOOT DROP SYSTEM (Phase 1)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function rollLoot(monster) {
            const loot = [];
            const rarityBonus = RARITY_CONFIG[monster.rarity].dropBonus || 0;
            
            if (!monster.possibleDrops || monster.possibleDrops.length === 0) {
                return loot;
            }
            
            monster.possibleDrops.forEach(itemKey => {
                let dropChance = 0;
                
                // Determine base drop chance
                if (ITEMS[itemKey]) {
                    // Consumable/sellable items use common drop rate
                    dropChance = monster.dropRates.common || 0.3;
                } else if (WEAPONS[itemKey] || ARMOR[itemKey]) {
                    // Equipment uses quality-based drop rates
                    const quality = getItemQuality(itemKey);
                    dropChance = monster.dropRates[quality] || 0.05;
                }
                
                // Apply rarity bonus + player LCK luck bonus
                const lckBonus = gameState.player ? calcLootBonus(gameState.player.lck || 0) / 100 : 0;
                const adjustedChance = Math.min(0.95, dropChance * (1 + rarityBonus * 0.1 + lckBonus));
                
                if (Math.random() < adjustedChance) {
                    loot.push(itemKey);
                }
            });
            
            // SPECIAL: Magical Butterknife check (Red Dragons only!)
            if (monster.key === 'red_dragon' && Math.random() < 0.000001) {
                loot.push('magical_butterknife');
                // Alert SYSOP terminal if active
                if (gameState.sysop && gameState.sysop.authenticated) {
                    terminalPrint('âš ï¸âš ï¸âš ï¸ ULTRA RARE DROP: MAGICAL BUTTERKNIFE! âš ï¸âš ï¸âš ï¸', 'success');
                }
            }
            
            return loot;
        }

        function getItemName(itemKey) {
            if (WEAPONS[itemKey]) return WEAPONS[itemKey].name;
            if (ARMOR[itemKey]) return ARMOR[itemKey].name;
            if (ITEMS[itemKey]) return ITEMS[itemKey].name;
            if (SPELLS[itemKey]) return SPELLS[itemKey].name;
            return itemKey;
        }

        function getItemColor(itemKey) {
            if (WEAPONS[itemKey]) {
                return QUALITY_CONFIG[WEAPONS[itemKey].quality].color;
            }
            if (ARMOR[itemKey]) {
                return QUALITY_CONFIG[ARMOR[itemKey].quality].color;
            }
            // Default green for items
            return '#00FF00';
        }

        function getItemQualityText(itemKey) {
            if (WEAPONS[itemKey]) {
                const quality = WEAPONS[itemKey].quality;
                return `[${QUALITY_CONFIG[quality].name}]`;
            }
            if (ARMOR[itemKey]) {
                const quality = ARMOR[itemKey].quality;
                return `[${QUALITY_CONFIG[quality].name}]`;
            }
            return '';
        }

        function getItemQuality(itemKey) {
            if (WEAPONS[itemKey]) return WEAPONS[itemKey].quality;
            if (ARMOR[itemKey]) return ARMOR[itemKey].quality;
            return 'normal';
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // END LOOT DROP SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


        function respawn() {
            gameState.player.hp = gameState.player.maxHp;
            gameState.player.mp = gameState.player.maxMp;
            gameState.player.gold = Math.floor(gameState.player.gold / 2);
            gameState.combatState = null;
            showTown();
        }


        // Start the game
        initGame();



    </script>
</body>
</html>