<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>âš”ï¸ DUNGEON QUEST  âš”ï¸</title>
   
   
   <style>

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ GLOBAL LAYOUT FIX (PUT THIS FIRST) â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
*,
*::before,
*::after {
    box-sizing: border-box;
}

html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    /* let each child manage its own overflow */
}

body {
    -webkit-user-select: none;
    user-select: none;
    touch-action: manipulation;
}

/* â”€â”€ Menu container (town/shop) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#menuContainer {
    height: 100%;
    height: 100dvh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    max-width: 900px;
    margin: 0 auto;
}

/* â”€â”€ Gameplay wrapper â€” full viewport, column flex â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#gameWrapper {
    position: fixed;          /* pin to viewport â€” immune to container padding */
    inset: 0;                 /* top/right/bottom/left = 0 */
    display: none;            /* JS shows this */
    flex-direction: column;
    overflow: hidden;
    /* safe area padding for notched phones */
    padding-bottom: env(safe-area-inset-bottom, 0px);
    box-sizing: border-box;
}

/* Shown in terminal mode */
body.terminal-mode #gameWrapper {
    display: flex;
}

/* â”€â”€ Desktop HUD (top) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#hud {
    flex: 0 0 auto;
    display: none;
}
body.terminal-mode #hud { display: block; }

/* â”€â”€ Mobile HUD (above action bar) â€” hidden on desktop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#mobileHud {
    display: none;  /* JS/CSS controls this */
    flex: 0 0 auto;
    background: var(--secondary-bg);
    border-top: 1px solid var(--border-color);
    padding: 2px 6px;
    box-sizing: border-box;
}

/* â”€â”€ Legacy bottomHud â€” always hidden â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#bottomHud { display: none !important; }

/* â”€â”€ Terminal â€” takes ALL leftover space, scrolls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#terminalWindow {
    flex: 1 1 0;
    min-height: 0;                     /* CRITICAL for flex scrolling */
    overflow-y: scroll;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior-y: contain;
    display: none;
}
body.terminal-mode #terminalWindow { display: block; }

/* â”€â”€ Action bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#actionBar {
    flex: 0 0 auto;
    display: none;
    overflow: visible;
    box-sizing: border-box;
}
body.terminal-mode #actionBar { display: block; }

/* default button sizing â€” minimal, let content + flex size them */
#actionBar button {
    min-width: 0;
    min-height: 32px;
    border-radius: 5px;
}

        @import url('https://fonts.googleapis.com/css2?family=VT323&family=Press+Start+2P&display=swap');

        :root {
            --primary-bg: #000080;
            --secondary-bg: #000000;
            --text-color: #00FF00;
            --highlight-color: #FFFF00;
            --error-color: #FF0000;
            --border-color: #00FFFF;
            --menu-color: #FFFFFF;
        }

        body {
            background: var(--primary-bg);
            color: var(--text-color);
            font-family: 'VT323', monospace;
            font-size: 20px;
            line-height: 1.4;
        }

        .scanline {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                transparent 50%,
                rgba(0, 0, 0, 0.25) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 1000;
            animation: flicker 0.15s infinite;
        }

        @keyframes flicker {
            0% { opacity: 0.95; }
            50% { opacity: 1; }
            100% { opacity: 0.95; }
        }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }

        @keyframes flashOrange {
            0%, 100% { color: #FF8C00; text-shadow: 0 0 6px #FF8C00; }
            50%      { color: #FFD700; text-shadow: 0 0 14px #FFD700; }
        }

        @keyframes flashRed {
            0%, 100% { color: #FF0000; text-shadow: 0 0 6px #FF0000; }
            50%      { color: #FF4444; text-shadow: 0 0 14px #FF4444; }
        }

        .dmg-player {
            animation: flashOrange 0.6s ease-in-out infinite;
            font-weight: bold;
        }

        .dmg-enemy {
            animation: flashRed 0.6s ease-in-out infinite;
            font-weight: bold;
        }

     .container {
    height: 100%;
    max-width: 900px;
    margin: 0 auto;
    padding: 0;
    display: flex;
    flex-direction: column;
    overflow: hidden; /* prevent container overflow */
}


        .header {
            flex-shrink: 0; /* prevent header from shrinking */
            text-align: center;
            border: 3px double var(--border-color);
            padding: 8px;
            margin-bottom: 8px;
            background: var(--secondary-bg);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .header h1 {
            font-family: 'Press Start 2P', monospace;
            font-size: 20px;
            color: var(--highlight-color);
            text-shadow: 2px 2px var(--error-color);
            margin-bottom: 5px;
            animation: titlePulse 2s infinite;
            transition: all 0.3s ease;
        }
        
        .header p {
            margin: 0;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        /* Compact header during gameplay */
        body.terminal-mode .header {
            padding: 4px;
            margin-bottom: 4px;
            border-width: 2px;
        }
        
        body.terminal-mode .header h1 {
            font-size: 12px;
            margin-bottom: 2px;
            animation: none; /* disable pulse during gameplay */
        }
        
        body.terminal-mode .header > div {
            display: none; /* hide decorative lines and subtitle */
        }

        @keyframes titlePulse {
            0%, 100% { text-shadow: 2px 2px var(--error-color); }
            50% { text-shadow: 2px 2px var(--error-color), 0 0 10px var(--highlight-color); }
        }
        
        @keyframes flash-green {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3) hue-rotate(10deg); }
        }
        
        @keyframes flash-blue {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2) hue-rotate(-20deg); }
        }

        /* â”€â”€â”€ main screen used by town / shop / menus â”€â”€â”€ */
        .screen {
            flex: 1 1 auto; /* allow screen to grow/shrink */
            min-height: 0; /* critical for flex scrolling */
            overflow-y: auto; /* enable scrolling */
            -webkit-overflow-scrolling: touch; /* smooth scrolling on iOS */
            
            background: var(--secondary-bg);
            border: 2px solid var(--border-color);
            padding: 12px;
            margin-bottom: 8px;
            box-shadow: inset 0 0 50px rgba(0, 255, 0, 0.1);
        }
        
        .menu-option {
            color: var(--menu-color);
            cursor: pointer;
            padding: 8px;
            margin: 5px 0;
            transition: all 0.1s;
        }
        .menu-option:hover {
            background: var(--primary-bg);
            color: var(--highlight-color);
            padding-left: 20px;
        }
        .menu-option.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            color: #666;
        }
        .menu-option.disabled:hover {
            background: transparent;
            padding-left: 8px;
        }

        /* â”€â”€â”€ desktop HUD visual styles â”€â”€â”€ */
#hud {
    background: var(--secondary-bg);
    border: 2px solid var(--border-color);
    border-bottom: none;
    padding: 6px 10px;
    box-shadow: inset 0 0 30px rgba(0,255,0,0.08);
}

        /* â”€â”€â”€ mobile HUD strip (between terminal and action bar) â”€â”€â”€ */
#mobileHud {
    display: none;
    font-family: 'VT323', monospace;
    font-size: 13px;
    line-height: 1;
    background: var(--secondary-bg);
    border-top: 1px solid #2a5a2a;
    border-bottom: 1px solid #2a5a2a;
    padding: 3px 6px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    box-sizing: border-box;
}
#mobileHud span {
    display: inline-block;
    margin-right: 8px;
}
#mobileHud #mhName  { color: var(--highlight-color); font-size: 12px; }
#mobileHud #mhHp    { color: #ff6666; }
#mobileHud #mhMp    { color: #4488ff; }
#mobileHud #mhXp    { color: var(--text-color); }
#mobileHud #mhGold  { color: #FFD700; }


        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 4px;
        }
        .hud-top .hud-name { color: var(--highlight-color); font-size: 18px; }
        .hud-top .hud-gold { color: #FFD700; font-size: 16px; }
        .hud-bars {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }
        .hud-bar-group label {
            color: var(--highlight-color);
            font-size: 14px;
            display: block;
            margin-bottom: 2px;
        }
        .hud-bar-group .bar-nums { color: var(--text-color); font-size: 14px; }
        .progress-bar {
            width: 100%;
            height: 12px;
            background: #111;
            border: 1px solid var(--border-color);
            margin-top: 2px;
        }
        .progress-fill { height: 100%; transition: width 0.35s ease; }
        .hp-bar { background: var(--error-color); }
        .mp-bar { background: #4488ff; }
        .xp-bar { background: var(--text-color); }

        /* â”€â”€â”€ scrolling terminal visual styles â”€â”€â”€ */
#terminalWindow {
    background: var(--secondary-bg);
    border: 2px solid var(--border-color);
    border-top: 1px solid #333;
    padding: 8px 10px;
    box-shadow: inset 0 0 40px rgba(0,255,0,0.07);
    /* NOTE: no scroll-behavior:smooth â€” it fights with programmatic scrollTop on mobile */
}

        .term-line {
            padding: 2px 0;
            font-size: 16px;
            color: var(--text-color);
            line-height: 1.3;
        }
        .term-line.term-dim       { color: #3a7a3a; }
        .term-line.term-highlight { color: var(--highlight-color); }
        .term-line.term-enemy     { color: var(--border-color); font-size: 17px; }
        .term-line.term-loot      { font-size: 17px; }
        .term-line.term-system    { color: #888; font-style: italic; }
        .term-line.term-separator { margin-top: 6px; padding-top: 6px; border-top: 1px solid #2a4a2a; }

        /* â”€â”€â”€ action bar visual styles â”€â”€â”€ */
#actionBar {
    background: var(--secondary-bg);
    border-top: 2px solid var(--border-color);
    padding: 5px 6px;
    gap: 4px;
}


        #actionBar button {
            background: linear-gradient(180deg, #1a1a1a 0%, #0a0a0a 100%);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            padding: 6px 8px;
            font-family: 'VT323', monospace;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.15s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            min-width: 0;
            min-height: 0;
            box-sizing: border-box;
        }
        
        /* Combat action buttons â€” one tight row */
        .action-icon-btn {
            flex: 1 1 0;
            min-width: 0 !important;
            padding: 6px 4px !important;
            text-align: center;
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
        }
        
        /* Target selection buttons */
        .target-btn {
            flex: 1 1 0;
            min-width: 0 !important;
            padding: 6px 5px !important;
            background: linear-gradient(180deg, #0a2a0a 0%, #051505 100%) !important;
            border-color: var(--text-color) !important;
        }
        
        .target-btn:hover:not(:disabled) {
            background: linear-gradient(180deg, #0f3f0f 0%, #0a2a0a 100%) !important;
            border-color: var(--highlight-color) !important;
            color: var(--highlight-color) !important;
        }
        
        /* Spell selection buttons */
        .spell-btn {
            flex: 1 1 0;
            min-width: 0 !important;
            padding: 6px 4px !important;
            background: linear-gradient(180deg, #1a1a2a 0%, #0a0a15 100%) !important;
            border-color: #4488ff !important;
            font-size: 13px;
            line-height: 1.2;
        }
        
        .spell-btn:hover:not(:disabled) {
            background: linear-gradient(180deg, #2a2a4a 0%, #1a1a2a 100%) !important;
            border-color: #88bbff !important;
            color: #88bbff !important;
        }

        /* â”€â”€ PIP COOLDOWN SWEEP (Diablo/WoW style) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .pip-btn {
            position: relative;
            overflow: hidden;
            isolation: isolate;
        }
        .pip-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            background: conic-gradient(
                rgba(0,0,0,0.70) var(--pip-pct, 100%),
                transparent      var(--pip-pct, 100%)
            );
            pointer-events: none;
            z-index: 1;
            transition: none;
        }
        .pip-btn > *, .pip-btn span { position: relative; z-index: 2; }
        .pip-btn.cooling {
            border-color: #ff8c00 !important;
            box-shadow: 0 0 8px rgba(255,140,0,0.35) !important;
        }
        .pip-btn.all-ready {
            border-color: #00ff88 !important;
            box-shadow: 0 0 10px rgba(0,255,136,0.5) !important;
        }
        .pip-badge {
            position: absolute;
            top: 2px; right: 4px;
            font-size: 10px; line-height: 1;
            color: #ff8c00;
            z-index: 3;
            pointer-events: none;
        }

        #actionBar button:hover {
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
            color: var(--highlight-color);
            border-color: var(--highlight-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 255, 0, 0.3);
        }
        #actionBar button:active {
            transform: translateY(0);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.8);
        }
        #actionBar button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }



        .term-line.term-victory   { color: var(--border-color); font-size: 22px; }
        .term-line.term-loot      { color: #FFD700; }
        .term-line.term-error     { color: var(--error-color); }
        .term-line.term-separator { border-top: 1px solid #2a5a2a; margin: 6px 0 4px; padding-top: 4px; }
        .enemy-card {
            border: 2px solid var(--error-color);
            padding: 8px 12px;
            margin: 6px 0;
            background: rgba(255,0,0,0.05);
            display: inline-block;
            min-width: 260px;
            vertical-align: top;
        }
        .enemy-card.is-target { border-color: var(--highlight-color); }
        .enemy-card .ec-name  { font-size: 21px; margin-bottom: 4px; }
        .enemy-card .ec-hp    { font-size: 18px; color: var(--text-color); }

   
   
/* stale actionBar block removed */





        #actionBar .action-label { color: var(--highlight-color); font-size: 18px; margin-bottom: 6px; }
        #actionBar .timer-line   { color: var(--highlight-color); font-size: 19px; margin-bottom: 4px; }

        /* â”€â”€â”€ legacy helpers for shop / inventory / town â”€â”€â”€ */
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid var(--border-color);
            background: rgba(0,128,0,0.1);
        }
        .stat       { color: var(--text-color); }
        .stat-label { color: var(--highlight-color); }
        .message {
            padding: 10px;
            margin: 10px 0;
            border-left: 3px solid var(--border-color);
        }
        .combat-message  { color: var(--highlight-color); font-weight: bold; }
        .error-message   { color: var(--error-color); }
        .success-message { color: var(--border-color); }

        button {
            background: var(--secondary-bg);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            padding: 10px 20px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) {
            background: var(--primary-bg);
            color: var(--highlight-color);
            box-shadow: 0 0 10px var(--border-color);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        input {
            background: var(--secondary-bg);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            padding: 10px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            width: 100%;
            margin: 10px 0;
        }

        .character-select {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .class-card {
            border: 2px solid var(--border-color);
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--secondary-bg);
        }

        .class-card:hover {
            background: var(--primary-bg);
            box-shadow: 0 0 15px var(--border-color);
            transform: scale(1.05);
        }

        .class-card.selected {
            border-color: var(--highlight-color);
            background: var(--primary-bg);
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .item-card {
            border: 1px solid var(--border-color);
            padding: 10px;
            background: rgba(0, 128, 0, 0.05);
        }

        .equipped {
            border-color: var(--highlight-color);
            background: rgba(255, 255, 0, 0.1);
        }

        .cursor {
            display: inline-block;
            width: 10px;
            height: 20px;
            background: var(--text-color);
            animation: blink 1s infinite;
            margin-left: 5px;
        }

        .location-header {
            font-family: 'Press Start 2P', monospace;
            font-size: 16px;
            color: var(--border-color);
            text-align: center;
            padding: 10px;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: 15px;
        }

        .enemy-display {
            text-align: center;
            padding: 20px;
            border: 2px solid var(--error-color);
            margin: 15px 0;
            background: rgba(255, 0, 0, 0.05);
        }

        .ascii-art {
            font-family: monospace;
            font-size: 14px;
            line-height: 1.2;
            white-space: pre;
            color: var(--text-color);
        }

        /* SYSOP Terminal Styles */
        .terminal-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--secondary-bg);
            border-top: 3px solid var(--error-color);
            padding: 10px 20px;
            z-index: 999;
            max-height: 300px;
            overflow-y: auto;
            display: none;
            box-shadow: 0 -5px 20px rgba(255, 0, 0, 0.5);
        }

        .terminal-container.active {
            display: block;
            animation: terminalSlideUp 0.3s;
        }

        @keyframes terminalSlideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        .terminal-header {
            color: var(--error-color);
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            margin-bottom: 10px;
            text-align: center;
            border-bottom: 1px solid var(--error-color);
            padding-bottom: 5px;
        }

        .terminal-output {
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
            color: var(--text-color);
        }

        .terminal-line {
            margin: 3px 0;
        }

        .terminal-error {
            color: var(--error-color);
        }

        .terminal-success {
            color: var(--border-color);
        }

        .terminal-warning {
            color: var(--highlight-color);
        }

        .terminal-input-line {
            display: flex;
            align-items: center;
        }

        .terminal-prompt {
            color: var(--error-color);
            margin-right: 10px;
        }

        .terminal-input {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--text-color);
            font-family: 'VT323', monospace;
            font-size: 20px;
            outline: none;
        }

        .sysop-badge {
            position: fixed;
            top: 10px;
            right: 10px;
            background: var(--error-color);
            color: var(--secondary-bg);
            padding: 5px 10px;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            border: 2px solid var(--highlight-color);
            z-index: 998;
            display: none;
            animation: badgePulse 2s infinite;
        }

        .sysop-badge.active {
            display: block;
        }

        @keyframes badgePulse {
            0%, 100% { box-shadow: 0 0 5px var(--error-color); }
            50% { box-shadow: 0 0 20px var(--error-color); }
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1001;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: var(--secondary-bg);
            border: 3px solid var(--error-color);
            padding: 20px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 30px var(--error-color);
        }


        .action-icon-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 2px solid var(--border-color);
            background: var(--secondary-bg);
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .action-icon-btn:hover:not(:disabled) {
            background: var(--primary-bg);
            border-color: var(--highlight-color);
            transform: scale(1.05);
        }
        
        .action-icon-btn:active:not(:disabled) {
            transform: scale(0.95);
        }
        
        .action-icon-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RESPONSIVE â€” mobile first, clean
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        /* All phones/tablets â‰¤768px */
        @media (max-width: 768px) {
            body { font-size: 15px; }

            /* Menu screen */
            #menuContainer { padding: 4px; }
            .header { padding: 5px 6px; margin-bottom: 3px; }
            .header h1 { font-size: 15px; margin-bottom: 2px; }
            .screen { padding: 8px; }

            /* Desktop HUD: hidden on mobile â€” mobileHud takes its place */
            body.terminal-mode #hud { display: none !important; }
            /* Mobile HUD strip: sits between terminal and action bar */
            body.terminal-mode #mobileHud { display: block; }

            /* Terminal: smallest still-readable text, maximise screen space */
            #terminalWindow { padding: 3px 5px; }
            .term-line { font-size: 13px; line-height: 1.2; margin: 0; padding: 0; }

            /* Action bar */
            #actionBar { padding: 3px; }
            #actionBar button { font-size: 13px; padding: 5px 7px; min-height: 34px; border-radius: 5px; }
            .action-icon-btn { font-size: 14px; padding: 5px 6px !important; min-height: 34px; }
            .spell-btn  { font-size: 12px; padding: 4px 5px !important; }
            .target-btn { font-size: 13px; padding: 5px 6px !important; }

            /* Other UI */
            .menu-option { padding: 8px; font-size: 16px; margin: 4px 0; }
            button { padding: 7px 10px; font-size: 14px; margin: 3px 1px; }
            .character-select { grid-template-columns: 1fr; gap: 8px; }
            .inventory-grid { grid-template-columns: repeat(2, 1fr); gap: 6px; }
            .item-card { padding: 6px; font-size: 13px; }
            .ascii-art { font-size: 9px; line-height: 1.1; }
        }

        /* Very small phones â‰¤390px */
        @media (max-width: 390px) {
            .term-line { font-size: 12px; line-height: 1.15; }
            #actionBar { padding: 2px 3px; }
            #actionBar button { font-size: 12px; padding: 4px 5px; min-height: 30px; }
            .action-icon-btn { font-size: 13px; padding: 4px 4px !important; min-height: 30px; }
            #mobileHud { font-size: 12px; padding: 2px 4px; }
        }

        /* Landscape tablets */
        @media (min-width: 769px) and (max-width: 1024px) {
            #menuContainer { max-width: 95%; padding: 12px; }
            .character-select { grid-template-columns: repeat(2, 1fr); }
            .inventory-grid { grid-template-columns: repeat(3, 1fr); }
        }

        /* Touch: no hover lift, tap highlight */
        @media (hover: none) and (pointer: coarse) {
            button, .menu-option, .class-card, .item-card {
                -webkit-tap-highlight-color: rgba(0,255,0,0.2);
                user-select: none; -webkit-user-select: none;
            }
            #actionBar button:hover { transform: none; box-shadow: none; }
            .action-icon-btn:hover:not(:disabled) { transform: none; }
        }

       
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   TERMINAL MODE â€“ show/hide rules
   (layout is handled by #gameWrapper fixed-position rules above)
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* Hide menu container in terminal mode */
body.terminal-mode #menuContainer {
    display: none;
}


        
    </style>
</head>
<body>
    <div class="scanline"></div>
    
    <!-- MENU WRAPPER (town/shop/etc) -->
    <div class="container" id="menuContainer">
        <div class="header">
            <h1>âš”ï¸ DUNGEON QUEST âš”ï¸</h1>
            <div style="color: var(--border-color);">â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</div>
            <div style="color: var(--menu-color); font-size: 16px;">A Classic Text Adventure</div>
        </div>
        <div class="screen" id="mainScreen">
            <!-- Menu / town content -->
        </div>
    </div>

<!-- GAMEPLAY WRAPPER â€” lives at body level, full viewport -->
<div id="gameWrapper">

    <!-- HUD (desktop: top of screen) -->
    <div id="hud">
        <div class="hud-inner">
            <div id="hudName"></div>
            <div class="hud-stats">
                <span id="hudHpNums"></span>
                <span id="hudMpNums"></span>
                <span id="hudXpNums"></span>
                <span id="hudGold"></span>
            </div>
        </div>
    </div>

    <!-- TERMINAL â€” fills all remaining space -->
    <div id="terminalWindow"></div>

    <!-- MOBILE HUD (mobile only: sits just above action bar) -->
    <div id="mobileHud">
        <span id="mhName"></span>
        <span id="mhHp"></span>
        <span id="mhMp"></span>
        <span id="mhXp"></span>
        <span id="mhGold"></span>
    </div>

    <!-- BOTTOM HUD (legacy, kept for compatibility) -->
    <div id="bottomHud">
        <span id="bottomHudName"></span>
        <span id="bottomHudHp"></span>
        <span id="bottomHudMp"></span>
        <span id="bottomHudXp"></span>
        <span id="bottomHudGold"></span>
    </div>

    <!-- ACTION BAR -->
    <div id="actionBar"></div>

</div>    

    <!-- SYSOP Terminal -->
    <div class="sysop-badge" id="sysopBadge">âš  SYSOP MODE âš </div>
    <div class="terminal-container" id="terminalContainer">
        <div class="terminal-header">â•â•â• SYSOP TERMINAL â•â•â•</div>
        <div class="terminal-output" id="terminalOutput"></div>
        <div class="terminal-input-line">
            <span class="terminal-prompt">root@dungeon:~#</span>
            <input type="text" class="terminal-input" id="terminalInput" autocomplete="off">
        </div>
    </div>

    <!-- Modal for forms -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal-content" id="modalContent"></div>
    </div>

    <!-- External Game Data Files -->
    <script src="dungeon-data.js"></script>
    <script src="Dungeon1.js"></script>
    <script src="town1.js"></script>
    <script src="town2.js"></script>
    <script src="monsters-expanded.js"></script>
    <script src="weapons.js"></script>
    <script src="armor.js"></script>
    <script src="items.js"></script>
    <script src="class-masters.js"></script>
    <script src="class-spells.js"></script>
    <script src="status-effects.js"></script>
    <script src="weapon-drops.js"></script>
    <script src="exploration-zones.js"></script>
    <script src="adventures.js"></script>

    <script>

        // ğŸ”‘ Prevent UI reset after restore (mobile fix)
// gameState.hasRestoredGame = false;


function updateTerminalSafeArea() {
    // No-op: layout handled by fixed-position flex column.
    // Terminal fills remaining space; actionBar sits below it naturally.
}



// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Direction helpers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const OPPOSITE_DIR = {
    N: 'South',
    S: 'North',
    E: 'West',
    W: 'East',
    NE: 'Southwest',
    NW: 'Southeast',
    SE: 'Northwest',
    SW: 'Northeast'
};



        // Game Data Structures
        const CLASSES = {
            warrior: {
                name: 'Warrior',
                hp: 120,
                mp: 20,
                strength: 15,
                defense: 12,
                magic: 3,
                speed: 7,
                description: 'Master of melee combat with high HP and defense',
                startWeapon: 'iron_sword',
                startArmor: 'leather_armor'
            },
            rogue: {
                name: 'Rogue',
                hp: 80,
                mp: 30,
                strength: 10,
                defense: 6,
                magic: 5,
                speed: 15,
                description: 'Swift and deadly, strikes first with critical hits',
                startWeapon: 'iron_dagger',
                startArmor: 'leather_vest'
            },
            paladin: {
                name: 'Paladin',
                hp: 100,
                mp: 50,
                strength: 12,
                defense: 10,
                magic: 8,
                speed: 8,
                description: 'Holy warrior with healing magic and strong defense',
                startWeapon: 'mace',
                startArmor: 'chain_mail'
            },
            mage: {
                name: 'Mage',
                hp: 60,
                mp: 100,
                strength: 5,
                defense: 4,
                magic: 18,
                speed: 9,
                description: 'Powerful spellcaster with devastating magic',
                startWeapon: 'staff',
                startArmor: 'cloth_robes'
            },
            cleric: {
                name: 'Cleric',
                hp: 90,
                mp: 70,
                strength: 8,
                defense: 8,
                magic: 12,
                speed: 7,
                description: 'Divine healer with support spells and moderate combat',
                startWeapon: 'mace',
                startArmor: 'leather_armor'
            },
            ranger: {
                name: 'Ranger',
                hp: 85,
                mp: 40,
                strength: 11,
                defense: 7,
                magic: 6,
                speed: 13,
                description: 'Skilled archer with nature magic and tracking',
                startWeapon: 'bow',
                startArmor: 'leather_armor'
            },
            warlock: {
                name: 'Warlock',
                hp: 70,
                mp: 90,
                strength: 6,
                defense: 5,
                magic: 16,
                speed: 8,
                description: 'Dark mage who drains life from enemies with shadow magic',
                startWeapon: 'staff',
                startArmor: 'cloth_robes'
            }
        };


        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STAT SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const STAT_BUDGET  = 30;
        const STAT_NAMES   = ['str','dex','wis','cha','con','lck'];
        const STAT_LABELS  = { str:'STR', dex:'DEX', wis:'WIS', cha:'CHA', con:'CON', lck:'LCK' };
        const STAT_DESCS   = {
            str:'Physical damage & multi-hit',
            dex:'Dodge chance & flee success',
            wis:'Spell power & magic resist',
            cha:'Shop prices & negotiation',
            con:'Max HP bonus & defense',
            lck:'Crit chance & loot luck'
        };
        // Opposed pairs: reroll engine biases against extremes in both.
        // Paladin is EXEMPT from str<->wis opposition.
        const OPPOSED_PAIRS = [['str','wis'],['dex','cha'],['con','lck']];

        const CLASS_STAT_PRESETS = {
            warrior : { str:10, dex:4, wis:2, cha:2, con:8, lck:4 },
            rogue   : { str:4,  dex:10,wis:2, cha:4, con:4, lck:6 },
            paladin : { str:7,  dex:3, wis:7, cha:4, con:6, lck:3 },
            mage    : { str:2,  dex:3, wis:10,cha:3, con:4, lck:8 },
            cleric  : { str:3,  dex:2, wis:9, cha:6, con:6, lck:4 },
            ranger  : { str:5,  dex:8, wis:3, cha:3, con:5, lck:6 },
            warlock : { str:2,  dex:4, wis:9, cha:5, con:4, lck:6 }
        };
        const CLASS_AFFINITIES = {
            warrior :['str','con'],
            rogue   :['dex','lck'],
            paladin :['str','wis','cha'],
            mage    :['wis','lck'],
            cleric  :['wis','cha'],
            ranger  :['dex','lck'],
            warlock :['wis','cha']
        };

        // â”€â”€ derived-stat helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Compute quality bonus as a % of the weapon/armor base damage/defense
        // QUALITY_CONFIG now uses bonusPct instead of a flat bonus
        function getQualityBonus(quality, baseStat) {
            const cfg = QUALITY_CONFIG[quality];
            if (!cfg) return 0;
            // Support old flat bonus saves gracefully
            if (cfg.bonusPct !== undefined) return Math.floor(baseStat * cfg.bonusPct);
            return cfg.bonus || 0;
        }

                function calcPlayerHits(p) {
            const baseClass = p.baseClass || p.class;
            
            // ROGUE: Dual-wield specialist with progressive pip scaling
            if (baseClass === 'rogue') {
                if (p.level >= 20) return 7;
                if (p.level >= 15) return 6;
                if (p.level >= 10) return 5;
                if (p.level >= 5) return 4;
                if (p.level >= 3) return 3;
                return 2; // Level 1-2: Dual wield
            }
            
            // OTHER CLASSES: Standard progression
            let h = 1;
            h += Math.floor((p.level || 1) / 4);    // +1 every 4 levels
            h += Math.floor(Math.max(0, (p.str||0) - 8) / 6);  // STR scaling
            return h;
        }
        function calcChaDiscount(cha) { return Math.min(30, (cha||0) * 2); }   // buy %  off
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CLASS EQUIPMENT RESTRICTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function canUseWeapon(playerClass, weapon) {
            // If weapon has allowedClasses, check it
            if (weapon.allowedClasses) {
                return weapon.allowedClasses.includes(playerClass);
            }
            
            // Default restrictions based on weapon type/name
            const weaponName = weapon.name.toLowerCase();
            
            // Staffs - magic users only
            if (weaponName.includes('staff') || weapon.baseMagicDamage > weapon.baseDamage) {
                return ['mage', 'warlock', 'cleric', 'acolyte', 'necrolyte', 'druid'].includes(playerClass);
            }
            
            // Bows - rangers and archers only
            if (weaponName.includes('bow')) {
                return ['ranger', 'archer', 'hunter'].includes(playerClass);
            }
            
            // Daggers - rogues primarily, but others can use
            if (weaponName.includes('dagger')) {
                return ['rogue', 'ranger', 'hunter'].includes(playerClass);
            }
            
            // Maces - paladins and clerics
            if (weaponName.includes('mace')) {
                return ['paladin', 'cleric', 'acolyte'].includes(playerClass);
            }
            
            // Swords and axes - warriors and melee classes
            if (weaponName.includes('sword') || weaponName.includes('axe') || weaponName.includes('hammer')) {
                return ['warrior', 'paladin', 'rogue'].includes(playerClass);
            }
            
            // Default: everyone can use
            return true;
        }
        
        function canUseArmor(playerClass, armor) {
            // If armor has allowedClasses, check it
            if (armor.allowedClasses) {
                return armor.allowedClasses.includes(playerClass);
            }
            
            // Default restrictions based on armor type/name
            const armorName = armor.name.toLowerCase();
            
            // Robes - magic users only
            if (armorName.includes('robe')) {
                return ['mage', 'warlock', 'cleric', 'acolyte', 'necrolyte', 'druid', 'sorceror'].includes(playerClass);
            }
            
            // Plate armor - heavy fighters only
            if (armorName.includes('plate')) {
                return ['warrior', 'paladin'].includes(playerClass);
            }
            
            // Chainmail - medium armor users
            if (armorName.includes('chain')) {
                return ['warrior', 'paladin', 'cleric', 'ranger'].includes(playerClass);
            }
            
            // Leather - light armor, most classes
            if (armorName.includes('leather')) {
                return ['warrior', 'rogue', 'ranger', 'hunter', 'cleric', 'paladin'].includes(playerClass);
            }
            
            // Cloth - everyone can wear
            return true;
        }
        function calcChaSellBonus(cha){ return Math.min(15, (cha||0) * 1); }   // sell %  bonus
        function calcInnCost(cha)     { return Math.max(20, 50 - (cha||0)); }
        function calcCritChance(lck, player)  { 
            // Base: 3% + 0.5% per LCK (not 1%) â€” prevents LCK-dumping giving 30%+ at level 1
            let baseCrit = 3 + Math.floor((lck || 0) * 0.5);
            
            if (player) {
                const baseClass = player.baseClass || player.class;
                const lvl = player.level || 1;
                if (baseClass === 'rogue') {
                    // Rogue: 5% base + 0.75% per LCK + 1% per 2 levels
                    // This gives ~15% at level 3 with 17 LCK (fun but not broken)
                    // and scales to ~50% at level 20 (exciting endgame)
                    baseCrit = 5 + Math.floor((lck || 0) * 0.75) + Math.floor(lvl / 2);
                }
            }
            
            const cap = (player && (player.baseClass || player.class) === 'rogue') ? 75 : 30;
            return Math.min(cap, baseCrit);
        }  // %
        function calcDodgeChance(dex) { return Math.min(40, (dex||0) * 2); }   // %
        function calcLootBonus(lck)   { return Math.min(25, (lck||0) * 2); }   // extra %

        // random reroll: scatter STAT_BUDGET among 6 stats (min 1 each)
        function rerollStats(classKey) {
            const s = { str:1, dex:1, wis:1, cha:1, con:1, lck:1 };
            let rem = STAT_BUDGET - 6;
            while (rem-- > 0) s[STAT_NAMES[Math.floor(Math.random()*6)]]++;
            return s;
        }

        const SPELLS = {
    heal: {
        name: 'Heal',
        mpCost: 15,
        pipCost: 1,
        power: 30,
        type: 'heal',
        level: 1,
        description: 'Restore HP'
    },
    fireball: {
        name: 'Fireball',
        mpCost: 20,
        pipCost: 1,
        power: 35,
        type: 'attack',
        level: 2,
        description: 'Fiery attack'
    },
    lightning: {
        name: 'Lightning',
        mpCost: 25,
        pipCost: 2,
        power: 45,
        type: 'attack',
        level: 4,
        description: 'Electric damage'
    },
    greater_heal: {
        name: 'Greater Heal',
        mpCost: 30,
        pipCost: 2,
        power: 60,
        type: 'heal',
        level: 5,
        description: 'Major healing'
    },
    ice_storm: {
        name: 'Ice Storm',
        mpCost: 35,
        pipCost: 2,
        power: 55,
        type: 'attack',
        level: 6,
        description: 'Freezing assault'
    },
    holy_light: {
        name: 'Holy Light',
        mpCost: 20,
        pipCost: 1,
        power: 25,
        type: 'attack',
        level: 3,
        description: 'Divine damage'
    },
    meteor: {
        name: 'Meteor',
        mpCost: 50,
        pipCost: 3,
        power: 80,
        type: 'attack',
        level: 8,
        description: 'Devastating spell'
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SPELL HELPER - Dynamically add spells from CLASS_SPELL_TREES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function ensureSpellExists(spellKey) {
    // If spell already exists, return it
    if (SPELLS[spellKey]) return SPELLS[spellKey];
    
    // Try to find it in CLASS_SPELL_TREES
    if (typeof CLASS_SPELL_TREES === 'undefined') return null;
    
    for (const classKey in CLASS_SPELL_TREES) {
        const classTree = CLASS_SPELL_TREES[classKey];
        if (classTree.spellTree && classTree.spellTree[spellKey]) {
            const spell = classTree.spellTree[spellKey];
            // Add it to SPELLS with pipCost
            SPELLS[spellKey] = {
                ...spell,
                pipCost: 1 // Default pip cost
            };
            console.log(`âœ… Dynamically added spell '${spellKey}' to SPELLS`);
            return SPELLS[spellKey];
        }
    }
    
    return null;
}

// Load all spells from CLASS_SPELL_TREES into SPELLS
function loadAllClassSpells() {
    if (typeof CLASS_SPELL_TREES === 'undefined') {
        console.warn('âš ï¸ CLASS_SPELL_TREES not loaded yet');
        return;
    }
    
    let count = 0;
    for (const classKey in CLASS_SPELL_TREES) {
        const classTree = CLASS_SPELL_TREES[classKey];
        if (classTree.spellTree) {
            for (const spellKey in classTree.spellTree) {
                if (!SPELLS[spellKey]) {
                    const spell = classTree.spellTree[spellKey];
                    SPELLS[spellKey] = {
                        ...spell,
                        pipCost: 1
                    };
                    count++;
                }
            }
        }
    }
    
    if (count > 0) {
        console.log(`âœ… Loaded ${count} class spells into SPELLS object`);
    }
}



        const LOCATIONS = {
    town: {
        name: 'Silverdale Town',
        description: 'A peaceful town with shops and an inn. Your adventure begins here.',
        canRest: true,
        hasShop: true
    },

    forest: {
        name: 'Whispering Forest',
        description: 'A dark forest filled with minor creatures.',
        enemyLevelRange: [1, 5],
        encounters: ['goblin', 'wolf', 'giant_spider'],
        requiredLevel: 1,
        locked: false
    },

    plains: {
        name: 'Endless Plains',
        description: 'Open grasslands with roaming beasts.',
        enemyLevelRange: [6, 10],
        encounters: ['orc', 'dire_wolf', 'bandit'],
        requiredLevel: 6,
        locked: true,
        unlockMessage: 'Defeat your class master in the forest to unlock this area!'
    },

    cave: {
        name: 'Shadow Cavern',
        description: 'A dungeon filled with dangerous monsters.',
        enemyLevelRange: [11, 15],
        encounters: ['troll', 'skeleton_warrior', 'dark_mage'],
        requiredLevel: 11,
        locked: true,
        unlockMessage: 'Defeat your class master in the plains to unlock this area!'
    },

    crypt: {
        name: 'Ancient Crypt',
        description: 'An ancient tomb haunted by the undead.',
        enemyLevelRange: [16, 20],
        encounters: ['lich', 'death_knight', 'wraith'],
        requiredLevel: 16,
        locked: true,
        unlockMessage: 'Defeat your class master in the cave to unlock this area!'
    },

    volcano: {
        name: 'Volcanic Wastes',
        description: 'A scorched wasteland of fire and ash.',
        enemyLevelRange: [21, 25],
        encounters: ['fire_elemental', 'lava_golem', 'phoenix'],
        requiredLevel: 21,
        locked: true,
        unlockMessage: 'Defeat your class master in the crypt to unlock this area!'
    },

    fireMountain: {
        name: 'Fire Mountain',
        description: 'A volcanic peak home to fierce creatures.',
        enemyLevelRange: [8, 12],
        encounters: ['fire_elemental', 'red_dragon', 'demon'],
        requiredLevel: 12,
        locked: true,
        unlockMessage: 'Defeat your class master in the crypt to unlock this area!'
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MERGE EXPANDED ZONES (if exploration-zones.js is loaded)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if (typeof EXPLORATION_ZONES !== 'undefined') {
    // Merge new zones while keeping custom zones
    Object.assign(LOCATIONS, EXPLORATION_ZONES);
    console.log('âœ… Loaded expanded exploration zones');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MERGE ZONE MONSTERS (if exploration-zones.js is loaded)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if (typeof ZONE_MONSTERS !== 'undefined') {
    Object.assign(ENEMIES, ZONE_MONSTERS);
    console.log('âœ… Loaded zone-specific monsters');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MERGE ADVENTURE ENEMIES (if adventures.js is loaded)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if (typeof ADVENTURE_ENEMIES !== 'undefined') {
    Object.assign(ENEMIES, ADVENTURE_ENEMIES);
    console.log('âœ… Loaded adventure enemies');
}



        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MODEM SPEED SIMULATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const MODEM_SPEEDS = {
            '56k': 7,      // ~7 characters per frame (56k modem - fast)
            '28.8k': 4,    // ~4 characters per frame (28.8k modem - medium)
            '14.4k': 2,    // ~2 characters per frame (14.4k modem - slow)
            '9600': 1,     // ~1 character per frame (9600 baud - very slow)
            '4800': 0.5,   // ~0.5 characters per frame (4800 baud - ultra slow)
            'instant': -1  // No delay
        };
        
        let currentModemSpeed = '14.4k'; // Default to 14.4k modem (authentic BBS experience)
        let isStreaming = false;
        let streamCancelled = false;
        
        function streamText(element, html, callback) {
           if (currentModemSpeed === 'instant') {
    line.innerHTML = html;

    // âœ… STEP 3A: scroll AFTER line is fully rendered
    if (shouldAutoScroll) {
        tw.scrollTop = tw.scrollHeight;
    }

line.innerHTML =
    sliceToVisible(html, visibleCount) +
    '<span style="animation:blink 1s infinite;">_</span>';


    if (onDone) onDone();
    termDrain();
    return;
}

            
            isStreaming = true;
            streamCancelled = false;
            
            // Strip HTML tags for character counting but keep them for display
            const charsPerFrame = MODEM_SPEEDS[currentModemSpeed];
            let currentIndex = 0;
            
            const interval = setInterval(() => {
                if (streamCancelled) {
                    clearInterval(interval);
                    element.innerHTML = html;
                    isStreaming = false;
                    if (callback) callback();
                    return;
                }
                
                currentIndex += charsPerFrame;
                
                if (currentIndex >= html.length) {
                    clearInterval(interval);
                    element.innerHTML = html;
                    isStreaming = false;
                    if (callback) callback();
                } else {
                    // Display partial HTML up to current index
                    element.innerHTML = html.substring(0, currentIndex) + '<span style="animation: blink 1s infinite;">_</span>';
                }
            }, 16); // ~60fps
        }
        
        function cancelStream() {
            streamCancelled = true;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SAVE FILE ENCRYPTION (Anti-Cheat)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // Simple but effective encryption key (obfuscated in code)
        const SAVE_KEY = 'DQ_' + btoa('DUNGEON_QUEST_2026').split('').reverse().join('');
        
        function encryptSave(data) {
            try {
                const jsonStr = JSON.stringify(data);
                const encoded = btoa(encodeURIComponent(jsonStr));
                
                // Add checksum to detect tampering
                const checksum = generateChecksum(jsonStr);
                
                // XOR cipher with key
                let encrypted = '';
                for (let i = 0; i < encoded.length; i++) {
                    encrypted += String.fromCharCode(
                        encoded.charCodeAt(i) ^ SAVE_KEY.charCodeAt(i % SAVE_KEY.length)
                    );
                }
                
                return btoa(JSON.stringify({
                    v: 1, // version
                    d: btoa(encrypted), // data
                    c: checksum // checksum
                }));
            } catch (e) {
                console.error('Encryption failed:', e);
                return null;
            }
        }
        
        function decryptSave(encryptedData) {
            try {
                const wrapper = JSON.parse(atob(encryptedData));
                
                if (wrapper.v !== 1) {
                    throw new Error('Invalid save version');
                }
                
                const encrypted = atob(wrapper.d);
                
                // XOR decipher
                let decoded = '';
                for (let i = 0; i < encrypted.length; i++) {
                    decoded += String.fromCharCode(
                        encrypted.charCodeAt(i) ^ SAVE_KEY.charCodeAt(i % SAVE_KEY.length)
                    );
                }
                
                const jsonStr = decodeURIComponent(atob(decoded));
                
                // Verify checksum
                const calculatedChecksum = generateChecksum(jsonStr);
                if (calculatedChecksum !== wrapper.c) {
                    throw new Error('Save file has been tampered with!');
                }
                
                return JSON.parse(jsonStr);
            } catch (e) {
                console.error('Decryption failed:', e);
                throw new Error('Invalid or corrupted save file');
            }
        }
        
        function generateChecksum(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return hash.toString(36);
        }
        
        function downloadSaveFile() {
            try {
                const snapshot = buildSaveSnapshot();
                if (!snapshot) {
                    alert('No character data to save!');
                    return;
                }
                
                const encrypted = encryptSave(snapshot);
                if (!encrypted) {
                    alert('Failed to encrypt save file!');
                    return;
                }
                
                // Create filename with character name and timestamp
                const timestamp = new Date().toISOString().slice(0, 10);
                const filename = `DungeonQuest_${snapshot.characterName}_${timestamp}.dqsave`;
                
                // Create blob and download
                const blob = new Blob([encrypted], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert(`âœ… Save file downloaded: ${filename}`);
            } catch (e) {
                console.error('Download failed:', e);
                alert('Failed to download save file!');
            }
        }
        
        function loadFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.dqsave';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const encryptedData = event.target.result;
                        const data = decryptSave(encryptedData);
                        
                        // Validate the save data
                        if (!data.player || !data.characterId) {
                            throw new Error('Invalid save file structure');
                        }
                        
                        // Save to localStorage
                        const key = `dq_save_${data.characterId}`;
                        localStorage.setItem(key, JSON.stringify(data));
                        
                        // Update character list
                        updateCharacterList(data);
                        
                        alert(`âœ… Character "${data.characterName}" loaded successfully!`);
                        
                        // Load the character
                        loadCharacter(data.characterId);
                    } catch (e) {
                        console.error('Load failed:', e);
                        alert('âŒ Failed to load save file: ' + e.message);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        // Game State
        let gameState = {
            player: null,
            currentLocation: 'town',
            currentTown: 'town1',   // which town hub the player is in
            combatState: null,
            combatTimer: null,
            lastAction: null,
            restState: {
                hpRegenTimer: null,    // ticks HP outside combat
                mpRegenTimer: null,    // ticks MP after 15s inactivity
                mpLastAction: 0        // timestamp of last attack/spell; 0 = never
            },
            sysop: {
                authenticated: false,
                username: null,
                terminalActive: false,
                commandHistory: []
            }
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PASSIVE REGENERATION SYSTEM  (rewritten)
        //
        // HP REGEN  â€” ticks every 8s when NOT in combat, anywhere (town
        //             or dungeon).  Restores 5% maxHP per tick.  Stops
        //             the moment combat begins; resumes when it ends.
        //
        // MP REGEN  â€” driven by a SINGLE long-running interval (3s tick).
        //             On each tick it checks: has it been â‰¥15s since the
        //             player last attacked or cast a spell?  If yes, add
        //             5% maxMP.  If the player attacks/casts, we record
        //             mpLastAction = Date.now() which resets the 15s clock.
        //             Works inside AND outside combat â€” a mage can tank
        //             hits and recover MP as long as they stop attacking.
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // â”€â”€ Called whenever the player fires an attack or casts a spell â”€
        function markMpAction() {
            gameState.restState.mpLastAction = Date.now();
        }

        // â”€â”€ HP regen: start ticking.  Safe to call multiple times â”€â”€â”€â”€â”€â”€â”€
        function startHpRegen() {
            // Clear any existing timer first
            if (gameState.restState.hpRegenTimer) {
                clearInterval(gameState.restState.hpRegenTimer);
                gameState.restState.hpRegenTimer = null;
            }

            gameState.restState.hpRegenTimer = setInterval(() => {
                const p = gameState.player;
                if (!p) return;

                // Pause if in active combat
                if (gameState.combatState) return;

                // Already full
                if (p.hp >= p.maxHp) {
                    p.hp = p.maxHp;
                    updateHud();
                    return;
                }

                const restore = Math.max(1, Math.ceil(p.maxHp * 0.05));
                p.hp = Math.min(p.maxHp, p.hp + restore);
                updateHud();
            }, 8000); // tick every 8 seconds
        }

        // â”€â”€ MP regen: start the global inactivity ticker â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function startMpRegen() {
            // Only start once â€” idempotent
            if (gameState.restState.mpRegenTimer) return;

            const MP_COOLDOWN = 15000;  // 15s of no attacks before MP ticks
            const MP_TICK_MS  = 3000;   // check every 3 seconds

            gameState.restState.mpRegenTimer = setInterval(() => {
                const p = gameState.player;
                if (!p) return;
                if (p.mp >= p.maxMp) return;

                const idle = Date.now() - (gameState.restState.mpLastAction || 0);
                if (idle < MP_COOLDOWN) return;  // still within the 15s window

                const restore = Math.max(1, Math.ceil(p.maxMp * 0.05));
                p.mp = Math.min(p.maxMp, p.mp + restore);
                updateHud();
            }, MP_TICK_MS);
        }

        // â”€â”€ Legacy shim â€” old code calls startResting / startMpRegen(isTown) â”€
        function startResting(isTown = false) {
            startHpRegen();
        }

        // â”€â”€ Stop HP regen only (called when combat starts) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function stopResting() {
            if (gameState.restState.hpRegenTimer) {
                clearInterval(gameState.restState.hpRegenTimer);
                gameState.restState.hpRegenTimer = null;
            }
        }

        // â”€â”€ Stop both timers entirely (logout, new character, etc.) â”€â”€â”€â”€â”€â”€
        function stopAllRegen() {
            stopResting();
            if (gameState.restState.mpRegenTimer) {
                clearInterval(gameState.restState.mpRegenTimer);
                gameState.restState.mpRegenTimer = null;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // END REGENERATION SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // ğŸ”‘ Prevent UI reset after restore (mobile fix)
gameState.hasRestoredGame = false;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SYSOP TERMINAL SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const SYSOP_CREDENTIALS = {
            username: 'sysop',
            password: 'Radojcsics'
        };

        // Toggle terminal with ~ key
        document.addEventListener('keydown', (e) => {
            if (e.key === '~' || e.key === '`') {
                e.preventDefault();
                toggleTerminal();
            }
            if (e.key === 'Escape' && gameState.sysop.terminalActive) {
                toggleTerminal();
            }
        });

function showActionBar() {
    // No-op: body.terminal-mode CSS handles actionBar visibility
}

function hideActionBar() {
    // No-op: body.terminal-mode CSS handles actionBar visibility
}


function buildSaveSnapshot() {
    if (!gameState.player) {
        console.warn('No player state to save');
        return null;
    }

    const p = gameState.player;
    
    const snapshot = {
        version: 1,
        characterId: p.id || 'default',
        characterName: p.name,
        timestamp: Date.now(),
        lastSaved: new Date().toLocaleString(),

        player: {
            // Identity
            id: p.id || 'default',
            name: p.name,
            class: p.class,
            
            // Core stats
            level: p.level,
            xp: p.xp,
            xpToNext: p.xpToNext,
            
            // Resources
            hp: p.hp,
            maxHp: p.maxHp,
            mp: p.mp,
            maxMp: p.maxMp,
            gold: p.gold,
            bankGold: p.bankGold || 0,  // Bank storage
            
            // Legacy base stats
            strength: p.strength,
            defense: p.defense,
            magic: p.magic,
            speed: p.speed,
            
            // New stat block (if exists)
            str: p.str,
            dex: p.dex,
            con: p.con,
            wis: p.wis,
            cha: p.cha,
            lck: p.lck,
            
            // Equipment
            weapon: p.weapon,
            armor: p.armor,
            
            // Inventory & spells
            inventory: [...(p.inventory || [])],
            knownSpells: [...(p.knownSpells || [])],
            
            // Stat points
            statPoints: p.statPoints || 0,
            
            // Base class (for evolution tracking)
            baseClass: p.baseClass,
            className: p.className,
            hasEvolved: p.hasEvolved,
            
            // Progression
            defeatedMasters: [...(p.defeatedMasters || [])],
            unlockedAreas: [...(p.unlockedAreas || [])],
            
            // Special flags
            godMode: p.godMode || false,

            // Achievements & runestones
            achievements: [...(p.achievements || [])],
            runestones: [...(p.runestones || [])]
        },
        
        // Town hub the player is in
        currentTown: gameState.currentTown || 'town1',
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GENERATED WEAPONS - Save all dynamically created weapon drops
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        generatedWeapons: (() => {
            const generated = {};
            // Find all weapons in inventory that have .isDropped flag
            (p.inventory || []).forEach(itemKey => {
                const weapon = WEAPONS[itemKey];
                if (weapon && weapon.isDropped) {
                    generated[itemKey] = weapon;
                }
            });
            // Also save equipped weapon if it's generated
            if (p.weapon && WEAPONS[p.weapon]?.isDropped) {
                generated[p.weapon] = WEAPONS[p.weapon];
            }
            return generated;
        })(),
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GENERATED ARMOR - Save all dynamically created armor drops
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        generatedArmor: (() => {
            const generated = {};
            // Find all armor in inventory that have .isDropped flag
            (p.inventory || []).forEach(itemKey => {
                const armor = ARMOR[itemKey];
                if (armor && armor.isDropped) {
                    generated[itemKey] = armor;
                }
            });
            // Also save equipped armor if it's generated
            if (p.armor && ARMOR[p.armor]?.isDropped) {
                generated[p.armor] = ARMOR[p.armor];
            }
            return generated;
        })(),

        // Current location/state
        currentLocation: gameState.currentLocation,

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ACTIVE COMBAT - Save mid-fight state so enemies persist on reload
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        activeCombat: (() => {
            const cs = gameState.combatState;
            if (!cs || gameState.dungeon) return null; // Only for world exploration combat
            return {
                location: gameState.currentLocation,
                monsters: cs.monsters.map(m => ({
                    // All fields needed to fully reconstruct the enemy
                    key:         m.key,
                    name:        m.name,
                    rarity:      m.rarity,
                    rarityColor: m.rarityColor,
                    hp:          m.hp,
                    maxHp:       m.maxHp,
                    damage:      m.damage,
                    defense:     m.defense,
                    xp:          m.xp,
                    gold:        m.gold,
                    level:       m.level,
                    possibleDrops: m.possibleDrops,
                    dropRates:   m.dropRates,
                    index:       m.index
                })),
                currentTarget:   cs.currentTarget,
                enemyDelay:      cs.enemyDelay,
                enemyHits:       cs.enemyHits,
                enemyHitsLeft:   cs.enemyHitsLeft,
                // Save pip state (how many pips are ready vs cooling down)
                pipCount:        cs.pipAvailable.length,
                pipsReady:       cs.pipAvailable.map(x => x),
            };
        })(),

        // Dungeon state (if in dungeon)
        dungeon: gameState.dungeon ? {
            dungeonKey: gameState.dungeon.dungeonKey,
            floor: gameState.dungeon.floor,
            currentRoom: gameState.dungeon.currentRoom,
            discoveredRooms: [...gameState.dungeon.discoveredRooms],
            spawnedRooms: [...(gameState.dungeon.spawnedRooms || [])],
            activeEnemies: gameState.dungeon.activeEnemies.map(e => ({
                id: e.id,
                monsterId: e.monsterId,
                name: e.name,
                hp: e.hp,
                maxHp: e.maxHp,
                currentRoom: e.currentRoom,
                leash: e.leash,
                drop: e.drop || null
            }))
        } : null,

        meta: {
            inDungeon: !!gameState.dungeon
        }
    };

    return snapshot;
}


function saveGame() {
    try {
        const snapshot = buildSaveSnapshot();
        if (!snapshot) return;

        const key = `dq_save_${snapshot.characterId}`;
        localStorage.setItem(key, JSON.stringify(snapshot));
        
        // Also update character list
        updateCharacterList(snapshot);

        console.log(`âœ… Game saved: ${snapshot.characterName} (${snapshot.lastSaved})`);
        
        // Show brief save confirmation
        const hud = document.getElementById('hud');
        if (hud && hud.style.display !== 'none') {
            const saveMsg = document.createElement('div');
            saveMsg.style.cssText = 'position:fixed;top:10px;right:10px;background:#0a0a0a;border:2px solid var(--text-color);padding:8px 12px;color:var(--text-color);font-size:14px;z-index:9999;';
            saveMsg.textContent = 'ğŸ’¾ Game Saved';
            document.body.appendChild(saveMsg);
            setTimeout(() => saveMsg.remove(), 2000);
        }
    } catch (e) {
        console.error('Error saving game:', e);
    }
}

function updateCharacterList(snapshot) {
    try {
        let charList = JSON.parse(localStorage.getItem('dq_character_list') || '[]');
        
        // Remove old entry for this character if exists
        charList = charList.filter(c => c.id !== snapshot.characterId);
        
        // Add new entry
        charList.push({
            id: snapshot.characterId,
            name: snapshot.characterName,
            level: snapshot.player.level,
            class: snapshot.player.class,
            timestamp: snapshot.timestamp,
            lastSaved: snapshot.lastSaved
        });
        
        // Sort by most recent
        charList.sort((a, b) => b.timestamp - a.timestamp);
        
        localStorage.setItem('dq_character_list', JSON.stringify(charList));
    } catch (e) {
        console.error('Error updating character list:', e);
    }
}

function getAllCharacters() {
    try {
        return JSON.parse(localStorage.getItem('dq_character_list') || '[]');
    } catch (e) {
        console.error('Error getting character list:', e);
        return [];
    }
}

function deleteCharacter(characterId) {
    try {
        // Remove save data
        localStorage.removeItem(`dq_save_${characterId}`);
        
        // Remove from character list
        let charList = getAllCharacters();
        charList = charList.filter(c => c.id !== characterId);
        localStorage.setItem('dq_character_list', JSON.stringify(charList));
        
        console.log(`ğŸ—‘ï¸ Deleted character: ${characterId}`);
        return true;
    } catch (e) {
        console.error('Error deleting character:', e);
        return false;
    }
}

// Auto-save on page unload
window.addEventListener('beforeunload', () => {
    saveGame();
});



        function toggleTerminal() {
            const terminal = document.getElementById('terminalContainer');
            const input = document.getElementById('terminalInput');
            
            gameState.sysop.terminalActive = !gameState.sysop.terminalActive;
            
            if (gameState.sysop.terminalActive) {
                terminal.classList.add('active');
                input.focus();
                if (!gameState.sysop.authenticated) {
                    terminalPrint('Terminal activated. Type /login <username> <password> to authenticate.', 'warning');
                }
            } else {
                terminal.classList.remove('active');
            }
        }

        function terminalPrint(message, type = 'normal') {
            const output = document.getElementById('terminalOutput');
            const line = document.createElement('div');
            line.className = `terminal-line ${type === 'error' ? 'terminal-error' : ''} ${type === 'success' ? 'terminal-success' : ''} ${type === 'warning' ? 'terminal-warning' : ''}`;
            line.textContent = message;
            output.appendChild(line);
            
            // Auto-scroll to bottom
            output.scrollTop = output.scrollHeight;
        }

        function clearTerminal() {
            document.getElementById('terminalOutput').innerHTML = '';
        }

        // Terminal input handler
        document.getElementById('terminalInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const input = e.target.value.trim();
                e.target.value = '';
                
                if (input) {
                    terminalPrint(`root@dungeon:~# ${input}`, 'normal');
                    gameState.sysop.commandHistory.push(input);
                    executeCommand(input);
                }
            }
        });

        function executeCommand(input) {
            const parts = input.split(' ');
            const command = parts[0].toLowerCase();
            const args = parts.slice(1);

            // Login command (always available)
            if (command === '/login') {
                handleLogin(args);
                return;
            }

            // Check authentication for all other commands
            if (!gameState.sysop.authenticated) {
                terminalPrint('ERROR: Authentication required. Use /login <username> <password>', 'error');
                return;
            }

            // Execute authenticated commands
            switch(command) {
                case '/help':
                    showHelp();
                    break;
                case '/logout':
                    handleLogout();
                    break;
                case '/clear':
                    clearTerminal();
                    break;
                case '/give':
                    handleGive(args);
                    break;
                case '/addmonster':
                    openAddMonsterForm();
                    break;
                case '/addweapon':
                    openAddWeaponForm();
                    break;
                case '/addarmor':
                    openAddArmorForm();
                    break;
                case '/additem':
                    openAddItemForm();
                    break;
                case '/listmonsters':
                    listMonsters();
                    break;
                case '/listweapons':
                    listWeapons();
                    break;
                case '/listarmor':
                    listArmor();
                    break;
                case '/listitems':
                    listItems();
                    break;
                case '/setlevel':
                    handleSetLevel(args);
                    break;
                case '/setgold':
                    handleSetGold(args);
                    break;
                case '/heal':
                    handleHeal();
                    break;
                case '/godmode':
                    handleGodMode(args);
                    break;
                case '/teleport':
                    handleTeleport(args);
                    break;
                case '/killmonster':
                    handleKillMonster();
                    break;
                case '/export':
                    handleExport(args);
                    break;
                default:
                    terminalPrint(`ERROR: Unknown command '${command}'. Type /help for available commands.`, 'error');
            }
        }

        function handleLogin(args) {
            if (args.length < 2) {
                terminalPrint('ERROR: Usage: /login <username> <password>', 'error');
                return;
            }

            const username = args[0];
            const password = args[1];

            if (username === SYSOP_CREDENTIALS.username && password === SYSOP_CREDENTIALS.password) {
                gameState.sysop.authenticated = true;
                gameState.sysop.username = username;
                document.getElementById('sysopBadge').classList.add('active');
                terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
                terminalPrint('  AUTHENTICATION SUCCESSFUL', 'success');
                terminalPrint('  Welcome, SYSOP ' + username, 'success');
                terminalPrint('  Type /help for available commands', 'success');
                terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
            } else {
                terminalPrint('ERROR: Authentication failed. Invalid credentials.', 'error');
            }
        }

        function handleLogout() {
            gameState.sysop.authenticated = false;
            gameState.sysop.username = null;
            document.getElementById('sysopBadge').classList.remove('active');
            terminalPrint('Logged out. Terminal locked.', 'warning');
        }

        function showHelp() {
            terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
            terminalPrint('SYSOP COMMANDS:', 'warning');
            terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
            terminalPrint('');
            terminalPrint('AUTHENTICATION:');
            terminalPrint('  /login <user> <pass>  - Authenticate as sysop');
            terminalPrint('  /logout               - End sysop session');
            terminalPrint('');
            terminalPrint('PLAYER COMMANDS:');
            terminalPrint('  /give <type> <id> [quality]  - Give item to player');
            terminalPrint('                                 Types: weapon, armor, item, spell');
            terminalPrint('                                 Quality (optional): poor, normal, rare,');
            terminalPrint('                                           epic, legendary, godly');
            terminalPrint('                                 Examples:');
            terminalPrint('                                   /give weapon iron_sword legendary');
            terminalPrint('                                   /give armor leather_armor godly');
            terminalPrint('  /setlevel <level>     - Set player level (1-25)');
            terminalPrint('                          âš¡ Level 20 triggers class evolution!');
            terminalPrint('  /setgold <amount>     - Set gold amount');
            terminalPrint('  /heal                 - Fully heal player');
            terminalPrint('  /godmode <on/off>     - Toggle invincibility');
            terminalPrint('');
            terminalPrint('GAME CONTENT:');
            terminalPrint('  /addmonster           - Add new monster (opens form)');
            terminalPrint('  /addweapon            - Add new weapon (opens form)');
            terminalPrint('  /addarmor             - Add new armor (opens form)');
            terminalPrint('  /additem              - Add new item (opens form)');
            terminalPrint('');
            terminalPrint('LISTING:');
            terminalPrint('  /listmonsters         - Show all monsters');
            terminalPrint('  /listweapons          - Show all weapons');
            terminalPrint('  /listarmor            - Show all armor');
            terminalPrint('  /listitems            - Show all items');
            terminalPrint('');
            terminalPrint('UTILITIES:');
            terminalPrint('  /teleport <dest>               - Teleport anywhere');
            terminalPrint('    /teleport town1              - Go to Silverdale');
            terminalPrint('    /teleport town2              - Go to Ashen Harbor');
            terminalPrint('    /teleport dungeon1           - Dungeon1 Floor 1 start');
            terminalPrint('    /teleport dungeon1 f2        - Dungeon1 Floor 2 start');
            terminalPrint('    /teleport dungeon1 f1 R57    - Dungeon1 Floor 1 Room R57');
            terminalPrint('    /teleport forest             - Any explore zone key');
            terminalPrint('  /killmonster          - Instantly kill current enemy');
            terminalPrint('  /export <type>        - Export data (monsters/weapons/armor/items)');
            terminalPrint('  /clear                - Clear terminal output');
            terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
        }

        function handleGive(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            if (args.length < 2) {
                terminalPrint('ERROR: Usage: /give <type> <id> [quality]', 'error');
                terminalPrint('Types: weapon, armor, item, spell', 'error');
                terminalPrint('Quality (optional, for weapons): poor, normal, rare, epic, legendary, godly', 'error');
                return;
            }

            const type = args[0].toLowerCase();
            const id = args[1].toLowerCase();
            const quality = args[2] ? args[2].toLowerCase() : null;

            switch(type) {
                case 'weapon':
                    if (WEAPONS[id]) {
                        // Check if quality was specified and is valid
                        if (quality && QUALITY_CONFIG[quality]) {
                            // Generate a weapon drop with specified quality
                            const baseWeapon = WEAPONS[id];
                            const weaponLevel = baseWeapon.level || gameState.player.level;
                            
                            // Create unique weapon ID with quality
                            const weaponId = `${id}_${quality}_sysop_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
                            
                            // Apply quality bonus (percentage-based)
                            const bonusPct = QUALITY_CONFIG[quality].bonusPct || 0;
                            const bonusDmg = Math.floor(baseWeapon.baseDamage * bonusPct);
                            const bonusMax = Math.floor((baseWeapon.maxDamage || baseWeapon.baseDamage) * bonusPct);
                            
                            // Create the quality weapon
                            const qualityWeapon = {
                                id: weaponId,
                                name: `${QUALITY_CONFIG[quality].name} ${baseWeapon.name}`,
                                baseDamage: baseWeapon.baseDamage + bonusDmg,
                                maxDamage: (baseWeapon.maxDamage || baseWeapon.baseDamage) + bonusMax,
                                baseMagicDamage: baseWeapon.baseMagicDamage || 0,
                                level: weaponLevel,
                                quality: quality,
                                modifiers: [],
                                cost: baseWeapon.cost * (QUALITY_CONFIG[quality].bonusPct + 1),
                                description: `A ${quality} quality ${baseWeapon.name}`,
                                slot: 'weapon',
                                isDropped: true, // Mark as generated
                                classRestriction: baseWeapon.classRestriction
                            };
                            
                            // Register in WEAPONS
                            WEAPONS[weaponId] = qualityWeapon;
                            
                            // Add to inventory
                            gameState.player.inventory.push(weaponId);
                            
                            terminalPrint(`SUCCESS: Gave ${quality} ${baseWeapon.name} (${qualityWeapon.baseDamage}-${qualityWeapon.maxDamage} dmg)`, 'success');
                        } else {
                            // Give base weapon without quality
                            if (!gameState.player.inventory.includes(id)) {
                                gameState.player.inventory.push(id);
                            }
                            terminalPrint(`SUCCESS: Gave weapon '${WEAPONS[id].name}' to player`, 'success');
                        }
                    } else {
                        terminalPrint(`ERROR: Weapon '${id}' not found`, 'error');
                        terminalPrint('Use /listweapons to see available weapons', 'error');
                    }
                    break;
                case 'armor':
                    if (ARMOR[id]) {
                        // Check if quality was specified and is valid
                        if (quality && QUALITY_CONFIG[quality]) {
                            // Generate armor with specified quality
                            const baseArmor = ARMOR[id];
                            const armorLevel = baseArmor.level || gameState.player.level;
                            
                            // Create unique armor ID with quality
                            const armorId = `${id}_${quality}_sysop_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
                            
                            // Apply quality bonus (percentage-based)
                            const bonusPct = QUALITY_CONFIG[quality].bonusPct || 0;
                            const bonusDef = Math.floor(baseArmor.baseDefense * bonusPct);
                            const bonusMag = Math.floor((baseArmor.baseMagicBonus || 0) * bonusPct);
                            
                            // Create the quality armor
                            const qualityArmor = {
                                id: armorId,
                                name: `${QUALITY_CONFIG[quality].name} ${baseArmor.name}`,
                                baseDefense: baseArmor.baseDefense + bonusDef,
                                baseMagicBonus: (baseArmor.baseMagicBonus || 0) + bonusMag,
                                level: armorLevel,
                                quality: quality,
                                cost: baseArmor.cost * (QUALITY_CONFIG[quality].bonusPct + 1),
                                description: `A ${quality} quality ${baseArmor.name}`,
                                slot: 'armor',
                                isDropped: true, // Mark as generated
                                classRestriction: baseArmor.classRestriction
                            };
                            
                            // Register in ARMOR
                            ARMOR[armorId] = qualityArmor;
                            
                            // Add to inventory
                            gameState.player.inventory.push(armorId);
                            
                            terminalPrint(`SUCCESS: Gave ${quality} ${baseArmor.name} (${qualityArmor.baseDefense} DEF${qualityArmor.baseMagicBonus > 0 ? `, +${qualityArmor.baseMagicBonus} MAG` : ''})`, 'success');
                        } else {
                            // Give base armor without quality
                            if (!gameState.player.inventory.includes(id)) {
                                gameState.player.inventory.push(id);
                            }
                            terminalPrint(`SUCCESS: Gave armor '${ARMOR[id].name}' to player`, 'success');
                        }
                    } else {
                        terminalPrint(`ERROR: Armor '${id}' not found`, 'error');
                        terminalPrint('Use /listarmor to see available armor', 'error');
                    }
                    break;
                case 'item':
                    if (ITEMS[id]) {
                        gameState.player.inventory.push(id); // Items can stack, so always push
                        terminalPrint(`SUCCESS: Gave item '${ITEMS[id].name}' to player`, 'success');
                    } else {
                        terminalPrint(`ERROR: Item '${id}' not found`, 'error');
                    }
                    break;
                case 'spell':
                    if (SPELLS[id]) {
                        if (!gameState.player.knownSpells.includes(id)) {
                            gameState.player.knownSpells.push(id);
                        }
                        terminalPrint(`SUCCESS: Taught spell '${SPELLS[id].name}' to player`, 'success');
                    } else {
                        terminalPrint(`ERROR: Spell '${id}' not found`, 'error');
                    }
                    break;
                default:
                    terminalPrint(`ERROR: Invalid type '${type}'`, 'error');
            }
        }

        function handleSetLevel(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const targetLevel = parseInt(args[0]);
            if (isNaN(targetLevel) || targetLevel < 1 || targetLevel > 25) {
                terminalPrint('ERROR: Invalid level. Use 1-25', 'error');
                return;
            }

            const p = gameState.player;
            const currentLevel = p.level;
            
            // Calculate how many levels to add
            const levelsToAdd = targetLevel - currentLevel;
            
            if (levelsToAdd === 0) {
                terminalPrint(`Player is already level ${targetLevel}`, 'info');
                return;
            }
            
            // Apply level-ups manually
            for (let i = 0; i < Math.abs(levelsToAdd); i++) {
                if (levelsToAdd > 0) {
                    // Level up
                    p.level++;
                    p.maxHp += 15 + (p.con || 0);
                    p.hp = p.maxHp;
                    p.maxMp += 10;
                    p.mp = p.maxMp;
                    p.strength += 2;
                    p.defense += 2;
                    p.magic += 2;
                    p.speed += 1;
                    
                    if (p.str !== undefined) {
                        p.str++; p.dex++; p.wis++; p.cha++; p.con++; p.lck++;
                        if (p.class === 'paladin' || p.baseClass === 'paladin') { 
                            p.str++; p.wis++; 
                        }
                    }
                    
                    // Check for class evolution at 20
                    if (p.level === 20 && evolveClass(p)) {
                        const evolution = ADVANCED_CLASSES[p.baseClass];
                        terminalPrint(`âš¡ CLASS EVOLUTION! ${evolution.announcement}`, 'success');
                    }
                } else {
                    // Level down
                    p.level--;
                    p.maxHp = Math.max(20, p.maxHp - 15 - (p.con || 0));
                    p.hp = Math.min(p.hp, p.maxHp);
                    p.maxMp = Math.max(10, p.maxMp - 10);
                    p.mp = Math.min(p.mp, p.maxMp);
                    p.strength = Math.max(1, p.strength - 2);
                    p.defense = Math.max(1, p.defense - 2);
                    p.magic = Math.max(1, p.magic - 2);
                    p.speed = Math.max(1, p.speed - 1);
                    
                    if (p.str !== undefined) {
                        p.str = Math.max(1, p.str - 1);
                        p.dex = Math.max(1, p.dex - 1);
                        p.wis = Math.max(1, p.wis - 1);
                        p.cha = Math.max(1, p.cha - 1);
                        p.con = Math.max(1, p.con - 1);
                        p.lck = Math.max(1, p.lck - 1);
                    }
                }
            }
            
            // Update XP to next
            p.xpToNext = getXpToNextLevel(p.baseClass || p.class, p.level);
            p.xp = 0; // Reset XP within level
            
            updateHud();
            terminalPrint(`SUCCESS: Set player level to ${targetLevel}`, 'success');
            
            if (p.hasEvolved) {
                terminalPrint(`Player is now a ${getAdvancedClassName(p)} with ${getClassDamageMultiplier(p)}x damage!`, 'info');
            }
        }

        function handleSetGold(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const gold = parseInt(args[0]);
            if (isNaN(gold) || gold < 0) {
                terminalPrint('ERROR: Invalid gold amount', 'error');
                return;
            }

            gameState.player.gold = gold;
            terminalPrint(`SUCCESS: Set gold to ${gold}`, 'success');
        }

        function handleHeal() {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            gameState.player.hp = gameState.player.maxHp;
            gameState.player.mp = gameState.player.maxMp;
            terminalPrint('SUCCESS: Player fully healed', 'success');
        }

        function handleGodMode(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const mode = args[0]?.toLowerCase();
            if (mode === 'on') {
                gameState.player.godMode = true;
                terminalPrint('SUCCESS: God Mode ENABLED - Player is invincible', 'success');
            } else if (mode === 'off') {
                gameState.player.godMode = false;
                terminalPrint('SUCCESS: God Mode DISABLED', 'success');
            } else {
                terminalPrint('ERROR: Usage: /godmode <on/off>', 'error');
            }
        }

        function handleTeleport(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }
            if (!args || args.length === 0) {
                terminalPrint('ERROR: Usage: /teleport <destination>', 'error');
                terminalPrint('  /teleport town1               â€” Silverdale', 'warning');
                terminalPrint('  /teleport town2               â€” Ashen Harbor', 'warning');
                terminalPrint('  /teleport dungeon1            â€” Dungeon1 Floor 1 start', 'warning');
                terminalPrint('  /teleport dungeon1 f2         â€” Dungeon1 Floor 2 start', 'warning');
                terminalPrint('  /teleport dungeon1 f3         â€” Dungeon1 Floor 3 start', 'warning');
                terminalPrint('  /teleport dungeon1 f1 R57     â€” Dungeon1 Floor 1 Room R57', 'warning');
                terminalPrint('  /teleport <zone>              â€” Any explore zone key', 'warning');
                return;
            }

            const dest = args[0].toLowerCase();

            // â”€â”€ Town teleport â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (dest === 'town1' || dest === 'town2') {
                // Clear any dungeon/combat state
                gameState.dungeon = null;
                gameState.combatState = null;
                if (gameState.combatTimer) { clearInterval(gameState.combatTimer); gameState.combatTimer = null; }
                document.body.classList.remove("terminal-mode");
                document.getElementById('actionBar').innerHTML = '';
                gameState._terminalOpen = false;
                gameState._currentExploreArea = null;
                gameState.currentTown = dest;
                saveGame();
                showTown(dest);
                const tname = (typeof TOWNS !== 'undefined' && TOWNS[dest]) ? TOWNS[dest].name : dest;
                terminalPrint(`SUCCESS: Teleported to ${tname}`, 'success');
                return;
            }

            // â”€â”€ Dungeon teleport: /teleport dungeon1 [fN] [RoomId] â”€â”€â”€â”€â”€â”€â”€â”€
            // Match dungeon key case-insensitively
            const dungeonKey = (() => {
                if (typeof DUNGEONS === 'undefined') return null;
                for (const k in DUNGEONS) {
                    if (k.toLowerCase() === dest) return k;
                }
                return null;
            })();

            if (dungeonKey) {
                if (typeof DUNGEONS === 'undefined' || !DUNGEONS[dungeonKey]) {
                    terminalPrint(`ERROR: Dungeon "${dungeonKey}" not loaded`, 'error');
                    return;
                }
                const dungeonData = DUNGEONS[dungeonKey];

                // Parse floor: second arg like "f2" or "2"
                let targetFloor = 1;
                if (args[1]) {
                    const floorStr = args[1].replace(/^f/i, '');
                    const parsed = parseInt(floorStr);
                    if (!isNaN(parsed) && dungeonData.floors[parsed]) {
                        targetFloor = parsed;
                    } else {
                        terminalPrint(`ERROR: Floor "${args[1]}" not found in ${dungeonKey}`, 'error');
                        terminalPrint(`Available floors: ${Object.keys(dungeonData.floors).map(f=>'F'+f).join(', ')}`, 'warning');
                        return;
                    }
                }

                const floorData = dungeonData.floors[targetFloor];

                // Parse room: third arg like "R57"
                let targetRoom = floorData.startRoom;
                if (args[2]) {
                    const roomId = args[2].toUpperCase();
                    if (floorData.rooms[roomId]) {
                        targetRoom = roomId;
                    } else {
                        // Try lowercase
                        const found = Object.keys(floorData.rooms).find(k => k.toUpperCase() === roomId);
                        if (found) {
                            targetRoom = found;
                        } else {
                            terminalPrint(`ERROR: Room "${args[2]}" not found on Floor ${targetFloor}`, 'error');
                            const roomList = Object.keys(floorData.rooms).join(', ');
                            terminalPrint(`Floor ${targetFloor} rooms: ${roomList}`, 'warning');
                            return;
                        }
                    }
                }

                // â”€â”€ Actually teleport into dungeon â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // Clear any current dungeon/combat/explore state
                gameState.combatState = null;
                if (gameState.combatTimer) { clearInterval(gameState.combatTimer); gameState.combatTimer = null; }
                gameState._terminalOpen = false;
                gameState._currentExploreArea = null;

                // Mark room as discovered
                const destRoom = floorData.rooms[targetRoom];
                destRoom.flags = destRoom.flags || {};
                destRoom.flags.discovered = true;

                gameState.dungeon = {
                    dungeonKey,
                    floor:          targetFloor,
                    currentRoom:    targetRoom,
                    discoveredRooms: new Set([targetRoom]),
                    activeEnemies: []
                };

                // Show terminal
                /* mainScreen hidden by terminal-mode CSS class */
                openTerminalView(dungeonKey);
                startMpRegen(false);
                startResting(false);

                termAppend('', 'term-separator');
                termAppend(`ğŸ”® <span style="color:#AA88FF;">[SYSOP TELEPORT]</span> Floor ${targetFloor} â€” ${targetRoom}`, 'term-highlight');
                termAppend(`<strong>${destRoom.name || targetRoom}</strong>`);
                termAppend(destRoom.description || '', 'term-dim');
                const exitList = buildExitList(destRoom);
                termAppend(`You see exits: ${exitList}.`, 'term-dim');
                checkTownExit(destRoom);

                saveGame();
                renderDungeonActionBar();

                terminalPrint(`SUCCESS: Teleported to ${dungeonKey} Floor ${targetFloor} Room ${targetRoom}`, 'success');
                return;
            }

            // â”€â”€ Exploration zone teleport â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (typeof LOCATIONS !== 'undefined' && LOCATIONS[dest]) {
                gameState.dungeon = null;
                gameState.combatState = null;
                if (gameState.combatTimer) { clearInterval(gameState.combatTimer); gameState.combatTimer = null; }
                gameState.currentLocation = dest;
                gameState._terminalOpen = false;
                exploreLocation(dest);
                terminalPrint(`SUCCESS: Teleported to ${LOCATIONS[dest].name}`, 'success');
                return;
            }

            // â”€â”€ Nothing matched â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            terminalPrint(`ERROR: Unknown destination "${dest}"`, 'error');
            terminalPrint('Valid towns: town1, town2', 'warning');
            if (typeof DUNGEONS !== 'undefined') {
                terminalPrint('Valid dungeons: ' + Object.keys(DUNGEONS).map(k=>k.toLowerCase()).join(', '), 'warning');
            }
            if (typeof LOCATIONS !== 'undefined') {
                terminalPrint('Valid zones: ' + Object.keys(LOCATIONS).filter(k=>k!=='town').join(', '), 'warning');
            }
        }

        function handleKillMonster() {
            if (!gameState.combatState) {
                terminalPrint('ERROR: Not in combat', 'error');
                return;
            }

            gameState.combatState.enemy.hp = 0;
            terminalPrint('SUCCESS: Enemy eliminated', 'success');
            checkCombatEnd();
        }

        function listMonsters() {
            terminalPrint('â•â•â• ALL MONSTERS â•â•â•', 'warning');
            Object.keys(ENEMIES).forEach(key => {
                const m = ENEMIES[key];
                terminalPrint(`${key}: ${m.name} (Lv${m.level}, HP:${m.hp}, DMG:${m.damage})`);
            });
        }

        function listWeapons() {
            terminalPrint('â•â•â• ALL WEAPONS â•â•â•', 'warning');
            Object.keys(WEAPONS).forEach(key => {
                const w = WEAPONS[key];
                terminalPrint(`${key}: ${w.name} (Lv${w.level}, DMG:${w.damage}, MAG:${w.magicDamage})`);
            });
        }

        function listArmor() {
            terminalPrint('â•â•â• ALL ARMOR â•â•â•', 'warning');
            Object.keys(ARMOR).forEach(key => {
                const a = ARMOR[key];
                terminalPrint(`${key}: ${a.name} (Lv${a.level}, DEF:${a.defense})`);
            });
        }

        function listItems() {
            terminalPrint('â•â•â• ALL ITEMS â•â•â•', 'warning');
            Object.keys(ITEMS).forEach(key => {
                const i = ITEMS[key];
                terminalPrint(`${key}: ${i.name} (${i.type}, Lv${i.level})`);
            });
        }

        function openAddMonsterForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW MONSTER</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Monster ID (lowercase, underscores):</label>
                    <input type="text" id="monsterId" placeholder="fire_dragon">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="monsterName" placeholder="Fire Dragon">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">HP:</label>
                    <input type="number" id="monsterHp" value="100">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Damage:</label>
                    <input type="number" id="monsterDamage" value="20">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Defense:</label>
                    <input type="number" id="monsterDefense" value="10">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">XP Reward:</label>
                    <input type="number" id="monsterXp" value="100">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Gold Reward:</label>
                    <input type="number" id="monsterGold" value="80">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level:</label>
                    <input type="number" id="monsterLevel" value="5">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="monsterDesc" placeholder="A fearsome creature">
                </div>
                <button onclick="submitAddMonster()">ADD MONSTER</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddMonster() {
            const id = document.getElementById('monsterId').value.trim().toLowerCase();
            const name = document.getElementById('monsterName').value.trim();
            const hp = parseInt(document.getElementById('monsterHp').value);
            const damage = parseInt(document.getElementById('monsterDamage').value);
            const defense = parseInt(document.getElementById('monsterDefense').value);
            const xp = parseInt(document.getElementById('monsterXp').value);
            const gold = parseInt(document.getElementById('monsterGold').value);
            const level = parseInt(document.getElementById('monsterLevel').value);
            const description = document.getElementById('monsterDesc').value.trim();

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            ENEMIES[id] = {
                name: name,
                hp: hp,
                damage: damage,
                defense: defense,
                xp: xp,
                gold: gold,
                level: level,
                description: description
            };

            closeModal();
            terminalPrint(`SUCCESS: Added monster '${name}' with ID '${id}'`, 'success');
            terminalPrint('Remember to add it to a location\'s encounter list!', 'warning');
        }

        function openAddWeaponForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW WEAPON</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Weapon ID:</label>
                    <input type="text" id="weaponId" placeholder="flame_sword">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="weaponName" placeholder="Flame Sword">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Damage:</label>
                    <input type="number" id="weaponDamage" value="30">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Magic Damage:</label>
                    <input type="number" id="weaponMagic" value="10">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Cost:</label>
                    <input type="number" id="weaponCost" value="200">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level Requirement:</label>
                    <input type="number" id="weaponLevel" value="5">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="weaponDesc" placeholder="A blazing weapon">
                </div>
                <button onclick="submitAddWeapon()">ADD WEAPON</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddWeapon() {
            const id = document.getElementById('weaponId').value.trim().toLowerCase();
            const name = document.getElementById('weaponName').value.trim();
            const damage = parseInt(document.getElementById('weaponDamage').value);
            const magicDamage = parseInt(document.getElementById('weaponMagic').value);
            const cost = parseInt(document.getElementById('weaponCost').value);
            const level = parseInt(document.getElementById('weaponLevel').value);
            const description = document.getElementById('weaponDesc').value.trim();

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            WEAPONS[id] = {
                name: name,
                damage: damage,
                magicDamage: magicDamage,
                cost: cost,
                level: level,
                description: description
            };

            closeModal();
            terminalPrint(`SUCCESS: Added weapon '${name}' with ID '${id}'`, 'success');
        }

        function openAddArmorForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW ARMOR</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Armor ID:</label>
                    <input type="text" id="armorId" placeholder="dragon_mail">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="armorName" placeholder="Dragon Mail">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Defense:</label>
                    <input type="number" id="armorDefense" value="25">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Magic Bonus:</label>
                    <input type="number" id="armorMagic" value="0">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Cost:</label>
                    <input type="number" id="armorCost" value="300">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level Requirement:</label>
                    <input type="number" id="armorLevel" value="6">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="armorDesc" placeholder="Strong protective armor">
                </div>
                <button onclick="submitAddArmor()">ADD ARMOR</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddArmor() {
            const id = document.getElementById('armorId').value.trim().toLowerCase();
            const name = document.getElementById('armorName').value.trim();
            const defense = parseInt(document.getElementById('armorDefense').value);
            const magicBonus = parseInt(document.getElementById('armorMagic').value);
            const cost = parseInt(document.getElementById('armorCost').value);
            const level = parseInt(document.getElementById('armorLevel').value);
            const description = document.getElementById('armorDesc').value.trim();

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            ARMOR[id] = {
                name: name,
                defense: defense,
                magicBonus: magicBonus,
                cost: cost,
                level: level,
                description: description
            };

            closeModal();
            terminalPrint(`SUCCESS: Added armor '${name}' with ID '${id}'`, 'success');
        }

        function openAddItemForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW ITEM</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Item ID:</label>
                    <input type="text" id="itemId" placeholder="super_potion">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="itemName" placeholder="Super Potion">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Type:</label>
                    <select id="itemType" style="width: 100%; background: var(--secondary-bg); color: var(--text-color); border: 2px solid var(--border-color); padding: 10px; font-family: 'VT323', monospace; font-size: 18px;">
                        <option value="consumable">Consumable</option>
                        <option value="quest">Quest</option>
                        <option value="permanent">Permanent</option>
                        <option value="utility">Utility</option>
                        <option value="passive">Passive</option>
                    </select>
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Subtype:</label>
                    <input type="text" id="itemSubtype" placeholder="heal_hp">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Power:</label>
                    <input type="number" id="itemPower" value="50">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Cost:</label>
                    <input type="number" id="itemCost" value="30">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level:</label>
                    <input type="number" id="itemLevel" value="1">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="itemDesc" placeholder="Restores HP">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">
                        <input type="checkbox" id="itemStackable" checked> Stackable
                    </label>
                </div>
                <button onclick="submitAddItem()">ADD ITEM</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddItem() {
            const id = document.getElementById('itemId').value.trim().toLowerCase();
            const name = document.getElementById('itemName').value.trim();
            const type = document.getElementById('itemType').value;
            const subtype = document.getElementById('itemSubtype').value.trim();
            const power = parseInt(document.getElementById('itemPower').value);
            const cost = parseInt(document.getElementById('itemCost').value);
            const level = parseInt(document.getElementById('itemLevel').value);
            const description = document.getElementById('itemDesc').value.trim();
            const stackable = document.getElementById('itemStackable').checked;

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            ITEMS[id] = {
                name: name,
                type: type,
                subtype: subtype,
                power: power,
                cost: cost,
                level: level,
                description: description,
                stackable: stackable
            };

            closeModal();
            terminalPrint(`SUCCESS: Added item '${name}' with ID '${id}'`, 'success');
        }

        function closeModal() {
            document.getElementById('modalOverlay').classList.remove('active');
        }

        function handleExport(args) {
            const type = args[0]?.toLowerCase();
            let data;
            let filename;

            switch(type) {
                case 'monsters':
                    data = JSON.stringify(ENEMIES, null, 2);
                    filename = 'monsters.json';
                    break;
                case 'weapons':
                    data = JSON.stringify(WEAPONS, null, 2);
                    filename = 'weapons.json';
                    break;
                case 'armor':
                    data = JSON.stringify(ARMOR, null, 2);
                    filename = 'armor.json';
                    break;
                case 'items':
                    data = JSON.stringify(ITEMS, null, 2);
                    filename = 'items.json';
                    break;
                default:
                    terminalPrint('ERROR: Usage: /export <monsters/weapons/armor/items>', 'error');
                    return;
            }

            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);

            terminalPrint(`SUCCESS: Exported ${type} to ${filename}`, 'success');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CLASS-SPECIFIC XP TABLES (Levels 1-25)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const XP_TABLES = {
            acolyte: [0, 1150, 3490, 9625, 20640, 42200, 78200, 134300, 216900, 333500, 492000, 701800, 972800, 1315900, 1742800],
            necrolyte: [0, 1150, 3490, 9625, 20640, 42200, 78200, 134300, 216900, 333500, 492000, 701800, 972800, 1315900, 1742800],
            archer: [0, 1125, 3240, 8025, 17890, 36000, 66300, 113400, 182600, 280200, 413000, 588700, 815600, 1102800, 1460100],
            druid: [0, 1180, 3800, 10290, 24160, 50000, 93000, 161400, 261500, 402700, 595000, 849600, 1178400, 1594900, 2113200],
            sorceror: [0, 1180, 3800, 10290, 24160, 50000, 93000, 161400, 261500, 402700, 595000, 849600, 1178400, 1594900, 2113200],
            hunter: [0, 1125, 3240, 8025, 17890, 36000, 66300, 113400, 182600, 280200, 413000, 588700, 815600, 1102800, 1460100],
            rogue: [0, 1120, 3200, 7860, 17440, 35000, 64400, 109000, 177000, 271500, 400000, 570100, 789600, 1067600, 1413500],
            warrior: [0, 1125, 3240, 8025, 17890, 36000, 66300, 113400, 182600, 280200, 413000, 588700, 815600, 1102800, 1460100],
            paladin: [0, 1125, 3240, 8025, 17890, 36000, 66300, 113400, 182600, 280200, 413000, 588700, 815600, 1102800, 1460100]
        };
        
        // Extend to level 25 (levels 16-25)
        XP_TABLES.acolyte.push(2266200, 2895900, 3657600, 4555300, 5609100, 6836000, 8254100, 9882100, 11739900, 13048000);
        XP_TABLES.necrolyte.push(2266200, 2895900, 3657600, 4555300, 5609100, 6836000, 8254100, 9882100, 11739900, 13048000);
        XP_TABLES.archer.push(1898300, 2428600, 3063100, 3814700, 4696900, 5724000, 6911200, 8274200, 9829700, 11594700);
        XP_TABLES.druid.push(2748800, 3518100, 4438700, 5529300, 6809500, 8300000, 10022900, 12001000, 14258400, 16820200);
        XP_TABLES.sorceror.push(2748800, 3518100, 4438700, 5529300, 6809500, 8300000, 10022900, 12001000, 14258400, 16820200);
        XP_TABLES.hunter.push(1898300, 2428600, 3063100, 3814700, 4696900, 5724000, 6911200, 8274200, 9829700, 11594700);
        XP_TABLES.rogue.push(1637500, 2350000, 2964800, 3692200, 4546000, 5540000, 6689000, 8008000, 9513300, 11221500);
        XP_TABLES.warrior.push(1898300, 2428600, 3063100, 3814700, 4696900, 5724000, 6911200, 8274200, 9829700, 11594700);
        XP_TABLES.paladin.push(1898300, 2428600, 3063100, 3814700, 4696900, 5724000, 6911200, 8274200, 9829700, 11594700);
        
        function getXpForLevel(playerClass, level) {
            const table = XP_TABLES[playerClass] || XP_TABLES.warrior;
            if (level < 1) return 0;
            if (level > 25) return table[24]; // Max at level 25
            return table[level - 1];
        }
        
        function getXpToNextLevel(playerClass, currentLevel) {
            if (currentLevel >= 25) return 999999999; // Max level
            return getXpForLevel(playerClass, currentLevel + 1);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // END XP TABLES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        window.submitAddMonster = submitAddMonster;
        window.submitAddWeapon = submitAddWeapon;
        window.submitAddArmor = submitAddArmor;
        window.submitAddItem = submitAddItem;
        window.closeModal = closeModal;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // END SYSOP TERMINAL SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•





        // Initialize Game
        function initGame() {
            try {
                // Try to auto-restore character (especially important for dungeons!)
                const characters = getAllCharacters();
                
                if (characters.length > 0) {
                    // Check if any character is currently in a dungeon
                    let dungeonChar = null;
                    try {
                        dungeonChar = characters.find(char => {
                            try {
                                const saveData = localStorage.getItem(`dq_save_${char.id}`);
                                if (saveData) {
                                    const data = JSON.parse(saveData);
                                    return data.meta?.inDungeon === true;
                                }
                            } catch (e) {
                                console.error(`Corrupted save for ${char.id}:`, e);
                                // Delete corrupted save
                                localStorage.removeItem(`dq_save_${char.id}`);
                            }
                            return false;
                        });
                    } catch (e) {
                        console.error('Error checking for dungeon characters:', e);
                    }
                    
                    if (dungeonChar) {
                        // Auto-load character that was in a dungeon (prevent cheating!)
                        console.log('ğŸ° Auto-restoring dungeon session:', dungeonChar.name);
                        try {
                            loadCharacter(dungeonChar.id);
                            return;
                        } catch (e) {
                            console.error('Failed to load dungeon character:', e);
                            alert('âš ï¸ Your dungeon save was corrupted. Returning to main menu.');
                            // Delete corrupted save and continue to main menu
                            deleteCharacter(dungeonChar.id);
                        }
                    }
                    
                    // If single character and not in dungeon, auto-load for convenience
                    if (characters.length === 1) {
                        console.log('Auto-loading single character:', characters[0].name);
                        try {
                            loadCharacter(characters[0].id);
                            return;
                        } catch (e) {
                            console.error('Failed to load character:', e);
                            alert('âš ï¸ Your save was corrupted. Returning to main menu.');
                            // Delete corrupted save and continue to main menu
                            deleteCharacter(characters[0].id);
                        }
                    }
                }
            } catch (e) {
                console.error('Critical error in initGame:', e);
                // Clear potentially corrupted data
                try {
                    localStorage.removeItem('dq_character_list');
                } catch (clearError) {
                    console.error('Could not clear character list:', clearError);
                }
            }
            
            // Always fall back to main menu if anything goes wrong
            showMainMenu();
            
            // Warn before leaving page without saving
            window.addEventListener('beforeunload', function(e) {
                // Only warn if player exists and has made progress
                if (gameState.player && gameState.player.level >= 1) {
                    const message = 'You have unsaved progress! Are you sure you want to leave?';
                    e.preventDefault();
                    e.returnValue = message;  // Chrome requires returnValue
                    return message;           // Some browsers use return value
                }
            });
        }

        function showMainMenu() {
            const screen = document.getElementById('mainScreen');
            const characters = getAllCharacters();
            const hasCharacters = characters.length > 0;
            
            screen.innerHTML = `
                <div class="location-header">MAIN MENU</div>
                <div style="text-align: center; margin: 30px 0;">
                    <div class="ascii-art" style="color: var(--highlight-color);">
    âš”ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• âš”ï¸
       â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
       â•‘   DUNGEON QUEST AWAITS!   â•‘
       â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    ğŸ—¡ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ—¡ï¸
                    </div>
                </div>
                <div style="max-width: 400px; margin: 0 auto;">
                    <div class="menu-option" onclick="newGame()">â–º NEW GAME</div>
                    <div class="menu-option ${!hasCharacters?'disabled':''}" onclick="${hasCharacters?'showCharacterSelect()':''}">
                        â–º CONTINUE ${hasCharacters?`(${characters.length} local save${characters.length>1?'s':''})`:' (No saves)'}
                    </div>
                    <div class="menu-option" onclick="loadFromFile()">ğŸ“ LOAD FROM FILE (.dqsave)</div>
                    <div class="menu-option" onclick="showInstructions()">â–º INSTRUCTIONS</div>
                </div>
            `;
        }

        function showCharacterSelect() {
            const characters = getAllCharacters();
            if (characters.length === 0) {
                alert('No saved characters found!');
                return;
            }
            
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">SELECT CHARACTER</div>
                <div id="characterList" style="max-width: 600px; margin: 20px auto;"></div>
                <button onclick="showMainMenu()">â† BACK TO MENU</button>
            `;
            
            const charList = document.getElementById('characterList');
            
            characters.forEach(char => {
                const card = document.createElement('div');
                card.className = 'character-card';
                card.style.cssText = `
                    background: var(--secondary-bg);
                    border: 2px solid var(--border-color);
                    padding: 15px;
                    margin-bottom: 15px;
                    cursor: pointer;
                    transition: all 0.2s;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                `;
                
                card.innerHTML = `
                    <div style="flex: 1;">
                        <div style="color: var(--highlight-color); font-size: 22px; margin-bottom: 5px;">
                            ${char.name}
                        </div>
                        <div style="color: var(--text-color); font-size: 16px;">
                            Level ${char.level} ${char.class || 'Adventurer'}
                        </div>
                        <div style="color: #8aaa8a; font-size: 14px; margin-top: 5px;">
                            Last played: ${char.lastSaved}
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="event.stopPropagation(); loadCharacter('${char.id}')" 
                                style="padding: 8px 16px; background: #0a3a0a; border: 2px solid var(--text-color);">
                            â–¶ PLAY
                        </button>
                        <button onclick="event.stopPropagation(); confirmDeleteCharacter('${char.id}', '${char.name}')" 
                                style="padding: 8px 16px; background: #3a0a0a; border: 2px solid var(--error-color); color: var(--error-color);">
                            ğŸ—‘ï¸ DELETE
                        </button>
                    </div>
                `;
                
                card.addEventListener('mouseenter', () => {
                    card.style.background = 'var(--primary-bg)';
                    card.style.borderColor = 'var(--highlight-color)';
                });
                
                card.addEventListener('mouseleave', () => {
                    card.style.background = 'var(--secondary-bg)';
                    card.style.borderColor = 'var(--border-color)';
                });
                
                charList.appendChild(card);
            });
        }

        function confirmDeleteCharacter(charId, charName) {
            if (confirm(`Are you sure you want to DELETE ${charName}? This cannot be undone!`)) {
                if (deleteCharacter(charId)) {
                    showCharacterSelect(); // Refresh the list
                } else {
                    alert('Error deleting character!');
                }
            }
        }

        function loadCharacter(characterId) {
            try {
                const saveData = localStorage.getItem(`dq_save_${characterId}`);
                if (!saveData) {
                    console.error('Save file not found:', characterId);
                    alert('âš ï¸ Save file not found!');
                    showMainMenu();
                    return;
                }

                const data = JSON.parse(saveData);
                
                // Validate save data structure
                if (!data.player) {
                    throw new Error('Invalid save data: missing player data');
                }
                
                // Restore complete player state
                gameState.player = {
                    ...data.player,
                    // Ensure all arrays are properly restored
                    inventory: data.player.inventory || [],
                    knownSpells: data.player.knownSpells || [],
                    defeatedMasters: data.player.defeatedMasters || [],
                    unlockedAreas: data.player.unlockedAreas || [],
                    // Ensure bankGold exists (for old saves)
                    bankGold: data.player.bankGold || 0,
                    achievements: data.player.achievements || [],
                    runestones: data.player.runestones || []
                };
                
                // Restore current town
                gameState.currentTown = data.currentTown || 'town1';
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // RESTORE GENERATED WEAPONS - Must happen BEFORE equipment check!
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if (data.generatedWeapons) {
                    Object.keys(data.generatedWeapons).forEach(weaponId => {
                        WEAPONS[weaponId] = data.generatedWeapons[weaponId];
                    });
                    console.log(`âœ… Restored ${Object.keys(data.generatedWeapons).length} generated weapons`);
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // RESTORE GENERATED ARMOR - Must happen BEFORE equipment check!
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if (data.generatedArmor) {
                    Object.keys(data.generatedArmor).forEach(armorId => {
                        ARMOR[armorId] = data.generatedArmor[armorId];
                    });
                    console.log(`âœ… Restored ${Object.keys(data.generatedArmor).length} generated armor pieces`);
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // EQUIPMENT MIGRATION (fix old save data with missing weapons/armor)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                const p = gameState.player;
                
                // Check if weapon exists
                if (!WEAPONS[p.weapon]) {
                    console.warn(`âš ï¸ Weapon '${p.weapon}' not found. Migrating to default weapon...`);
                    // Try to find a suitable replacement based on class
                    const classDefaults = {
                        warrior: 'iron_sword',
                        rogue: 'dagger',
                        acolyte: 'staff',
                        cleric: 'mace',
                        necrolyte: 'staff',
                        paladin: 'mace',
                        hunter: 'bow',
                        archer: 'bow',
                        ranger: 'bow',
                        druid: 'staff',
                        mage: 'staff',
                        sorceror: 'staff',
                        warlock: 'staff'
                    };
                    p.weapon = classDefaults[p.class] || 'iron_sword';
                    console.log(`âœ… Migrated weapon to: ${p.weapon}`);
                }
                
                // Check if armor exists
                if (!ARMOR[p.armor]) {
                    console.warn(`âš ï¸ Armor '${p.armor}' not found. Migrating to default armor...`);
                    // Class-based armor defaults
                    const armorDefaults = {
                        warrior: 'leather_armor',
                        rogue: 'leather_vest',
                        paladin: 'chain_mail',
                        cleric: 'leather_armor',
                        acolyte: 'cloth_robes',
                        mage: 'cloth_robes',
                        warlock: 'cloth_robes',
                        ranger: 'leather_armor',
                        hunter: 'leather_armor',
                        archer: 'leather_vest'
                    };
                    p.armor = armorDefaults[p.class] || 'leather_vest';
                    console.log(`âœ… Migrated armor to: ${p.armor}`);
                }
                
                // Ensure className exists (for old saves)
                if (!p.className && p.class && CLASSES[p.class]) {
                    p.className = CLASSES[p.class].name;
                    console.log(`âœ… Added className: ${p.className}`);
                }
                
                gameState.currentLocation = data.currentLocation || 'silverdale';
                
                // Restore dungeon state if applicable
                if (data.meta?.inDungeon && data.dungeon) {
                    // Check if DUNGEONS is loaded
                    if (typeof DUNGEONS === 'undefined') {
                        console.error('âš ï¸ DUNGEONS not loaded! Check dungeon-data.js for syntax errors.');
                        alert('âš ï¸ Dungeon data failed to load. Returning to town.');
                        gameState.dungeon = null;
                        showTown();
                        return;
                    }
                    
                    console.log('ğŸ” Loading dungeon:', data.dungeon.dungeonKey);
                    console.log('ğŸ“¦ Available dungeons:', Object.keys(DUNGEONS));
                    
                    let dungeonKey = data.dungeon.dungeonKey;
                    
                    // Migrate old dungeon keys if needed
                    if (!DUNGEONS[dungeonKey]) {
                        console.warn(`âš ï¸ Dungeon "${dungeonKey}" not found. Attempting migration...`);
                        const availableDungeons = Object.keys(DUNGEONS);
                        if (availableDungeons.length > 0) {
                            dungeonKey = availableDungeons[0];
                            console.log(`âœ… Migrated to dungeon: ${dungeonKey}`);
                        } else {
                            console.error('âŒ No dungeons available!');
                            alert('âš ï¸ Dungeon not found. Returning to town.');
                            gameState.dungeon = null;
                            showTown();
                            return;
                        }
                    }
                    
                    const dungeon = DUNGEONS[dungeonKey];
                    
                    gameState.dungeon = {
                        dungeonKey: dungeonKey,
                        floor: data.dungeon.floor,
                        currentRoom: data.dungeon.currentRoom,
                        discoveredRooms: new Set(data.dungeon.discoveredRooms),
                        spawnedRooms: new Set(data.dungeon.spawnedRooms || []),
                        activeEnemies: (data.dungeon.activeEnemies || []).map(e => ({
                            ...e,
                            isChasing: false,
                            roomsFollowed: 0
                        }))
                    };
                    
                    // Open dungeon UI
                    openTerminalView(dungeonKey);
                    
                    const floor = dungeon.floors[data.dungeon.floor];
                    if (!floor) {
                        console.error(`âš ï¸ Floor ${data.dungeon.floor} not found!`);
                        alert('âš ï¸ Invalid dungeon floor. Returning to town.');
                        gameState.dungeon = null;
                        showTown();
                        return;
                    }
                    
                    const room = floor.rooms[data.dungeon.currentRoom];
                    if (!room) {
                        console.error(`âš ï¸ Room ${data.dungeon.currentRoom} not found!`);
                        alert('âš ï¸ Invalid dungeon room. Returning to town.');
                        gameState.dungeon = null;
                        showTown();
                        return;
                    }
                    
                    termAppend('', 'term-separator');
                    termAppend(`<strong>${room.name}</strong>`);
                    termAppend(room.description, 'term-dim');
                    
                    const exits = Object.keys(room.exits).map(d => d.toUpperCase()).join(', ');
                    termAppend(`You see exits: ${exits}.`, 'term-dim');
                    
                    checkEnemiesInRoom(data.dungeon.currentRoom);
                    renderDungeonActionBar();
                    
                    // Start regeneration in dungeon (normal speed)
                    startMpRegen(false);
                    startResting(false);
                } else if (data.activeCombat && data.activeCombat.monsters && data.activeCombat.monsters.length > 0) {
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // RESTORE MID-COMBAT STATE - enemies still waiting from last session
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    const ac = data.activeCombat;
                    const p  = gameState.player;
                    
                    // Restore pip array
                    const pipCount  = ac.pipCount || calcPlayerHits(p);
                    const pipTimers = Array(pipCount).fill(10);
                    const pipReady  = ac.pipsReady || Array(pipCount).fill(true);
                    
                    gameState.combatState = {
                        monsters:           ac.monsters,
                        currentTarget:      ac.currentTarget || 0,
                        messages:           [],
                        defeatedMonsters:   [],
                        pipTimers:          pipTimers,
                        pipAvailable:       pipReady,
                        enemyTimer:         ac.enemyDelay || 15,
                        enemyDelay:         ac.enemyDelay || 15,
                        enemyHits:          ac.enemyHits  || 1,
                        enemyHitsLeft:      ac.enemyHitsLeft || 1,
                        playerStatusEffects:  [],
                        monsterStatusEffects: {},
                        dotTimers:            {},
                        actionMode:           'main'
                    };
                    
                    // Open the terminal view for the saved location
                    const loc = ac.location || gameState.currentLocation;
                    gameState.currentLocation = loc;
                    gameState._terminalOpen = false;
                    openTerminalView(loc);
                    
                    // Print restoration message
                    termAppend('', 'term-separator');
                    termAppend(`<span style="color:#FF8800;">âš ï¸ You were mid-combat when you left!</span>`, 'term-enemy');
                    
                    const names = ac.monsters.map(m =>
                        `<span style="color:${m.rarityColor};">${m.name}</span> (${m.hp}/${m.maxHp} HP)`
                    ).join(', ');
                    termAppend(`Still fighting: ${names}`, 'term-enemy');
                    
                    // Start regen, render UI
                    startMpRegen(false);
                    startResting(false);
                    renderEnemyCards();
                    renderActionBar();
                    startCombatTimer();
                    
                    console.log(`âš”ï¸ Restored combat: ${ac.monsters.length} enemies waiting`);
                } else {
                    showTown();
                }
                
                console.log(`âœ… Character loaded: ${data.characterName}`);
                console.log(`   Weapon: ${gameState.player.weapon} | Armor: ${gameState.player.armor}`);
            } catch (e) {
                console.error('Error loading character:', e);
                alert('âš ï¸ Failed to load save file. The data may be corrupted. Returning to main menu.');
                
                // Clean up corrupted state
                gameState.player = null;
                gameState.dungeon = null;
                gameState.combatState = null;
                
                // Try to delete corrupted save
                try {
                    deleteCharacter(characterId);
                } catch (deleteError) {
                    console.error('Could not delete corrupted save:', deleteError);
                }
                
                // Always return to main menu on error
                showMainMenu();
            }
        }

        function showInstructions() {
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">INSTRUCTIONS</div>
                <div class="message">
                    <p><span class="stat-label">OBJECTIVE:</span> Explore dungeons, defeat monsters, level up, and become legendary!</p>
                    <br>
                    <p><span class="stat-label">COMBAT:</span> Combat is turn-based with a timer. Choose your action before time runs out!</p>
                    <br>
                    <p><span class="stat-label">EXPLORATION:</span> Travel to different locations, each with stronger monsters.</p>
                    <br>
                    <p><span class="stat-label">PROGRESSION:</span> Gain XP, level up, buy better equipment, and learn new spells.</p>
                    <br>
                    <p><span class="stat-label">SAVING:</span> Save your game at any time from the town menu.</p>
                </div>
                <button onclick="showMainMenu()">BACK TO MENU</button>
            `;
        }

        function newGame() {
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">CHARACTER CREATION</div>
                <div class="message">
                    <p>Enter your character name:</p>
                    <input type="text" id="playerName" maxlength="20" placeholder="Hero Name">
                </div>
                <div class="message">
                    <p><span class="stat-label">Choose your class:</span></p>
                </div>
                <div class="character-select" id="classSelect"></div>
                <button onclick="goToStatAlloc()" id="createBtn" disabled>ALLOCATE STATS â†’</button>
                <button onclick="showMainMenu()">CANCEL</button>
            `;

            const classSelect = document.getElementById('classSelect');
            window._selectedClass = null;

            Object.keys(CLASSES).forEach(classKey => {
                const cd   = CLASSES[classKey];
                const card = document.createElement('div');
                card.className = 'class-card';
                card.innerHTML = `
                    <div style="color:var(--highlight-color);font-size:22px;margin-bottom:8px;">${cd.name}</div>
                    <div style="font-size:16px;margin-bottom:8px;">${cd.description}</div>
                    <div class="stat">HP: ${cd.hp} | MP: ${cd.mp}</div>
                    <div class="stat" style="color:#8aaa8a;">STR/DEF/MAG/SPD set at creation</div>
                `;
                card.onclick = () => {
                    document.querySelectorAll('.class-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    window._selectedClass = classKey;
                    document.getElementById('createBtn').disabled = false;
                };
                classSelect.appendChild(card);
            });
        }

        // â”€â”€ stat allocation screen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window._pendingStats = null;
        window._pendingName  = '';

        function goToStatAlloc() {
            const name = document.getElementById('playerName').value.trim();
            if (!name)                { alert('Please enter a character name!'); return; }
            if (!window._selectedClass) { alert('Please select a class!');       return; }
            window._pendingName  = name;
            window._pendingStats = Object.assign({}, CLASS_STAT_PRESETS[window._selectedClass]);
            renderStatAllocScreen();
        }

        function renderStatAllocScreen() {
            const classKey   = window._selectedClass;
            const classData  = CLASSES[classKey];
            const stats      = window._pendingStats;
            const spent      = STAT_NAMES.reduce((a,k) => a + stats[k], 0);
            const remaining  = STAT_BUDGET - spent;
            const affinities = CLASS_AFFINITIES[classKey];
            const screen     = document.getElementById('mainScreen');

            // preview derived values
            const previewHp   = classData.hp + stats.con * 5;
            const previewHits = (function(){
                let h=1;
                if(classKey==='rogue') h++;
                h += Math.floor(Math.max(0, stats.str-8)/6);
                return h;
            })();

            let rows = '';
            STAT_NAMES.forEach(s => {
                const isAff   = affinities.includes(s);
                const canUp   = remaining > 0 && stats[s] < 15;
                const canDown = stats[s] > 1;
                rows += `
                <div style="display:flex;align-items:center;gap:6px;padding:5px 0;border-bottom:1px solid #1a4a1a;flex-wrap:wrap;">
                    <span style="min-width:36px;color:${isAff?'var(--highlight-color)':'var(--text-color)'};font-weight:bold;">${STAT_LABELS[s]}</span>
                    <span style="flex:1;min-width:120px;font-size:16px;color:#8aaa8a;">${STAT_DESCS[s]}${isAff?' â˜…':''}</span>
                    <button onclick="statAdj('${s}',-1)" ${canDown?'':'disabled'} style="width:32px;padding:4px 0;margin:0;font-size:20px;">âˆ’</button>
                    <span style="min-width:28px;text-align:center;color:var(--highlight-color);font-size:22px;">${stats[s]}</span>
                    <button onclick="statAdj('${s}',+1)" ${canUp ?'':'disabled'} style="width:32px;padding:4px 0;margin:0;font-size:20px;">+</button>
                </div>`;
            });

            screen.innerHTML = `
                <div class="location-header">ALLOCATE STATS â€“ ${classData.name}</div>
                <div class="message" style="border-color:var(--highlight-color);">
                    <span style="color:var(--highlight-color);">Points remaining: </span>
                    <span style="color:${remaining>0?'var(--text-color)':'var(--error-color)'};font-size:22px;">${remaining}</span>
                    <span style="color:#8aaa8a;font-size:15px;"> (â˜… = class affinity)</span>
                </div>
                <div style="max-width:520px;margin:0 auto;">${rows}</div>
                <div class="message" style="border-color:#005500;margin-top:12px;font-size:15px;">
                    <span style="color:#8aaa8a;">PREVIEW:</span><br>
                    <span style="color:var(--highlight-color);">HP ${previewHp}</span>
                    <span style="color:var(--border-color);"> | ATK/rd: ${previewHits}</span><br>
                    <span style="color:#8aaa8a;">Crit ${calcCritChance(stats.lck)}% | Dodge ${calcDodgeChance(stats.dex)}%</span>
                </div>
                <div style="margin-top:14px;display:flex;flex-wrap:wrap;gap:8px;">
                    <button onclick="window._pendingStats=Object.assign({},CLASS_STAT_PRESETS['${classKey}']);renderStatAllocScreen();">ğŸ“‹ CLASS PRESET</button>
                    <button onclick="window._pendingStats=rerollStats('${classKey}');renderStatAllocScreen();">ğŸ² REROLL</button>
                </div>
                <div style="margin-top:14px;">
                    <button onclick="finaliseCharacter()" ${remaining===0?'':'disabled'} style="font-size:20px;">âš”ï¸ BEGIN ADVENTURE âš”ï¸</button>
                    <button onclick="newGame()">â† BACK</button>
                </div>
            `;
        }

        window.statAdj = function(stat, dir) {
            const stats = window._pendingStats;
            const spent = STAT_NAMES.reduce((a,k) => a + stats[k], 0);
            if (dir > 0 && spent >= STAT_BUDGET) return;
            if (dir < 0 && stats[stat] <= 1)      return;
            stats[stat] += dir;
            renderStatAllocScreen();
        };

        function finaliseCharacter() {
            const classKey  = window._selectedClass;
            const classData = CLASSES[classKey];
            const stats     = window._pendingStats;

            // Generate unique character ID
            const charId = 'char_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

            gameState.player = {
                id: charId,  // Unique character ID
                name: window._pendingName,
                class: classKey,  className: classData.name,
                level: 1,  xp: 0,  xpToNext: getXpToNextLevel(classKey, 1),
                hp: classData.hp + stats.con * 5,
                maxHp: classData.hp + stats.con * 5,
                mp: classData.mp,  maxMp: classData.mp,
                strength: classData.strength,   // legacy weapon-calc field
                defense:  classData.defense,
                magic:    classData.magic,
                speed:    classData.speed,
                gold: 100,
                bankGold: 0,  // Bank storage starts empty
                weapon: classData.startWeapon,
                armor:  classData.startArmor,
                inventory:  [classData.startWeapon, classData.startArmor],
                knownSpells: getStartingSpells(classKey),
                defeatedMasters: [],
                unlockedAreas:  ['forest'],
                // â”€â”€ new stat block â”€â”€
                str: stats.str,  dex: stats.dex,  wis: stats.wis,
                cha: stats.cha,  con: stats.con,  lck: stats.lck,
                // â”€â”€ stat point allocation â”€â”€
                statPoints: 0,   // earned 3 per level-up, spent in Character Stats
                // â”€â”€ store base class so evolution doesn't lose class identity â”€â”€
                baseClass: classKey
            };
            gameState.currentLocation = 'town';
            
            // Auto-save new character
            saveGame();
            
            showTown();
        }

        function getStartingSpells(classKey) {
            // Use CLASS_SPELL_TREES to get starting spell
            if (typeof CLASS_SPELL_TREES !== 'undefined' && CLASS_SPELL_TREES[classKey]) {
                const startingSpell = CLASS_SPELL_TREES[classKey].startingSpell;
                return startingSpell ? [startingSpell] : [];
            }
            
            // Fallback for classes without spell trees (warriors, rogues, etc.)
            return [];
        }

        function showTown(townId) {
            document.body.classList.remove("terminal-mode");
            
            // Update current town if specified
            if (townId) gameState.currentTown = townId;
            const tid = gameState.currentTown || 'town1';
            
            // Get town definition (fall back to inline data if TOWNS not loaded yet)
            const townDef = (typeof TOWNS !== 'undefined' && TOWNS[tid]) ? TOWNS[tid] : null;
            const townName = townDef ? townDef.name : 'Silverdale';
            const townDesc = townDef ? townDef.description : 'A peaceful starting town.';

            // Apply town color theme
            if (townDef && townDef.theme) {
                document.documentElement.style.setProperty('--text-color', townDef.theme);
            } else {
                document.documentElement.style.setProperty('--text-color', '#00FF41');
            }

            // Start MP/HP regen (slower in town)
            startMpRegen(true);
            startResting(true);

            const p = gameState.player;
            const screen = document.getElementById('mainScreen');

            // â”€â”€ Portal tab (shown if player has white_runestone) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const hasRunestone = p.runestones && p.runestones.includes('white_runestone');
            let portalOption = '';
            if (hasRunestone && townDef && townDef.portalDestination) {
                const destDef = (typeof TOWNS !== 'undefined' && TOWNS[townDef.portalDestination]) 
                    ? TOWNS[townDef.portalDestination] : null;
                const destName = destDef ? destDef.name : townDef.portalDestination;
                portalOption = `
                    <div class="menu-option" onclick="usePortal('${townDef.portalDestination}')"
                         style="border-color:#AA88FF;background:rgba(170,136,255,0.07);">
                        ğŸŒ€ PORTAL â†’ ${destName}
                        <span style="color:#AA88FF;font-size:12px;"> [White Runestone âœ¦]</span>
                    </div>`;
            }

            // â”€â”€ Dungeon option (level-gated) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            let dungeonOption = '';
            if (townDef && townDef.dungeonKey) {
                const dungeonReady = p.level >= (townDef.dungeonRequiredLevel || 5);
                if (dungeonReady) {
                    dungeonOption = `
                        <div class="menu-option" onclick="enterTownDungeon('${tid}')"
                             style="border-color:var(--highlight-color);">
                            ğŸ° ${townDef.dungeonName || 'DUNGEON'}
                        </div>`;
                } else {
                    dungeonOption = `
                        <div class="menu-option" style="opacity:0.45;cursor:default;"
                             onclick="alert('${townDef.dungeonUnlockMessage || 'Not yet ready.'}')">
                            ğŸ° ${townDef.dungeonName || 'DUNGEON'}
                            <span style="color:var(--error-color);font-size:12px;"> [Requires Lv ${townDef.dungeonRequiredLevel || 5}]</span>
                        </div>`;
                }
            } else if (!townDef) {
                // Legacy fallback for old saves
                dungeonOption = `<div class="menu-option" onclick="enterDungeons()">ğŸ° DUNGEONS</div>`;
            }

            // â”€â”€ Runestone badge next to name â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            let runestoneBadge = '';
            if (p.runestones && p.runestones.length > 0) {
                const badges = {
                    'white_runestone': '<span title="White Runestone: Discovered Ashen Harbor" style="color:#FFFFFF;margin-left:6px;font-size:14px;" >âœ¦</span>'
                };
                runestoneBadge = p.runestones.map(r => badges[r] || '').join('');
            }

            screen.innerHTML = `
                <div class="location-header">${townName}${runestoneBadge}</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>${townDesc}</p>
                    <p style="color: var(--border-color); font-size: 14px;">Modem Speed: ${currentModemSpeed}</p>
                </div>
                <div style="margin: 20px 0;">
                    <div class="menu-option" onclick="showShop()">â–º VISIT SHOP</div>
                    <div class="menu-option" onclick="showBank()">ğŸ¦ BANK (${p.bankGold || 0}g stored)</div>
                    <div class="menu-option" onclick="showCharacterStats()">ğŸ“Š CHARACTER STATS</div>
                    <div class="menu-option" onclick="showTemple()">â›ª TEMPLE OF REBIRTH</div>
                    ${dungeonOption}
                    <div class="menu-option" onclick="restAtInn()">â–º REST AT INN (${calcInnCost(p.cha)} Gold)</div>
                    <div class="menu-option" onclick="showInventory()">â–º INVENTORY</div>
                    <div class="menu-option" onclick="showExplore()">â–º EXPLORE WORLD</div>
                    ${portalOption}
                    <div class="menu-option" onclick="showModemSettings()">â–º MODEM SETTINGS</div>
                    <div class="menu-option" onclick="saveGame()" style="border-color:var(--text-color);">ğŸ’¾ QUICK SAVE</div>
                    <div class="menu-option" onclick="downloadSaveFile()" style="border-color:var(--highlight-color);background:rgba(255,255,0,0.05);">ğŸ“¥ DOWNLOAD SAVE FILE</div>
                    <div class="menu-option" onclick="showMainMenu()">â–º QUIT TO MENU</div>
                </div>
            `;
        }

        // â”€â”€ Travel to another town via portal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function usePortal(destTownId) {
            const p = gameState.player;
            if (!p.runestones || !p.runestones.includes('white_runestone')) {
                alert('You need the White Runestone to use the portal!');
                return;
            }
            const destDef = (typeof TOWNS !== 'undefined' && TOWNS[destTownId]) ? TOWNS[destTownId] : null;
            const destName = destDef ? destDef.name : destTownId;
            gameState.currentTown = destTownId;
            saveGame();
            showTown(destTownId);
            // Flash a brief arrival message
            setTimeout(() => {
                const screen = document.getElementById('mainScreen');
                const flash = document.createElement('div');
                flash.style.cssText = 'position:fixed;top:15px;left:50%;transform:translateX(-50%);background:#0a0a0a;border:2px solid #AA88FF;padding:10px 20px;color:#AA88FF;font-size:16px;z-index:9999;';
                flash.textContent = `ğŸŒ€ Arrived in ${destName}`;
                document.body.appendChild(flash);
                setTimeout(() => flash.remove(), 2500);
            }, 50);
        }

        // â”€â”€ Enter the dungeon attached to the current town â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function enterTownDungeon(townId) {
            const tid = townId || gameState.currentTown || 'town1';
            const townDef = (typeof TOWNS !== 'undefined' && TOWNS[tid]) ? TOWNS[tid] : null;
            if (!townDef || !townDef.dungeonKey) {
                alert('No dungeon available here yet!');
                return;
            }
            const p = gameState.player;
            if (p.level < (townDef.dungeonRequiredLevel || 5)) {
                alert(townDef.dungeonUnlockMessage || `You must be level ${townDef.dungeonRequiredLevel} to enter!`);
                return;
            }
            if (typeof DUNGEONS === 'undefined' || !DUNGEONS[townDef.dungeonKey]) {
                alert(`âš ï¸ Dungeon data not loaded! Make sure ${townDef.dungeonKey}.js is in the game folder.`);
                return;
            }

            // â”€â”€ Show dungeon warning modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const hasRecall  = p.inventory.includes('recall_potion');
            const dungeonName = DUNGEONS[townDef.dungeonKey].name || townDef.dungeonKey;
            const recallNote  = hasRecall
                ? `<div style="color:#00ff88;margin-top:8px;">âœ… You carry a <strong>Recall Potion</strong> â€” you can use it to escape at any time.</div>`
                : `<div style="color:#ff4444;margin-top:8px;">âŒ You do NOT have a Recall Potion!<br>
                   Visit the <strong>Shop â†’ Potions</strong> to buy one for <span style="color:#FFD700;">5,000 gold</span> before you go.</div>`;

            const modal = document.createElement('div');
            modal.id = 'dungeonWarningModal';
            modal.style.cssText = `
                position:fixed;inset:0;z-index:9999;
                display:flex;align-items:center;justify-content:center;
                background:rgba(0,0,0,0.85);
                font-family:'VT323',monospace;
            `;
            modal.innerHTML = `
                <div style="
                    border:3px double #ff4444;
                    background:#000;
                    max-width:480px;width:90%;
                    padding:22px 24px;
                    box-shadow:0 0 40px rgba(255,0,0,0.4);
                    color:#00ff00;
                    line-height:1.4;
                ">
                    <div style="font-size:22px;color:#ff4444;text-align:center;margin-bottom:12px;letter-spacing:2px;">
                        âš ï¸ DUNGEON WARNING âš ï¸
                    </div>
                    <div style="font-size:18px;color:#ffff00;margin-bottom:12px;text-align:center;">
                        ${dungeonName}
                    </div>

                    <div style="font-size:16px;margin-bottom:10px;">
                        Once you enter, there are <strong style="color:#ff4444;">only three ways to leave:</strong>
                    </div>
                    <div style="font-size:16px;padding-left:8px;margin-bottom:14px;">
                        <div style="margin-bottom:4px;">ğŸŒ€ <strong style="color:#AA88FF;">Recall Potion</strong> â€” instantly return to town
                            <div style="font-size:13px;color:#888;padding-left:22px;">Purchase one at the shop for 5,000 gold. One use.</div>
                        </div>
                        <div style="margin-bottom:4px;">ğŸšª <strong style="color:#00ff88;">Entrance / Exit</strong> â€” walk back the way you came</div>
                        <div>ğŸ™ï¸ <strong style="color:#4488ff;">Town portal rooms</strong> â€” special dungeon rooms with an exit portal</div>
                    </div>

                    <div style="
                        border:1px solid #444;padding:10px;margin-bottom:14px;
                        background:rgba(255,100,0,0.05);font-size:15px;color:#ff8800;
                    ">
                        âš”ï¸ Prepare yourself before embarking â€” stock up on potions, spells, and equipment.
                        Once inside, you cannot return to the shop without finding your way out first.
                    </div>

                    ${recallNote}

                    <div style="display:flex;gap:10px;margin-top:18px;justify-content:center;">
                        <button onclick="
                            document.getElementById('dungeonWarningModal').remove();
                            startDungeon('${townDef.dungeonKey}');
                        " style="
                            font-family:'VT323',monospace;font-size:18px;
                            padding:8px 22px;cursor:pointer;
                            background:linear-gradient(180deg,#1a0000,#0a0000);
                            color:#ff4444;border:2px solid #ff4444;
                        ">âš”ï¸ ENTER DUNGEON</button>
                        <button onclick="document.getElementById('dungeonWarningModal').remove();" style="
                            font-family:'VT323',monospace;font-size:18px;
                            padding:8px 22px;cursor:pointer;
                            background:linear-gradient(180deg,#001a00,#000a00);
                            color:#00ff88;border:2px solid #00ff88;
                        ">â† STAY SAFE</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // â”€â”€ Generic dungeon start (replaces testDungeon) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function startDungeon(dungeonKey) {
            document.body.classList.add("terminal-mode");
            startMpRegen(false);
            startResting(false);

            const dungeon = DUNGEONS[dungeonKey];
            const floor = dungeon.floors[1];

            // Reset only discovered state for fresh run â€” preserve design flags (townExit, etc.)
            Object.values(floor.rooms).forEach(r => {
                r.flags = r.flags || {};
                r.flags.discovered = false;
                // Re-arm firstDiscovery only if player doesn't have runestone yet
                if (r.flags.townExit === 'town2') {
                    const p = gameState.player;
                    const hasRunestone = p && p.runestones && p.runestones.includes('white_runestone');
                    r.flags.firstDiscovery = !hasRunestone;
                }
            });

            gameState.dungeon = {
                dungeonKey,
                floor: 1,
                currentRoom: floor.startRoom,
                discoveredRooms: new Set([floor.startRoom]),
                activeEnemies: []
            };

            openTerminalView(dungeonKey);

            const room = floor.rooms[floor.startRoom];
            room.flags.discovered = true;

            termAppend('', 'term-separator');
            termAppend(`<strong>${room.name || 'Entrance'}</strong>`);
            termAppend(room.description || 'You step into the darkness.', 'term-dim');

            const exits = Object.keys(room.exits).map(d => d.toUpperCase()).join(', ');
            termAppend(`You see exits: ${exits}.`, 'term-dim');

            // Check for townExit flag at start room
            checkTownExit(room);

            saveGame();
            renderDungeonActionBar();
        }

        function showBank() {
            const screen = document.getElementById('mainScreen');
            const p = gameState.player;
            screen.innerHTML = `
                <div class="location-header">ğŸ¦ TOWN BANK</div>
                ${renderPlayerStats()}
                <div class="message" style="border-color:var(--highlight-color);">
                    <p><strong style="color:var(--highlight-color);">ğŸ’° YOUR VAULT IS SAFE</strong></p>
                    <p style="color:#8aaa8a;">Gold stored in the bank is protected from death penalties in dungeons!</p>
                </div>
                <div class="message">
                    <p><span class="stat-label">Carried Gold:</span> <span style="color:#FFD700;">${p.gold}g</span></p>
                    <p><span class="stat-label">Bank Vault:</span> <span style="color:#00FF00;">${p.bankGold || 0}g</span></p>
                </div>
                <div style="margin: 20px 0;">
                    <div class="message">
                        <p><span class="stat-label">Deposit Gold:</span></p>
                        <input type="number" id="depositAmount" min="1" max="${p.gold}" value="${Math.min(100, p.gold)}" 
                               style="width:150px;padding:8px;background:var(--secondary-bg);color:var(--text-color);border:2px solid var(--border-color);font-family:'Courier New',monospace;font-size:16px;">
                        <button onclick="depositGold()" style="margin-left:10px;">ğŸ’° DEPOSIT</button>
                    </div>
                    <div class="message">
                        <p><span class="stat-label">Withdraw Gold:</span></p>
                        <input type="number" id="withdrawAmount" min="1" max="${p.bankGold || 0}" value="${Math.min(100, p.bankGold || 0)}" 
                               style="width:150px;padding:8px;background:var(--secondary-bg);color:var(--text-color);border:2px solid var(--border-color);font-family:'Courier New',monospace;font-size:16px;">
                        <button onclick="withdrawGold()" style="margin-left:10px;">ğŸ’µ WITHDRAW</button>
                    </div>
                </div>
                <button onclick="showTown()">â† BACK TO TOWN</button>
            `;
        }

        function depositGold() {
            const amount = parseInt(document.getElementById('depositAmount').value);
            const p = gameState.player;
            
            if (isNaN(amount) || amount <= 0) {
                alert('Invalid amount!');
                return;
            }
            
            if (amount > p.gold) {
                alert('You don\'t have that much gold!');
                return;
            }
            
            p.gold -= amount;
            p.bankGold = (p.bankGold || 0) + amount;
            
            saveGame();
            showBank();
        }

        function withdrawGold() {
            const amount = parseInt(document.getElementById('withdrawAmount').value);
            const p = gameState.player;
            
            if (isNaN(amount) || amount <= 0) {
                alert('Invalid amount!');
                return;
            }
            
            if (amount > (p.bankGold || 0)) {
                alert('You don\'t have that much gold in the bank!');
                return;
            }
            
            p.bankGold -= amount;
            p.gold += amount;
            
            saveGame();
            showBank();
        }

        function showModemSettings() {
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">ğŸ“ MODEM SETTINGS ğŸ“</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>Select your connection speed:</p>
                    <p style="font-size: 14px; color: var(--border-color);">Current: ${currentModemSpeed}</p>
                </div>
                <div style="margin: 20px 0;">
                    <div class="menu-option ${currentModemSpeed === '4800' ? 'equipped' : ''}" onclick="setModemSpeed('4800')">
                        â–º 4800 BAUD (Ultra Slow - Maximum Nostalgia)
                    </div>
                    <div class="menu-option ${currentModemSpeed === '9600' ? 'equipped' : ''}" onclick="setModemSpeed('9600')">
                        â–º 9600 BAUD (Very Slow - Early 90s)
                    </div>
                    <div class="menu-option ${currentModemSpeed === '14.4k' ? 'equipped' : ''}" onclick="setModemSpeed('14.4k')">
                        â–º 14.4k MODEM (Slow - Classic BBS Feel)
                    </div>
                    <div class="menu-option ${currentModemSpeed === '28.8k' ? 'equipped' : ''}" onclick="setModemSpeed('28.8k')">
                        â–º 28.8k MODEM (Medium - Mid 90s Standard)
                    </div>
                    <div class="menu-option ${currentModemSpeed === '56k' ? 'equipped' : ''}" onclick="setModemSpeed('56k')">
                        â–º 56k MODEM (Fast - Late 90s)
                    </div>
                    <div class="menu-option ${currentModemSpeed === 'instant' ? 'equipped' : ''}" onclick="setModemSpeed('instant')">
                        â–º INSTANT (No Delay - Modern Broadband)
                    </div>
                </div>
                <div class="message" style="border-color: var(--highlight-color);">
                    <p style="color: var(--highlight-color);">â„¹ï¸ INFO</p>
                    <p style="font-size: 14px;">Modem speed affects how quickly text appears on screen.</p>
                    <p style="font-size: 14px;">Lower speeds = more authentic 1990s BBS experience!</p>
                    <p style="font-size: 14px;">Combat timer won't start until screen finishes loading.</p>
                </div>
                <button onclick="showTown()">BACK TO TOWN</button>
            `;
        }

        function setModemSpeed(speed) {
            currentModemSpeed = speed;
            showModemSettings();
        }

        function renderPlayerStats() {
            const p = gameState.player;
            const hpPercent = (p.hp / p.maxHp) * 100;
            const mpPercent = (p.mp / p.maxMp) * 100;
            const xpPercent = (p.xp / p.xpToNext) * 100;
            
            // Get display class name
            let displayClass;
            if (p.hasEvolved) {
                // Show advanced class name if evolved
                displayClass = `<span style="color:#FF00FF;font-weight:bold;">${getAdvancedClassName(p)}</span>`;
            } else if (p.className) {
                // Use stored className
                displayClass = p.className;
            } else if (p.class && CLASSES[p.class]) {
                // Fallback: get from CLASSES object
                displayClass = CLASSES[p.class].name;
            } else {
                // Last resort: capitalize the class key
                displayClass = p.class ? p.class.charAt(0).toUpperCase() + p.class.slice(1) : 'Adventurer';
            }

            return `
                <div class="stats-bar">
                    <div>
                        <span class="stat-label">${p.name}</span> - Level ${p.level} ${displayClass}
                    </div>
                    <div>
                        <span class="stat-label">Gold:</span> ${p.gold}
                    </div>
                </div>
                <div class="stats-bar">
                    <div>
                        <span class="stat-label">HP:</span> ${p.hp}/${p.maxHp}
                    </div>
                    <div>
                        <span class="stat-label">MP:</span> ${p.mp}/${p.maxMp}
                    </div>
                    <div>
                        <span class="stat-label">XP:</span> ${p.xp}/${p.xpToNext}
                    </div>
                </div>
            `;
        }

        function showShop() {
            const screen = document.getElementById('mainScreen');
            
            let shopHtml = `
                <div class="location-header">MERCHANT SHOP</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>Welcome to my shop! What can I do for you?</p>
                </div>
                <div style="margin: 20px 0;">
                    <button onclick="showShopBuy()" style="margin-right: 10px;">ğŸ’° BUY ITEMS</button>
                    <button onclick="showShopSell()">ğŸ’ SELL ITEMS</button>
                </div>
                <div id="shopContent"></div>
                <button onclick="showTown()">LEAVE SHOP</button>
            `;
            
            screen.innerHTML = shopHtml;
            showShopBuy(); // Default to buy tab
        }

        function enterDungeons() {
    termClear();
    testDungeon();
}


        function showShopBuy() {
            const p = gameState.player;
            const playerClass = p.baseClass || p.class;
            
            let shopHtml = `
                <div style="margin: 20px 0;">
                    <h3 style="color: var(--highlight-color);">WEAPONS</h3>
                    <div class="inventory-grid">
            `;

            Object.keys(WEAPONS).forEach(key => {
                const weapon = WEAPONS[key];
                
                // Filter by level and class
                if (weapon.level <= p.level + 2 && canUseWeapon(playerClass, weapon)) {
                    const owned = p.inventory.includes(key);
                    const equipped = p.weapon === key;
                    const qualityColor = QUALITY_CONFIG[weapon.quality].color;
                    const qualityBonus = getQualityBonus(weapon.quality, weapon.baseDamage);
                    const totalDmg = weapon.baseDamage + qualityBonus;
                    const totalMag = weapon.baseMagicDamage + getQualityBonus(weapon.quality, weapon.baseMagicDamage);
                    
                    // Build modifier display
                    let modifierHtml = '';
                    if (weapon.modifiers && weapon.modifiers.length > 0) {
                        modifierHtml = '<div style="margin-top:3px;font-size:11px;">';
                        weapon.modifiers.forEach(modKey => {
                            const mod = WEAPON_MODIFIERS[modKey];
                            if (mod) {
                                modifierHtml += `<div style="color:${mod.color};">â€¢ ${mod.name}</div>`;
                            }
                        });
                        modifierHtml += '</div>';
                    }
                    
                    shopHtml += `
                        <div class="item-card ${equipped ? 'equipped' : ''}">
                            <div style="color: ${qualityColor};">${weapon.name}</div>
                            <div>DMG: ${weapon.maxDamage ? `${totalDmg}-${weapon.maxDamage}` : totalDmg}${totalMag > 0 ? ` | MAG: ${totalMag}` : ''}</div>
                            ${modifierHtml}
                            <div>Level: ${weapon.level}</div>
                            ${owned ? '<div style="color: var(--border-color);">OWNED</div>' : 
                              `<button onclick="buyItem('weapon', '${key}', ${weapon.cost})">Buy ${weapon.cost}G</button>`}
                            ${p.cha ? '<div style="color:#8aaa8a;font-size:15px;">CHA disc: ' + calcChaDiscount(p.cha) + '%</div>' : ''}
                        </div>
                    `;
                }
            });

            shopHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">ARMOR</h3>
                    <div class="inventory-grid">
            `;

            Object.keys(ARMOR).forEach(key => {
                const armor = ARMOR[key];
                
                // Filter by level and class
                if (armor.level <= p.level + 2 && canUseArmor(playerClass, armor)) {
                    const owned = p.inventory.includes(key);
                    const equipped = p.armor === key;
                    const qualityColor = QUALITY_CONFIG[armor.quality].color;
                    const qualityBonus = getQualityBonus(armor.quality, armor.baseDefense);
                    const totalDef = armor.baseDefense + qualityBonus;
                    const totalMag = (armor.baseMagicBonus || 0) + getQualityBonus(armor.quality, armor.baseMagicBonus || 0);
                    
                    shopHtml += `
                        <div class="item-card ${equipped ? 'equipped' : ''}">
                            <div style="color: ${qualityColor};">${armor.name}</div>
                            <div>DEF: ${totalDef}</div>
                            ${totalMag > 0 ? `<div>MAG+: ${totalMag}</div>` : ''}
                            <div>Level: ${armor.level}</div>
                            ${owned ? '<div style="color: var(--border-color);">OWNED</div>' : 
                              `<button onclick="buyItem('armor', '${key}', ${armor.cost})">Buy ${armor.cost}G</button>`}
                            ${p.cha ? '<div style="color:#8aaa8a;font-size:15px;">CHA disc: ' + calcChaDiscount(p.cha) + '%</div>' : ''}
                        </div>
                    `;
                }
            });

            shopHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">POTIONS</h3>
                    <div class="inventory-grid">
            `;

            // Add potions to shop
            const potionsForSale = ['health_potion', 'greater_health_potion', 'superior_health_potion',
                                   'mana_potion', 'greater_mana_potion', 'superior_mana_potion', 'elixir',
                                   'recall_potion'];
            
            potionsForSale.forEach(key => {
                if (ITEMS[key]) {
                    const item = ITEMS[key];
                    const p = gameState.player;

                    if (key === 'recall_potion') {
                        // Special recall potion card â€” one per character, dungeon use only
                        const alreadyOwned = p.inventory.includes('recall_potion');
                        shopHtml += `
                            <div class="item-card" style="border-color:#AA88FF;">
                                <div style="color:#AA88FF;font-size:17px;">ğŸŒ€ ${item.name}</div>
                                <div style="color:#888;font-size:13px;font-style:italic;">${item.lore}</div>
                                <div style="color:#ffcc00;margin-top:4px;">${item.description}</div>
                                <div style="color:#ff8800;font-size:13px;">âš  Dungeon use only Â· 1 per adventure</div>
                                ${alreadyOwned
                                    ? '<div style="color:#AA88FF;font-size:14px;margin-top:4px;">ALREADY OWNED</div>'
                                    : `<button onclick="buyItem('item', 'recall_potion', 5000)"
                                        style="border-color:#AA88FF;color:#AA88FF;margin-top:6px;">Buy 5000G</button>`
                                }
                            </div>
                        `;
                    } else {
                        shopHtml += `
                            <div class="item-card">
                                <div style="color: var(--highlight-color);">${item.name}</div>
                                <div>${item.description}</div>
                                <div>Power: ${item.power || 'Full'}</div>
                                <button onclick="buyItem('item', '${key}', ${item.cost})">Buy ${item.cost}G</button>
                                ${p.cha ? '<div style="color:#8aaa8a;font-size:15px;">CHA disc: ' + calcChaDiscount(p.cha) + '%</div>' : ''}
                            </div>
                        `;
                    }
                }
            });

            shopHtml += `
                    </div>
                </div>
            `;
            
            document.getElementById('shopContent').innerHTML = shopHtml;
        }

        function showShopSell() {
            const p = gameState.player;
            
            // Group items by key and count them
            const itemCounts = {};
            
            p.inventory.forEach(itemKey => {
                // Items with sellValue
                if (ITEMS[itemKey] && ITEMS[itemKey].sellValue > 0) {
                    if (!itemCounts[itemKey]) itemCounts[itemKey] = { type: 'item', count: 0 };
                    itemCounts[itemKey].count++;
                }
                // Duplicate weapons/armor (not currently equipped)
                else if (WEAPONS[itemKey] && itemKey !== p.weapon) {
                    if (!itemCounts[itemKey]) itemCounts[itemKey] = { type: 'weapon', count: 0 };
                    itemCounts[itemKey].count++;
                }
                else if (ARMOR[itemKey] && itemKey !== p.armor) {
                    if (!itemCounts[itemKey]) itemCounts[itemKey] = { type: 'armor', count: 0 };
                    itemCounts[itemKey].count++;
                }
            });
            
            let sellHtml = '<h3 style="color: var(--highlight-color);">YOUR SELLABLE ITEMS</h3>';
            sellHtml += '<div class="inventory-grid">';
            
            const itemKeys = Object.keys(itemCounts);
            if (itemKeys.length === 0) {
                sellHtml += '<div class="message">You have nothing to sell.</div>';
            } else {
                itemKeys.forEach(itemKey => {
                    const data = itemCounts[itemKey];
                    let itemName, itemColor, sellValue, itemDesc;
                    
                    if (data.type === 'item') {
                        const item = ITEMS[itemKey];
                        itemName = item.name;
                        itemColor = '#00FF00';
                        sellValue = item.sellValue;
                        itemDesc = item.description;
                    } else if (data.type === 'weapon') {
                        const weapon = WEAPONS[itemKey];
                        itemName = weapon.name;
                        itemColor = QUALITY_CONFIG[weapon.quality].color;
                        sellValue = Math.floor(weapon.cost * 0.5);
                        const qualityBonus = getQualityBonus(weapon.quality, weapon.baseDamage);
                        itemDesc = `DMG: ${weapon.baseDamage + qualityBonus} | MAG: ${weapon.baseMagicDamage + qualityBonus}`;
                    } else if (data.type === 'armor') {
                        const armor = ARMOR[itemKey];
                        itemName = armor.name;
                        itemColor = QUALITY_CONFIG[armor.quality].color;
                        sellValue = Math.floor(armor.cost * 0.5);
                        const qualityBonus = getQualityBonus(armor.quality, armor.baseDefense);
                        itemDesc = `DEF: ${armor.baseDefense + qualityBonus}`;
                    }
                    
                    sellHtml += `
                        <div class="item-card">
                            <div style="color: ${itemColor};">${itemName} ${data.count > 1 ? `<span style="color:#FFD700;">x${data.count}</span>` : ''}</div>
                            <div style="font-size: 16px;">${itemDesc}</div>
                            <div style="color: var(--border-color); margin-top: 10px;">
                                ${sellValue}g each
                                ${data.count > 1 ? `<br><span style="color:#FFD700;">Total: ${sellValue * data.count}g</span>` : ''}
                            </div>
                            ${data.count > 1 ? `
                                <button onclick="showSellQuantityPrompt('${itemKey}', ${sellValue}, ${data.count})">SELL (${data.count})</button>
                            ` : `
                                <button onclick="sellItem('${itemKey}', ${sellValue}, 1)">SELL</button>
                            `}
                        </div>
                    `;
                });
            }
            
            sellHtml += '</div>';
            document.getElementById('shopContent').innerHTML = sellHtml;
        }
        
        function showSellQuantityPrompt(itemKey, unitPrice, totalCount) {
            const itemName = getItemName(itemKey);
            const bonus = calcChaSellBonus(gameState.player.cha);
            const actualPrice = Math.floor(unitPrice * (1 + bonus/100));
            
            const quantity = prompt(
                `How many ${itemName} do you want to sell?\n\n` +
                `You have: ${totalCount}\n` +
                `Price: ${actualPrice}g each${bonus > 0 ? ` (+${bonus}% CHA bonus)` : ''}\n\n` +
                `Enter quantity (1-${totalCount}) or "all":`,
                totalCount
            );
            
            if (!quantity || quantity === '' || quantity === null) return;
            
            let amount;
            if (quantity.toLowerCase() === 'all') {
                amount = totalCount;
            } else {
                amount = parseInt(quantity);
                if (isNaN(amount) || amount < 1 || amount > totalCount) {
                    alert('Invalid quantity!');
                    return;
                }
            }
            
            sellItem(itemKey, unitPrice, amount);
        }

        function sellItem(itemKey, baseValue, quantity = 1) {
            const p = gameState.player;
            
            // Remove items from inventory
            let removed = 0;
            for (let i = p.inventory.length - 1; i >= 0 && removed < quantity; i--) {
                if (p.inventory[i] === itemKey) {
                    p.inventory.splice(i, 1);
                    removed++;
                }
            }
            
            if (removed === 0) {
                alert('Item not found!');
                return;
            }
            
            const bonus = calcChaSellBonus(p.cha);
            const unitValue = Math.floor(baseValue * (1 + bonus/100));
            const totalValue = unitValue * removed;
            
            p.gold += totalValue;
            
            const itemName = getItemName(itemKey);
            const quantityText = removed > 1 ? ` x${removed}` : '';
            const bonusText = bonus > 0 ? ` (+${bonus}% CHA bonus)` : '';
            
            alert(`Sold ${itemName}${quantityText} for ${totalValue}g!${bonusText}`);
            
            // ğŸ’¾ AUTO-SAVE after selling
            saveGame();
            
            showShopSell();
        }

        function buyItem(type, key, baseCost) {
            const p = gameState.player;
            const playerClass = p.baseClass || p.class;
            
            // Recall potion: only one allowed at a time
            if (key === 'recall_potion' && p.inventory.includes('recall_potion')) {
                alert('You already carry a Recall Potion.\nYou can only hold one at a time.');
                return;
            }

            // Validate class restrictions
            if (type === 'weapon') {
                const weapon = WEAPONS[key];
                if (!canUseWeapon(playerClass, weapon)) {
                    alert(`Your class (${playerClass}) cannot use ${weapon.name}!`);
                    return;
                }
                if (weapon.level > p.level) {
                    alert(`You must be level ${weapon.level} to buy ${weapon.name}!`);
                    return;
                }
            } else if (type === 'armor') {
                const armor = ARMOR[key];
                if (!canUseArmor(playerClass, armor)) {
                    alert(`Your class (${playerClass}) cannot use ${armor.name}!`);
                    return;
                }
                if (armor.level > p.level) {
                    alert(`You must be level ${armor.level} to buy ${armor.name}!`);
                    return;
                }
            }
            
            const disc   = calcChaDiscount(p.cha);
            const cost   = Math.max(1, Math.floor(baseCost * (1 - disc/100)));
            if (p.gold < cost) {
                alert('Not enough gold!');
                return;
            }
            p.gold -= cost;
            p.inventory.push(key);
            let itemName;
            if (type === 'weapon') itemName = WEAPONS[key].name;
            else if (type === 'armor') itemName = ARMOR[key].name;
            else if (type === 'item') itemName = ITEMS[key].name;
            alert(`Purchased ${itemName} for ${cost}g!` + (disc > 0 ? ` (${disc}% CHA discount)` : ''));
            
            // ğŸ’¾ AUTO-SAVE after buying
            saveGame();
            
            showShopBuy();
        }

        function restAtInn() {
            const cost = calcInnCost(gameState.player.cha);
            if (gameState.player.gold < cost) {
                alert('Not enough gold!');
                return;
            }
            gameState.player.gold -= cost;
            gameState.player.hp = gameState.player.maxHp;
            gameState.player.mp = gameState.player.maxMp;
            alert('You rest at the inn and recover fully!');
            showTown();
        }

        function showInventory() {
            const p = gameState.player;
            const playerClass = p.baseClass || p.class;
            const screen = document.getElementById('mainScreen');
            
            let invHtml = `
                <div class="location-header">INVENTORY</div>
                ${renderPlayerStats()}
                <div style="margin: 20px 0;">
                    <h3 style="color: var(--highlight-color);">WEAPONS</h3>
                    <div class="inventory-grid">
            `;

            p.inventory.filter(item => {
                const weapon = WEAPONS[item];
                return weapon && canUseWeapon(playerClass, weapon);
            }).forEach(key => {
                const weapon = WEAPONS[key];
                const equipped = p.weapon === key;
                const qualityColor = QUALITY_CONFIG[weapon.quality].color;
                const qualityBonus = getQualityBonus(weapon.quality, weapon.baseDamage);
                const totalDmg = weapon.baseDamage + qualityBonus;
                const totalMag = weapon.baseMagicDamage + Math.floor(weapon.baseMagicDamage * (QUALITY_CONFIG[weapon.quality]?.bonusPct || 0));
                
                // Build modifier display
                let modifierHtml = '';
                if (weapon.modifiers && weapon.modifiers.length > 0) {
                    modifierHtml = '<div style="margin-top:5px;font-size:12px;">';
                    weapon.modifiers.forEach(modKey => {
                        const mod = WEAPON_MODIFIERS[modKey];
                        if (mod) {
                            modifierHtml += `<div style="color:${mod.color};">â€¢ ${mod.name}`;
                            if (mod.minDamage) {
                                modifierHtml += ` (${mod.minDamage}-${mod.maxDamage})`;
                            }
                            modifierHtml += `</div>`;
                        }
                    });
                    modifierHtml += '</div>';
                }
                
                invHtml += `
                    <div class="item-card ${equipped ? 'equipped' : ''}">
                        <div style="color: ${qualityColor};">${weapon.name}</div>
                        <div>DMG: ${weapon.maxDamage ? `${totalDmg}-${weapon.maxDamage}` : totalDmg}${totalMag > 0 ? ` | MAG: ${totalMag}` : ''}</div>
                        ${modifierHtml}
                        ${equipped ? '<div style="color: var(--border-color);">EQUIPPED</div>' : 
                          `<button onclick="equipItem('weapon', '${key}')">EQUIP</button>`}
                    </div>
                `;
            });

            invHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">ARMOR</h3>
                    <div class="inventory-grid">
            `;

            p.inventory.filter(item => {
                const armor = ARMOR[item];
                return armor && canUseArmor(playerClass, armor);
            }).forEach(key => {
                const armor = ARMOR[key];
                const equipped = p.armor === key;
                const qualityColor = QUALITY_CONFIG[armor.quality].color;
                const qualityBonus = getQualityBonus(armor.quality, armor.baseDefense);
                const totalDef = armor.baseDefense + qualityBonus;
                const totalMag = (armor.baseMagicBonus || 0) + Math.floor((armor.baseMagicBonus || 0) * (QUALITY_CONFIG[armor.quality]?.bonusPct || 0));
                
                invHtml += `
                    <div class="item-card ${equipped ? 'equipped' : ''}">
                        <div style="color: ${qualityColor};">${armor.name}</div>
                        <div>DEF: ${totalDef}</div>
                        ${totalMag > 0 ? `<div>MAG+: ${totalMag}</div>` : ''}
                        ${equipped ? '<div style="color: var(--border-color);">EQUIPPED</div>' : 
                          `<button onclick="equipItem('armor', '${key}')">EQUIP</button>`}
                    </div>
                `;
            });

            invHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">SPELLS</h3>
                    <div class="inventory-grid">
            `;

            if (p.knownSpells.length === 0) {
                invHtml += '<div class="message">No spells learned yet.</div>';
            } else {
                p.knownSpells.forEach(spellKey => {
                    const spell = ensureSpellExists(spellKey) || SPELLS[spellKey];
                    if (!spell) {
                        console.warn(`âš ï¸ Spell '${spellKey}' not found in SPELLS object (inventory display)`);
                        return; // Skip this spell
                    }
                    invHtml += `
                        <div class="item-card">
                            <div style="color: var(--highlight-color);">${spell.name}</div>
                            <div>MP Cost: ${spell.mpCost}</div>
                            <div>Power: ${spell.power}</div>
                            <div>${spell.description}</div>
                        </div>
                    `;
                });
            }

            invHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">CONSUMABLES & ITEMS</h3>
                    <div class="inventory-grid">
            `;

            // Count and display items
            const itemCounts = {};
            p.inventory.filter(item => ITEMS[item]).forEach(key => {
                itemCounts[key] = (itemCounts[key] || 0) + 1;
            });

            if (Object.keys(itemCounts).length === 0) {
                invHtml += '<div class="message">No items.</div>';
            } else {
                Object.keys(itemCounts).forEach(itemKey => {
                    const item = ITEMS[itemKey];
                    const count = itemCounts[itemKey];
                    const color = item.type === 'sellable' ? '#FFD700' : 
                                 item.subtype === 'heal_hp' ? '#FF0000' :
                                 item.subtype === 'heal_mp' ? '#0000FF' : '#00FF00';
                    
                    // Check if it's a usable potion
                    const isPotion = item.subtype === 'heal_hp' || 
                                    item.subtype === 'heal_mp' || 
                                    item.subtype === 'full_restore' ||
                                    item.subtype?.startsWith('buff_');
                    
                    // Check if at full HP/MP for healing potions
                    let canUse = true;
                    let disabledReason = '';
                    if (item.subtype === 'heal_hp' && p.hp >= p.maxHp) {
                        canUse = false;
                        disabledReason = '(Already at full HP)';
                    } else if (item.subtype === 'heal_mp' && p.mp >= p.maxMp) {
                        canUse = false;
                        disabledReason = '(Already at full MP)';
                    } else if (item.subtype === 'full_restore' && p.hp >= p.maxHp && p.mp >= p.maxMp) {
                        canUse = false;
                        disabledReason = '(Already fully restored)';
                    }
                    
                    // Show total value if sellable and multiple
                    let valueDisplay = '';
                    if (item.sellValue) {
                        if (count > 1) {
                            valueDisplay = `<div style="color: var(--border-color);">${item.sellValue}g each | <span style="color:#FFD700;">Total: ${item.sellValue * count}g</span></div>`;
                        } else {
                            valueDisplay = `<div style="color: var(--border-color);">Value: ${item.sellValue}g</div>`;
                        }
                    }
                    
                    // Add USE button for potions
                    let buttonHtml = '';
                    if (isPotion) {
                        buttonHtml = canUse ? 
                            `<button onclick="useInventoryPotion('${itemKey}')">USE</button>` :
                            `<div style="color:#666;font-size:12px;">${disabledReason}</div>`;
                    }
                    
                    invHtml += `
                        <div class="item-card">
                            <div style="color: ${color};">${item.name} ${count > 1 ? `<span style="color:#FFD700;">x${count}</span>` : ''}</div>
                            <div style="font-size: 16px;">${item.description}</div>
                            ${valueDisplay}
                            ${buttonHtml}
                        </div>
                    `;
                });
            }

            invHtml += `
                    </div>
                </div>
                <button onclick="showTown()">BACK</button>
            `;

            screen.innerHTML = invHtml;
        }

        function equipItem(type, key) {
            const p = gameState.player;
            const playerClass = p.baseClass || p.class;
            
            if (type === 'weapon') {
                const weapon = WEAPONS[key];
                if (!weapon) {
                    alert('Invalid weapon!');
                    return;
                }
                if (!canUseWeapon(playerClass, weapon)) {
                    alert(`Your class (${playerClass}) cannot use ${weapon.name}!`);
                    return;
                }
                if (weapon.level > p.level) {
                    alert(`You must be level ${weapon.level} to equip ${weapon.name}!`);
                    return;
                }
                p.weapon = key;
            } else {
                const armor = ARMOR[key];
                if (!armor) {
                    alert('Invalid armor!');
                    return;
                }
                if (!canUseArmor(playerClass, armor)) {
                    alert(`Your class (${playerClass}) cannot use ${armor.name}!`);
                    return;
                }
                if (armor.level > p.level) {
                    alert(`You must be level ${armor.level} to equip ${armor.name}!`);
                    return;
                }
                p.armor = key;
            }
            
            // ğŸ’¾ AUTO-SAVE after equipping
            saveGame();
            
            showInventory();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // USE POTION FROM INVENTORY
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function useInventoryPotion(potionKey) {
            const potion = ITEMS[potionKey];
            const p = gameState.player;
            
            if (!potion) {
                alert('Invalid potion!');
                return;
            }

            // â”€â”€ Recall Potion â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (potion.subtype === 'recall') {
                alert('Recall Potions can only be used while inside a dungeon.');
                return;
            }
            
            let msg = '';
            let used = false;
            
            // Handle different potion types
            if (potion.subtype === 'heal_hp') {
                if (p.hp >= p.maxHp) {
                    alert("You're already at full HP!");
                    return;
                }
                const actual = Math.min(p.maxHp - p.hp, potion.power);
                p.hp = Math.min(p.maxHp, p.hp + potion.power);
                msg = `Used ${potion.name} â€“ restored ${actual} HP!`;
                used = true;
            } 
            else if (potion.subtype === 'heal_mp') {
                if (p.mp >= p.maxMp) {
                    alert("You're already at full MP!");
                    return;
                }
                const actual = Math.min(p.maxMp - p.mp, potion.power);
                p.mp = Math.min(p.maxMp, p.mp + potion.power);
                msg = `Used ${potion.name} â€“ restored ${actual} MP!`;
                used = true;
            } 
            else if (potion.subtype === 'full_restore') {
                if (p.hp >= p.maxHp && p.mp >= p.maxMp) {
                    alert("You're already fully restored!");
                    return;
                }
                const hpR = p.maxHp - p.hp;
                const mpR = p.maxMp - p.mp;
                p.hp = p.maxHp;
                p.mp = p.maxMp;
                msg = `Used ${potion.name} â€“ fully restored ${hpR} HP & ${mpR} MP!`;
                used = true;
            }
            else if (potion.subtype?.startsWith('buff_')) {
                // Apply buff
                const buffType = potion.subtype;
                const duration = potion.duration || 300000; // 5 minutes default
                
                if (!p.activeBuffs) p.activeBuffs = {};
                
                // Check if buff is already active
                if (p.activeBuffs[buffType] && Date.now() < p.activeBuffs[buffType].endTime) {
                    // Check if we can stack
                    const currentStacks = p.activeBuffs[buffType].stacks || 1;
                    if (currentStacks >= 3) {
                        alert(`${potion.name} is already at maximum stacks (3x)!`);
                        return;
                    }
                    // Stack the buff
                    p.activeBuffs[buffType].stacks = currentStacks + 1;
                    p.activeBuffs[buffType].power = potion.power * (currentStacks + 1);
                    p.activeBuffs[buffType].endTime = Date.now() + duration;
                    msg = `Used ${potion.name} â€“ buff stacked! (${currentStacks + 1}x)`;
                } else {
                    // New buff
                    p.activeBuffs[buffType] = {
                        power: potion.power,
                        endTime: Date.now() + duration,
                        stacks: 1
                    };
                    msg = `Used ${potion.name} â€“ buff activated!`;
                }
                used = true;
            }
            
            if (used) {
                // Remove potion from inventory
                const idx = p.inventory.indexOf(potionKey);
                if (idx !== -1) {
                    p.inventory.splice(idx, 1);
                }
                
                // Update HUD
                updateHud();
                
                // Save game
                saveGame();
                
                // Show message and refresh inventory
                alert(msg);
                showInventory();
            }
        }

        function showExplore() {
            const screen = document.getElementById('mainScreen');
            const p = gameState.player;
            const tid = gameState.currentTown || 'town1';
            const townDef = (typeof TOWNS !== 'undefined' && TOWNS[tid]) ? TOWNS[tid] : null;

            // Determine which zone keys belong to this town
            // A zone belongs here if: it has no 'town' field (legacy), OR its town matches current
            const townZoneKeys = townDef ? (townDef.zones || []) : null;

            // Auto-unlock zones that are not locked (level-only requirement)
            Object.keys(LOCATIONS).forEach(key => {
                const loc = LOCATIONS[key];
                if (key === 'town') return;
                // Only auto-unlock zones that belong to this town
                if (townZoneKeys && !townZoneKeys.includes(key)) return;
                if (!loc.locked && loc.requiredLevel && p.level >= loc.requiredLevel) {
                    if (!p.unlockedAreas.includes(key)) {
                        p.unlockedAreas.push(key);
                    }
                }
                // Safety: strip locks that shouldn't be held
                if (loc.locked && loc.requiredLevel && p.level < loc.requiredLevel) {
                    const idx = p.unlockedAreas.indexOf(key);
                    if (idx !== -1) p.unlockedAreas.splice(idx, 1);
                }
            });

            const townName = townDef ? townDef.name : 'World';
            let exploreHtml = `
                <div class="location-header">${townName} â€” EXPLORE</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>Where would you like to explore?</p>
                </div>
                <div style="margin: 20px 0;">
            `;

            // Only show zones that belong to this town (or all zones if no town system)
            Object.keys(LOCATIONS).forEach(key => {
                const loc = LOCATIONS[key];
                if (key === 'town') return;
                // Filter by town
                if (townZoneKeys && !townZoneKeys.includes(key)) return;

                const levelInfo = loc.enemyLevelRange ?
                    ` (Lv ${loc.enemyLevelRange[0]}-${loc.enemyLevelRange[1]})` : '';

                const isUnlocked = p.unlockedAreas.includes(key);
                const meetsLevelReq = p.level >= (loc.requiredLevel || 1);

                // Hide zones that don't meet level requirement and aren't unlocked
                if (!isUnlocked && !meetsLevelReq) return;

                if (isUnlocked) {
                    exploreHtml += `
                        <div class="menu-option" onclick="exploreLocation('${key}')">
                            â–º ${loc.name}${levelInfo} <span style="color: var(--border-color);">âœ“</span>
                        </div>
                    `;
                    // Show master challenge if available
                    const masterKey = `${p.class}_master_${key}`;
                    if (typeof CLASS_MASTERS !== 'undefined' && CLASS_MASTERS[masterKey] && !p.defeatedMasters.includes(masterKey)) {
                        const master = CLASS_MASTERS[masterKey];
                        if (p.level >= master.requiredLevel) {
                            exploreHtml += `
                                <div class="menu-option" onclick="challengeMaster('${masterKey}')"
                                     style="border-color:var(--highlight-color);background:rgba(255,255,0,0.1);">
                                    âš”ï¸ CHALLENGE MASTER: ${master.name} (Lv ${master.level})
                                </div>
                            `;
                        }
                    }
                } else {
                    // Locked but level met â€” show with unlock requirement
                    const masterKey = typeof getMasterKeyForArea !== 'undefined' ? getMasterKeyForArea(key) : null;
                    const master = masterKey && typeof CLASS_MASTERS !== 'undefined' ? CLASS_MASTERS[masterKey] : null;
                    if (master) {
                        exploreHtml += `
                            <div class="menu-option" style="opacity:0.6;cursor:default;"
                                 onclick="alert('${loc.unlockMessage || 'Locked'}')">
                                ğŸ”’ ${loc.name}${levelInfo} - LOCKED
                            </div>
                            <div class="menu-option" onclick="challengeMaster('${masterKey}')"
                                 style="border-color:var(--error-color);background:rgba(255,0,0,0.1);">
                                âš”ï¸ CHALLENGE MASTER: ${master.name} (Lv ${master.level}) TO UNLOCK
                            </div>
                        `;
                    } else {
                        exploreHtml += `
                            <div class="menu-option" style="opacity:0.6;cursor:default;"
                                 onclick="alert('${loc.unlockMessage || 'Complete previous areas to unlock!'}')">
                                ğŸ”’ ${loc.name}${levelInfo} - LOCKED
                            </div>
                        `;
                    }
                }
            });

            exploreHtml += `
                </div>
                <button onclick="showTown()">RETURN TO TOWN</button>
            `;

            screen.innerHTML = exploreHtml;
        }

        function getMasterKeyForArea(areaKey) {
            // Find which area unlocks this one
            const areaOrder = ['forest', 'plains', 'cave', 'crypt', 'volcano'];
            const index = areaOrder.indexOf(areaKey);
            if (index > 0) {
                const previousArea = areaOrder[index - 1];
                return `${gameState.player.class}_master_${previousArea}`;
            }
            return null;
        }

        function challengeMaster(masterKey) {
            const master = CLASS_MASTERS[masterKey];
            if (!master) {
                alert('Master not found!');
                return;
            }
            
            const p = gameState.player;
            
            // Check if already defeated
            if (p.defeatedMasters.includes(masterKey)) {
                alert('You have already defeated this master!');
                return;
            }
            
            // Check level requirement
            if (p.level < master.requiredLevel) {
                alert(`You need to be level ${master.requiredLevel} to challenge this master!`);
                return;
            }
            
            // Show master challenge screen
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">âš”ï¸ MASTER CHALLENGE âš”ï¸</div>
                ${renderPlayerStats()}
                <div class="message" style="border-color: var(--error-color); background: rgba(255, 0, 0, 0.1);">
                    <p style="color: var(--highlight-color); font-size: 24px;">${master.name}</p>
                    <p style="color: var(--text-color); margin: 10px 0;">${master.description}</p>
                    <p style="color: var(--border-color);">Level: ${master.level} | HP: ${master.baseHp} | Defense: ${master.baseDefense}</p>
                    <p style="color: var(--error-color); margin-top: 15px;">âš ï¸ THIS IS A BOSS FIGHT! âš ï¸</p>
                    <p>Defeating this master will unlock: <span style="color: var(--highlight-color);">${LOCATIONS[master.unlocks].name}</span></p>
                </div>
                <div class="message" style="border-color: var(--highlight-color);">
                    <p style="color: var(--highlight-color);">GUARANTEED REWARDS:</p>
                    ${master.guaranteedDrops.map(item => `<p>â€¢ ${getItemName(item)}</p>`).join('')}
                    <p style="margin-top: 10px;">+ ${master.xp} XP and ${master.gold} Gold</p>
                </div>
                <div style="margin: 20px 0;">
                    <button onclick="startMasterBattle('${masterKey}')" style="background: var(--error-color); font-size: 22px;">âš”ï¸ BEGIN BATTLE âš”ï¸</button>
                    <button onclick="showExplore()">RETREAT</button>
                </div>
            `;
        }

        function startMasterBattle(masterKey) {
            const master = CLASS_MASTERS[masterKey];
            const masterMonster = {
                key: masterKey, name: master.name, rarity: 'epic',
                rarityColor: RARITY_CONFIG.epic.color,
                hp: master.baseHp, maxHp: master.baseHp,
                damage: master.baseDamage, defense: master.baseDefense,
                xp: master.xp, gold: master.gold, level: master.level,
                possibleDrops: master.possibleDrops, dropRates: master.dropRates,
                isMaster: true, masterKey: masterKey,
                guaranteedDrops: master.guaranteedDrops
            };
            const maxHits   = calcPlayerHits(gameState.player);
            const pipTimers = [];
            for (let i = 0; i < maxHits; i++) {
                pipTimers.push(10);
            }
            gameState.combatState = {
                monsters: [masterMonster], currentTarget: 0,
                messages: [], defeatedMonsters: [],
                pipTimers:     pipTimers,
                pipAvailable:  pipTimers.map(() => true),
                enemyTimer:    18,
                enemyDelay:    18,
                enemyHits:     3,
                enemyHitsLeft: 3
            };
            // Open the terminal view (clear it fresh for a boss)
            openTerminalView(gameState.currentLocation);
            // stream the boss-intro line; show cards + start timer only after it finishes
            termAppend(`<span style="color:${RARITY_CONFIG.epic.color}; font-size:22px;">âš”ï¸ ${master.name} challenges you to an honorable duel! âš”ï¸</span>`, 'term-highlight', () => {
                renderEnemyCards();
                renderActionBar();
                startCombatTimer();
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // HUD â€“ write once, update in place
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function initHud() {
            updateHud();
        }
        function updateHud() {
    const p = gameState.player;

    // â”€â”€ helper: set element text safely â”€â”€
    const set = (id, txt) => { const el = document.getElementById(id); if (el) el.textContent = txt; };

    if (!p) {
        set('hudName',    'â€” No Adventurer â€”');
        set('hudHpNums',  'â¤ï¸ HP: â€”');
        set('hudMpNums',  'âœ¨ MP: â€”');
        set('hudXpNums',  'â­ XP: â€”');
        set('hudGold',    'ğŸ’° 0 g');
        // mobile hud
        set('mhName', 'â€” No Adventurer â€”');
        set('mhHp',   'â¤ï¸ â€”');
        set('mhMp',   'âœ¨ â€”');
        set('mhXp',   'â­ â€”');
        set('mhGold', 'ğŸ’° 0');
        return;
    }

    // â”€â”€ Desktop HUD (gold last) â”€â”€
    set('hudName',    `${p.name} â€“ Lv ${p.level} ${p.className}`);
    set('hudHpNums',  `â¤ï¸ ${p.hp}/${p.maxHp}`);
    set('hudMpNums',  `âœ¨ ${p.mp}/${p.maxMp}`);
    set('hudXpNums',  `â­ ${p.xp}/${p.xpToNext}`);
    set('hudGold',    `ğŸ’° ${p.gold}g`);

    // â”€â”€ Mobile HUD strip (gold last) â”€â”€
    set('mhName', `${p.name} Lv${p.level}`);
    set('mhHp',   `â¤ï¸${p.hp}/${p.maxHp}`);
    set('mhMp',   `âœ¨${p.mp}/${p.maxMp}`);
    set('mhXp',   `â­${p.xp}/${p.xpToNext}`);
    set('mhGold', `ğŸ’°${p.gold}g`);
}


        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TERMINAL VIEW helpers
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
function openTerminalView(locKey) {
    // CSS body.terminal-mode handles all show/hide â€” just add the class
    document.body.classList.add('terminal-mode');

    const term = document.getElementById('terminalWindow');

    updateHud();
    initHud();

    if (!gameState._terminalOpen) {
        term.innerHTML = '';
        term.scrollTop = 0;

        gameState._terminalOpen = true;
        gameState._currentExploreArea = locKey;

        if (LOCATIONS?.[locKey]) {
            termAppend(`â”€â”€ ${LOCATIONS[locKey].name} â”€â”€`, 'term-separator');
        }
    }

    updateTerminalSafeArea();
}


function stabilizeTerminalLayout() {
    const tw = document.getElementById('terminalWindow');
    if (!tw) return;

    // Force flexbox to resolve height again
    tw.style.display = 'block';
    tw.offsetHeight;   // read triggers reflow

    // Reassert scrolling
    tw.style.overflowY = 'auto';

    // Scroll to bottom â€” triple rAF on mobile to survive layout shifts
    requestAnimationFrame(() => requestAnimationFrame(() => requestAnimationFrame(() => {
        tw.scrollTop = tw.scrollHeight + 9999;
    })));
}



        function closeTerminalView() {
            // Remove terminal-mode class â€” CSS handles all element visibility
            document.body.classList.remove('terminal-mode');
            gameState._terminalOpen = false;
            gameState._currentExploreArea = null;
        }
        // â”€â”€ modem-style line queue â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const termQueue   = [];          // pending { html, extraClass, onDone }
        let   termBusy    = false;       // true while a line is mid-stream



        function termAppend(html, extraClass, onDone) {
            termQueue.push({ html, extraClass, onDone: onDone || null });
            if (!termBusy) termDrain();
        }

        function scrollTerminalToBottom() {
    const tw = document.getElementById('terminalWindow');
    if (!tw) return;
    // Double rAF: first frame paints, second measures correct scrollHeight
    requestAnimationFrame(() => requestAnimationFrame(() => {
        tw.scrollTop = tw.scrollHeight + 9999;
    }));
}


 function termDrain() {
    if (termQueue.length === 0) {
        termBusy = false;
        return;
    }

    termBusy = true;
    const { html, extraClass, onDone } = termQueue.shift();
    const tw = document.getElementById('terminalWindow');

    // Decide whether to auto-scroll BEFORE appending so we know
    // if the user has manually scrolled up.
    // During combat: ALWAYS follow (never let new text appear off-screen).
    // Outside combat: follow only if already near the bottom (user hasn't scrolled up).
    const distFromBottom = tw.scrollHeight - tw.scrollTop - tw.clientHeight;
    const shouldAutoScroll = !!gameState.combatState || distFromBottom < 80;

    const line = document.createElement('div');
    line.className = 'term-line' + (extraClass ? ' ' + extraClass : '');
    tw.appendChild(line);

    // Inline scroll helper â€” fires after paint so scrollHeight is correct
    const doScroll = () => {
        if (shouldAutoScroll) {
            requestAnimationFrame(() => { tw.scrollTop = tw.scrollHeight + 9999; });
        }
    };

    // separator or empty lines â€” no streaming
    if (extraClass === 'term-separator' || html === '') {
        line.innerHTML = html;
        doScroll();
        if (onDone) onDone();
        termDrain();
        return;
    }

    // instant mode
    if (currentModemSpeed === 'instant') {
        line.innerHTML = html;
        doScroll();
        if (onDone) onDone();
        termDrain();
        return;
    }

    // streaming mode â€” scroll on EVERY tick so the line scrolls into view
    // as characters arrive, not just when it completes
    const charsPerTick = MODEM_SPEEDS[currentModemSpeed];
    let visibleCount = 0;
    let totalVisible = 0;

    {
        let inTag = false;
        for (let i = 0; i < html.length; i++) {
            if (html[i] === '<') inTag = true;
            else if (html[i] === '>') inTag = false;
            else if (!inTag) totalVisible++;
        }
    }

    const ticker = setInterval(() => {
        visibleCount += charsPerTick;

        if (visibleCount >= totalVisible) {
            clearInterval(ticker);
            line.innerHTML = html;
            doScroll();
            if (onDone) onDone();
            termDrain();
        } else {
            line.innerHTML =
                sliceToVisible(html, visibleCount) +
                '<span style="animation:blink 1s infinite;">_</span>';
            // Scroll during streaming so text stays visible as it types
            if (shouldAutoScroll) tw.scrollTop = tw.scrollHeight + 9999;
        }
    }, 16);
}



            function sliceToVisible(html, n) {
    let vis = 0;
    let inTag = false;

    for (let i = 0; i < html.length; i++) {
        if (html[i] === '<') inTag = true;
        else if (html[i] === '>') inTag = false;
        else if (!inTag) {
            vis++;
            if (vis >= n) return html.slice(0, i + 1);
        }
    }
    return html;
}


     

       function termClear() {
    const tw = document.getElementById('terminalWindow');
    tw.innerHTML = '';
    tw.scrollTop = 0;  // ğŸ”¥ RESET SCROLL TO TOP
}


        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EXPLORE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function exploreLocation(locKey) {
            document.body.classList.add("terminal-mode");

            const location = LOCATIONS[locKey];
            const p = gameState.player;
            
            // Hard level gate - even if somehow unlocked, enforce min level
            if (location.requiredLevel && p.level < location.requiredLevel) {
                document.body.classList.remove("terminal-mode");
                alert(`You must be level ${location.requiredLevel} to explore ${location.name}!`);
                showExplore();
                return;
            }
            
            if (!p.unlockedAreas.includes(locKey)) {
                document.body.classList.remove("terminal-mode");
                alert(location.unlockMessage || 'This area is locked!');
                showExplore();
                return;
            }

            gameState.currentLocation = locKey;
            
            // Start regeneration when exploring (normal speed)
            startMpRegen(false);
            startResting(false);

            // If we just arrived (from town / map), open the terminal fresh
            if (!gameState._terminalOpen || gameState._currentExploreArea !== locKey) {
                gameState._terminalOpen = false;   // force fresh open
                openTerminalView(locKey);
            } else {
                // Already in this area â€“ just add a separator
                termAppend('', 'term-separator');
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ROLL FOR RANDOM ADVENTURE (if adventure system is loaded)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof rollForAdventure !== 'undefined') {
                const adventureRoll = Math.random();
                const adventureThreshold = location.adventureChance || 0.05;
                
                if (adventureRoll < adventureThreshold) {
                    const adventure = rollForAdventure(p.level);
                    if (adventure) {
                        startAdventure(adventure);
                        return; // Adventure takes over, no normal combat
                    }
                }
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // NORMAL COMBAT ENCOUNTER
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (Math.random() < 0.7) {
                const numMonsters = rollMonsterCount();
                const enemyKeys = [];
                for (let i = 0; i < numMonsters; i++) {
                    enemyKeys.push(location.encounters[Math.floor(Math.random() * location.encounters.length)]);
                }
                startCombat(enemyKeys);
            } else {
                termAppend(`You explore the areaâ€¦ but find nothing.`, 'term-dim');
                renderActionBar();   // show "Continue / Town" buttons
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COMBAT â€“ start / spawn / rarity
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function rollMonsterCount() {
            const r = Math.random() * 100;
            if (r < 70) return 1;
            if (r < 95) return 2;
            return 3;
        }
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STATUS EFFECTS SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function cleanupCombatStatusEffects() {
            const cs = gameState.combatState;
            if (!cs) return;
            
            // Clear all DOT timers
            for (const timerKey in cs.dotTimers) {
                clearInterval(cs.dotTimers[timerKey]);
            }
            cs.dotTimers = {};
            cs.playerStatusEffects = [];
            cs.monsterStatusEffects = {};
        }
        
        function applyStatusEffect(target, statusKey, isPlayer = false) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            const statusDef = STATUS_EFFECTS[statusKey];
            if (!statusDef) return;
            
            // Get target's status effects array
            let effects;
            if (isPlayer) {
                effects = cs.playerStatusEffects;
            } else {
                if (!cs.monsterStatusEffects[target.index]) {
                    cs.monsterStatusEffects[target.index] = [];
                }
                effects = cs.monsterStatusEffects[target.index];
            }
            
            // Check if already has this status
            if (effects.find(e => e.type === statusKey)) {
                return; // Don't stack same status
            }
            
            // Add status effect
            const effect = {
                type: statusKey,
                startTime: Date.now(),
                duration: statusDef.duration
            };
            effects.push(effect);
            
            // Show message
            const targetName = isPlayer ? 'You' : target.name;
            termAppend(statusDef.message(targetName), 'term-warning');
            
            // Start DOT ticks if applicable
            if (statusDef.type === 'dot') {
                startDOTTicks(target, statusKey, isPlayer);
            }
            
            // Auto-remove after duration
            setTimeout(() => {
                removeStatusEffect(target, statusKey, isPlayer);
            }, statusDef.duration);
        }
        
        function removeStatusEffect(target, statusKey, isPlayer = false) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            let effects;
            if (isPlayer) {
                effects = cs.playerStatusEffects;
            } else {
                effects = cs.monsterStatusEffects[target.index] || [];
            }
            
            const index = effects.findIndex(e => e.type === statusKey);
            if (index > -1) {
                effects.splice(index, 1);
                
                // Stop DOT timer if exists
                const timerKey = isPlayer ? `player_${statusKey}` : `monster_${target.index}_${statusKey}`;
                if (cs.dotTimers[timerKey]) {
                    clearInterval(cs.dotTimers[timerKey]);
                    delete cs.dotTimers[timerKey];
                }
            }
        }
        
        function startDOTTicks(target, statusKey, isPlayer = false) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            const statusDef = STATUS_EFFECTS[statusKey];
            if (!statusDef || statusDef.type !== 'dot') return;
            
            const timerKey = isPlayer ? `player_${statusKey}` : `monster_${target.index}_${statusKey}`;
            
            // Don't start if already ticking
            if (cs.dotTimers[timerKey]) return;
            
            cs.dotTimers[timerKey] = setInterval(() => {
                if (!cs || !gameState.combatState) {
                    clearInterval(cs.dotTimers[timerKey]);
                    return;
                }
                
                const damage = statusDef.damagePerTick;
                target.hp -= damage;
                
                const targetName = isPlayer ? 'You' : target.name;
                termAppend(statusDef.message(targetName, damage), 'term-warning');
                
                updateHud();
                updateEnemyCards();
                
                // Check if target died from DOT
                if (target.hp <= 0) {
                    if (!isPlayer) {
                        termAppend(`${target.name} succumbs to ${statusDef.name}!`, 'term-victory');
                        checkCombatEnd();
                    } else {
                        gameState.player.hp = 0;
                        checkCombatEnd();
                    }
                }
            }, statusDef.tickInterval);
        }
        
        function hasStatusEffect(target, statusKey, isPlayer = false) {
            const cs = gameState.combatState;
            if (!cs) return false;
            
            const effects = isPlayer ? cs.playerStatusEffects : (cs.monsterStatusEffects[target.index] || []);
            return effects.some(e => e.type === statusKey);
        }
        
        function getStatusEffectIcons(target, isPlayer = false) {
            const cs = gameState.combatState;
            if (!cs) return '';
            
            const effects = isPlayer ? cs.playerStatusEffects : (cs.monsterStatusEffects[target.index] || []);
            if (effects.length === 0) return '';
            
            return effects.map(effect => {
                const def = STATUS_EFFECTS[effect.type];
                return `<span title="${def.description}" style="color:${def.color};">${def.icon}</span>`;
            }).join(' ');
        }
        
        function applyWeaponModifiers(attacker, target, baseDamage, weapon) {
            if (!weapon.modifiers || weapon.modifiers.length === 0) {
                return { totalDamage: baseDamage, messages: [] };
            }
            
            let totalDamage = baseDamage;
            const messages = [];
            
            weapon.modifiers.forEach(modKey => {
                const mod = WEAPON_MODIFIERS[modKey];
                if (!mod) return;
                
                // Add elemental/bonus damage
                if (mod.minDamage !== undefined) {
                    const bonusDmg = Math.floor(Math.random() * (mod.maxDamage - mod.minDamage + 1)) + mod.minDamage;
                    totalDamage += bonusDmg;
                    messages.push(`<span style="color:${mod.color};">+${bonusDmg} ${mod.name} damage</span>`);
                }
                
                // Apply status effect chance
                if (mod.statusEffect && Math.random() < mod.statusChance) {
                    applyStatusEffect(target, mod.statusEffect, false);
                }
                
                // Apply lifesteal
                if (mod.lifestealPercent) {
                    const heal = Math.floor(totalDamage * (mod.lifestealPercent / 100));
                    attacker.hp = Math.min(attacker.maxHp, attacker.hp + heal);
                    messages.push(`<span style="color:#00FF00;">+${heal} HP (Lifesteal)</span>`);
                }
                
                // Apply crit bonus
                if (mod.critBonus) {
                    // This will be used in the attack calculation
                    // Store for now (handled in executeAttack)
                }
            });
            
            return { totalDamage, messages };
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COMBAT FUNCTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function startCombat(enemyKeys) {
            // Stop resting when combat starts
            stopResting();
            
            if (!Array.isArray(enemyKeys)) enemyKeys = [enemyKeys];
            const monsters = enemyKeys.map((k, index) => {
                const monster = spawnMonsterWithRarity(k, true); // true = use zone level
                monster.index = index; // Add index for status effect tracking
                return monster;
            });

            let msg;
            if (monsters.length === 1) {
                const m0 = monsters[0];
                const lvlDiff = (m0.level || 1) - (gameState.player.level || 1);
                const lvlColor = lvlDiff > 2 ? '#ff4444' : lvlDiff > 0 ? '#ff8c00' : lvlDiff < 0 ? '#88ff88' : '#aaa';
                const lvlTag = `<span style="color:${lvlColor};font-size:14px;"> [Lv.${m0.level || '?'}]</span>`;
                msg = `A wild <span style="color:${m0.rarityColor};">${m0.name}</span>${lvlTag} appears!`;
            } else {
                const names = monsters.map(m => {
                    const lvlDiff = (m.level||1) - (gameState.player.level||1);
                    const lvlColor = lvlDiff > 2 ? '#ff4444' : lvlDiff > 0 ? '#ff8c00' : lvlDiff < 0 ? '#88ff88' : '#aaa';
                    return `<span style="color:${m.rarityColor};">${m.name}</span><span style="color:${lvlColor};"> Lv.${m.level||'?'}</span>`;
                }).join(', ');
                msg = `${monsters.length} enemies appear: ${names}!`;
            }

            // enemy multi-hit based on rarity of first monster
            const rar0 = monsters[0].rarity;
            let eHits = 1;
            if      (rar0==='rare')      eHits = Math.random()<0.5 ? 2 : 1;
            else if (rar0==='epic')      eHits = 2;
            else if (rar0==='legendary') eHits = 2 + (Math.random()<0.5 ? 1 : 0);
            else if (rar0==='mythic')    eHits = 3;

            const enemyDelay = 12 + Math.floor(Math.random()*4);  // 12-15s, fixed for this combat
            const maxHits    = calcPlayerHits(gameState.player);
            const pipTimers  = [];
            for (let i = 0; i < maxHits; i++) {
                pipTimers.push(10);  // each pip starts at 10s
            }
            gameState.combatState = {
                monsters, currentTarget: 0,
                messages: [], defeatedMonsters: [],
                pipTimers:     pipTimers,    // array of timers, one per pip
                pipAvailable:  pipTimers.map(() => true),  // which pips are ready
                enemyTimer:    enemyDelay,
                enemyDelay:    enemyDelay,
                enemyHits:     eHits,
                enemyHitsLeft: eHits,
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // STATUS EFFECTS SYSTEM
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                playerStatusEffects: [], // Active status effects on player
                monsterStatusEffects: {}, // Active status effects per monster (by index)
                dotTimers: {} // DOT tick interval IDs
            };
            // stream the encounter line; show cards + start timer only after it finishes
            termAppend(msg, 'term-enemy', () => {
                renderEnemyCards();
                renderActionBar();
                setTimeout(updatePipButtons, 0);
                startCombatTimer();
            });
        }

        function spawnMonsterWithRarity(enemyKey, zoneLevel = null) {
            const template = ENEMIES[enemyKey];
            const rarity   = rollRarity();
            const mult     = RARITY_CONFIG[rarity].multiplier;
            
            // Determine monster level (use zone level if provided, otherwise template level)
            let monsterLevel = template.level;
            if (zoneLevel !== null) {
                // Random level within zone range
                const location = LOCATIONS[gameState.currentLocation];
                if (location && location.enemyLevelRange) {
                    const [minLvl, maxLvl] = location.enemyLevelRange;
                    monsterLevel = minLvl + Math.floor(Math.random() * (maxLvl - minLvl + 1));
                }
            }
            
            // Scale stats based on monster level
            const levelMult = 1 + (monsterLevel - 1) * 0.15; // 15% increase per level
            
            const monster = {
                key: enemyKey, 
                name: template.name, 
                rarity, 
                rarityColor: RARITY_CONFIG[rarity].color,
                hp: Math.floor(template.baseHp * mult * levelMult), 
                maxHp: Math.floor(template.baseHp * mult * levelMult),
                damage: Math.floor(template.baseDamage * mult * levelMult), 
                defense: Math.floor(template.baseDefense * mult * levelMult),
                xp: Math.floor(template.baseXp * mult * levelMult), // Base XP, will be scaled on defeat
                gold: Math.floor(template.baseGold * mult * levelMult),
                level: monsterLevel, 
                possibleDrops: template.possibleDrops, 
                dropRates: template.dropRates
            };
            
            return monster;
        }
        
        function calculateXpReward(monster, playerLevel) {
            // Dynamic XP based on level difference and rarity
            const levelDiff = monster.level - playerLevel;
            
            // Base XP from monster
            let xp = monster.xp;
            
            // Level difference multiplier
            // Same level: 100%
            // 1 level higher: 120%
            // 2 levels higher: 140%
            // 1 level lower: 80%
            // 5+ levels lower: 10%
            let levelMult = 1.0;
            
            if (levelDiff >= 5) {
                levelMult = 2.0; // Huge bonus for fighting much stronger enemies
            } else if (levelDiff >= 3) {
                levelMult = 1.6;
            } else if (levelDiff >= 1) {
                levelMult = 1.0 + (levelDiff * 0.2);
            } else if (levelDiff === 0) {
                levelMult = 1.0;
            } else if (levelDiff >= -2) {
                levelMult = 1.0 + (levelDiff * 0.1); // 90%, 80%
            } else if (levelDiff >= -5) {
                levelMult = 0.5;
            } else {
                levelMult = 0.1; // Killing gray mobs gives almost nothing
            }
            
            // Rarity bonus (already in base XP, but add a small extra)
            const rarityBonus = RARITY_CONFIG[monster.rarity].multiplier * 0.1;
            
            xp = Math.floor(xp * levelMult * (1 + rarityBonus));
            
            // Minimum 1 XP
            return Math.max(1, xp);
        }
        
        function rollRarity() {
            const roll = Math.random() * 100;
            let cum = 0;
            for (const [rarity, config] of Object.entries(RARITY_CONFIG)) {
                cum += config.spawnWeight;
                if (roll < cum) return rarity;
            }
            return 'common';
        }
        function getRarityText(rarity) {
            return `<span style="color:${RARITY_CONFIG[rarity].color}; font-weight:bold;">${RARITY_CONFIG[rarity].name}</span>`;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ENEMY CARDS â€“ rendered into terminal, updated in place
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function renderEnemyCards() {
            // Enemy info is now shown only in terminal messages - no visual cards needed
            // This function is still called for compatibility but does nothing
        }
        function updateEnemyCards() {
            // No longer needed - enemy info shown in terminal only
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ACTION BAR â€“ combat buttons / explore buttons / spell & potion menus
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
       // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       // DUNGEON MAP SYSTEM
       // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       
       function showDungeonMap() {
           const ds = gameState.dungeon;
           if (!ds) return;
           
           if (typeof DUNGEONS === 'undefined') {
               alert('Dungeon data not loaded!');
               return;
           }
           
           const dungeon = DUNGEONS[ds.dungeonKey];
           const floor = dungeon.floors[ds.floor];
           
           // Build ASCII map
           const mapAscii = generateAsciiMap(floor, ds.currentRoom, ds.discoveredRooms);
           
           // Show map in terminal
           const term = document.getElementById('terminalWindow');
           term.innerHTML = `
               <div style="font-family: monospace; white-space: pre; line-height: 1.2; color: var(--text-color);">
                   <div style="text-align: center; margin-bottom: 10px; color: var(--highlight-color);">
                       === ${dungeon.name} - Floor ${ds.floor} ===
                   </div>
                   <div style="text-align: center; margin-bottom: 15px; color: #8aaa8a; font-size: 14px;">
                       Legend: [@] = You | [ ] = Room | [?] = Undiscovered
                   </div>
${mapAscii}
               </div>
           `;
           
           // Update action bar
           const ab = document.getElementById('actionBar');
           ab.innerHTML = '<button onclick="hideDungeonMap()">â¬… BACK TO DUNGEON</button>';
       }
       
       function hideDungeonMap() {
           const ds = gameState.dungeon;
           if (!ds) return;
           
           // Store combat state before clearing
           const wasInCombat = !!gameState.combatState;
           
           termClear();
           
           // Redraw current room
           const dungeon = DUNGEONS[ds.dungeonKey];
           const floor = dungeon.floors[ds.floor];
           const room = floor.rooms[ds.currentRoom];
           
           termAppend('', 'term-separator');
           termAppend(`<strong>${room.name}</strong>`);
           termAppend(room.description, 'term-dim');
           
           const exits = Object.keys(room.exits).map(d => d.toUpperCase()).join(', ');
           termAppend(`You see exits: ${exits}.`, 'term-dim');
           
           // If there was combat before viewing map, show enemy cards again
           if (wasInCombat) {
               renderEnemyCards();
           } else {
               // Check for enemies in room (if not already in combat)
               checkEnemiesInRoom(ds.currentRoom);
           }
           
           renderDungeonActionBar();
       }
       
       function generateAsciiMap(floor, currentRoom, discoveredRooms) {
           const rooms = floor.rooms;
           
           // Find map bounds
           let minX = Infinity, maxX = -Infinity;
           let minY = Infinity, maxY = -Infinity;
           
           Object.keys(rooms).forEach(roomId => {
               const room = rooms[roomId];
               if (room.map && discoveredRooms.has(roomId)) {
                   minX = Math.min(minX, room.map.x);
                   maxX = Math.max(maxX, room.map.x);
                   minY = Math.min(minY, room.map.y);
                   maxY = Math.max(maxY, room.map.y);
               }
           });
           
           // Create grid (each room takes 4 chars wide, 2 chars tall for spacing)
           const cellWidth = 4;
           const cellHeight = 2;
           const width = (maxX - minX + 1) * cellWidth + 1;
           const height = (maxY - minY + 1) * cellHeight + 1;
           const grid = Array(height).fill(null).map(() => Array(width).fill(' '));
           
           // Helper to get grid position
           const toGridX = (mapX) => (mapX - minX) * cellWidth;
           const toGridY = (mapY) => (mapY - minY) * cellHeight;
           
           // First pass: Draw all connections
           Object.keys(rooms).forEach(roomId => {
               const room = rooms[roomId];
               if (!room.map || !discoveredRooms.has(roomId)) return;
               
               const x = toGridX(room.map.x);
               const y = toGridY(room.map.y);
               
               // Draw connections to discovered rooms
               Object.keys(room.exits).forEach(dir => {
                   const targetId = room.exits[dir];
                   const targetRoom = rooms[targetId];
                   
                   if (!targetRoom || !targetRoom.map || !discoveredRooms.has(targetId)) return;
                   
                   const direction = dir.toLowerCase();
                   
                   if (direction === 'n') {
                       grid[y - 1][x + 1] = '|';
                   } else if (direction === 's') {
                       grid[y + 2][x + 1] = '|';
                   } else if (direction === 'e') {
                       grid[y + 1][x + 3] = '-';
                   } else if (direction === 'w') {
                       grid[y + 1][x - 1] = '-';
                   } else if (direction === 'ne') {
                       grid[y][x + 2] = '/';
                   } else if (direction === 'nw') {
                       grid[y][x] = '\\';
                   } else if (direction === 'se') {
                       grid[y + 2][x + 2] = '\\';
                   } else if (direction === 'sw') {
                       grid[y + 2][x] = '/';
                   }
               });
           });
           
           // Second pass: Draw rooms (overwrites connections at room positions)
           Object.keys(rooms).forEach(roomId => {
               const room = rooms[roomId];
               if (!room.map || !discoveredRooms.has(roomId)) return;
               
               const x = toGridX(room.map.x);
               const y = toGridY(room.map.y);
               
               // Draw room
               const isPlayer = roomId === currentRoom;
               if (isPlayer) {
                   grid[y + 1][x] = '[';
                   grid[y + 1][x + 1] = '@';
                   grid[y + 1][x + 2] = ']';
               } else {
                   grid[y + 1][x] = '[';
                   grid[y + 1][x + 1] = ' ';
                   grid[y + 1][x + 2] = ']';
               }
           });
           
           // Convert grid to string with proper coloring
           let result = '';
           for (let y = 0; y < height; y++) {
               let line = '';
               for (let x = 0; x < width; x++) {
                   const char = grid[y][x];
                   if (char === '@') {
                       line += `<span style="color:var(--highlight-color);">${char}</span>`;
                   } else if (char === '[' || char === ']') {
                       line += `<span style="color:var(--border-color);">${char}</span>`;
                   } else {
                       line += char;
                   }
               }
               result += line + '\n';
           }
           
           return result;
       }

       function renderDungeonActionBar() {
    const ab = document.getElementById('actionBar');

    function updateTerminalSafeArea() {
        // No-op with fixed flex layout
    }

    // Clear action bar
    ab.innerHTML = '';
    ab.style.display = 'block';

    const ds = gameState.dungeon;
    if (!ds) return;

    // Safety check for DUNGEONS
    if (typeof DUNGEONS === 'undefined') {
        console.error('âš ï¸ DUNGEONS not loaded!');
        ab.innerHTML = '<button onclick="returnToTown()">âš ï¸ ERROR - Return to Town</button>';
        return;
    }

    const dungeon = DUNGEONS[ds.dungeonKey];
    const floor = dungeon.floors[ds.floor];
    const room = floor.rooms[ds.currentRoom];

    const cs = gameState.combatState;
    
    // â•â•â• COMBAT BUTTONS (if in combat) â•â•â•
if (cs) {
    const maxHits  = cs.pipAvailable
        ? cs.pipAvailable.length
        : calcPlayerHits(gameState.player);

    const hitsLeft = cs.pipAvailable
        ? cs.pipAvailable.filter(x => x).length
        : maxHits;

    const canAct = hitsLeft > 0;
    const pips = 'â—'.repeat(hitsLeft) + 'â—‹'.repeat(maxHits - hitsLeft);
    const mode = cs.actionMode || 'main';

    const combatDiv = document.createElement('div');
    combatDiv.style.cssText =
        'border-bottom:1px solid var(--border-color);padding-bottom:6px;margin-bottom:6px;';

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ MAIN COMBAT MENU â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    if (mode === 'main') {
        combatDiv.innerHTML = `
            <div style="color:var(--highlight-color);font-size:16px;margin-bottom:4px;text-align:center;">
                âš”ï¸ <span style="letter-spacing:2px;">${pips}</span>
                <span style="color:#8aaa8a;font-size:13px;">(${hitsLeft}/${maxHits})</span>
            </div>
            <div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:center;">
                <button onclick="showAttackMenu()" ${!canAct ? 'disabled' : ''} class="pip-btn" id="pipBtn-attack">âš”ï¸</button>
                <button onclick="showSpellMenu()"  ${!canAct ? 'disabled' : ''} class="pip-btn" id="pipBtn-spell">âœ¨</button>
                <button onclick="showPotionMenu()" ${!canAct ? 'disabled' : ''}>ğŸ§ª</button>
                <button onclick="playerDefend()"   ${!canAct ? 'disabled' : ''}>ğŸ›¡ï¸</button>
                <button onclick="attemptFlee()"    ${!canAct ? 'disabled' : ''}>ğŸƒ</button>
            </div>
        `;
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ATTACK TYPE MENU â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    else if (mode === 'attack_type') {
        const normalCost  = 1;
        const heavyCost   = 2;
        const showSpecial = hitsLeft >= 3;

        combatDiv.innerHTML = `
            <div style="color:var(--highlight-color);font-size:14px;margin-bottom:4px;text-align:center;">
                ATTACK TYPE
            </div>
            <div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:center;">
                <button onclick="selectAttackType('normal')" ${hitsLeft < normalCost ? 'disabled' : ''}>
                    âš”ï¸ Normal
                </button>
                <button onclick="selectAttackType('heavy')" ${hitsLeft < heavyCost ? 'disabled' : ''}
                    title="35% miss â€” hits for 3x!">
                    ğŸ’¥ Heavy<span style="font-size:10px;color:#ff8c00;"> âš </span>
                </button>
                ${showSpecial ? `<button onclick="selectAttackType('special')">â­ Special</button>` : ''}
                <button onclick="cancelAction()">âŒ</button>
            </div>
        `;
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ TARGET SELECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    else if (mode === 'target_attack' || mode === 'target_spell') {
        const targetBtns = cs.monsters.map((m, i) => `
            <button onclick="executeTargetedAction(${i})">
                #${i + 1} ${m.name}<br>
                <span style="font-size:11px;">HP ${m.hp}/${m.maxHp}</span>
            </button>
        `).join('');

        combatDiv.innerHTML = `
            <div style="color:var(--highlight-color);font-size:14px;margin-bottom:4px;text-align:center;">
                TARGET
            </div>
            <div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:center;">
                ${targetBtns}
                <button onclick="cancelAction()">âŒ</button>
            </div>
        `;
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ SPELL LIST â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    else if (mode === 'spell_list') {
        const spells = gameState.player.knownSpells || [];

        const spellBtns = spells.map(sk => {
            const spell = SPELLS[sk];
            const disabled = !canAct || gameState.player.mp < spell.mpCost;
            return `
                <button onclick="selectSpell('${sk}')" ${disabled ? 'disabled' : ''}>
                    ${spell.name}<br>
                    <span style="font-size:11px;">${spell.mpCost} MP</span>
                </button>
            `;
        }).join('');

        combatDiv.innerHTML = `
            <div style="color:var(--highlight-color);font-size:14px;margin-bottom:4px;text-align:center;">
                SPELL
            </div>
            <div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:center;">
                ${spellBtns}
                <button onclick="cancelAction()">âŒ</button>
            </div>
        `;
    }

    actionBar.appendChild(combatDiv);
}


    // â•â•â• NAVIGATION BUTTONS (always visible) â•â•â•
    const canMove = !cs || !cs.pipAvailable || cs.pipAvailable.every(x => x);
    
    // Show pip status if in combat/recovery
    if (cs && cs.pipAvailable && !canMove) {
        const available = cs.pipAvailable.filter(x => x).length;
        const total = cs.pipAvailable.length;
        const pips = 'â—'.repeat(available) + 'â—‹'.repeat(total - available);
        
        const statusDiv = document.createElement('div');
        statusDiv.style.cssText = 'color:#8aaa8a;font-size:12px;margin-bottom:4px;text-align:center;';
        statusDiv.innerHTML = `â³ Resting to move: ${pips} (${available}/${total})`;
        ab.appendChild(statusDiv);
    }

    // Create compact button container
    const btnContainer = document.createElement('div');
    btnContainer.style.cssText = 'display:flex;flex-wrap:wrap;gap:4px;justify-content:center;';

    // Entrance exit button (always enabled when at start room)
    if (ds.currentRoom === floor.startRoom) {
        const startRoom = floor.rooms[floor.startRoom];
        const exitTown = startRoom.flags && startRoom.flags.townExit ? startRoom.flags.townExit : null;
        const exitLabel = (startRoom.flags && startRoom.flags.townExitLabel) || 'â¬… Town';
        const exitBtn = document.createElement('button');
        exitBtn.innerHTML = exitLabel;
        exitBtn.onclick = () => returnToTown(exitTown || gameState.currentTown);
        exitBtn.style.cssText = 'min-width:55px;padding:6px 8px;font-size:13px;';
        btnContainer.appendChild(exitBtn);
    }
    
    // Town-exit button for non-start rooms with townExit flag
    if (ds.currentRoom !== floor.startRoom) {
        const curRoom = floor.rooms[ds.currentRoom];
        if (curRoom && curRoom.flags && curRoom.flags.townExit) {
            const townId = curRoom.flags.townExit;
            const label  = curRoom.flags.townExitLabel || `Exit to ${townId}`;
            const portalBtn = document.createElement('button');
            portalBtn.innerHTML = label;
            portalBtn.onclick = () => townExitFromDungeon(townId);
            portalBtn.style.cssText = 'min-width:80px;padding:6px 8px;font-size:13px;border-color:#AA88FF;color:#AA88FF;';
            btnContainer.appendChild(portalBtn);
        }
    }
    
    // MAP button (always enabled)
    const mapBtn = document.createElement('button');
    mapBtn.textContent = 'ğŸ—ºï¸';
    mapBtn.onclick = showDungeonMap;
    mapBtn.style.cssText = 'min-width:40px;padding:6px 8px;font-size:13px;border-color:var(--highlight-color);';
    btnContainer.appendChild(mapBtn);

    // Direction buttons (can be disabled)
    const directionOrder = ['n', 'ne', 'e', 'se', 's', 'sw', 'w', 'nw'];
    const directionLabels = {
        'n': 'N',
        'ne': 'NE', 
        'e': 'E',
        'se': 'SE',
        's': 'S',
        'sw': 'SW',
        'w': 'W',
        'nw': 'NW'
    };
    
    directionOrder.forEach(dir => {
        if (room.exits[dir]) {
            const btn = document.createElement('button');
            btn.textContent = directionLabels[dir];
            btn.onclick = () => moveInDungeon(dir);
            btn.disabled = !canMove;
            btn.style.cssText = 'min-width:42px;padding:6px 4px;font-size:13px;font-weight:bold;';
            if (!canMove) {
                btn.style.opacity = '0.4';
                btn.style.cursor = 'not-allowed';
            }
            btnContainer.appendChild(btn);
        }
    });

    // â¬†â¬‡ Ladder buttons (Up/Down) â€” shown when room has a ladder
    if (room.contents && room.contents.ladder) {
        const ladderDir = room.contents.ladder.direction; // 'up' or 'down'
        const ladderBtn = document.createElement('button');
        ladderBtn.textContent = ladderDir === 'up' ? 'â¬† UP' : 'â¬‡ DOWN';
        ladderBtn.title = ladderDir === 'up'
            ? `Climb up to Floor ${room.contents.ladder.leadsTo.floor}`
            : `Climb down to Floor ${room.contents.ladder.leadsTo.floor}`;
        ladderBtn.onclick = () => moveInDungeon(ladderDir);
        ladderBtn.disabled = !canMove;
        ladderBtn.style.cssText = 'min-width:60px;padding:6px 8px;font-size:13px;font-weight:bold;border-color:#FFD700;color:#FFD700;';
        if (!canMove) {
            ladderBtn.style.opacity = '0.4';
            ladderBtn.style.cursor = 'not-allowed';
        }
        btnContainer.appendChild(ladderBtn);
    }

    ab.appendChild(btnContainer);
}







        
        
        function renderActionBar() {
            const ab = document.getElementById('actionBar');
            showActionBar();
            
            // If in dungeon, always use dungeon action bar with combat overlay
            if (gameState.dungeon) {
                renderDungeonActionBar();
                // Sweep animation + scroll fix (deferred so DOM is settled)
                requestAnimationFrame(() => { updatePipButtons(); stabilizeTerminalLayout(); });
                return;
            }
            
            if (gameState.combatState) {
                const cs       = gameState.combatState;
                const monsters = cs.monsters;
                const p        = gameState.player;
                const maxHits  = cs.pipAvailable ? cs.pipAvailable.length : calcPlayerHits(p);
                const hitsLeft = cs.pipAvailable ? cs.pipAvailable.filter(x => x).length : maxHits;
                const canAct   = hitsLeft > 0;

                // attack-charge pips  â—â—â—‹
                const pips = 'â—'.repeat(hitsLeft) + 'â—‹'.repeat(maxHits - hitsLeft);

                // Check what menu mode we're in
                const mode = cs.actionMode || 'main';

                if (mode === 'main') {
                    // Main combat menu â€” single row of 5 equal buttons + pip indicator above
                    ab.innerHTML = `
                        <div style="color:var(--highlight-color);font-size:11px;line-height:1;margin-bottom:3px;text-align:center;letter-spacing:1px;">
                            <span style="letter-spacing:3px;">${pips}</span>
                            <span style="color:#8aaa8a;font-size:11px;"> ${hitsLeft}/${maxHits}</span>
                        </div>
                        <div style="display:flex;gap:3px;width:100%;">
                            <button onclick="showAttackMenu()" ${!canAct?'disabled':''} class="action-icon-btn pip-btn" title="Attack" id="pipBtn-attack">âš”ï¸ Atk</button>
                            <button onclick="showSpellMenu()"  ${!canAct?'disabled':''} class="action-icon-btn pip-btn" title="Cast Spell" id="pipBtn-spell">âœ¨ Spl</button>
                            <button onclick="showPotionMenu()" class="action-icon-btn" title="Use Potion" style="border-color:#00FF00;">ğŸ§ª Pot</button>
                            <button onclick="playerDefend()"   ${!canAct?'disabled':''} class="action-icon-btn" title="Defend">ğŸ›¡ï¸ Def</button>
                            <button onclick="attemptFlee()"    ${!canAct?'disabled':''} class="action-icon-btn" title="Flee">ğŸƒ Flee</button>
                        </div>
                    `;
                } else if (mode === 'attack_type') {
                    const normalCost = 1;
                    const heavyCost = 2;
                    const showSpecial = hitsLeft >= 3;
                    ab.innerHTML = `
                        <div style="display:flex;gap:3px;width:100%;">
                            <button onclick="selectAttackType('normal')" ${hitsLeft < normalCost ? 'disabled' : ''} class="action-icon-btn">âš”ï¸ Nrm</button>
                            <button onclick="selectAttackType('heavy')"  ${hitsLeft < heavyCost  ? 'disabled' : ''} class="action-icon-btn" title="35% miss, 3x dmg" style="border-color:#ff8c00;">ğŸ’¥ Hvy</button>
                            ${showSpecial ? `<button onclick="selectAttackType('special')" class="action-icon-btn" style="border-color:#FFD700;">â­ Spc</button>` : ''}
                            <button onclick="cancelAction()" class="action-icon-btn" style="border-color:#888;">âŒ</button>
                        </div>
                    `;
                } else if (mode === 'target_attack' || mode === 'target_spell' || mode === 'target_staff_melee') {
                    // Target selection menu
                    let actionName;
                    if (mode === 'target_spell') {
                        actionName = cs.pendingSpell?.name || 'Spell';
                    } else if (mode === 'target_staff_melee') {
                        actionName = 'Staff Melee';
                    } else {
                        actionName = 'Attack';
                    }
                    
                    const targetBtns = monsters.map((m, i) => {
    return `<button onclick="executeTargetedAction(${i})"
        class="target-btn">
        #${i + 1} ${m.name}
    </button>`;
}).join('');

                    
                    ab.innerHTML = `
                        <div style="display:flex;flex-wrap:wrap;gap:3px;width:100%;">
                            ${targetBtns}
                            <button onclick="cancelAction()" class="action-icon-btn" style="border-color:#888;">âŒ</button>
                        </div>
                    `;
                } else if (mode === 'spell_list') {
                    // Spell selection menu
                    const spellBtns = p.knownSpells.map(sk => {
                        const spell = ensureSpellExists(sk) || SPELLS[sk];
                        if (!spell) {
                            console.warn(`âš ï¸ Spell '${sk}' not found in SPELLS object`);
                            return ''; // Skip this spell
                        }
                        const canCast = p.mp >= spell.mpCost;
                        const aoeTag = spell.type === 'aoe_damage' ? ' <span style="color:#FF8800;">AOE</span>' : '';
                        return `<button onclick="selectSpell('${sk}')" ${!canCast?'disabled':''} class="spell-btn">
                            ${spell.name}${aoeTag}<br>
                            <span style="font-size:12px;">${spell.mpCost} MP</span>
                        </button>`;
                    }).filter(Boolean).join('');
                    
                    // Check if player has a staff weapon
                    const weapon = WEAPONS[p.weapon];
                    const hasStaff = weapon && (weapon.name.toLowerCase().includes('staff') || weapon.baseMagicDamage > 0);
                    
                    // Add melee attack option if player has staff (can bonk enemies with it!)
                    const meleeOption = hasStaff ? 
                        `<button onclick="staffMeleeAttack()" class="spell-btn" style="border-color:#FF8800;">
                            âš”ï¸ Staff Melee<br>
                            <span style="font-size:12px;">Bonk! (No MP)</span>
                        </button>` : '';
                    
                    ab.innerHTML = `
                        <div style="display:flex;flex-wrap:wrap;gap:3px;width:100%;">
                            ${spellBtns}
                            ${meleeOption}
                            <button onclick="cancelAction()" class="action-icon-btn" style="border-color:#888;">âŒ</button>
                        </div>
                    `;
                }
            } else {
                // Out of combat - exploring
                // Show pip recovery status if any pips are still cooling down
                const cs2 = gameState.combatState;
                let pipWarning = '';
                let canLeave = true;
                if (cs2 && cs2.pipAvailable) {
                    const ready = cs2.pipAvailable.filter(x => x).length;
                    const total = cs2.pipAvailable.length;
                    canLeave = (ready === total);
                    if (!canLeave) {
                        pipWarning = `<div style="color:#FF8800;font-size:11px;margin-bottom:4px;">
                            â³ Pips recovering: ${'â—'.repeat(ready) + 'â—‹'.repeat(total-ready)} â€” wait to leave</div>`;
                    }
                }
                ab.innerHTML = `
                    ${pipWarning}
                    <div style="display:flex;gap:3px;width:100%;">
                        <button onclick="exploreLocation('${gameState.currentLocation}')" style="flex:2;">ğŸ” Explore</button>
                        <button onclick="showPotionMenuExplore()" style="flex:1;border-color:#00FF00;">ğŸ§ª Pots</button>
                        <button onclick="leaveExploreToTown()" ${canLeave ? '' : 'disabled'}
                            style="flex:1;${canLeave ? '' : 'opacity:0.4;'}border-color:${canLeave ? 'var(--text-color)' : '#888'};">
                            ğŸ˜ï¸ Town
                        </button>
                    </div>
                `;
            }
            // After any button-set change, fix terminal scroll on mobile
            requestAnimationFrame(() => { updatePipButtons(); stabilizeTerminalLayout(); });
        }
        function goBackToTown() {
            leaveExploreToTown();
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // NEW DYNAMIC COMBAT MENU SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function showAttackMenu() {
            const cs = gameState.combatState;
            if (!cs) return;
            cs.actionMode = 'attack_type';
            renderActionBar();
        }
        
        function selectAttackType(type) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            cs.pendingAttackType = type;
            cs.actionMode = 'target_attack';
            renderActionBar();
        }
        
        function cancelAction() {
            const cs = gameState.combatState;
            if (!cs) return;
            cs.actionMode = 'main';
            cs.pendingAttackType = null;
            cs.pendingSpell = null;
            renderActionBar();
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STAFF MELEE ATTACK (for mages out of MP)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function staffMeleeAttack() {
            const cs = gameState.combatState;
            if (!cs) return;
            
            // Switch to target selection for staff melee
            cs.actionMode = 'target_staff_melee';
            renderActionBar();
        }
        
        function executeStaffMelee(targetIndex) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            const p = gameState.player;
            const enemy = cs.monsters[targetIndex];
            const weapon = WEAPONS[p.weapon];
            
            // Consume 1 pip
            const consumed = consumePips(cs, 1, getPipCooldown(p));
            if (consumed < 1) {
                termAppend('Not enough action points!', 'term-error');
                return;
            }
            markMpAction();  // reset 15s MP regen countdown
            
            // Staff melee does reduced damage (50% of normal + small magic bonus)
            // Formula: (weapon base damage Ã— 0.5) + (STR Ã— 0.3) + (magic damage Ã— 0.3)
            let baseDamage = Math.floor((weapon.baseDamage || 1) * 0.5);
            const strBonus = Math.floor((p.str || p.strength || 0) * 0.3);
            const magicBonus = Math.floor((weapon.baseMagicDamage || 0) * 0.3);
            
            // Total damage
            let totalDamage = baseDamage + strBonus + magicBonus;
            
            // Apply class damage multiplier (if evolved)
            const classMult = getClassDamageMultiplier(p);
            totalDamage = Math.floor(totalDamage * classMult);
            
            // Calculate final damage with enemy defense
            const result = calculateDamage({
                attacker: p,
                defender: enemy,
                base: totalDamage,
                type: 'physical',
                critChance: calcCritChance(p.lck || 0, p) / 100,
                dodgeChance: enemy.dodge || 0,
                armorPiercing: 0
            });
            
            const tName = cs.monsters.length > 1
                ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${targetIndex+1}</span>`
                : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;
            
            if (result.dodged) {
                termAppend(`You swing your staff at ${tName} but they <span style="color:#88ff88;">DODGE!</span>`);
            } else {
                const critTag = result.crit ? ' <span style="color:#FFD700;">â˜… CRITICAL HIT!</span>' : '';
                enemy.hp -= result.damage;
                termAppend(
                    `You <span style="color:#FF8800;">BONK</span> ${tName} with your staff for <span class="dmg-enemy">${result.damage} damage!</span>${critTag}`,
                    null,
                    () => {
                        checkCombatEnd();
                        updateEnemyCards();
                        updateHud();
                    }
                );
            }
            
            // Return to main combat menu
            cs.actionMode = 'main';
            renderActionBar();
        }
        
        function executeTargetedAction(targetIndex) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            cs.currentTarget = targetIndex;
            
            if (cs.actionMode === 'target_attack') {
                executeAttack(cs.pendingAttackType);
            } else if (cs.actionMode === 'target_spell') {
                castSpellOnTarget(cs.pendingSpell);
            } else if (cs.actionMode === 'target_staff_melee') {
                executeStaffMelee(targetIndex);
            }
            
            // Reset to main menu
            cs.actionMode = 'main';
            cs.pendingAttackType = null;
            cs.pendingSpell = null;
        }
        
        function selectSpell(spellKey) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            const spell = SPELLS[spellKey];
            cs.pendingSpell = spell;
            cs.pendingSpellKey = spellKey;
            
            // AOE spells don't need target selection - cast immediately
            if (spell && spell.type === 'aoe_damage') {
                castSpellOnTarget(spell);
                cs.actionMode = 'main';
                cs.pendingSpell = null;
                cs.pendingSpellKey = null;
            } else {
                // Regular spells need target selection
                cs.actionMode = 'target_spell';
                renderActionBar();
            }
        }
        
        // Update showSpellMenu to use the new system
        function showSpellMenuOld() {
            const cs = gameState.combatState;
            if (!cs) return;
            
            cs.actionMode = 'spell_list';
            renderActionBar();
        }
        

        function tryExploreLocation(locKey) {
            if (!isFullyRested()) {
                termAppend('<span style="color:var(--error-color);">You are too exhausted to continue! Wait for your charges to restoreâ€¦</span>', 'term-error');
                return;
            }
            // Clear old combat state now that we're starting fresh
            gameState.combatState = null;
            exploreLocation(locKey);
        }
        
        function tryGoBackToTown() {
            // Delegate to leaveExploreToTown â€” it handles pip check and enemy preservation
            leaveExploreToTown();
        }
        
        function tryViewWorldMap() {
            if (!isFullyRested()) {
                termAppend('<span style="color:var(--error-color);">You are too exhausted to travel! Wait for your charges to restoreâ€¦</span>', 'term-error');
                return;
            }
            // Preserve combatState â€” enemies wait here until player returns
            closeTerminalView();
            showExplore();
        }
        
        function selectTarget(index) {
            const cs = gameState.combatState;
            if (!cs || !cs.monsters || index < 0 || index >= cs.monsters.length) return;
            cs.currentTarget = index;
            updateEnemyCards();
            renderActionBar();
        }

        function isFullyRested() {
            const cs = gameState.combatState;
            if (!cs || !cs.pipAvailable) return true;
            // all pips must be available
            return cs.pipAvailable.every(x => x);
        }


      function startCombatTimer() {
    if (gameState.combatTimer) clearInterval(gameState.combatTimer);

    gameState.combatTimer = setInterval(() => {
        const cs = gameState.combatState;

        // No combat state at all â†’ stop timer
        if (!cs) {
            clearInterval(gameState.combatTimer);
            gameState.combatTimer = null;
            return;
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // PIP RECOVERY (always runs)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let anyRestored = false;
        const pipCooldown = gameState.player ? getPipCooldown(gameState.player) : BASE_PIP_COOLDOWN;

        for (let i = 0; i < cs.pipTimers.length; i++) {
            if (!cs.pipAvailable[i] && cs.pipTimers[i] > 0) {
                cs.pipTimers[i]--;
                if (cs.pipTimers[i] <= 0) {
                    cs.pipAvailable[i] = true;
                    cs.pipTimers[i] = pipCooldown;
                    anyRestored = true;
                }
            }
        }

        if (anyRestored) {
            renderActionBar();
        }
        // Always update pip sweep animation each tick
        updatePipButtons();

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // POST-COMBAT RECOVERY CLEANUP
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (cs.combatOver) {
            // Once ALL pips are restored, exit recovery
            if (cs.pipAvailable.every(p => p)) {
                gameState.postCombatRecovery = false;
                gameState.combatState = null;

                renderActionBar();
                clearInterval(gameState.combatTimer);
                gameState.combatTimer = null;
            }
            return; // No enemy actions during recovery
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // ENEMY TIMER + INTENT TELEGRAPHING
        // (only while combat is active)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (cs.enemyTimer > 0) cs.enemyTimer--;

        // Telegraph intent 1 second before attack
        if (cs.enemyTimer === 1 && !cs.enemyIntent) {
            const enemy = cs.monsters[cs.currentTarget];
            if (enemy) {
                cs.enemyIntent = selectEnemyIntent(enemy);
                termAppend(
                    `<span style="color:${enemy.rarityColor};">${enemy.name}</span> ${cs.enemyIntent.telegraph}`,
                    'term-dim'
                );
            }
        }

        // Execute enemy attack
        if (cs.enemyTimer <= 0) {
            clearInterval(gameState.combatTimer);
            gameState.combatTimer = null;
            enemyAttackSingle();
        }

    }, 1000);
}


 // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLAYER ACTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function checkRoomEncounter(room) {
    const ds = gameState.dungeon;
    if (!ds) return;
    if (!ds.activeEnemies) ds.activeEnemies = [];

    // â”€â”€ NEW FORMAT: contents.enemies[] from dungeon editor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Each entry: { key: 'giant_scorpion', drop: 'copper_key' } or plain string.
    // Only spawn once per room per dungeon session.
    if (room.contents && Array.isArray(room.contents.enemies) && room.contents.enemies.length > 0) {
        if (!ds.spawnedRooms) ds.spawnedRooms = new Set();
        if (ds.spawnedRooms.has(ds.currentRoom)) return;
        ds.spawnedRooms.add(ds.currentRoom);

        room.contents.enemies.forEach(entry => {
            const monsterId = typeof entry === 'string' ? entry : entry.key;
            const drop      = typeof entry === 'string' ? null  : (entry.drop || null);
            const enemyDef  = ENEMIES[monsterId];
            if (!enemyDef) { console.warn('Dungeon enemy not found:', monsterId); return; }

            const inst = {
                id: crypto.randomUUID(),
                monsterId,
                name:          enemyDef.name,
                currentRoom:   ds.currentRoom,
                leash:         enemyDef.isBoss ? 6 : 3,
                roomsFollowed: 0,
                drop
            };
            ds.activeEnemies.push(inst);
            termAppend(`\u26a0\ufe0f <strong>${inst.name}</strong> steps out of the shadows!`, 'term-warning');
        });
        return;
    }

    // â”€â”€ OLD FORMAT: room.encounter.monsterId â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (!room || !room.encounter) return;
    if (room.encounter.resolved) return;

    const enemyDef = ENEMIES[room.encounter.monsterId];
    if (!enemyDef) { console.warn('Enemy not found:', room.encounter.monsterId); return; }

    const enemyInstance = {
        id: crypto.randomUUID(),
        monsterId:     room.encounter.monsterId,
        name:          enemyDef.name,
        currentRoom:   ds.currentRoom,
        leash:         enemyDef.isBoss ? 6 : 3,
        roomsFollowed: 0,
        drop:          room.encounter.drop || null
    };

    ds.activeEnemies.push(enemyInstance);
    room.encounter.resolved = true;

    termAppend(`\u26a0\ufe0f <strong>${enemyInstance.name}</strong> steps out of the shadows!`, 'term-warning');
}


function updateDungeonEnemies() {
    const ds = gameState.dungeon;
    if (!ds || !ds.activeEnemies) return;

    const dungeon = DUNGEONS[ds.dungeonKey];
    const floor = dungeon.floors[ds.floor];

    ds.activeEnemies.forEach(enemy => {
        const enemyRoom = floor.rooms[enemy.currentRoom];
        if (!enemyRoom) return;

        // ğŸ§  START chase ONLY when player enters enemy's room
        if (!enemy.isChasing && enemy.currentRoom === ds.currentRoom) {
            enemy.isChasing = true;
            enemy.roomsFollowed = 0;

            //  IF THE ENEMY IS CHASING YOU, PRINT THIS MESSAGE
         //   termAppend(
         //       `ğŸ‘ï¸ <strong>${enemy.name}</strong> begins to pursue youâ€¦`,
         //       'term-warning'
         //   );
         //   return;
        }

        // âŒ not chasing â†’ do nothing
        if (!enemy.isChasing) return;

        // ğŸ›‘ leash exhausted â†’ STOP and STAY
        if (enemy.roomsFollowed >= enemy.leash) {
            enemy.isChasing = false;

            termAppend(
                `ğŸ›‘ <strong>${enemy.name}</strong> stops the chase.`,
                'term-dim'
            );
            return; // â›” ABSOLUTELY REQUIRED
        }

        // ğŸ‘£ follow ONLY while chasing
        const exits = enemyRoom.exits || {};
for (const dir in exits) {
    if (exits[dir] === ds.currentRoom) {
        enemy.currentRoom = ds.currentRoom;
enemy.roomsFollowed++;
enemy.justArrived = true; // ğŸ‘ˆ add this

const fromDir = OPPOSITE_DIR[dir] || dir;

termAppend(
    `âš ï¸ <strong>${enemy.name}</strong> enters from the <em>${fromDir}</em>.`,
    'term-warning'
);

return;

    }
}

    });
}




function moveInDungeon(direction) {
    // Check if player has full pips (required for movement)
    const cs = gameState.combatState;
    if (cs && cs.pipAvailable) {
        const hasFullPips = cs.pipAvailable.every(x => x);
        if (!hasFullPips) {
            const available = cs.pipAvailable.filter(x => x).length;
            const total = cs.pipAvailable.length;
            termAppend(`âš¡ You're too exhausted to move! (${available}/${total} pips restored)`, 'term-error');
            return;
        }
    }

    if (!gameState.dungeon) {
        console.warn('Not in a dungeon');
        return;
    }

    const ds = gameState.dungeon;
    const dungeonData = DUNGEONS[ds.dungeonKey];

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LADDER MOVEMENT â€” "up" or "down"
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (direction === 'up' || direction === 'down') {
        const currentFloor = dungeonData.floors[ds.floor];
        const currentRoom = currentFloor.rooms[ds.currentRoom];

        if (!currentRoom.contents || !currentRoom.contents.ladder) {
            termAppend(`There is no ladder here.`, 'term-dim');
            return;
        }
        const ladder = currentRoom.contents.ladder;
        if (ladder.direction !== direction) {
            termAppend(`The ladder only goes ${ladder.direction}.`, 'term-dim');
            return;
        }

        const targetFloor = ladder.leadsTo.floor;
        const targetRoom  = ladder.leadsTo.room;

        if (!dungeonData.floors[targetFloor] || !dungeonData.floors[targetFloor].rooms[targetRoom]) {
            termAppend(`âš ï¸ Ladder leads nowhere (floor ${targetFloor} / ${targetRoom} not found).`, 'term-error');
            return;
        }

        // â”€â”€ Transition â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ds.floor      = targetFloor;
        ds.currentRoom = targetRoom;
        if (!ds.discoveredRooms) ds.discoveredRooms = new Set();
        ds.discoveredRooms.add(targetRoom);

        const destFloorData = dungeonData.floors[targetFloor];
        const destRoom = destFloorData.rooms[targetRoom];
        destRoom.flags = destRoom.flags || {};
        destRoom.flags.discovered = true;

        termAppend('', 'term-separator');
        termAppend(`ğŸªœ You ${direction === 'up' ? 'climb up' : 'descend'} the ladder to <strong>Floor ${targetFloor}</strong>.`, 'term-highlight');
        termAppend(`<strong>${destRoom.name || targetRoom}</strong>`);
        termAppend(destRoom.description || '', 'term-dim');

        // List exits including any ladder in the destination room
        const exitList = buildExitList(destRoom);
        termAppend(`You see exits: ${exitList}.`, 'term-dim');

        checkTownExit(destRoom);
        triggerRoomTrap(destRoom);
        checkRoomEncounter(destRoom);
        checkEnemiesInRoom(targetRoom);
        saveGame();
        renderDungeonActionBar();
        return;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // NORMAL DIRECTION MOVEMENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const floor = dungeonData.floors[ds.floor];
    const currentRoom = floor.rooms[ds.currentRoom];

    const nextRoomId = currentRoom.exits[direction];
    if (!nextRoomId) {
        termAppend(`You cannot go that way.`, 'term-dim');
        return;
    }

    // â”€â”€ DOOR LOCK CHECK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // If a locked door exists on this exit, player must have the matching key.
    const door = currentRoom.contents?.doors?.[direction];
    if (door && door.locked) {
        const keyItem = door.type + '_key';   // e.g. 'copper' â†’ 'copper_key'
        const inv = gameState.player.inventory || [];
        const hasKey = inv.includes(keyItem);

        if (!hasKey) {
            // Door color names for flavour text
            const COLOR_NAMES = {
                bronze:'Bronze', copper:'Copper', iron:'Iron', brass:'Brass',
                silver:'Silver', electrum:'Electrum', ruby:'Ruby', topaz:'Topaz',
                diamond:'Diamond', obsidian:'Obsidian', bone:'Bone'
            };
            const doorName = (COLOR_NAMES[door.type] || door.type) + ' door';
            termAppend(
                `ğŸ”’ A locked <span style="color:${getDoorColor(door.type)}">${doorName}</span> blocks your path. You need a ${COLOR_NAMES[door.type] || door.type} key.`,
                'term-warning'
            );
            return;
        }

        // Player has the key â€” consume it (one-time use) and proceed
        const keyIdx = inv.indexOf(keyItem);
        inv.splice(keyIdx, 1);
        const COLOR_NAMES2 = {
            bronze:'Bronze', copper:'Copper', iron:'Iron', brass:'Brass',
            silver:'Silver', electrum:'Electrum', ruby:'Ruby', topaz:'Topaz',
            diamond:'Diamond', obsidian:'Obsidian', bone:'Bone'
        };
        termAppend(
            `ğŸ”“ You use your <span style="color:${getDoorColor(door.type)}">${COLOR_NAMES2[door.type] || door.type} key</span> to unlock the door.`,
            'term-highlight'
        );
        door.locked = false; // door stays unlocked for rest of session
    }

    const nextRoom = floor.rooms[nextRoomId];

    ds.currentRoom = nextRoomId;
    if (!ds.discoveredRooms) ds.discoveredRooms = new Set();
    ds.discoveredRooms.add(nextRoomId);
    nextRoom.flags = nextRoom.flags || {};
    nextRoom.flags.discovered = true;

    termAppend('', 'term-separator');
    termAppend(`<strong>${nextRoom.name || nextRoomId}</strong>`);
    termAppend(nextRoom.description || '', 'term-dim');

    // ğŸ”¥ Spawn encounter (once)
    checkRoomEncounter(nextRoom);

    // ğŸ‘£ Move any active enemies that can follow
    updateDungeonEnemies();

    // ğŸ‘ï¸ enemies already present (no combat)
    checkEnemiesInRoom(nextRoomId);

    const exitList = buildExitList(nextRoom);
    termAppend(`You see exits: ${exitList}.`, 'term-dim');

    // ğŸŒ€ Check for town portal exit in this room
    checkTownExit(nextRoom);

    // ğŸª¤ Check for traps
    triggerRoomTrap(nextRoom);

    // ğŸ’¾ AUTO-SAVE after moving in dungeon
    saveGame();

    // ğŸ”‘ update buttons for new room
    renderDungeonActionBar();
}

// Build the exit string including ladder directions
function buildExitList(room) {
    const exits = Object.keys(room.exits || {}).map(d => d.toUpperCase());
    if (room.contents && room.contents.ladder) {
        exits.push(room.contents.ladder.direction === 'up' ? 'â¬† UP' : 'â¬‡ DOWN');
    }
    // Mark locked exits
    if (room.contents && room.contents.doors) {
        return exits.map(d => {
            const dl = d.toLowerCase();
            const door = room.contents.doors[dl];
            if (door && door.locked) {
                return `${d}<span style="color:#e8b84a">ğŸ”’</span>`;
            }
            return d;
        }).join(', ') || 'none';
    }
    return exits.length ? exits.join(', ') : 'none';
}

// Return the CSS color for a door type (matches dungeon editor palette)
function getDoorColor(type) {
    const DOOR_COLORS = {
        bronze:   '#cd7f32',
        copper:   '#b87333',
        iron:     '#a8a9ad',
        brass:    '#b5a642',
        silver:   '#c0c0c0',
        electrum: '#d4af37',
        ruby:     '#e0455b',
        topaz:    '#ffa07a',
        diamond:  '#aef0ff',
        obsidian: '#9b59b6',
        bone:     '#e8dcc8'
    };
    return DOOR_COLORS[type] || '#aaa';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRAP SYSTEM â€” triggers when player enters a room with a trap
// Supports both old singular (room.contents.trap) and new array
// (room.contents.traps[]) format from dungeon editor.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function triggerRoomTrap(room) {
    if (!room || !room.contents) return;
    const p = gameState.player;
    if (!p) return;

    // Build trap list â€” support both old (.trap) and new (.traps[]) formats
    let traps = [];
    if (room.contents.traps && Array.isArray(room.contents.traps)) {
        traps = room.contents.traps;                  // new array format
    } else if (room.contents.trap) {
        traps = [room.contents.trap];                 // old single-trap format
    }

    if (!traps.length) return;

    traps.forEach(trap => {
        if (!trap || !trap.type) return;

        // resetOnLeave = re-arm when player leaves (new format); no field = one-shot legacy
        const resetable = (trap.resetOnLeave === true);
        const dotType   = (trap.type === 'poison' || trap.type === 'acid');

        // Skip if already triggered and not resetable (one-shot spent)
        if (trap.triggered && !resetable && !dotType) return;

        const damage = trap.damage || 0;
        const name   = trap.name   || trap.type;

        switch (trap.type) {

            case 'spike':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`âš ï¸ <span style="color:#FF4444;">SPIKE TRAP!</span> Sharp spikes shoot from the floor â€” you take <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'stone':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`âš ï¸ <span style="color:#AA8866;">STONE TRAP!</span> A massive stone swings from the ceiling â€” you take <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'poison': {
                // DOT: damage spread over duration (default 10s, 5 ticks)
                const duration = trap.duration || 10;
                const ticks = 5;
                const tickInterval = Math.max(1000, (duration * 1000) / ticks);
                const tickDmg = Math.max(1, Math.ceil(damage / ticks));
                termAppend(`â˜ ï¸ <span style="color:#44FF44;">POISON TRAP!</span> Toxic gas floods the room â€” you feel your strength seeping away!`, 'term-error');
                let t = 0;
                const timer = setInterval(() => {
                    if (!gameState.player || t >= ticks) { clearInterval(timer); return; }
                    gameState.player.hp = Math.max(1, gameState.player.hp - tickDmg);
                    termAppend(`â˜ ï¸ Poison deals <strong>${tickDmg}</strong> damage... (${gameState.player.hp}/${gameState.player.maxHp} HP)`, 'term-error');
                    updateHud(); t++;
                }, tickInterval);
                break;
            }

            case 'acid': {
                // Acid: instant damage + short DOT
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`ğŸ§ª <span style="color:#a8e63d;">ACID TRAP!</span> Acid spray burns you â€” <strong>${damage} damage!</strong>`, 'term-error');
                const acidDuration = trap.duration || 5;
                const acidTicks = 3;
                const acidInterval = Math.max(500, (acidDuration * 1000) / acidTicks);
                const acidTickDmg = Math.max(1, Math.ceil(damage * 0.4 / acidTicks));
                let at = 0;
                const acidTimer = setInterval(() => {
                    if (!gameState.player || at >= acidTicks) { clearInterval(acidTimer); return; }
                    gameState.player.hp = Math.max(1, gameState.player.hp - acidTickDmg);
                    termAppend(`ğŸ§ª Acid burns for <strong>${acidTickDmg}</strong> more damage...`, 'term-error');
                    updateHud(); at++;
                }, acidInterval);
                if (!resetable) trap.triggered = true;
                break;
            }

            case 'fire':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`ğŸ”¥ <span style="color:#FF8800;">FIRE TRAP!</span> Flames erupt from hidden vents â€” you take <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'lightning':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`âš¡ <span style="color:#FFDD00;">LIGHTNING TRAP!</span> A bolt of lightning strikes you â€” <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'arrow':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`ğŸ¹ <span style="color:#CCCC44;">ARROW TRAP!</span> A crossbow bolt catches you off guard â€” you take <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'freeze':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`â„ï¸ <span style="color:#88CCFF;">FREEZE TRAP!</span> A burst of ice envelops you â€” you take <strong>${damage} damage</strong> and feel sluggish!`, 'term-error');
                if (gameState.combatState && gameState.combatState.pipTimers) {
                    gameState.combatState.pipTimers = gameState.combatState.pipTimers.map(t => t + 8);
                }
                if (!resetable) trap.triggered = true;
                break;

            case 'pit':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`ğŸ•³ï¸ <span style="color:#95a5a6;">PIT TRAP!</span> The floor gives way! You fall hard â€” <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'alarm':
                termAppend(`ğŸ”” <span style="color:#dfe6e9;">ALARM TRAP!</span> A deafening bell rings out â€” nearby monsters are alerted!`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'web':
                termAppend(`ğŸ•¸ï¸ <span style="color:#b2bec3;">WEB TRAP!</span> Sticky strands bind your limbs â€” you're slowed for 2 rounds!`, 'term-error');
                // Disable movement pip for 2 recovery cycles
                if (gameState.combatState && gameState.combatState.pipTimers) {
                    gameState.combatState.pipTimers = gameState.combatState.pipTimers.map(t => t + 5);
                }
                if (!resetable) trap.triggered = true;
                break;

            case 'curse':
                termAppend(`ğŸŒ€ <span style="color:#a855f7;">CURSE TRAP!</span> Dark energy courses through you â€” your stats are reduced!`, 'term-error');
                // Temporarily reduce attack by 20% for the session
                if (p.curseStacks === undefined) p.curseStacks = 0;
                p.curseStacks = Math.min(3, p.curseStacks + 1);
                if (!resetable) trap.triggered = true;
                break;

            default:
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`âš ï¸ <span style="color:#FF4444;">TRAP!</span> A ${name} catches you â€” you take <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
        }
    });

    updateHud();
}


function getEnemyInRoom(roomId) {
    const ds = gameState.dungeon;
    if (!ds || !ds.activeEnemies) return null;

    return ds.activeEnemies.find(enemy => enemy.currentRoom === roomId) || null;
}



function checkEnemiesInRoom(roomId) {
    const ds = gameState.dungeon;
    if (!ds || !ds.activeEnemies) return;

    // Find enemy in current room
    const enemyHere = ds.activeEnemies.find(e => e.currentRoom === roomId);
    
    if (enemyHere) {
        // AUTO-ENGAGE COMBAT!
        termAppend(
            `âš”ï¸ <strong>${enemyHere.name}</strong> confronts you!`,
            'term-warning'
        );
        
        // Start combat with this dungeon enemy
        startDungeonCombat(enemyHere);
    }
}

function startDungeonCombat(dungeonEnemy) {
    // Use the enemy's monsterId to start combat
    if (!dungeonEnemy.monsterId) {
        console.error('Dungeon enemy missing monsterId:', dungeonEnemy);
        return;
    }
    
    // Start normal combat using the monsterId
    startCombat([dungeonEnemy.monsterId]);
    
    // Link combat to dungeon enemy for persistence
    if (gameState.combatState) {
        gameState.combatState.dungeonEnemyId = dungeonEnemy.id;
        
        // If this enemy has saved HP, restore it to the combat monster
        if (dungeonEnemy.hp !== undefined && dungeonEnemy.hp < dungeonEnemy.maxHp) {
            const monster = gameState.combatState.monsters[0];
            if (monster) {
                monster.hp = dungeonEnemy.hp;
                monster.maxHp = dungeonEnemy.maxHp;
                console.log(`Restored dungeon enemy HP: ${monster.hp}/${monster.maxHp}`);
            }
        }
    }
    
    // ğŸ’¾ Save combat state
    saveGame();
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TEMP: DUNGEON TEST HARNESS (SAFE)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function returnToTown(townId) {
    console.log('â¬… returnToTown() called');

    // Clear dungeon state
    gameState.dungeon = null;
    gameState.combatState = null;
    gameState.postCombatRecovery = false;

    if (gameState.combatTimer) {
        clearInterval(gameState.combatTimer);
        gameState.combatTimer = null;
    }

    // Update current town if specified
    if (townId) gameState.currentTown = townId;

    document.body.classList.remove("terminal-mode");
    termClear();

    const ab = document.getElementById('actionBar');
    ab.innerHTML = '';

    gameState._terminalOpen = false;
    gameState._currentExploreArea = null;

    saveGame();
    showTown();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHECK TOWN EXIT FLAG IN DUNGEON ROOMS
// When a room has flags.townExit, show a portal button to that town.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function checkTownExit(room) {
    if (!room || !room.flags || !room.flags.townExit) return;
    const townId = room.flags.townExit;
    const label  = room.flags.townExitLabel || `Exit to ${townId}`;
    const firstDiscovery = room.flags.firstDiscovery;

    // Special first-discovery logic: award White Runestone
    if (firstDiscovery && townId === 'town2') {
        const p = gameState.player;
        if (!p.runestones) p.runestones = [];
        if (!p.runestones.includes('white_runestone')) {
            p.runestones.push('white_runestone');
            if (!p.achievements) p.achievements = [];
            p.achievements.push({ id: 'white_runestone', name: 'White Runestone', earned: Date.now() });

            termAppend('', 'term-separator');
            termAppend('âœ¦ <span style="color:#FFFFFF;font-weight:bold;">WHITE RUNESTONE</span> âœ¦', 'term-highlight');
            termAppend('You have discovered Ashen Harbor! A pale runestone materializes in your hand.', 'term-loot');
            termAppend('The Portal network is now accessible from both towns.', 'term-dim');
            termAppend('', 'term-separator');

            // Don't trigger again
            room.flags.firstDiscovery = false;
            saveGame();
        }
    }

    // Post a clickable portal message in the terminal
    setTimeout(() => {
        termAppend(
            `<span style="color:#AA88FF;cursor:pointer;font-weight:bold;" onclick="townExitFromDungeon('${townId}')">` +
            `[ ${label} ]</span>`,
            'term-highlight'
        );
    }, 300);
}

// Called when player clicks the town exit link from a dungeon room
function townExitFromDungeon(townId) {
    const townDef = (typeof TOWNS !== 'undefined' && TOWNS[townId]) ? TOWNS[townId] : null;
    const townName = townDef ? townDef.name : townId;
    if (confirm(`Leave the dungeon and travel to ${townName}?`)) {
        returnToTown(townId);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LEAVE EXPLORATION TO TOWN (allowed when pips are full)
// Enemies are preserved via activeCombat save system
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function leaveExploreToTown() {
    const cs = gameState.combatState;
    if (cs) {
        const allReady = cs.pipAvailable && cs.pipAvailable.every(x => x);
        if (!allReady) {
            termAppend('<span style="color:var(--error-color);">âš  You must wait for all pips to recover before leaving!</span>');
            return;
        }
        // Enemies are preserved â€” activeCombat will save them
    }

    // Clear timers but NOT combatState (save will capture it)
    if (gameState.combatTimer) {
        clearInterval(gameState.combatTimer);
        gameState.combatTimer = null;
    }

    // Stop resting timers
    stopResting();

    document.body.classList.remove("terminal-mode");
    document.getElementById('actionBar').innerHTML = '';
    gameState._terminalOpen = false;
    gameState._currentExploreArea = null;

    saveGame();  // Saves activeCombat with enemies still alive
    showTown();
}

function testDungeon() {
    // Legacy redirect â€” use town1's dungeon
    startDungeon('Dungeon1');
}



const BASE_PIP_COOLDOWN = 10;
const MIN_PIP_COOLDOWN = 5;

// â”€â”€ PIP SWEEP BUTTON ANIMATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Called each tick to update the conic-gradient overlay on Attack/Spell btns.
// Uses total "worst" pip state: sweep = fraction of the longest cooling pip.
function updatePipButtons() {
    const cs = gameState.combatState;
    if (!cs || !cs.pipTimers) return;

    const cd     = gameState.player ? getPipCooldown(gameState.player) : BASE_PIP_COOLDOWN;
    const total  = cs.pipTimers.length;
    const ready  = cs.pipAvailable.filter(Boolean).length;
    const cooling = total - ready;

    // Fraction complete = 1 means "fully cooled" (no overlay)
    // We show the cooldown of the pip that will recover SOONEST (smallest remaining)
    let pct = 1; // default = ready (no overlay)
    if (cooling > 0) {
        // Find the minimum remaining timer among cooling pips
        let minRemaining = Infinity;
        for (let i = 0; i < total; i++) {
            if (!cs.pipAvailable[i]) {
                minRemaining = Math.min(minRemaining, cs.pipTimers[i]);
            }
        }
        // pct = fraction ALREADY elapsed (so sweep goes from full â†’ empty as timer counts down)
        pct = 1 - (minRemaining / cd);
        pct = Math.max(0, Math.min(1, pct));
    }

    // For multi-pip, the dial wraps: each full rotation = one pip recovery
    // We rotate based on: (pips already recovered this cycle) + current pip fraction
    // Visual: dial spins continuously once per pip cooldown duration
    const revolutionsLeft = cooling;  // each remaining pip = one more sweep
    // conic-gradient percentage = fraction of current pip elapsed
    const pipPct = (pct * 100).toFixed(1) + '%';

    // Update all pip-btn elements
    document.querySelectorAll('.pip-btn').forEach(btn => {
        btn.style.setProperty('--pip-pct', pipPct);
        if (cooling > 0) {
            btn.classList.add('cooling');
            btn.classList.remove('all-ready');
            // Show pip badge if >1 pip cooling
            let badge = btn.querySelector('.pip-badge');
            if (cooling > 1) {
                if (!badge) { badge = document.createElement('span'); badge.className='pip-badge'; btn.appendChild(badge); }
                badge.textContent = cooling + 'Ã—';
            } else if (badge) {
                badge.remove();
            }
        } else {
            btn.style.setProperty('--pip-pct', '0%');
            btn.classList.remove('cooling');
            btn.classList.add('all-ready');
            const badge = btn.querySelector('.pip-badge');
            if (badge) badge.remove();
        }
    });
}

function getPipCooldown(player){
    // Base is always 10s for all classes regardless of class speed stat.
    // Only active speed_boost buff potions reduce pip recovery time.
    let cooldown = BASE_PIP_COOLDOWN;

    // Check for active speed_boost buff (from speed potions only)
    if (player.buffs) {
        const speedBuff = player.buffs.find(b => b.type === 'speed_boost');
        if (speedBuff) {
            // speedBuff.power is a percentage bonus (e.g. 25 = 25% faster)
            const reduction = Math.floor(cooldown * (speedBuff.power / 100));
            cooldown -= reduction;
        }
    }

    return Math.max(MIN_PIP_COOLDOWN, cooldown);
}



function selectEnemyIntent(enemy) {
    // Default / basic attack
    let intent = {
        type: 'basic',
        damageMult: 1,
        armorPiercing: 0,
        telegraph: 'prepares to strike...'
    };

    // Bosses and elites sometimes wind up a heavy hit
    if (enemy.isBoss && Math.random() < 0.4) {
        intent = {
            type: 'heavy',
            damageMult: 1.75,
            armorPiercing: 0.3,
            telegraph: 'draws in power for a devastating attack!'
        };
    }

    return intent;
}


function consumePips(cs, amount, cooldown) {
    let used = 0;

    for (let i = 0; i < cs.pipAvailable.length && used < amount; i++) {
        if (cs.pipAvailable[i]) {
            cs.pipAvailable[i] = false;
            cs.pipTimers[i] = cooldown;
            used++;
        }
    }
}




        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DAMAGE SCALING (Rebalanced for harder early game)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const DAMAGE_SCALING = {
            // Reduce player starting damage by 30%
            playerStarterWeaponMult: 0.7,
            // Increase monster damage by 30%
            monsterDamageMult: 1.3
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ENEMY DODGE CALCULATION - Based on level difference
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function calculateEnemyDodge(playerLevel, enemyLevel) {
            const levelDiff = enemyLevel - playerLevel;
            
            // Base dodge: 5% when levels are equal
            let dodgeChance = 0.05;
            
            if (levelDiff > 0) {
                // Enemy is higher level: +5% dodge per level difference
                dodgeChance += (levelDiff * 0.05);
            } else if (levelDiff < 0) {
                // Player is higher level: -1% dodge per level difference
                dodgeChance += (levelDiff * 0.01); // levelDiff is negative, so this subtracts
            }
            
            // Cap at 0% minimum (can't go negative)
            dodgeChance = Math.max(0, dodgeChance);
            
            // Cap at 50% maximum (so it's not impossible to hit)
            dodgeChance = Math.min(0.50, dodgeChance);
            
            return dodgeChance;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // LEVEL-SCALING DAMAGE MODIFIER
        // Per level enemy is ABOVE player: player deals -5%, takes +5%
        // Per level enemy is BELOW player: player deals +5%, takes -5%
        // Capped at Â±50%.
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function getLevelDamageMult(playerLevel, enemyLevel) {
            const diff = (enemyLevel || 1) - (playerLevel || 1);
            const PCT  = 0.05;
            const CAP  = 0.50;
            const shift = Math.max(-CAP, Math.min(CAP, diff * PCT));
            return {
                playerDealt: Math.max(0.1, 1 - shift),  // enemy higher â†’ player deals less
                enemyDealt:  Math.max(0.5, 1 + shift)   // enemy higher â†’ player takes more
            };
        }
        
        function calculateDamage({
  attacker,
  defender,
  base,
  type = 'physical', // 'physical' | 'magic'
  critChance = 0,
  critMult = 1.5,
  dodgeChance = 0,
  armorPiercing = 0,
  isSpecial = false
}) {
  // Dodge check
  if (Math.random() < dodgeChance) {
    return { damage: 0, dodged: true, crit: false };
  }

  // Base damage roll
  let damage = base;

  // Defense mitigation
  let defense =
    type === 'magic'
      ? (defender.magicDefense || 0)
      : (defender.defense || 0);

  defense *= (1 - armorPiercing);
  damage = Math.max(1, Math.floor(damage - defense));

  // Crit check
  let crit = false;
  if (Math.random() < critChance) {
    damage = Math.floor(damage * critMult);
    crit = true;
  }

  return { damage, dodged: false, crit };
}

        
     function executeAttack(attackType) {
    const cs = gameState.combatState;
    if (!cs) return;

    const p  = gameState.player;
    const ti = cs.currentTarget;
    const enemy = cs.monsters[ti];
    let weapon = WEAPONS[p.weapon];
    
    // Safety check: if weapon doesn't exist, use a default weapon
    if (!weapon) {
        console.error(`âŒ Weapon '${p.weapon}' not found in WEAPONS! Using default weapon.`);
        p.weapon = 'iron_sword'; // Default to iron sword
        weapon = WEAPONS[p.weapon];
        if (!weapon) {
            termAppend('ERROR: No weapons available! Please contact sysop.', 'term-error');
            return;
        }
    }
    
    const qBonus = getQualityBonus(weapon.quality, weapon.baseDamage);

    // Determine pip cost and damage multiplier
    let pipCost = 1;
    let damageMultiplier = 1;
    let attackName = 'attacks';
    let armorPiercing = 0;

    if (attackType === 'normal') {
        pipCost = 1;
    } 
    else if (attackType === 'heavy') {
        // HIGH RISK / HIGH REWARD: costs 2 pips, 35% miss chance, but hits for 3x damage
        pipCost = 2;
        damageMultiplier = 3.0;
        attackName = 'winds up a <span style="color:#FF8800;">HEAVY STRIKE</span>';
        armorPiercing = 0.35;
    } 
    else if (attackType === 'special') {
        const availablePips = cs.pipAvailable.filter(x => x).length;
        pipCost = availablePips;
        damageMultiplier = 1 + (availablePips * 0.5);
        attackName = `unleashes a <span style="color:#FFD700;">â­ SPECIAL ATTACK â­</span> (${availablePips} pips)`;
        armorPiercing = 0.3;
    }

    // Check pip availability
    const availablePips = cs.pipAvailable.filter(x => x).length;
    if (availablePips < pipCost) {
        termAppend('Not enough attack charges!', 'term-error');
        return;
    }

    // Consume pips
    consumePips(cs, pipCost, getPipCooldown(p));
    markMpAction();  // reset 15s MP regen countdown on every attack
    
    // Always reset action mode to main - whether the attack hits or dodges,
    // the player should see the main combat menu (with updated pips)
    cs.actionMode = 'main';
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ROGUE: SHADOW STRIKE - Guaranteed crit from stealth
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let shadowStrike = false;
    const baseClass = p.baseClass || p.class;
    if (baseClass === 'rogue' && p.shadowStrikeReady) {
        shadowStrike = true;
        p.shadowStrikeReady = false;
        
        // Clear the timer
        if (p.shadowStrikeTimer) {
            clearTimeout(p.shadowStrikeTimer);
            p.shadowStrikeTimer = null;
        }
        
        termAppend('', 'term-separator');
        termAppend('âš« <span style="color:#8888FF;font-weight:bold;">You leap from the shadows!</span> âš«', 'term-highlight');
    }

    // Calculate base damage WITH RANGE ROLLING
    // Roll between baseDamage and maxDamage
    const minDmg = weapon.baseDamage + qBonus;
    const maxDmg = (weapon.maxDamage || weapon.baseDamage) + qBonus;
    let weaponDamage = Math.floor(Math.random() * (maxDmg - minDmg + 1)) + minDmg;

    if (p.level <= 5) {
        weaponDamage = Math.floor(
            weaponDamage * DAMAGE_SCALING.playerStarterWeaponMult
        );
    }

    const physicalBase =
        weaponDamage + (p.strength || 0) + (p.str || 0);

    const magicBase =
        (weapon.baseMagicDamage + qBonus) +
        Math.floor((p.magic || 0) / 2);

    let totalBase = Math.floor(
        (physicalBase + magicBase) * damageMultiplier
    );

    const classMult = getClassDamageMultiplier(p);
    totalBase = Math.floor(totalBase * classMult);

    // Calculate enemy dodge chance based on level difference
    const enemyDodgeChance = calculateEnemyDodge(p.level, enemy.level);

    // â”€â”€ HEAVY ATTACK: extra 35% miss chance on top of dodge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (attackType === 'heavy' && Math.random() < 0.35) {
        termAppend(
            `You ${attackName} but overswing and <span style="color:#ff8c00;">MISS!</span>`,
            'term-warning'
        );
        updateEnemyCards();
        updateHud();
        renderActionBar();
        return;
    }

    // â”€â”€ LEVEL SCALING: player damage modifier â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const lvlMult = getLevelDamageMult(p.level, enemy.level);
    totalBase = Math.max(1, Math.floor(totalBase * lvlMult.playerDealt));

    // Resolve damage
    const result = calculateDamage({
        attacker: p,
        defender: enemy,
        base: totalBase,
        type: magicBase > physicalBase ? 'magic' : 'physical',
        critChance: shadowStrike ? 1.0 : (calcCritChance(p.lck || 0, p) / 100),  // 100% crit if Shadow Strike
        dodgeChance: enemyDodgeChance, // Use level-based dodge
        armorPiercing
    });

    const tName = cs.monsters.length > 1
        ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${ti + 1}</span>`
        : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;

    if (result.dodged) {
        termAppend(
            `You ${attackName} but ${tName} <span style="color:#88ff88;">DODGES!</span>`
        );
    } 
    else {
        const critTag = result.crit
            ? ' <span style="color:#FFD700;">â˜… CRITICAL HIT!</span>'
            : '';

        // Apply weapon modifiers (elemental damage, status effects, lifesteal)
        const modifierResult = applyWeaponModifiers(p, enemy, result.damage, weapon);
        const finalDamage = modifierResult.totalDamage;
        
        enemy.hp -= finalDamage;
        
        // Check for poison chance on daggers (Venom Spike, Serpent's Tooth, etc.)
        if (weapon.poisonChance && Math.random() < weapon.poisonChance && enemy.hp > 0) {
            applyStatusEffect(enemy, 'poisoned', false);
            modifierResult.messages.push('<span style="color:#00FF00;">ğŸ’€ Poisoned!</span>');
        }

        // Calculate condition text
        const hpPct = Math.max(0, (enemy.hp / enemy.maxHp) * 100);
        let condition = 'healthy';
        if (hpPct < 75) condition = 'injured';
        if (hpPct < 50) condition = 'wounded';
        if (hpPct < 25) condition = 'severely wounded';
        if (hpPct < 10) condition = 'barely standing';

        termAppend(
            `You ${attackName} ${tName} for <span class="dmg-enemy">${finalDamage} damage!</span>${critTag}`,
            null,
            () => {
                // Show modifier messages
                modifierResult.messages.forEach(msg => {
                    termAppend(`â†’ ${msg}`, 'term-loot');
                });

                if (enemy.hp > 0) {
                    termAppend(
                        `â†’ ${tName} is <span style="color:#8aaa8a;">${condition}</span>`,
                        'term-dim'
                    );
                }

                updateEnemyCards();
                updateHud();
                renderActionBar();
                checkCombatEnd();
            }
        );
    }

    // Immediate UI update for responsiveness
    updateEnemyCards();
    updateHud();
    renderActionBar();
}



       // Legacy function kept for compatibility
       function playerAttack() {
    executeAttack('normal');
}

        


            function showSpellMenu() {
            const cs = gameState.combatState;
            if (!cs) return;
            const anyAvail = cs.pipAvailable && cs.pipAvailable.some(x => x);
            if (!anyAvail) return;
            const p = gameState.player;
            if (p.knownSpells.length === 0) {
                termAppend('You have no spells!', 'term-error');
                renderActionBar();
                return;
            }
            
            cs.actionMode = 'spell_list';
            renderActionBar();
        }




            function castSpellOnTarget(spell) {
            const p  = gameState.player;
            const cs = gameState.combatState;
            const spellKey = cs.pendingSpellKey;
            
            if (p.mp < spell.mpCost) {
                termAppend('Not enough MP!', 'term-error');
                return;
            }
            

// --- Pip check for spells ---
const availablePips = cs.pipAvailable.filter(x => x).length;

if (availablePips < (spell.pipCost || 1)) {
    termAppend('Not enough spell charges!', 'term-error');
    return;
}

// Consume spell pips
consumePips(cs, spell.pipCost || 1, getPipCooldown(p));



            p.mp -= spell.mpCost;
            markMpAction();  // reset 15s MP regen countdown on every spell cast

            if (spell.type === 'heal') {
                const heal = spell.power + Math.floor(p.magic * 1.5) + (p.wis || 0);
                p.hp = Math.min(p.maxHp, p.hp + heal);
                updateHud();
                renderActionBar();
                termAppend(`You cast ${spell.name} and restore <span style="color:#88ff88;">${heal} HP!</span>`);
            } else if (spell.type === 'aoe_damage') {
                // AOE DAMAGE - Hit all enemies for reduced damage each
                const monsters = cs.monsters;
                let totalDamage = 0;
                let hitCount = 0;
                
                termAppend(`You cast ${spell.name}!`, 'term-highlight');
                termAppend(`<span style="color:#FF8800;">ğŸ”¥ AREA OF EFFECT! ğŸ”¥</span>`, 'term-victory');
                
                // Check if fire spell for burning
                const spellName = spell.name.toLowerCase();
                const isFire = spellName.includes('fire') || spellName.includes('flame') || 
                               spellName.includes('burn') || spellName.includes('pyro') || 
                               spellName.includes('inferno') || spellName.includes('ember');
                
                monsters.forEach((enemy, i) => {
                    if (enemy.hp > 0) {
                        // Calculate enemy dodge chance
                        const enemyDodgeChance = calculateEnemyDodge(p.level, enemy.level);
                        
                        const tName = monsters.length > 1
                            ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${i+1}</span>`
                            : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;
                        
                        // Check if enemy dodges
                        if (Math.random() < enemyDodgeChance) {
                            termAppend(`â†’ ${tName} <span style="color:#88ff88;">DODGES!</span>`);
                            return; // Skip this enemy
                        }
                        
                        // SPELL DAMAGE WITH WIDE RANGE ROLLING (each enemy rolls independently!)
                        const minPower = spell.minPower || spell.power;
                        const maxPower = spell.maxPower || spell.power;
                        const spellRoll = Math.floor(Math.random() * (maxPower - minPower + 1)) + minPower;
                        
                        let dmg = Math.max(1, (spellRoll + p.magic + (p.wis || 0)) - Math.floor(enemy.defense / 2));
                        let crit = false;
                        if (Math.random() * 100 < calcCritChance(p.lck || 0, p)) { 
                            dmg = Math.floor(dmg * 1.75); 
                            crit = true; 
                        }
                        
                        enemy.hp -= dmg;
                        totalDamage += dmg;
                        hitCount++;
                        
                        const critTag = crit ? ' <span style="color:#FFD700;">â˜… CRIT!</span>' : '';
                        termAppend(`â†’ ${tName} takes <span class="dmg-enemy">${dmg} damage!</span>${critTag}`);
                        
                        // Apply burning to each enemy hit (AOE fire spells)
                        if (isFire && Math.random() < 0.5 && enemy.hp > 0) { // 50% chance per target
                            applyStatusEffect(enemy, 'burning', false);
                        }
                    }
                });
                
                termAppend(`<span style="color:#FFD700;">Total: ${totalDamage} damage to ${hitCount} ${hitCount === 1 ? 'enemy' : 'enemies'}!</span>`, 'term-loot');
                checkCombatEnd();
                updateEnemyCards();
                updateHud();
                renderActionBar();
            } else if (spell.type === 'lifesteal') {
                // LIFESTEAL - damage enemy and heal yourself
                const ti = cs.currentTarget;
                const enemy = cs.monsters[ti];
                
                // Calculate enemy dodge chance
                const enemyDodgeChance = calculateEnemyDodge(p.level, enemy.level);
                
                const tName = cs.monsters.length > 1
                    ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${ti+1}</span>`
                    : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;
                
                // Check if enemy dodges
                if (Math.random() < enemyDodgeChance) {
                    termAppend(`You cast ${spell.name} but ${tName} <span style="color:#88ff88;">DODGES!</span>`);
                    updateEnemyCards();
                    updateHud();
                    cs.actionMode = 'main';
                    cs.pendingSpellKey = null;
                    renderActionBar();
                    return;
                }
                
                // SPELL DAMAGE WITH WIDE RANGE ROLLING
                const minPower = spell.minPower || spell.power;
                const maxPower = spell.maxPower || spell.power;
                const spellRoll = Math.floor(Math.random() * (maxPower - minPower + 1)) + minPower;
                
                let dmg = Math.max(1, (spellRoll + p.magic + (p.wis || 0)) - Math.floor(enemy.defense / 2));
                let crit = false;
                if (Math.random() * 100 < calcCritChance(p.lck || 0, p)) { dmg = Math.floor(dmg * 1.75); crit = true; }
                
                enemy.hp -= dmg;
                
                // Heal based on lifesteal percentage
                const lifestealPercent = spell.lifestealPercent || 50;
                const healAmount = Math.floor(dmg * (lifestealPercent / 100));
                p.hp = Math.min(p.maxHp, p.hp + healAmount);
                
                const critTag = crit ? ' <span style="color:#FFD700;">â˜… CRIT!</span>' : '';
                termAppend(`You cast ${spell.name} on ${tName} for <span class="dmg-enemy">${dmg} damage!</span>${critTag}`, null, () => {
                    termAppend(`<span style="color:#00FF00;">ğŸ©¸ Drained ${healAmount} HP!</span>`, 'term-loot');
                    if (enemy.hp > 0) {
                        const hpPct = Math.max(0, (enemy.hp / enemy.maxHp) * 100);
                        let condition = 'healthy';
                        if (hpPct < 75) condition = 'injured';
                        if (hpPct < 50) condition = 'wounded';
                        if (hpPct < 25) condition = 'severely wounded';
                        if (hpPct < 10) condition = 'barely standing';
                        termAppend(`â†’ ${tName} is <span style="color:#8aaa8a;">${condition}</span>`, 'term-dim');
                    }
                    checkCombatEnd();
                });
            } else {
                // REGULAR DAMAGE SPELL
                const ti    = cs.currentTarget;
                const enemy = cs.monsters[ti];
                
                // Calculate enemy dodge chance based on level difference
                const enemyDodgeChance = calculateEnemyDodge(p.level, enemy.level);
                
                // Check if enemy dodges the spell
                if (Math.random() < enemyDodgeChance) {
                    const tName = cs.monsters.length > 1
                        ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${ti+1}</span>`
                        : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;
                    termAppend(`You cast ${spell.name} but ${tName} <span style="color:#88ff88;">DODGES!</span>`);
                    updateEnemyCards();
                    updateHud();
                    cs.actionMode = 'main';
                    cs.pendingSpellKey = null;
                    renderActionBar();
                    return;
                }
                
                // SPELL DAMAGE WITH WIDE RANGE ROLLING
                const minPower = spell.minPower || spell.power;
                const maxPower = spell.maxPower || spell.power;
                const spellRoll = Math.floor(Math.random() * (maxPower - minPower + 1)) + minPower;
                
                let   dmg   = Math.max(1, (spellRoll + p.magic + (p.wis||0)) - Math.floor(enemy.defense / 2));
                let crit = false;
                if (Math.random()*100 < calcCritChance(p.lck||0, p)) { dmg = Math.floor(dmg*1.75); crit = true; }
                enemy.hp -= dmg;
                
                // Check for spell status effects (burning from fire spells, etc.)
                const spellName = spell.name.toLowerCase();
                if ((spellName.includes('fire') || spellName.includes('flame') || spellName.includes('burn') || 
                     spellName.includes('pyro') || spellName.includes('inferno') || spellName.includes('ember')) && 
                    Math.random() < 0.5) { // 50% chance
                    enemy.statusToApply = 'burning';
                } else if ((spellName.includes('ice') || spellName.includes('frost') || spellName.includes('frozen')) && 
                           Math.random() < 0.4) { // 40% chance
                    enemy.statusToApply = 'frozen';
                } else if (spellName.includes('lightning') && Math.random() < 0.2) { // 20% chance
                    enemy.statusToApply = 'stunned';
                } else if (spellName.includes('shadow') && Math.random() < 0.3) { // 30% chance
                    enemy.statusToApply = 'blinded';
                }
                
                const tName = cs.monsters.length > 1
                    ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${ti+1}</span>`
                    : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;
              
                const critTag = crit ? ' <span style="color:#FFD700;">â˜… CRIT!</span>' : '';
                const hpPct = Math.max(0, (enemy.hp / enemy.maxHp) * 100);
                let condition = 'healthy';
                if (hpPct < 75) condition = 'injured';
                if (hpPct < 50) condition = 'wounded';
                if (hpPct < 25) condition = 'severely wounded';
                if (hpPct < 10) condition = 'barely standing';
                termAppend(`You cast ${spell.name} on ${tName} for <span class="dmg-enemy">${dmg} damage!</span>${critTag}`, null, () => {
                    // Apply status effect if flagged
                    if (enemy.statusToApply && enemy.hp > 0) {
                        applyStatusEffect(enemy, enemy.statusToApply, false);
                        enemy.statusToApply = null;
                    }
                    
                    if (enemy.hp > 0) {
                        termAppend(`â†’ ${tName} is <span style="color:#8aaa8a;">${condition}</span>`, 'term-dim');
                    }
                    checkCombatEnd();
                });
            }
              updateEnemyCards();
                updateHud();
            
            // Reset to main combat menu after spell cast
            cs.actionMode = 'main';
            cs.pendingSpellKey = null;
            renderActionBar();
        }

        // Legacy function for backward compatibility
        function castSpell(spellKey) {
            const spell = SPELLS[spellKey];
            castSpellOnTarget(spell);
        }

        function playerDefend() {
            const cs = gameState.combatState;
            if (!cs || cs.hitsLeft <= 0) return;
            cs.defending = true;
            cs.hitsLeft  = 0;            // end player's turn
            renderActionBar();
            termAppend('You brace for impactâ€¦');  // timer keeps ticking â†’ enemy phase
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SHOW PLAYER STATS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function showPlayerStats() {
            const p = gameState.player;
            if (!p) return;
            
            termAppend('', 'term-separator');
            termAppend('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'term-highlight');
            termAppend(`ğŸ“Š CHARACTER STATS - ${p.name.toUpperCase()}`, 'term-highlight');
            termAppend('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'term-highlight');
            termAppend('');
            
            // Basic Info
            const className = p.hasEvolved ? getAdvancedClassName(p) : (p.className || p.class);
            termAppend(`<span style="color:var(--highlight-color);">Name:</span> ${p.name}`);
            termAppend(`<span style="color:var(--highlight-color);">Class:</span> ${className} ${p.hasEvolved ? '<span style="color:#FFD700;">âš¡ (Evolved)</span>' : ''}`);
            termAppend(`<span style="color:var(--highlight-color);">Level:</span> ${p.level}`);
            termAppend('');
            
            // Resources
            termAppend(`<span style="color:#ff6666;">â¤ï¸  HP:</span> ${p.hp} / ${p.maxHp}`);
            termAppend(`<span style="color:#4488ff;">âœ¨ MP:</span> ${p.mp} / ${p.maxMp}`);
            termAppend(`<span style="color:#FFD700;">ğŸ’° Gold:</span> ${p.gold}g`);
            termAppend(`<span style="color:var(--text-color);">â­ XP:</span> ${p.xp} / ${p.xpToNext} (${Math.floor((p.xp / p.xpToNext) * 100)}%)`);
            termAppend('');
            
            // Combat Stats
            termAppend('<span style="color:var(--highlight-color);">â•â•â• COMBAT STATS â•â•â•</span>');
            
            // Primary Stats (D&D style if they exist)
            if (p.str !== undefined) {
                termAppend(`<span style="color:#FF8800;">STR:</span> ${p.str} (Strength)`);
                termAppend(`<span style="color:#00FF88;">DEX:</span> ${p.dex} (Dexterity)`);
                termAppend(`<span style="color:#8888FF;">WIS:</span> ${p.wis} (Wisdom)`);
                termAppend(`<span style="color:#FF88FF;">CHA:</span> ${p.cha} (Charisma)`);
                termAppend(`<span style="color:#FFAA00;">CON:</span> ${p.con} (Constitution)`);
                termAppend(`<span style="color:#FFD700;">LCK:</span> ${p.lck} (Luck)`);
                termAppend('');
            }
            
            // Legacy stats
            if (p.strength !== undefined) {
                termAppend(`<span style="color:#FF8800;">Strength:</span> ${p.strength}`);
                termAppend(`<span style="color:#00AAFF;">Defense:</span> ${p.defense}`);
                termAppend(`<span style="color:#8888FF;">Magic:</span> ${p.magic}`);
                termAppend(`<span style="color:#00FF88;">Speed:</span> ${p.speed}`);
                termAppend('');
            }
            
            // Derived Stats
            const weapon = WEAPONS[p.weapon];
            const armor = ARMOR[p.armor];
            const weaponDmg = weapon ? `${weapon.baseDamage}-${weapon.maxDamage || weapon.baseDamage}` : '0';
            const weaponMag = weapon && weapon.baseMagicDamage ? `+${weapon.baseMagicDamage}` : '';
            const armorDef = armor ? armor.baseDefense : 0;
            
            termAppend(`<span style="color:#FF4444;">âš”ï¸  Weapon Damage:</span> ${weaponDmg} ${weaponMag}`);
            termAppend(`<span style="color:#4444FF;">ğŸ›¡ï¸  Armor Defense:</span> ${armorDef}`);
            termAppend(`<span style="color:#FFD700;">ğŸ¯ Crit Chance:</span> ${calcCritChance(p.lck || 0, p)}%`);
            
            // Rogue Shadow Strike status
            const baseClass = p.baseClass || p.class;
            if (baseClass === 'rogue') {
                if (p.shadowStrikeReady) {
                    termAppend(`<span style="color:#8888FF;">ğŸŒ‘ Shadow Strike:</span> READY! (Next attack guaranteed crit)`);
                } else {
                    termAppend(`<span style="color:#666666;">ğŸŒ‘ Shadow Strike:</span> On cooldown (activate after 5s out of combat)`);
                }
            }
            
            // Class damage multiplier if evolved
            if (p.hasEvolved) {
                const dmgMult = getClassDamageMultiplier(p);
                termAppend(`<span style="color:#FFD700;">âš¡ Damage Multiplier:</span> ${dmgMult}x (Class Evolution)`);
            }
            
            termAppend('');
            
            // Equipment
            termAppend('<span style="color:var(--highlight-color);">â•â•â• EQUIPMENT â•â•â•</span>');
            termAppend(`<span style="color:#FFD700;">Weapon:</span> ${weapon ? weapon.name : 'None'}`);
            termAppend(`<span style="color:#4488FF;">Armor:</span> ${armor ? armor.name : 'None'}`);
            termAppend('');
            
            // Active Buffs
            if (p.activeBuffs && Object.keys(p.activeBuffs).length > 0) {
                termAppend('<span style="color:var(--highlight-color);">â•â•â• ACTIVE BUFFS â•â•â•</span>');
                for (const [buffType, buff] of Object.entries(p.activeBuffs)) {
                    if (Date.now() < buff.endTime) {
                        const timeLeft = Math.ceil((buff.endTime - Date.now()) / 1000);
                        const minutes = Math.floor(timeLeft / 60);
                        const seconds = timeLeft % 60;
                        const timeStr = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                        
                        let buffName = buffType.replace('buff_', '').toUpperCase();
                        termAppend(`<span style="color:#00FF88;">âœ¨ ${buffName}:</span> +${buff.power} (${timeStr})`);
                    }
                }
                termAppend('');
            }
            
            // Progress
            termAppend('<span style="color:var(--highlight-color);">â•â•â• PROGRESSION â•â•â•</span>');
            termAppend(`<span style="color:#FFD700;">Defeated Masters:</span> ${p.defeatedMasters?.length || 0}`);
            termAppend(`<span style="color:#4488FF;">Unlocked Areas:</span> ${p.unlockedAreas?.length || 0}`);
            termAppend(`<span style="color:#FF8800;">Known Spells:</span> ${p.knownSpells?.length || 0}`);
            termAppend(`<span style="color:#00FF88;">Inventory Items:</span> ${p.inventory?.length || 0}`);
            
            termAppend('');
            termAppend('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'term-highlight');
        }

        function attemptFlee() {
            const cs = gameState.combatState;
            if (!cs) return;
            
            // find first available pip
            let pipIndex = -1;
            for (let i = 0; i < cs.pipAvailable.length; i++) {
                if (cs.pipAvailable[i]) {
                    pipIndex = i;
                    break;
                }
            }
            if (pipIndex === -1) return;

            clearInterval(gameState.combatTimer);
            const p        = gameState.player;
            const fleePct  = Math.min(70, 30 + (p.dex||0)*3);
            if (Math.random()*100 < fleePct) {
                gameState.combatState = null;
                termAppend('You successfully fled!', 'term-highlight', () => {
                    renderActionBar();
                });
            } else {
                cs.pipAvailable[pipIndex] = false;
                cs.pipTimers[pipIndex] = gameState.player ? getPipCooldown(gameState.player) : BASE_PIP_COOLDOWN;
                renderActionBar();
                termAppend('Failed to escape!', 'term-error');
                startCombatTimer();
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // POTION MENU (in action bar)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function showPotionMenu() {
            const cs = gameState.combatState;
            if (!cs) return;
            const p = gameState.player;
            const inDungeon = !!gameState.dungeon;
            const potions = {};
            p.inventory.forEach(ik => {
                const item = ITEMS[ik];
                if (!item) return;
                const isRecall = item.subtype === 'recall';
                // recall only available outside combat (cs exists here so block it)
                if (isRecall) return;
                if (
                    ['heal_hp','heal_mp','full_restore'].includes(item.subtype) ||
                    item.subtype?.startsWith('buff_')
                ) {
                    if (!potions[ik]) potions[ik] = { item: item, count: 0 };
                    potions[ik].count++;
                }
            });
            const keys = Object.keys(potions);
            if (keys.length === 0) {
                termAppend('You have no potions!', 'term-error');
                renderActionBar();
                return;
            }
            
            // Set action mode for potion menu
            cs.actionMode = 'potion_list';
            
            const ab = document.getElementById('actionBar');
            let html = '<div style="color:var(--highlight-color);font-size:10px;margin-bottom:4px;">USE POTION (No pip cost!):</div>';
            html += '<div style="display:flex;flex-wrap:wrap;gap:4px;max-width:100%;justify-content:flex-start;">';
            keys.forEach(pk => {
                const pd  = potions[pk];
                const item = pd.item;
                
                // Color based on potion type
                let col = '#00FF00';
                if (item.subtype === 'recall') col = '#AA88FF';
                else if (item.subtype === 'heal_hp') col = '#ff4444';
                else if (item.subtype === 'heal_mp') col = '#4488ff';
                else if (item.subtype === 'full_restore') col = '#FFD700';
                else if (item.subtype === 'buff_str') col = '#FF8800';
                else if (item.subtype === 'buff_def') col = '#00AAFF';
                else if (item.subtype === 'buff_xp') col = '#FFD700';
                else if (item.subtype === 'buff_gold') col = '#FFD700';
                else if (item.subtype === 'buff_magic') col = '#8888FF';
                else if (item.subtype === 'buff_damage') col = '#FF0000';
                else if (item.subtype === 'buff_invuln') col = '#AAAAAA';
                else if (item.subtype === 'buff_luck') col = '#FFAA00';
                else if (item.subtype === 'buff_regen') col = '#00FF88';
                else if (item.subtype === 'buff_speed') col = '#00FF00';
                else if (item.subtype === 'buff_crit') col = '#FF00FF';
                
                // Icon based on potion type
                let icon = 'ğŸ§ª';
                if (item.subtype === 'recall') icon = 'ğŸŒ€';
                else if (item.subtype === 'heal_hp') icon = 'â¤ï¸';
                else if (item.subtype === 'heal_mp') icon = 'ğŸ’™';
                else if (item.subtype === 'full_restore') icon = 'âœ¨';
                else if (item.subtype === 'buff_str') icon = 'ğŸ’ª';
                else if (item.subtype === 'buff_def') icon = 'ğŸ›¡ï¸';
                else if (item.subtype === 'buff_xp') icon = 'â­';
                else if (item.subtype === 'buff_gold') icon = 'ğŸ’°';
                else if (item.subtype === 'buff_magic') icon = 'ğŸ”®';
                else if (item.subtype === 'buff_damage') icon = 'âš”ï¸';
                else if (item.subtype === 'buff_invuln') icon = 'ğŸ—¿';
                else if (item.subtype === 'buff_luck') icon = 'ğŸ€';
                else if (item.subtype === 'buff_regen') icon = 'ğŸ’š';
                else if (item.subtype === 'buff_speed') icon = 'âš¡';
                else if (item.subtype === 'buff_crit') icon = 'ğŸ¯';
                
                html += `<button onclick="usePotion('${pk}')" style="
                    color:${col};
                    border-color:${col};
                    background:var(--secondary-bg);
                    padding:4px 6px;
                    min-width:70px;
                    max-width:90px;
                    height:auto;
                    font-size:11px;
                    text-align:center;
                    cursor:pointer;
                    border:1px solid ${col};
                    flex:0 0 auto;
                    white-space:nowrap;
                    overflow:hidden;
                    text-overflow:ellipsis;
                ">
                    ${icon} ${item.name.substring(0, 12)}${item.name.length > 12 ? '...' : ''} x${pd.count}
                </button>`;
            });
            html += `<button onclick="renderActionBar();" style="
                padding:4px 8px;
                min-width:60px;
                background:var(--secondary-bg);
                border:1px solid var(--border-color);
                color:var(--text-color);
                cursor:pointer;
                font-size:11px;
                flex:0 0 auto;
            ">âŒ Back</button>`;
            html += '</div>';
            ab.innerHTML = html;
        }

        function usePotion(potionKey) {
            const potion = ITEMS[potionKey];
            const p      = gameState.player;
            let msg;

            // â”€â”€ Recall Potion â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (potion.subtype === 'recall') {
                if (!gameState.dungeon) {
                    termAppend('<span style="color:#ff8800;">âš  Recall Potions only work inside dungeons!</span>');
                    renderActionBar();
                    return;
                }
                if (gameState.combatState) {
                    termAppend('<span style="color:#ff4444;">âš  You cannot recall while in combat! Defeat or flee your enemies first.</span>');
                    renderActionBar();
                    return;
                }
                // Consume and recall
                const idx = p.inventory.indexOf(potionKey);
                if (idx !== -1) p.inventory.splice(idx, 1);
                updateHud();
                const dest = gameState.currentTown || 'town1';
                termAppend(`<span style="color:#AA88FF;">ğŸŒ€ The Recall Potion dissolves in your hand â€” a swirling portal opens beneath you...</span>`);
                termAppend(`<span style="color:#AA88FF;">You are swept away to safety!</span>`);
                setTimeout(() => {
                    gameState.dungeon      = null;
                    gameState.combatState  = null;
                    if (gameState.combatTimer) { clearInterval(gameState.combatTimer); gameState.combatTimer = null; }
                    document.getElementById('actionBar').innerHTML = '';
                    document.body.classList.remove('terminal-mode');
                    gameState._terminalOpen = false;
                    saveGame();
                    showTown(dest);
                }, 1800);
                return;
            }

            if (potion.subtype === 'heal_hp') {
                const actual = Math.min(p.maxHp - p.hp, potion.power);
                p.hp = Math.min(p.maxHp, p.hp + potion.power);
                msg = `Used ${potion.name} â€“ restored <span style="color:#88ff88;">${actual} HP!</span>`;
            } else if (potion.subtype === 'heal_mp') {
                const actual = Math.min(p.maxMp - p.mp, potion.power);
                p.mp = Math.min(p.maxMp, p.mp + potion.power);
                msg = `Used ${potion.name} â€“ restored <span style="color:#88ff88;">${actual} MP!</span>`;
            } else if (potion.subtype === 'full_restore') {
                const hpR = p.maxHp - p.hp, mpR = p.maxMp - p.mp;
                p.hp = p.maxHp; p.mp = p.maxMp;
                msg = `Used ${potion.name} â€“ fully restored <span style="color:#88ff88;">${hpR} HP & ${mpR} MP!</span>`;
            } else if (potion.subtype === 'buff_xp') {
                // XP Boost buff
                applyBuff(p, 'xp_boost', potion.duration || 900000, potion.power); // 15 min default
                msg = `Used ${potion.name} â€“ <span style="color:#FFD700;">+${potion.power}% XP for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_str') {
                // Strength buff
                applyBuff(p, 'strength_boost', potion.duration || 300000, potion.power); // 5 min default
                msg = `Used ${potion.name} â€“ <span style="color:#FF8800;">+${potion.power} Strength for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_def') {
                // Defense buff
                applyBuff(p, 'defense_boost', potion.duration || 300000, potion.power); // 5 min default
                msg = `Used ${potion.name} â€“ <span style="color:#00AAFF;">+${potion.power} Defense for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_crit') {
                // Crit chance buff
                applyBuff(p, 'crit_boost', potion.duration || 300000, potion.power); // 5 min default
                msg = `Used ${potion.name} â€“ <span style="color:#FFD700;">+${potion.power}% Crit Chance for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_speed') {
                // Speed buff (faster pip regen)
                applyBuff(p, 'speed_boost', potion.duration || 300000, potion.power); // 5 min default
                msg = `Used ${potion.name} â€“ <span style="color:#00FF00;">+${potion.power}% Attack Speed for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_gold') {
                // Gold boost buff
                applyBuff(p, 'gold_boost', potion.duration || 900000, potion.power);
                msg = `Used ${potion.name} â€“ <span style="color:#FFD700;">+${potion.power}% Gold for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_magic') {
                // Magic buff
                applyBuff(p, 'magic_boost', potion.duration || 300000, potion.power);
                msg = `Used ${potion.name} â€“ <span style="color:#8888FF;">+${potion.power} Magic for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_damage') {
                // Damage boost buff
                applyBuff(p, 'damage_boost', potion.duration || 180000, potion.power);
                msg = `Used ${potion.name} â€“ <span style="color:#FF0000;">+${potion.power}% Damage for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_invuln') {
                // Damage reduction buff
                applyBuff(p, 'damage_reduction', potion.duration || 120000, potion.power);
                msg = `Used ${potion.name} â€“ <span style="color:#AAAAAA;">+${potion.power}% Damage Resist for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_luck') {
                // Luck buff
                applyBuff(p, 'luck_boost', potion.duration || 600000, potion.power);
                msg = `Used ${potion.name} â€“ <span style="color:#FFD700;">+${potion.power} Luck for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_regen') {
                // Regeneration buff
                applyBuff(p, 'regen_boost', potion.duration || 300000, potion.power);
                msg = `Used ${potion.name} â€“ <span style="color:#00FF88;">+${potion.power} HP/sec for ${(potion.duration/60000)} minutes!</span>`;
            }
            const idx = p.inventory.indexOf(potionKey);
            if (idx !== -1) p.inventory.splice(idx, 1);
            updateHud();
            
            // Reset to main combat menu after using potion
            const cs = gameState.combatState;
            if (cs) {
                cs.actionMode = 'main';
            }
            
            renderActionBar();
            termAppend(msg);   // no callback â€“ timer keeps ticking, player can still act
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUFF SYSTEM - Temporary stat boosts from potions
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function applyBuff(player, buffType, duration, power) {
            if (!player.activeBuffs) player.activeBuffs = {};
            
            // If buff already active, extend duration and stack power
            if (player.activeBuffs[buffType]) {
                const existing = player.activeBuffs[buffType];
                clearTimeout(existing.timer);
                existing.power = Math.min(existing.power + power, power * 3); // Cap at 3x
                existing.endTime = Date.now() + duration;
            } else {
                player.activeBuffs[buffType] = {
                    power: power,
                    endTime: Date.now() + duration
                };
            }
            
            // Set timer to remove buff
            player.activeBuffs[buffType].timer = setTimeout(() => {
                delete player.activeBuffs[buffType];
                termAppend(`<span style="color:#888;">Your ${buffType.replace('_', ' ')} has worn off.</span>`, 'term-dim');
            }, duration);
        }
        
        function getActiveBuff(player, buffType) {
            if (!player.activeBuffs || !player.activeBuffs[buffType]) return 0;
            const buff = player.activeBuffs[buffType];
            if (Date.now() > buff.endTime) {
                delete player.activeBuffs[buffType];
                return 0;
            }
            return buff.power;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // POTION MENU - EXPLORATION (Out of Combat)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function showPotionMenuExplore() {
            const p = gameState.player;
            const ab = document.getElementById('actionBar');
            const inDungeon = !!gameState.dungeon;
            
            // Count all usable potions (healing + buffs + recall if in dungeon)
            const potions = {};
            p.inventory.forEach(ik => {
                const item = ITEMS[ik];
                if (!item) return;
                const isRecall = item.subtype === 'recall';
                if (isRecall && !inDungeon) return; // recall only usable in dungeon
                if (
                    isRecall ||
                    ['heal_hp','heal_mp','full_restore'].includes(item.subtype) ||
                    item.subtype?.startsWith('buff_')
                ) {
                    if (!potions[ik]) potions[ik] = { item, count: 0 };
                    potions[ik].count++;
                }
            });
            
            const keys = Object.keys(potions);
            if (keys.length === 0) {
                ab.innerHTML = `
                    <div style="color:var(--error-color);font-size:10px;margin-bottom:4px;">You have no potions!</div>
                    <button onclick="renderActionBar()">â† BACK</button>
                `;
                return;
            }
            
            // Color + icon lookup (mirrors combat potion menu)
            function potionColor(subtype) {
                if (subtype==='recall') return '#AA88FF';
                if (subtype==='heal_hp') return '#ff4444';
                if (subtype==='heal_mp') return '#4488ff';
                if (subtype==='full_restore') return '#FFD700';
                if (subtype==='buff_str') return '#FF8800';
                if (subtype==='buff_def') return '#00AAFF';
                if (subtype==='buff_xp') return '#FFD700';
                if (subtype==='buff_gold') return '#FFD700';
                if (subtype==='buff_magic') return '#8888FF';
                if (subtype==='buff_damage') return '#FF0000';
                if (subtype==='buff_invuln') return '#AAAAAA';
                if (subtype==='buff_luck') return '#FFAA00';
                if (subtype==='buff_regen') return '#00FF88';
                if (subtype==='buff_speed') return '#00FF00';
                if (subtype==='buff_crit') return '#FF00FF';
                return '#00FF00';
            }
            function potionIcon(subtype) {
                if (subtype==='recall') return 'ğŸŒ€';
                if (subtype==='heal_hp') return 'â¤ï¸';
                if (subtype==='heal_mp') return 'ğŸ’™';
                if (subtype==='full_restore') return 'âœ¨';
                if (subtype==='buff_str') return 'ğŸ’ª';
                if (subtype==='buff_def') return 'ğŸ›¡ï¸';
                if (subtype==='buff_xp') return 'â­';
                if (subtype==='buff_gold') return 'ğŸ’°';
                if (subtype==='buff_magic') return 'ğŸ”®';
                if (subtype==='buff_damage') return 'âš”ï¸';
                if (subtype==='buff_invuln') return 'ğŸ—¿';
                if (subtype==='buff_luck') return 'ğŸ€';
                if (subtype==='buff_regen') return 'ğŸ’š';
                if (subtype==='buff_speed') return 'âš¡';
                if (subtype==='buff_crit') return 'ğŸ¯';
                return 'ğŸ§ª';
            }

            let html = `<div style="color:var(--highlight-color);font-size:10px;margin-bottom:4px;">USE POTION (HP: ${p.hp}/${p.maxHp} | MP: ${p.mp}/${p.maxMp}):</div>`;
            html += `<div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:flex-start;">`;
            
            keys.forEach(pk => {
                const pd  = potions[pk];
                const col = potionColor(pd.item.subtype);
                const icon = potionIcon(pd.item.subtype);
                const atFull = (pd.item.subtype === 'heal_hp' && p.hp >= p.maxHp) ||
                               (pd.item.subtype === 'heal_mp' && p.mp >= p.maxMp) ||
                               (pd.item.subtype === 'full_restore' && p.hp >= p.maxHp && p.mp >= p.maxMp);
                const shortName = pd.item.name.length > 12 ? pd.item.name.substring(0,12)+'â€¦' : pd.item.name;
                html += `<button onclick="usePotionExplore('${pk}')" ${atFull ? 'disabled' : ''} style="
                    color:${col}; border:1px solid ${col};
                    background:var(--secondary-bg);
                    padding:4px 6px; min-width:70px; max-width:90px;
                    font-size:11px; flex:0 0 auto;
                    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
                    opacity:${atFull ? 0.4 : 1};
                ">${icon} ${shortName} x${pd.count}</button>`;
            });
            
            html += `<button onclick="renderActionBar()" style="
                padding:4px 8px; min-width:60px; flex:0 0 auto;
                background:var(--secondary-bg); border:1px solid var(--border-color);
                color:var(--text-color); font-size:11px;">âŒ Back</button>`;
            html += `</div>`;
            ab.innerHTML = html;
        }
        
        function usePotionExplore(potionKey) {
            const potion = ITEMS[potionKey];
            const p = gameState.player;
            
            // â”€â”€ Recall Potion â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (potion.subtype === 'recall') {
                if (!gameState.dungeon) {
                    termAppend('<span style="color:#ff8800;">âš  Recall Potions only work inside dungeons!</span>');
                    return;
                }
                const idx2 = p.inventory.indexOf(potionKey);
                if (idx2 !== -1) p.inventory.splice(idx2, 1);
                updateHud();
                const dest = gameState.currentTown || 'town1';
                termAppend(`<span style="color:#AA88FF;">ğŸŒ€ The Recall Potion dissolves in your hand â€” a swirling portal opens beneath you...</span>`);
                termAppend(`<span style="color:#AA88FF;">You are swept away to safety!</span>`);
                setTimeout(() => {
                    gameState.dungeon      = null;
                    gameState.combatState  = null;
                    if (gameState.combatTimer) { clearInterval(gameState.combatTimer); gameState.combatTimer = null; }
                    document.getElementById('actionBar').innerHTML = '';
                    document.body.classList.remove('terminal-mode');
                    gameState._terminalOpen = false;
                    saveGame();
                    showTown(dest);
                }, 1800);
                return;
            }

            let msg;
            if (potion.subtype === 'heal_hp') {
                const actual = Math.min(p.maxHp - p.hp, potion.power);
                if (actual === 0) {
                    msg = `You're already at full HP!`;
                } else {
                    p.hp = Math.min(p.maxHp, p.hp + potion.power);
                    msg = `Used ${potion.name} â€“ restored <span style="color:#88ff88;">${actual} HP!</span>`;
                }
            } else if (potion.subtype === 'heal_mp') {
                const actual = Math.min(p.maxMp - p.mp, potion.power);
                if (actual === 0) {
                    msg = `You're already at full MP!`;
                } else {
                    p.mp = Math.min(p.maxMp, p.mp + potion.power);
                    msg = `Used ${potion.name} â€“ restored <span style="color:#88ff88;">${actual} MP!</span>`;
                }
            } else if (potion.subtype === 'full_restore') {
                const hpR = p.maxHp - p.hp;
                const mpR = p.maxMp - p.mp;
                if (hpR === 0 && mpR === 0) {
                    msg = `You're already fully restored!`;
                } else {
                    p.hp = p.maxHp;
                    p.mp = p.maxMp;
                    msg = `Used ${potion.name} â€“ fully restored <span style="color:#88ff88;">${hpR} HP & ${mpR} MP!</span>`;
                }
            }
            
            // Remove potion from inventory
            const idx = p.inventory.indexOf(potionKey);
            if (idx !== -1) p.inventory.splice(idx, 1);
            
            updateHud();
            termAppend(msg);
            
            // Refresh potion menu to show updated counts
            showPotionMenuExplore();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ENEMY ATTACK
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       function enemyAttackSingle() {
    // Enemy uses ONE charge, attacks once, then resets its own timer
    const cs       = gameState.combatState;
    const monsters = cs.monsters;
    const p        = gameState.player;

    // Defensive stats
    let armor = ARMOR[p.armor];
    
    // Safety check: if armor doesn't exist, use default armor
    if (!armor) {
        console.error(`âŒ Armor '${p.armor}' not found in ARMOR! Using default armor.`);
        p.armor = 'leather_vest'; // Default to leather vest
        armor = ARMOR[p.armor];
        if (!armor) {
            console.error('âŒ CRITICAL: No armor available!');
            armor = { baseDefense: 0, quality: 'poor' }; // Emergency fallback
        }
    }
    
    const qBonus = getQualityBonus(armor.quality, armor.baseDefense);
    let totalDef   = p.defense + armor.baseDefense + qBonus + (p.con || 0);

    if (cs.defending) {
        totalDef *= 2;
        cs.defending = false;
    }

    // Pull intent (or fallback)
    const intent = cs.enemyIntent || {
        type: 'basic',
        damageMult: 1,
        armorPiercing: 0
    };

    // Each monster in the pack gets ONE hit
    const hits = [];

    monsters.forEach((enemy, i) => {
        const eName = monsters.length > 1
            ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${i + 1}</span>`
            : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;

        // God mode bypass
        if (p.godMode) {
            hits.push({ eName, godMode: true });
            return;
        }

        // Level scaling: enemy deals more/less based on level gap
        const _lvlMult = getLevelDamageMult(p.level, enemy.level);
        const _scaledBase = Math.max(1,
            Math.floor(enemy.damage * intent.damageMult * DAMAGE_SCALING.monsterDamageMult * _lvlMult.enemyDealt)
        );

        const result = calculateDamage({
            attacker: enemy,
            defender: {
                defense: totalDef,
                magicDefense: totalDef
            },
            base: _scaledBase,
            type: enemy.magicAttack ? 'magic' : 'physical',
            dodgeChance: calcDodgeChance(p.dex || 0) / 100,
            armorPiercing: intent.armorPiercing
        });

        if (result.dodged) {
            hits.push({ eName, dodged: true });
            return;
        }

        p.hp -= result.damage;

        // â”€â”€ Passive hooks (future-safe) â”€â”€
        // if (enemy.passives?.includes('lifedrain')) {
        //     enemy.hp = Math.min(enemy.maxHp, enemy.hp + Math.floor(result.damage * 0.3));
        // }

        hits.push({
            eName,
            dmg: result.damage,
            crit: result.crit
        });
    });

    updateHud();

    // After attack messages stream, reset enemy timer and resume
    const afterAttack = () => {
        cs.enemyIntent = null; // clear intent after execution

        if (p.hp <= 0 && !p.godMode) {
            endCombat(false);
        } else {
            cs.enemyTimer = cs.enemyDelay;
            renderActionBar();
            startCombatTimer();
        }
    };

    hits.forEach((hit, i) => {
        const isLast = (i === hits.length - 1);

        if (hit.godMode) {
            termAppend(
                `${hit.eName} attacks but you are <span class="term-highlight">INVINCIBLE!</span>`,
                null,
                isLast ? afterAttack : null
            );
        } else if (hit.dodged) {
            termAppend(
                `${hit.eName} attacksâ€¦ <span style="color:#88ff88;">DODGED!</span>`,
                null,
                isLast ? afterAttack : null
            );
        } else {
            const critTag = hit.crit
                ? ' <span style="color:#FFD700;">â˜… CRIT!</span>'
                : '';

            termAppend(
                `${hit.eName} attacks for <span class="dmg-player">${hit.dmg} damage!</span>${critTag}`,
                null,
                isLast ? afterAttack : null
            );
        }
    });
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHECK / END COMBAT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function checkCombatEnd() {
    const cs = gameState.combatState;
    if (!cs || !cs.monsters || cs.monsters.length === 0) return;

    let ti = cs.currentTarget;

    // Clamp target index (important after splicing)
    if (ti < 0 || ti >= cs.monsters.length) {
        cs.currentTarget = 0;
        ti = 0;
    }

    const target = cs.monsters[ti];
    if (!target) return;

    if (!cs.defeatedMonsters) cs.defeatedMonsters = [];

    if (target.hp <= 0) {
        const dead = target;

        // Calculate rewards for THIS enemy immediately
        const baseXp = dead.xp || (dead.level * 10);
        const baseGold = dead.gold || (dead.level * 5);
        
        termAppend(
            `<span style="color:${dead.rarityColor};">${dead.name}</span> has been defeated!`,
            'term-victory'
        );
        
        // Show individual rewards immediately
        termAppend(`Gained <span style="color:#FFD700;">${baseXp} XP</span> and <span style="color:#FFD700;">${baseGold} Gold!</span>`, 'term-loot');
        
        // Apply rewards immediately
        const p = gameState.player;
        p.xp += baseXp;
        p.gold += baseGold;
        
        // Check for level up
        if (p.xp >= p.xpToNext) {
            levelUp();
            termAppend(`<span style="color:var(--highlight-color);font-size:18px;">â¬†ï¸ LEVEL UP! You are now level ${p.level}!</span>`, 'term-victory');
            termAppend(`<span style="color:#FFD700;">+3 Stat Points! </span><span style="color:#00FFFF;">â†’ Spend them at CHARACTER STATS in town.</span>`, 'term-loot');
        }
        
        // Add to defeated list and remove from active combat
        cs.defeatedMonsters.push(dead);
        cs.monsters.splice(ti, 1);

        // Adjust target after removal
        if (cs.currentTarget >= cs.monsters.length) {
            cs.currentTarget = Math.max(0, cs.monsters.length - 1);
        }

        // Update cards and HUD immediately
        updateEnemyCards();
        updateHud();
        
        // Check if all enemies dead
        if (cs.monsters.length === 0) {
            // All enemies dead - end combat
            // Don't give rewards again in endCombat
            cs.rewardsAlreadyGiven = true;
            endCombat(true);
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// END COMBAT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function endCombat(victory) {

    // â”€â”€ defeat â”€â”€
    if (!victory) {
        clearInterval(gameState.combatTimer);
        gameState.combatTimer = null;

        const p = gameState.player;
        const inDungeon = !!gameState.dungeon;

        // Restore HP/MP
        p.hp = p.maxHp;
        p.mp = p.maxMp;

        if (inDungeon) {
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // HARSH DUNGEON DEATH PENALTY
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // Lose 10% of TOTAL XP earned
            const currentLevelXp = getXpForLevel(p.class, p.level);
            const totalXpEarned = currentLevelXp + p.xp;
            const xpLost = Math.floor(totalXpEarned * 0.10);
            
            // Calculate new total XP
            let newTotalXp = totalXpEarned - xpLost;
            if (newTotalXp < 0) newTotalXp = 0;
            
            // Find new level based on XP
            let newLevel = 1;
            for (let lvl = 25; lvl >= 1; lvl--) {
                if (newTotalXp >= getXpForLevel(p.class, lvl)) {
                    newLevel = lvl;
                    break;
                }
            }
            
            const levelsLost = p.level - newLevel;
            
            // Apply level loss
            if (levelsLost > 0) {
                for (let i = 0; i < levelsLost; i++) {
                    p.level--;
                    
                    // Reduce stats from level loss
                    p.maxHp = Math.max(20, p.maxHp - 15 - (p.con || 0));
                    p.maxMp = Math.max(10, p.maxMp - 10);
                    p.strength = Math.max(1, p.strength - 2);
                    p.defense = Math.max(1, p.defense - 2);
                    p.magic = Math.max(1, p.magic - 2);
                    p.speed = Math.max(1, p.speed - 1);
                    
                    if (p.str !== undefined) {
                        p.str = Math.max(1, p.str - 1);
                        p.dex = Math.max(1, p.dex - 1);
                        p.wis = Math.max(1, p.wis - 1);
                        p.cha = Math.max(1, p.cha - 1);
                        p.con = Math.max(1, p.con - 1);
                        p.lck = Math.max(1, p.lck - 1);
                    }
                }
            }
            
            // Set XP to remainder after new level
            const newLevelBaseXp = getXpForLevel(p.class, newLevel);
            p.xp = newTotalXp - newLevelBaseXp;
            p.xpToNext = getXpToNextLevel(p.class, newLevel);
            
            // Ensure XP doesn't go negative
            if (p.xp < 0) p.xp = 0;
            
            // Lose ALL carried gold (bank is safe)
            const goldLost = p.gold;
            p.gold = 0;
            
            // Clear dungeon state - you're kicked out
            gameState.dungeon = null;
            
            gameState.combatState = null;
            gameState.postCombatRecovery = false;

            updateHud();
            
            // Dramatic death message
            let deathMsg = `<span style="color:var(--error-color);font-size:20px;">ğŸ’€ YOU HAVE DIED ğŸ’€</span><br><br>`;
            deathMsg += `<span style="color:#ff6666;">XP Lost: ${xpLost.toLocaleString()}</span><br>`;
            if (levelsLost > 0) {
                deathMsg += `<span style="color:#ff3333;">LEVELS LOST: ${levelsLost}!</span><br>`;
            }
            deathMsg += `<span style="color:#ffaa00;">Gold Lost: ${goldLost} (Bank is safe)</span><br><br>`;
            deathMsg += `<span style="color:#888;">You wake up in town, broken and defeated...</span>`;
            
            termAppend(deathMsg, 'term-error', () => {
                setTimeout(() => { 
                    closeTerminalView(); 
                    showTown();
                    // Auto-save the harsh penalty
                    saveGame();
                }, 3000);
            });
        } else {
            // Standard overworld death - just lose 50% gold
            p.gold = Math.floor(p.gold / 2);
            
            gameState.combatState = null;
            gameState.postCombatRecovery = false;

            updateHud();
            termAppend(
                'You have been defeatedâ€¦ You wake up in town.',
                'term-error',
                () => setTimeout(() => { closeTerminalView(); showTown(); }, 1200)
            );
        }
        return;
    }

    // â”€â”€ victory â”€â”€
    const defeated   = gameState.combatState.defeatedMonsters || [];
    const cs = gameState.combatState;
    const isMaster   = defeated.some(m => m.isMaster);
    let masterData   = null;
    let unlockedArea = null;

    if (isMaster) {
        const m = defeated.find(d => d.isMaster);
        masterData   = CLASS_MASTERS[m.masterKey];
        unlockedArea = masterData.unlocks;

        if (!gameState.player.defeatedMasters.includes(m.masterKey))
            gameState.player.defeatedMasters.push(m.masterKey);

        if (!gameState.player.unlockedAreas.includes(unlockedArea))
            gameState.player.unlockedAreas.push(unlockedArea);

        masterData.guaranteedDrops.forEach(ik => {
            if (!defeated[0].possibleDrops) defeated[0].possibleDrops = [];
            if (!defeated[0].possibleDrops.includes(ik))
                defeated[0].possibleDrops.push(ik);

            if (!defeated[0].dropRates) defeated[0].dropRates = {};
            defeated[0].dropRates[
                (WEAPONS[ik] || ARMOR[ik]) ? getItemQuality(ik) : 'common'
            ] = 1.0;
        });
    }

    // Check if rewards were already given during combat (multi-enemy)
    const rewardsAlreadyGiven = cs.rewardsAlreadyGiven;
    
    let totalXp = 0, totalGold = 0, allLoot = [];
    
    // Only calculate if NOT already given
    if (!rewardsAlreadyGiven) {
        defeated.forEach(e => {
            // Calculate XP based on level difference and rarity
            const xpReward = calculateXpReward(e, gameState.player.level);
            totalXp   += xpReward;
            totalGold += e.gold;
            allLoot    = allLoot.concat(rollLoot(e));
        });

        gameState.player.xp   += totalXp;
        gameState.player.gold += totalGold;
    } else {
        // Still roll for loot even if XP/gold already given
        defeated.forEach(e => {
            allLoot = allLoot.concat(rollLoot(e));
        });
    }

    // â”€â”€ Remove defeated dungeon enemy & award drop â”€â”€
    if (gameState.dungeon && gameState.combatState?.dungeonEnemyId) {
        const dungeonEnemyId = gameState.combatState.dungeonEnemyId;

        // Find the enemy before removing it so we can read its drop
        const defeatedDungeonEnemy = gameState.dungeon.activeEnemies.find(
            e => e.id === dungeonEnemyId
        );

        // Award the drop item if set
        if (defeatedDungeonEnemy && defeatedDungeonEnemy.drop) {
            const dropKey = defeatedDungeonEnemy.drop;
            if (dropKey && ITEMS[dropKey]) {
                gameState.player.inventory.push(dropKey);
                const dropItem = ITEMS[dropKey];
                const dropIcon = dropItem.icon || 'ğŸ“¦';
                const keyColor = dropItem.subtype === 'dungeon_key' ? '#e8b84a' : '#00FF88';
                termAppend(
                    `${dropIcon} <span style="color:${keyColor};">${dropItem.name}</span> found on the body!`,
                    'term-loot'
                );
            }
        }

        gameState.dungeon.activeEnemies = gameState.dungeon.activeEnemies.filter(
            e => e.id !== dungeonEnemyId
        );
        console.log(`ğŸ—‘ï¸ Removed dungeon enemy: ${dungeonEnemyId}`);
    }

    // â”€â”€ terminal output â”€â”€
    termAppend('', 'term-separator');

    if (isMaster) {
        termAppend(`ğŸ† ${masterData.name} HAS BEEN DEFEATED! ğŸ†`, 'term-victory');
        termAppend(`âœ¨ ${LOCATIONS[unlockedArea].name} IS NOW UNLOCKED! âœ¨`, 'term-loot');
    }

    if (defeated.length === 1) {
        termAppend(
            `You defeated <span style="color:${defeated[0].rarityColor};">${defeated[0].name}</span>!`,
            'term-highlight'
        );
    } else {
        termAppend(`You defeated ${defeated.length} enemies!`, 'term-highlight');
        defeated.forEach(e =>
            termAppend(`  â€¢ <span style="color:${e.rarityColor};">${e.name}</span>`)
        );
    }

    // Only show total XP/Gold if NOT already shown during combat
    if (!rewardsAlreadyGiven) {
        termAppend(
            `Gained <span style="color:#FFD700;">${totalXp} XP</span> and ` +
            `<span style="color:#FFD700;">${totalGold} Gold</span>!`
        );
    }

    if (allLoot.length > 0) {
        termAppend('âš¡ LOOT:', 'term-loot');
        allLoot.forEach(ik => {
            gameState.player.inventory.push(ik);
            termAppend(
                `  + <span style="color:${getItemColor(ik)};">${getItemName(ik)}</span>`,
                'term-loot'
            );
        });
    } else {
        termAppend('No items droppedâ€¦', 'term-dim');
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WEAPON DROPS! ğŸ—¡ï¸
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    defeated.forEach((monster, index) => {
        const weaponDrop = generateWeaponDrop(
            gameState.player, 
            monster.level, 
            monster.rarity || 'common'
        );
        
        if (weaponDrop) {
            // Add to WEAPONS object
            WEAPONS[weaponDrop.id] = weaponDrop;
            
            // Add to player inventory
            gameState.player.inventory.push(weaponDrop.id);
            
            // Show drop message with quality color
            const qualityColor = QUALITY_CONFIG[weaponDrop.quality].color;
            termAppend('', 'term-separator');
            termAppend(`ğŸ’ <span style="color:${qualityColor};font-size:18px;font-weight:bold;">WEAPON DROP!</span>`, 'term-victory');
            termAppend(`<span style="color:${qualityColor};">${weaponDrop.name}</span>`, 'term-loot');
            termAppend(`<span style="color:#8aaa8a;">Level ${weaponDrop.level} ${weaponDrop.quality} ${weaponDrop.type}</span>`, 'term-dim');
            termAppend(`<span style="color:#FFD700;">DMG: ${weaponDrop.baseDamage}-${weaponDrop.maxDamage}</span>`);
            
            // Show modifiers
            if (weaponDrop.modifiers && weaponDrop.modifiers.length > 0) {
                termAppend('<span style="color:#00FFFF;">Special Properties:</span>');
                weaponDrop.modifiers.forEach(modKey => {
                    const mod = WEAPON_MODIFIERS[modKey];
                    if (mod) {
                        let modText = `  â€¢ <span style="color:${mod.color};">${mod.name}`;
                        if (mod.minDamage) {
                            modText += ` (${mod.minDamage}-${mod.maxDamage} dmg)`;
                        }
                        if (mod.statusEffect) {
                            const status = STATUS_EFFECTS[mod.statusEffect];
                            modText += ` - ${Math.floor(mod.statusChance * 100)}% ${status.icon} ${status.name}`;
                        }
                        modText += `</span>`;
                        termAppend(modText, 'term-loot');
                    }
                });
            }
            termAppend('', 'term-separator');
        }
    });

    // Check for level-up (possibly multiple levels)
    while (gameState.player.xp >= gameState.player.xpToNext && gameState.player.level < 25) {
        levelUp();
        termAppend(`â¬†ï¸ LEVEL UP! You are now level ${gameState.player.level}!`, 'term-victory');
        termAppend(`<span style="color:#00FFFF;">+3 Stat Points! â†’ Spend them at CHARACTER STATS in town.</span>`, 'term-loot');
        
        // Check for class evolution announcement
        if (gameState.player._justEvolved) {
            termAppend('', 'term-separator');
            termAppend(`<span style="color:#FF00FF;font-size:24px;font-weight:bold;">âš¡ CLASS EVOLUTION! âš¡</span>`, 'term-victory');
            termAppend(gameState.player._evolutionMessage, 'term-victory');
            termAppend(`<span style="color:#FFD700;">Your power has DOUBLED!</span>`, 'term-loot');
            gameState.player._justEvolved = false;
            gameState.player._evolutionMessage = null;
        }
    }
    
    // Max level message
    if (gameState.player.level >= 25 && gameState.player.xp >= gameState.player.xpToNext) {
        termAppend(`ğŸŒŸ You have reached MAX LEVEL! (25)`, 'term-victory');
        gameState.player.xp = gameState.player.xpToNext; // Cap XP
    }

    updateHud();
    
    // ğŸ’¾ AUTO-SAVE after victory
    saveGame();

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // âœ… EXIT COMBAT, ENTER EXHAUSTION
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Mark combat as finished, but keep state for timers & UI
  cleanupCombatStatusEffects(); // Clear all DOT timers and status effects
gameState.combatState.combatOver = true;
gameState.postCombatRecovery = true;

    // Resume regeneration after combat (normal speed - you're still in the field)
    startMpRegen(false);
    startResting(false);

    const ab = document.getElementById('actionBar');
    
    // Check if we're in a dungeon
    if (gameState.dungeon) {
        // Dungeon handles its own buttons - just render them
        renderDungeonActionBar();
    } else if (isMaster) {
        ab.innerHTML = `
            <button onclick="tryViewWorldMap()">ğŸ—ºï¸ VIEW WORLD MAP</button>
            <button onclick="tryGoBackToTown()">ğŸ˜ï¸ RETURN TO TOWN</button>`;
        renderActionBar();
    } else {
        ab.innerHTML = `
            <button onclick="tryExploreLocation('${gameState.currentLocation}')">ğŸ” CONTINUE EXPLORING</button>
            <button onclick="tryGoBackToTown()">ğŸ˜ï¸ RETURN TO TOWN</button>`;
        renderActionBar();

        stabilizeTerminalLayout();
    }

    if (!gameState.combatTimer) {
        startCombatTimer();
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ROGUE: SHADOW STRIKE - Activate stealth after combat
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const p = gameState.player;
    const baseClass = p.baseClass || p.class;
    if (baseClass === 'rogue' && victory) {
        // Clear any existing timer
        if (p.shadowStrikeTimer) {
            clearTimeout(p.shadowStrikeTimer);
        }
        
        // Set 5-second timer for Shadow Strike
        p.shadowStrikeTimer = setTimeout(() => {
            p.shadowStrikeReady = true;
            termAppend('', 'term-separator');
            termAppend('ğŸŒ‘ You melt into the shadows... <span style="color:#8888FF;">[Shadow Strike Ready]</span>', 'term-highlight');
        }, 5000);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POST-COMBAT EXHAUSTION CHECK
// (used by navigation actions)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function continueDungeonExploration() {
    // Clear combat state and show dungeon navigation
    gameState.combatState = null;
    gameState.postCombatRecovery = false;
    
    // Clear combat timer
    if (gameState.combatTimer) {
        clearInterval(gameState.combatTimer);
        gameState.combatTimer = null;
    }
    
    // Return to dungeon navigation
    renderDungeonActionBar();
}

function playerIsExhausted() {
    if (!gameState.postCombatRecovery) return false;

    const cs = gameState.combatState;
    if (!cs || !cs.pipAvailable) return false;

    return cs.pipAvailable.some(p => !p);
}
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ADVANCED CLASS EVOLUTION (Level 20)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const ADVANCED_CLASSES = {
            warrior: {
                advancedClass: 'warlord',
                advancedName: 'Warlord',
                description: 'Master of all weapons and combat. Unstoppable in battle.',
                damageMultiplier: 2.0,
                bonusStats: { str: 10, con: 10, dex: 5 },
                newSpells: ['battle_fury', 'titan_strike'],
                announcement: 'âš”ï¸ You have mastered the art of war! You are now a WARLORD!'
            },
            rogue: {
                advancedClass: 'shadowmaster',
                advancedName: 'Shadowmaster',
                description: 'Master assassin who strikes from the void itself.',
                damageMultiplier: 2.5,
                bonusStats: { dex: 15, lck: 10, str: 5 },
                newSpells: ['shadow_strike', 'void_step'],
                announcement: 'ğŸ—¡ï¸ You have become one with the shadows! You are now a SHADOWMASTER!'
            },
            acolyte: {
                advancedClass: 'high_priest',
                advancedName: 'High Priest',
                description: 'Chosen of the divine, wielding ultimate holy power.',
                damageMultiplier: 2.0,
                bonusStats: { wis: 15, cha: 10, con: 5 },
                newSpells: ['divine_judgment', 'mass_resurrection', 'holy_nova'],
                announcement: 'âœ¨ The gods have chosen you! You are now a HIGH PRIEST!'
            },
            necrolyte: {
                advancedClass: 'lich',
                advancedName: 'Lich',
                description: 'Immortal master of death itself. Reality bends to your will.',
                damageMultiplier: 2.0,
                bonusStats: { wis: 15, magic: 10, con: 5 },
                newSpells: ['death_wave', 'summon_undead_army', 'soul_drain'],
                announcement: 'ğŸ’€ You have transcended mortality! You are now a LICH!'
            },
            archer: {
                advancedClass: 'deadeye',
                advancedName: 'Deadeye',
                description: 'Perfect marksman whose arrows never miss their mark.',
                damageMultiplier: 2.3,
                bonusStats: { dex: 15, lck: 10, str: 5 },
                newSpells: ['piercing_shot', 'rain_of_arrows'],
                announcement: 'ğŸ¹ Your aim is now perfect! You are now a DEADEYE!'
            },
            druid: {
                advancedClass: 'archdruid',
                advancedName: 'Archdruid',
                description: 'Master of nature and the primal forces of creation.',
                damageMultiplier: 2.0,
                bonusStats: { wis: 15, con: 10, str: 5 },
                newSpells: ['natures_wrath', 'wild_shape', 'earthquake'],
                announcement: 'ğŸŒ¿ Nature itself answers your call! You are now an ARCHDRUID!'
            },
            sorceror: {
                advancedClass: 'archmage',
                advancedName: 'Archmage',
                description: 'Master of all magic. Reality itself obeys your command.',
                damageMultiplier: 2.5,
                bonusStats: { wis: 20, magic: 15, cha: 5 },
                newSpells: ['apocalypse', 'time_stop', 'disintegrate'],
                announcement: 'ğŸ”® You have mastered all magic! You are now an ARCHMAGE!'
            },
            hunter: {
                advancedClass: 'beastlord',
                advancedName: 'Beastlord',
                description: 'Master of beasts and the wild. Animals bow to your command.',
                damageMultiplier: 2.2,
                bonusStats: { dex: 12, str: 8, con: 8, wis: 5 },
                newSpells: ['beast_stampede', 'primal_bond'],
                announcement: 'ğŸº All beasts obey you! You are now a BEASTLORD!'
            },
            rogue: {
                advancedClass: 'shadowmaster',
                advancedName: 'Shadowmaster',
                description: 'Master assassin who strikes from the void itself.',
                damageMultiplier: 2.5,
                bonusStats: { dex: 15, lck: 10, str: 5 },
                newSpells: ['shadow_strike', 'void_step'],
                announcement: 'ğŸ—¡ï¸ You have become one with the shadows! You are now a SHADOWMASTER!'
            },
            paladin: {
                advancedClass: 'crusader',
                advancedName: 'Crusader',
                description: 'Holy warrior blessed by the gods themselves.',
                damageMultiplier: 2.2,
                bonusStats: { str: 10, wis: 10, con: 8, cha: 5 },
                newSpells: ['holy_crusade', 'divine_shield', 'smite_evil'],
                announcement: 'âš¡ The heavens bless your crusade! You are now a CRUSADER!'
            },
            warlock: {
                advancedClass: 'demonlord',
                advancedName: 'Demonlord',
                description: 'Master of dark pacts who commands legions of demons.',
                damageMultiplier: 2.4,
                bonusStats: { wis: 18, cha: 12, con: 5 },
                newSpells: ['summon_demon', 'dark_pact', 'soul_harvest'],
                announcement: 'ğŸ˜ˆ You have bound demons to your will! You are now a DEMONLORD!'
            }
        };

        function evolveClass(player) {
            if (player.level !== 20) return false;
            if (player.hasEvolved) return false; // Already evolved
            
            const baseClass = player.class;
            const evolution = ADVANCED_CLASSES[baseClass];
            
            if (!evolution) return false;
            
            // Store original class
            player.baseClass = baseClass;
            player.class = evolution.advancedClass;
            player.className = evolution.advancedName;
            player.hasEvolved = true;
            
            // Apply bonus stats
            Object.keys(evolution.bonusStats).forEach(stat => {
                if (player[stat] !== undefined) {
                    player[stat] += evolution.bonusStats[stat];
                }
            });
            
            // Apply damage multiplier
            player.advancedClassMultiplier = evolution.damageMultiplier;
            
            // Add new spells
            evolution.newSpells.forEach(spell => {
                if (!player.knownSpells.includes(spell)) {
                    player.knownSpells.push(spell);
                }
            });
            
            // Heal to full and boost HP/MP
            player.maxHp = Math.floor(player.maxHp * 1.5);
            player.maxMp = Math.floor(player.maxMp * 1.5);
            player.hp = player.maxHp;
            player.mp = player.maxMp;
            
            return true;
        }

        function getAdvancedClassName(player) {
            if (player.hasEvolved && ADVANCED_CLASSES[player.baseClass]) {
                return ADVANCED_CLASSES[player.baseClass].advancedName;
            }
            return player.className || player.class;
        }

        function getClassDamageMultiplier(player) {
            return player.advancedClassMultiplier || 1.0;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // END ADVANCED CLASS SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function levelUp() {
            const p = gameState.player;
            
            // Cap at level 25
            if (p.level >= 25) {
                p.xp = p.xpToNext; // Keep at max
                return;
            }
            
            const oldLevel = p.level;
            p.level++;
            p.xp -= p.xpToNext;
            
            // Update xpToNext using class-specific table
            p.xpToNext = getXpToNextLevel(p.baseClass || p.class, p.level);

            // HP/MP increases (CON scaling for HP)
            p.maxHp += 15 + (p.con||0);   // CON scales HP gain
            p.hp     = p.maxHp;
            p.maxMp += 10;
            p.mp     = p.maxMp;
            
            // Legacy stats still auto-increase for backwards compatibility
            p.strength += 2;
            p.defense  += 2;
            p.magic    += 2;
            p.speed    += 1;

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // NEW STAT POINT SYSTEM (3 points per level to allocate)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (p.statPoints === undefined) {
                p.statPoints = 0; // Initialize if not present (old saves)
            }
            p.statPoints += 3; // Give 3 stat points per level
            
            // Auto-allocate 1 point to each stat (base progression)
            if (p.str !== undefined) {
                p.str++; p.dex++; p.wis++; p.cha++; p.con++; p.lck++;
                // Paladin bonus: extra +1 to both STR and WIS
                if (p.class === 'paladin' || p.baseClass === 'paladin') { 
                    p.str++; p.wis++; 
                }
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CHECK FOR NEW ZONE DISCOVERY
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            Object.keys(LOCATIONS).forEach(key => {
                const loc = LOCATIONS[key];
                if (key !== 'town' && loc.requiredLevel === p.level) {
                    // Just reached the level for this zone!
                    termAppend('', 'term-separator');
                    termAppend(`<span style="color:#00FFFF;font-size:18px;">ğŸ—ºï¸ NEW AREA DISCOVERED!</span>`, 'term-victory');
                    termAppend(`<span style="color:#FFD700;">${loc.name} is now visible on the world map!</span>`, 'term-loot');
                    termAppend(`<span style="color:#8aaa8a;">Check "Explore World" to visit this area.</span>`, 'term-dim');
                }
            });
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CHECK FOR CLASS EVOLUTION AT LEVEL 20
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (p.level === 20 && evolveClass(p)) {
                const evolution = ADVANCED_CLASSES[p.baseClass];
                // Evolution message will be shown in endCombat
                p._justEvolved = true;
                p._evolutionMessage = evolution.announcement;
            }
            
            // Spells are no longer auto-learned - must be purchased at temple!
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // LOOT DROP SYSTEM (Phase 1)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function rollLoot(monster) {
            const loot = [];
            const rarityBonus = RARITY_CONFIG[monster.rarity].dropBonus || 0;
            
            if (!monster.possibleDrops || monster.possibleDrops.length === 0) {
                return loot;
            }
            
            monster.possibleDrops.forEach(itemKey => {
                let dropChance = 0;
                
                // Determine base drop chance
                if (ITEMS[itemKey]) {
                    // Consumable/sellable items use common drop rate
                    dropChance = monster.dropRates.common || 0.3;
                } else if (WEAPONS[itemKey] || ARMOR[itemKey]) {
                    // Equipment uses quality-based drop rates
                    const quality = getItemQuality(itemKey);
                    dropChance = monster.dropRates[quality] || 0.05;
                }
                
                // Apply rarity bonus + player LCK luck bonus
                const lckBonus = gameState.player ? calcLootBonus(gameState.player.lck || 0) / 100 : 0;
                const adjustedChance = Math.min(0.95, dropChance * (1 + rarityBonus * 0.1 + lckBonus));
                
                if (Math.random() < adjustedChance) {
                    loot.push(itemKey);
                }
            });
            
            // SPECIAL: Magical Butterknife check (Red Dragons only!)
            if (monster.key === 'red_dragon' && Math.random() < 0.000001) {
                loot.push('magical_butterknife');
                // Alert SYSOP terminal if active
                if (gameState.sysop && gameState.sysop.authenticated) {
                    terminalPrint('âš ï¸âš ï¸âš ï¸ ULTRA RARE DROP: MAGICAL BUTTERKNIFE! âš ï¸âš ï¸âš ï¸', 'success');
                }
            }
            
            return loot;
        }

        function getItemName(itemKey) {
            if (WEAPONS[itemKey]) return WEAPONS[itemKey].name;
            if (ARMOR[itemKey]) return ARMOR[itemKey].name;
            if (ITEMS[itemKey]) return ITEMS[itemKey].name;
            if (SPELLS[itemKey]) return SPELLS[itemKey].name;
            return itemKey;
        }

        function getItemColor(itemKey) {
            if (WEAPONS[itemKey]) {
                return QUALITY_CONFIG[WEAPONS[itemKey].quality].color;
            }
            if (ARMOR[itemKey]) {
                return QUALITY_CONFIG[ARMOR[itemKey].quality].color;
            }
            // Default green for items
            return '#00FF00';
        }

        function getItemQualityText(itemKey) {
            if (WEAPONS[itemKey]) {
                const quality = WEAPONS[itemKey].quality;
                return `[${QUALITY_CONFIG[quality].name}]`;
            }
            if (ARMOR[itemKey]) {
                const quality = ARMOR[itemKey].quality;
                return `[${QUALITY_CONFIG[quality].name}]`;
            }
            return '';
        }

        function getItemQuality(itemKey) {
            if (WEAPONS[itemKey]) return WEAPONS[itemKey].quality;
            if (ARMOR[itemKey]) return ARMOR[itemKey].quality;
            return 'normal';
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // END LOOT DROP SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


        function respawn() {
            gameState.player.hp = gameState.player.maxHp;
            gameState.player.mp = gameState.player.maxMp;
            gameState.player.gold = Math.floor(gameState.player.gold / 2);
            gameState.combatState = null;
            showTown();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ADVENTURE SYSTEM (Choose-Your-Own-Adventure encounters)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function startAdventure(adventure) {
            gameState.currentAdventure = adventure;
            
            termAppend('', 'term-separator');
            termAppend(`<span style="color:#FFD700;font-size:20px;">âœ¨ ${adventure.name}! âœ¨</span>`, 'term-highlight');
            termAppend('', 'term-separator');
            termAppend(adventure.intro, 'term-dim');
            termAppend('', 'term-separator');
            termAppend('<span style="color:var(--highlight-color);">What do you do?</span>');
            termAppend('', 'term-separator');
            
            // Show choices
            adventure.choices.forEach((choice, index) => {
                termAppend(`<span style="color:var(--highlight-color);">${index + 1}.</span> ${choice.text}`, 'term-highlight');
            });
            
            // Render adventure action bar
            renderAdventureActionBar();
        }
        
        function renderAdventureActionBar() {
            const adventure = gameState.currentAdventure;
            if (!adventure) return;
            
            const ab = document.getElementById('actionBar');
            ab.style.display = 'flex';
            ab.innerHTML = '';
            
            adventure.choices.forEach((choice, index) => {
                const btn = document.createElement('button');
                btn.textContent = `${index + 1}. ${choice.text.substring(0, 30)}${choice.text.length > 30 ? '...' : ''}`;
                btn.style.fontSize = '12px';
                btn.style.padding = '6px';
                btn.onclick = () => chooseAdventurePath(index);
                ab.appendChild(btn);
            });
        }
        
        function chooseAdventurePath(choiceIndex) {
            const adventure = gameState.currentAdventure;
            if (!adventure) return;
            
            const choice = adventure.choices[choiceIndex];
            
            termAppend('', 'term-separator');
            termAppend(`<span style="color:var(--text-color);">â–º You choose: ${choice.text}</span>`, 'term-highlight');
            termAppend('', 'term-separator');
            
            // Roll for outcome
            let totalWeight = 0;
            choice.outcomes.forEach(o => totalWeight += o.weight);
            
            let roll = Math.random() * totalWeight;
            let selectedOutcome = choice.outcomes[0];
            
            for (const outcome of choice.outcomes) {
                roll -= outcome.weight;
                if (roll <= 0) {
                    selectedOutcome = outcome;
                    break;
                }
            }
            
            // Show outcome
            termAppend(selectedOutcome.text, 'term-highlight');
            
            // Apply rewards
            if (selectedOutcome.rewards) {
                applyAdventureRewards(selectedOutcome.rewards);
            }
            
            // Start combat if needed
            if (selectedOutcome.combat) {
                termAppend('', 'term-separator');
                gameState.currentAdventure = null;
                startCombat(selectedOutcome.combat);
                return;
            }
            
            // Check if this outcome leads to another choice
            if (selectedOutcome.nextChoices && selectedOutcome.nextChoices.length > 0) {
                // Continue the adventure with new choices
                termAppend('', 'term-separator');
                termAppend('<span style="color:var(--highlight-color);">What do you do?</span>');
                termAppend('', 'term-separator');
                
                // Update adventure choices
                adventure.choices = selectedOutcome.nextChoices;
                
                // Show new choices
                adventure.choices.forEach((choice, index) => {
                    termAppend(`<span style="color:var(--highlight-color);">${index + 1}.</span> ${choice.text}`, 'term-highlight');
                });
                
                // Render new choice buttons
                renderAdventureActionBar();
                return;
            }
            
            // Adventure over, return to exploration
            gameState.currentAdventure = null;
            termAppend('', 'term-separator');
            renderActionBar();
        }
        
        function applyAdventureRewards(rewards) {
            const p = gameState.player;
            
            if (rewards.gold) {
                p.gold = Math.max(0, p.gold + rewards.gold);
                if (rewards.gold > 0) {
                    termAppend(`<span style="color:#FFD700;">ğŸ’° +${rewards.gold} Gold!</span>`, 'term-loot');
                } else {
                    termAppend(`<span style="color:#FF6666;">ğŸ’° ${rewards.gold} Gold (paid)</span>`, 'term-error');
                }
            }
            
            if (rewards.xp) {
                p.xp += rewards.xp;
                termAppend(`<span style="color:#88FF88;">â­ +${rewards.xp} XP!</span>`, 'term-loot');
                
                // Check for level up
                while (p.xp >= p.xpToNext && p.level < 25) {
                    levelUp();
                    termAppend(`â¬†ï¸ LEVEL UP! You are now level ${p.level}!`, 'term-victory');
                    
                    // Check for class evolution
                    if (p._justEvolved) {
                        termAppend('', 'term-separator');
                        termAppend(`<span style="color:#FF00FF;font-size:24px;font-weight:bold;">âš¡ CLASS EVOLUTION! âš¡</span>`, 'term-victory');
                        termAppend(p._evolutionMessage, 'term-victory');
                        termAppend(`<span style="color:#FFD700;">Your power has DOUBLED!</span>`, 'term-loot');
                        p._justEvolved = false;
                        p._evolutionMessage = null;
                    }
                }
            }
            
            if (rewards.damage) {
                p.hp -= rewards.damage;
                termAppend(`<span style="color:#FF6666;">ğŸ’” Took ${rewards.damage} damage!</span>`, 'term-error');
                if (p.hp <= 0) {
                    p.hp = 1; // Can't die from adventure damage
                    termAppend(`<span style="color:#FFAA00;">You barely survive!</span>`, 'term-warning');
                }
            }
            
            if (rewards.heal === 'full') {
                p.hp = p.maxHp;
                p.mp = p.maxMp;
                termAppend(`<span style="color:#00FF00;">âœ¨ Fully restored!</span>`, 'term-victory');
            }
            
            if (rewards.items) {
                rewards.items.forEach(itemKey => {
                    p.inventory.push(itemKey);
                    const item = ITEMS[itemKey] || WEAPONS[itemKey] || ARMOR[itemKey];
                    if (item) {
                        termAppend(`<span style="color:#00FFFF;">ğŸ Received: ${item.name}!</span>`, 'term-loot');
                    } else {
                        termAppend(`<span style="color:#00FFFF;">ğŸ Received: ${itemKey}!</span>`, 'term-loot');
                    }
                });
            }
            
            if (rewards.spell) {
                if (!p.knownSpells.includes(rewards.spell)) {
                    p.knownSpells.push(rewards.spell);
                    termAppend(`<span style="color:#FF00FF;">ğŸ“– Learned spell: ${rewards.spell}!</span>`, 'term-victory');
                }
            }
            
            updateHud();
            saveGame();
        }


        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CHARACTER STATS & STAT ALLOCATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function showCharacterStats() {
            const p = gameState.player;
            const screen = document.getElementById('mainScreen');
            
            // Initialize stat points if not present (old saves)
            if (p.statPoints === undefined) p.statPoints = 0;
            
            const hasPoints = p.statPoints > 0;
            
            screen.innerHTML = `
                <div class="location-header">ğŸ“Š CHARACTER STATS</div>
                ${renderPlayerStats()}
                
                <div class="message" style="border-color:${hasPoints ? '#FFD700' : 'var(--border-color)'};">
                    <p><strong style="color:${hasPoints ? '#FFD700' : 'var(--highlight-color)'};">Available Stat Points: ${p.statPoints}</strong></p>
                    ${hasPoints ? '<p style="color:#00FF00;">You have unspent stat points! Allocate them below.</p>' : '<p style="color:#888;">You gain 3 stat points per level up.</p>'}
                </div>
                
                <div class="message">
                    <h3 style="color:var(--highlight-color);">Core Stats</h3>
                    ${renderStatRow('STR (Strength)', p.str, 'Increases physical damage')}
                    ${renderStatRow('DEX (Dexterity)', p.dex, 'Increases dodge, accuracy, crit chance')}
                    ${renderStatRow('CON (Constitution)', p.con, 'Increases HP gain per level')}
                    ${renderStatRow('WIS (Wisdom)', p.wis, 'Increases spell damage and magic defense')}
                    ${renderStatRow('CHA (Charisma)', p.cha, 'Reduces shop prices and inn costs')}
                    ${renderStatRow('LCK (Luck)', p.lck, 'Increases crit chance and rare drops')}
                </div>
                
                <div class="message">
                    <h3 style="color:var(--highlight-color);">Derived Stats</h3>
                    <p><span class="stat-label">Level:</span> ${p.level}</p>
                    <p><span class="stat-label">XP:</span> ${p.xp} / ${p.xpToNext}</p>
                    <p><span class="stat-label">HP:</span> ${p.hp} / ${p.maxHp}</p>
                    <p><span class="stat-label">MP:</span> ${p.mp} / ${p.maxMp}</p>
                    <p><span class="stat-label">Physical Damage:</span> ${calculatePhysicalDamage()}</p>
                    <p><span class="stat-label">Magic Damage:</span> ${calculateMagicDamage()}</p>
                    <p><span class="stat-label">Defense:</span> ${calculateTotalDefense()}</p>
                    <p><span class="stat-label">Crit Chance:</span> ${calcCritChance(p.lck, p)}%</p>
                </div>
                
                ${hasPoints ? `
                    <div class="message" style="border-color:#FFD700;">
                        <h3 style="color:#FFD700;">Allocate Stat Points (${p.statPoints} remaining)</h3>
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;">
                            <button onclick="allocateStat('str')">+1 STR</button>
                            <button onclick="allocateStat('dex')">+1 DEX</button>
                            <button onclick="allocateStat('con')">+1 CON</button>
                            <button onclick="allocateStat('wis')">+1 WIS</button>
                            <button onclick="allocateStat('cha')">+1 CHA</button>
                            <button onclick="allocateStat('lck')">+1 LCK</button>
                        </div>
                    </div>
                ` : ''}
                
                <button onclick="showTown()">â† BACK TO TOWN</button>
            `;
        }
        
        function renderStatRow(name, value, description) {
            return `
                <p>
                    <span class="stat-label">${name}:</span> 
                    <span style="color:#FFD700;">${value}</span>
                    <span style="color:#888;font-size:12px;"> - ${description}</span>
                </p>
            `;
        }
        
        function calculatePhysicalDamage() {
            const p = gameState.player;
            const weapon = WEAPONS[p.weapon] || { baseDamage: 1, quality: 'poor' };
            const qBonus = getQualityBonus(weapon.quality, weapon.baseDamage);
            let weaponDamage = weapon.baseDamage + qBonus;
            if (p.level <= 5) weaponDamage = Math.floor(weaponDamage * 0.7);
            return weaponDamage + (p.str || 0);
        }
        
        function calculateMagicDamage() {
            const p = gameState.player;
            const weapon = WEAPONS[p.weapon] || { baseMagicDamage: 0, quality: 'poor' };
            const qBonus = getQualityBonus(weapon.quality, weapon.baseDamage);
            return (weapon.baseMagicDamage + qBonus) + (p.wis || 0);
        }
        
        function calculateTotalDefense() {
            const p = gameState.player;
            const armor = ARMOR[p.armor] || { baseDefense: 0, quality: 'poor' };
            const qBonus = getQualityBonus(armor.quality, armor.baseDefense);
            return p.defense + armor.baseDefense + qBonus + (p.con || 0);
        }
        
        function allocateStat(statName) {
            const p = gameState.player;
            
            if (p.statPoints <= 0) {
                alert('No stat points available!');
                return;
            }
            
            p[statName]++;
            p.statPoints--;
            
            // Update max HP if CON was increased
            if (statName === 'con') {
                p.maxHp += 1; // Small bonus for increasing CON
                p.hp = Math.min(p.hp, p.maxHp);
            }
            
            saveGame();
            showCharacterStats(); // Refresh display
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TEMPLE OF REBIRTH (Stat Reset)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function showTemple() {
            const p = gameState.player;
            const screen = document.getElementById('mainScreen');
            
            // Calculate total stat points that have been allocated
            const totalAllocated = calculateTotalAllocatedPoints();
            const respecCost = calculateRespecCost(p.level);
            
            screen.innerHTML = `
                <div class="location-header">â›ª TEMPLE OF REBIRTH</div>
                ${renderPlayerStats()}
                
                <div class="message">
                    <p style="color:var(--highlight-color);font-size:16px;">
                        <strong>Welcome to the Temple of Rebirth</strong>
                    </p>
                    <p>
                        Here, the priests offer spiritual services: spell training and personal rebirth.
                    </p>
                </div>
                
                <div style="margin: 20px 0;">
                    <div class="menu-option" onclick="showSpellShop()">ğŸ“– SPELL TRAINING</div>
                    <div class="menu-option" onclick="showRespec()">ğŸ”„ STAT RESPEC (${respecCost}g)</div>
                    <button onclick="showTown()">â† BACK TO TOWN</button>
                </div>
            `;
        }
        
        function showRespec() {
            const p = gameState.player;
            const screen = document.getElementById('mainScreen');
            
            const totalAllocated = calculateTotalAllocatedPoints();
            const respecCost = calculateRespecCost(p.level);
            
            screen.innerHTML = `
                <div class="location-header">ğŸ”„ STAT RESPEC</div>
                ${renderPlayerStats()}
                
                <div class="message" style="border-color:#8aaa8a;">
                    <p>Refund all allocated stat points to rebuild your character.</p>
                </div>
                
                <div class="message" style="border-color:#FFD700;">
                    <h3 style="color:#FFD700;">Respec Info</h3>
                    <p><span class="stat-label">Level:</span> ${p.level}</p>
                    <p><span class="stat-label">Allocated:</span> ${totalAllocated}</p>
                    <p><span class="stat-label">Available:</span> ${p.statPoints || 0}</p>
                    <p><span class="stat-label">Cost:</span> <span style="color:#FFD700;">${respecCost}g</span></p>
                </div>
                
                <div class="message" style="border-color:var(--error-color);">
                    <p style="color:var(--error-color);"><strong>âš ï¸ Warning:</strong> This resets ALL stat points.</p>
                </div>
                
                <div style="margin: 20px 0;">
                    ${p.gold >= respecCost ? `<button onclick="confirmRespec()" style="border-color:#FFD700;">ğŸ’° RESPEC (${respecCost}g)</button>` : `<button disabled>Need ${respecCost - p.gold}g more</button>`}
                    <button onclick="showTemple()">â† BACK</button>
                </div>
            `;
        }
        
        function calculateTotalAllocatedPoints() {
            const p = gameState.player;
            // Each level gives 3 points, so total available = level * 3
            const totalAvailable = (p.level - 1) * 3; // -1 because level 1 has no points yet
            const remaining = p.statPoints || 0;
            return totalAvailable - remaining;
        }
        
        function calculateRespecCost(level) {
            // Cost scales with level: 1000g per level
            return level * 1000;
        }
        
        function confirmRespec() {
            const p = gameState.player;
            const cost = calculateRespecCost(p.level);
            
            if (p.gold < cost) {
                alert('Not enough gold!');
                return;
            }
            
            if (!confirm(`Are you sure you want to respec for ${cost} gold? This will refund all your allocated stat points.`)) {
                return;
            }
            
            performRespec();
        }
        
        function performRespec() {
            const p = gameState.player;
            const cost = calculateRespecCost(p.level);
            
            // Deduct gold
            p.gold -= cost;
            
            // Calculate how many points were manually allocated
            const totalLevelPoints = (p.level - 1) * 3;
            
            // Reset stats to base (level 1 + auto-gains)
            // Auto-gains: +1 to each stat per level (except paladin gets +2 str/wis)
            const baseLevels = p.level - 1; // Levels gained beyond 1
            
            p.str = 10 + baseLevels; // Base 10 + 1 per level
            p.dex = 10 + baseLevels;
            p.wis = 10 + baseLevels;
            p.cha = 10 + baseLevels;
            p.con = 10 + baseLevels;
            p.lck = 10 + baseLevels;
            
            // Paladin bonus (gets extra str/wis each level)
            if (p.class === 'paladin' || p.baseClass === 'paladin') {
                p.str += baseLevels;
                p.wis += baseLevels;
            }
            
            // Refund all allocated points
            p.statPoints = totalLevelPoints;
            
            // Recalculate HP based on new CON
            p.maxHp = 100 + (p.level - 1) * 15 + ((p.level - 1) * (p.con - 10)); // Base + level gains + con bonus
            p.hp = Math.min(p.hp, p.maxHp);
            
            saveGame();
            
            alert(`Respec complete! You have ${p.statPoints} stat points to reallocate.`);
            showCharacterStats();
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SPELL SHOP - Temple Spell Training
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function showSpellShop() {
            const p = gameState.player;
            const screen = document.getElementById('mainScreen');
            
            // Get class spell tree
            const classKey = p.baseClass || p.class;
            const spellTree = CLASS_SPELL_TREES[classKey];
            
            if (!spellTree) {
                screen.innerHTML = `
                    <div class="location-header">ğŸ“– SPELL TRAINING</div>
                    ${renderPlayerStats()}
                    <div class="message" style="border-color:var(--error-color);">
                        <p>Your class (${classKey}) does not have spell training available.</p>
                    </div>
                    <button onclick="showTemple()">â† BACK TO TEMPLE</button>
                `;
                return;
            }
            
            // Get available spells
            const availableSpells = [];
            const currentSpells = [];
            
            Object.entries(spellTree.spellTree).forEach(([key, spell]) => {
                const hasSpell = p.knownSpells.includes(key);
                const canAfford = p.gold >= spell.cost;
                const levelReq = p.level >= spell.level;
                const meetsRequirement = !spell.requires || p.knownSpells.includes(spell.requires);
                
                if (hasSpell) {
                    currentSpells.push({ key, spell });
                } else if (levelReq && meetsRequirement) {
                    availableSpells.push({ key, spell, canAfford });
                }
            });
            
            let html = `
                <div class="location-header">ğŸ“– SPELL TRAINING</div>
                ${renderPlayerStats()}
                
                <div class="message">
                    <p style="color:var(--highlight-color);"><strong>The priests offer to teach you the sacred arts</strong></p>
                    <p style="color:#8aaa8a;">Learn new spells or upgrade existing ones</p>
                </div>
            `;
            
            // Show current spells
            if (currentSpells.length > 0) {
                html += `<div class="message" style="border-color:#00FF00;"><h3 style="color:#00FF00;">Your Known Spells</h3>`;
                currentSpells.forEach(({ key, spell }) => {
                    const typeColor = spell.type === 'heal' || spell.type === 'lifesteal' ? '#00FF00' : '#FF6666';
                    const typeIcon = spell.type === 'heal' ? 'ğŸ’š' : spell.type === 'lifesteal' ? 'ğŸ©¸' : spell.type === 'aoe_damage' ? 'ğŸ”¥' : 'ğŸ’¥';
                    const lifestealInfo = spell.lifestealPercent ? ` (${spell.lifestealPercent}%)` : '';
                    const aoeTag = spell.type === 'aoe_damage' ? ' <span style="color:#FF8800;">[AOE]</span>' : '';
                    html += `<p>${typeIcon} <strong>${spell.name}${aoeTag}</strong> - <span style="color:${typeColor};">${spell.power} ${spell.type === 'heal' ? 'HP' : 'DMG'}${lifestealInfo}</span> (${spell.mpCost} MP)${spell.upgradesTo ? `<br><span style="color:#FFD700;font-size:12px;">â†’ Upgrade available</span>` : ''}</p>`;
                });
                html += `</div>`;
            }
            
            // Show available spells
            if (availableSpells.length > 0) {
                html += `<div class="message" style="border-color:#FFD700;"><h3 style="color:#FFD700;">Available Training</h3>`;
                availableSpells.forEach(({ key, spell, canAfford }) => {
                    const typeColor = spell.type === 'heal' || spell.type === 'lifesteal' ? '#00FF00' : '#FF6666';
                    const typeIcon = spell.type === 'heal' ? 'ğŸ’š' : spell.type === 'lifesteal' ? 'ğŸ©¸' : spell.type === 'aoe_damage' ? 'ğŸ”¥' : 'ğŸ’¥';
                    const lifestealInfo = spell.lifestealPercent ? ` (${spell.lifestealPercent}% lifesteal)` : '';
                    const aoeTag = spell.type === 'aoe_damage' ? ' <span style="color:#FF8800;">[AOE]</span>' : '';
                    const isUpgrade = spell.requires && p.knownSpells.includes(spell.requires);
                    
                    html += `<div style="margin:10px 0;padding:10px;border:1px solid ${canAfford ? '#FFD700' : '#666'};"><p>${typeIcon} <strong style="color:${typeColor};">${spell.name}${aoeTag}</strong> ${isUpgrade ? '(Upgrade)' : '(New)'}<br><span style="font-size:12px;">${spell.description}</span><br><span style="color:${typeColor};">${spell.power} ${spell.type === 'heal' ? 'HP' : 'DMG'}${lifestealInfo}</span> | ${spell.mpCost} MP | Level ${spell.level}<br><span style="color:#FFD700;">Cost: ${spell.cost}g</span></p>${canAfford ? `<button onclick="learnSpell('${key}')" style="border-color:#FFD700;">ğŸ’° Learn (${spell.cost}g)</button>` : `<button disabled style="opacity:0.5;">Need ${spell.cost - p.gold}g more</button>`}</div>`;
                });
                html += `</div>`;
            } else {
                html += `<div class="message"><p style="color:#888;">No new spells available at your level.</p></div>`;
            }
            
            html += `<button onclick="showTemple()">â† BACK</button>`;
            screen.innerHTML = html;
        }
        
        function learnSpell(spellKey) {
            const p = gameState.player;
            const classKey = p.baseClass || p.class;
            const spell = CLASS_SPELL_TREES[classKey].spellTree[spellKey];
            
            if (!spell || p.gold < spell.cost || p.level < spell.level) {
                alert('Cannot learn this spell!');
                return;
            }
            
            if (spell.requires && !p.knownSpells.includes(spell.requires)) {
                alert('Learn previous spell first!');
                return;
            }
            
            p.gold -= spell.cost;
            
            // Remove old spell if upgrade
            if (spell.requires) {
                const idx = p.knownSpells.indexOf(spell.requires);
                if (idx > -1) p.knownSpells.splice(idx, 1);
            }
            
            p.knownSpells.push(spellKey);
            
            // Add to SPELLS if not present
            if (!SPELLS[spellKey]) {
                SPELLS[spellKey] = { ...spell, pipCost: 1 };
            }
            
            saveGame();
            alert(`Learned ${spell.name}!`);
            showSpellShop();
        }


        // Start the game
        
        // Load all class spells from CLASS_SPELL_TREES
        if (typeof CLASS_SPELL_TREES !== 'undefined') {
            loadAllClassSpells();
        }
        
        initGame();



    </script>
</body>
</html>