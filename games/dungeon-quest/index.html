<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
   <!-- PWA: standalone mode removes browser chrome on iOS/Android -->
   <meta name="apple-mobile-web-app-capable" content="yes">
   <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
   <meta name="apple-mobile-web-app-title" content="Dungeon Quest">
   <meta name="mobile-web-app-capable" content="yes">
   <meta name="theme-color" content="#000000">

    <title>⚔️ DUNGEON QUEST  ⚔️</title>
   
   
   <style>




    /* ───────── GLOBAL LAYOUT FIX (PUT THIS FIRST) ───────── */
*,
*::before,
*::after {
    box-sizing: border-box;
}

html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    /* let each child manage its own overflow */
}

body {
    -webkit-user-select: none;
    user-select: none;
    touch-action: manipulation;
}

/* ── Menu container (town/shop) ────────────────────────────────── */
#menuContainer {
    height: 100%;
    height: 100dvh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    max-width: 900px;
    margin: 0 auto;
}

/* ── Gameplay wrapper — full viewport, column flex ──────────────── */
#gameWrapper {
    position: fixed;
    inset: 0;
    display: none;
    flex-direction: column;
    overflow: hidden;
    padding-bottom: env(safe-area-inset-bottom, 0px);
    box-sizing: border-box;
    /* ── Desktop: cap width, centre, add side backdrop ── */
    background: #000;
}

/* Desktop: constrain play area to readable column */
@media (min-width: 769px) {
    #gameWrapper {
        /* Dark backdrop fills full viewport, game column sits centred */
        background: #050505;
    }
    #gameWrapper > * {
        /* All direct children get the same max-width and centring */
        max-width: 820px;
        width: 100%;
        margin-left: auto;
        margin-right: auto;
        box-sizing: border-box;
    }
    /* Terminal itself also needs width constraint but stretches vertically */
    #terminalWindow {
        max-width: 820px !important;
    }
    /* HUD strip: same max-width, let it sit at bottom */
    #hud {
        max-width: 820px !important;
    }
    /* Status bars: same max-width */
    #statusBars {
        max-width: 820px !important;
    }
    /* Desktop: taller action bar buttons, easier mouse click */
    #actionBar button { min-height: 48px !important; font-size: 22px !important; }
    .action-icon-btn  { min-height: 48px !important; font-size: 24px !important; }
}

/* Shown in terminal mode */
body.terminal-mode #gameWrapper {
    display: flex;
}

/* ── Desktop HUD (top) ──────────────────────────────────────────── */
#hud {
    flex: 0 0 auto;
    display: none;
}
body.terminal-mode #hud {
    display: block;
    order: 2;   /* terminal=1, hud=2, statusBars=3, actionBar=4, XP=5 */
}

/* ── Mobile HUD text strip ── */
#mobileHud {
    display: none;
    flex: 0 0 auto;
    box-sizing: border-box;
    order: 2;
}
/* On mobile, show mobileHud in terminal mode so player name/gold are visible */
@media (max-width: 768px) {
    body.terminal-mode #mobileHud {
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        justify-content: space-between;
        align-items: center;
        padding: 3px 8px;
        background: #000;
        font-family: 'VT323', monospace;
        font-size: 15px;
        gap: 6px;
        white-space: nowrap;
        overflow: hidden;
    }
    body.terminal-mode #mobileHud span {
        display: inline !important;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    body.terminal-mode #mhHp   { color: #00ff88; flex: 1 1 auto; min-width: 0; }
    body.terminal-mode #mhMp   { color: #aaaaaa; flex: 0 0 auto; }
    body.terminal-mode #mhGold { color: #FFD700; flex: 0 0 auto; }
    body.terminal-mode #mobileHud .mhud-xp { display: none !important; }
}

/* ── Legacy bottomHud — always hidden ──────────────────────────── */
#bottomHud { display: none !important; }

/* ── Terminal — takes ALL leftover space, scrolls ───────────────── */
#terminalWindow {
    flex: 1 1 0;
    min-height: 0;
    overflow-y: scroll;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior-y: contain;
    display: none;
    order: 1;
}
body.terminal-mode #terminalWindow { display: block; }

/* ── Action bar ─────────────────────────────────────────────────── */
#actionBar {
    flex: 0 0 auto;
    display: none;
    overflow: visible;
    box-sizing: border-box;
    order: 4;
    padding: 4px;
    /* safe area handled by XP bar below — just normal padding here */
    padding-bottom: 4px;
}
body.terminal-mode #actionBar { display: block; }

/* default button sizing */
#actionBar button {
    min-width: 0;
    min-height: 44px;       /* taller — easier to tap/click */
    border-radius: 5px;
    font-size: 20px;
}
/* Compass direction buttons have fixed sizes — don't let min-height bloat them */
#dungeonCompass button {
    min-height: 0 !important;
    min-width: 0 !important;
}

/* ── Status bars (HP/MP) — order:3, sits just above actionBar(4) ── */
#statusBars {
    flex: 0 0 auto;
    display: none;
    order: 3;
    padding: 0;
    padding-bottom: 4px;
    box-sizing: border-box;
    background: #000;
}
body.terminal-mode #statusBars { display: block; }

/* HP + MP side-by-side row — each 50% width, same pill style as XP bar */
#sbHpMpRow {
    display: flex;
    flex-direction: row;
    gap: 6px;
    padding: 4px 10px 2px;
    background: #000;
    box-sizing: border-box;
}
#sbHpTrack, #sbMpTrack {
    flex: 1;
    height: 22px;
    border-radius: 11px;
    overflow: hidden;
    position: relative;
    border: 1px solid #222;
}
#sbHpTrack { background: #1a0000; border-color: #330000; }
#sbMpTrack { background: #00001a; border-color: #000033; }

#sbHpFill {
    height: 100%;
    background: linear-gradient(90deg, #cc0000, #ff3333);
    box-shadow: 0 0 4px #ff0000, 0 0 8px rgba(255,0,0,0.4);
    transition: width 0.4s ease;
    border-radius: 11px;
}
#sbMpFill {
    height: 100%;
    background: linear-gradient(90deg, #0044cc, #4499ff);
    box-shadow: 0 0 4px #0066ff, 0 0 8px rgba(0,102,255,0.4);
    transition: width 0.4s ease;
    border-radius: 11px;
    animation: mpPulse 3s ease-in-out infinite;
}
@keyframes mpPulse {
    0%, 100% { opacity: 1; }
    50%       { opacity: 0.85; }
}
#sbHpLabel, #sbMpLabel {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 13px;
    font-family: 'VT323', monospace;
    color: rgba(255,255,255,0.9);
    text-shadow: 0 0 4px #000, 0 0 6px #000, 1px 1px 0 #000;
    pointer-events: none;
    letter-spacing: 1px;
}
@keyframes runeOverloadPulse {
    0%   {
        border-color: #CC2200 !important;
        box-shadow: 0 0 8px 3px #FF3300, 0 0 20px 6px #FF5500, inset 0 0 10px rgba(255,60,0,0.5) !important;
        background: #1a0000 !important;
        color: #FF6644 !important;
        outline: 2px solid #CC2200;
    }
    50%  {
        border-color: #FF7700 !important;
        box-shadow: 0 0 20px 8px #FF5500, 0 0 40px 14px #FF3300, inset 0 0 22px rgba(255,150,0,0.7) !important;
        background: #3a0e00 !important;
        color: #FFAA44 !important;
        outline: 2px solid #FF7700;
    }
    100% {
        border-color: #CC2200 !important;
        box-shadow: 0 0 8px 3px #FF3300, 0 0 20px 6px #FF5500, inset 0 0 10px rgba(255,60,0,0.5) !important;
        background: #1a0000 !important;
        color: #FF6644 !important;
        outline: 2px solid #CC2200;
    }
}
/* Runesmith overload — kill ALL competing styles so the animation wins */
#pipBtn-attack[style*="runeOverloadPulse"] {
    outline-offset: -2px !important;
    border-color: #FF4400 !important;
    background: #1a0000 !important;
    box-shadow: 0 0 12px 4px #FF3300, inset 0 0 10px rgba(255,60,0,0.4) !important;
    /* Override the .all-ready green and .pip-btn defaults */
    animation: runeOverloadPulse 0.65s ease-in-out infinite !important;
}

@keyframes hpLowPulse {
    0%, 100% { opacity: 1;    box-shadow: 0 0 6px #ff0000, 0 0 12px rgba(255,0,0,0.6); }
    50%       { opacity: 0.6; box-shadow: 0 0 2px #ff0000; }
}

/* XP bar wrapper — pinned below action bar, very bottom of screen */
#sbXpBar {
    flex: 0 0 auto;
    display: none;
    order: 5;   /* below actionBar (order:4) */
    padding: 4px 10px;
    padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 4px);
    box-sizing: border-box;
    background: #000;
}
body.terminal-mode #sbXpBar { display: block; }

/* XP bar container — inset from edges so iPhone curved corners don't clip it */
#sbXpBar {
    padding-left: 10px;
    padding-right: 10px;
}
/* XP track — inset, rounded, with room for label */
#sbXpTrack {
    height: 28px;
    background: #0d0d00;
    margin: 3px 0 0;
    border-radius: 14px;
    overflow: hidden;
    border: 1px solid #333300;
    position: relative;
}
#sbXpFill {
    height: 100%;
    background: linear-gradient(90deg, #886600, #ffdd00);
    box-shadow: 0 0 4px #ffaa00, 0 0 8px #cc8800;
    transition: width 0.5s ease;
    border-radius: 14px;
}
#sbXpLabel {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 15px;
    font-family: 'VT323', monospace;
    color: rgba(255,255,255,0.9);
    text-shadow: 0 0 4px #000, 0 0 6px #000, 1px 1px 0 #000;
    pointer-events: none;
    letter-spacing: 1px;
}

        @import url('https://fonts.googleapis.com/css2?family=VT323&family=Press+Start+2P&display=swap');

        :root {
            --primary-bg: #000080;
            --secondary-bg: #000000;
            --text-color: #00FF00;
            --highlight-color: #FFFF00;
            --error-color: #FF0000;
            --border-color: #00FFFF;
            --menu-color: #FFFFFF;
        }

        body {
            background: var(--primary-bg);
            color: var(--text-color);
            font-family: 'VT323', monospace;
            font-size: 20px;
            line-height: 1.4;
        }

        .scanline {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                transparent 50%,
                rgba(0, 0, 0, 0.25) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 1000;
            animation: flicker 0.15s infinite;
        }

        @keyframes flicker {
            0% { opacity: 0.95; }
            50% { opacity: 1; }
            100% { opacity: 0.95; }
        }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }

        @keyframes flashRed {
            0%, 100% { color: #FF8C00; text-shadow: 0 0 6px #FF8C00; }
            50%      { color: #FFD700; text-shadow: 0 0 14px #FFD700; }
        }

        @keyframes flashOrange {
            0%, 100% { color: #FF0000; text-shadow: 0 0 6px #FF0000; }
            50%      { color: #FF4444; text-shadow: 0 0 14px #FF4444; }
        }

        .dmg-player {
            animation: flashOrange 0.6s ease-in-out infinite;
            font-weight: bold;
        }

        .dmg-enemy {
            animation: flashRed 0.6s ease-in-out infinite;
            font-weight: bold;
        }

     .container {
    height: 100%;
    max-width: 900px;
    margin: 0 auto;
    padding: 0;
    display: flex;
    flex-direction: column;
    overflow: hidden; /* prevent container overflow */
}


        .header {
            flex-shrink: 0; /* prevent header from shrinking */
            text-align: center;
            border: 3px double var(--border-color);
            padding: 8px;
            margin-bottom: 8px;
            background: var(--secondary-bg);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .header h1 {
            font-family: 'Press Start 2P', monospace;
            font-size: 20px;
            color: var(--highlight-color);
            text-shadow: 2px 2px var(--error-color);
            margin-bottom: 5px;
            animation: titlePulse 2s infinite;
            transition: all 0.3s ease;
        }
        
        .header p {
            margin: 0;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        /* Compact header during gameplay */
        body.terminal-mode .header {
            padding: 4px;
            margin-bottom: 4px;
            border-width: 2px;
        }
        
        body.terminal-mode .header h1 {
            font-size: 12px;
            margin-bottom: 2px;
            animation: none; /* disable pulse during gameplay */
        }
        
        body.terminal-mode .header > div {
            display: none; /* hide decorative lines and subtitle */
        }

        @keyframes titlePulse {
            0%, 100% { text-shadow: 2px 2px var(--error-color); }
            50% { text-shadow: 2px 2px var(--error-color), 0 0 10px var(--highlight-color); }
        }
        
        @keyframes flash-green {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3) hue-rotate(10deg); }
        }
        
        @keyframes flash-blue {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2) hue-rotate(-20deg); }
        }

        /* ─── LOW HP heartbeat border on terminal ─── */
        /* Two quick beats then a long pause — like a real heartbeat */
        @keyframes heartbeat-border {
            0%   { box-shadow: inset 0 0 40px rgba(0,255,0,0.07), 0 0 0px rgba(255,0,0,0);   border-color: var(--border-color); }
            6%   { box-shadow: inset 0 0 40px rgba(0,255,0,0.07), 0 0 18px rgba(255,0,0,0.9); border-color: #ff2222; }
            12%  { box-shadow: inset 0 0 40px rgba(0,255,0,0.07), 0 0 4px  rgba(255,0,0,0.3); border-color: #881111; }
            18%  { box-shadow: inset 0 0 40px rgba(0,255,0,0.07), 0 0 18px rgba(255,0,0,0.9); border-color: #ff2222; }
            30%  { box-shadow: inset 0 0 40px rgba(0,255,0,0.07), 0 0 0px  rgba(255,0,0,0);   border-color: var(--border-color); }
            100% { box-shadow: inset 0 0 40px rgba(0,255,0,0.07), 0 0 0px  rgba(255,0,0,0);   border-color: var(--border-color); }
        }

        #terminalWindow.danger-heartbeat {
            animation: heartbeat-border 1.4s ease-in-out infinite;
            border-color: #881111;
        }

        /* ─── main screen used by town / shop / menus ─── */
        .screen {
            flex: 1 1 auto; /* allow screen to grow/shrink */
            min-height: 0; /* critical for flex scrolling */
            overflow-y: auto; /* enable scrolling */
            -webkit-overflow-scrolling: touch; /* smooth scrolling on iOS */
            
            background: var(--secondary-bg);
            border: 2px solid var(--border-color);
            padding: 12px;
            margin-bottom: 8px;
            box-shadow: inset 0 0 50px rgba(0, 255, 0, 0.1);
        }
        
        .menu-option {
            color: var(--menu-color);
            cursor: pointer;
            padding: 8px;
            margin: 5px 0;
            transition: all 0.1s;
        }
        .menu-option:hover {
            background: var(--primary-bg);
            color: var(--highlight-color);
            padding-left: 20px;
        }
        .menu-option.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            color: #666;
        }
        .menu-option.disabled:hover {
            background: transparent;
            padding-left: 8px;
        }

        /* ─── desktop HUD visual styles ─── */
#hud {
    background: var(--secondary-bg);
    border: 2px solid var(--border-color);
    border-bottom: none;
    padding: 6px 10px;
    box-shadow: inset 0 0 30px rgba(0,255,0,0.08);
}

        /* mobileHud text spans — hidden in terminal mode, bars take over */
#mobileHud span { display: none; }

/* Hide XP and gold on very narrow screens — bars show it visually */
@media (max-width: 420px) {
    #mobileHud .mhud-xp   { display: none !important; }
    #mobileHud .mhud-gold { display: none !important; }
}

/* ─── Desktop HUD: compact strip in terminal-mode ───────────────── */
body.terminal-mode #hud {
    padding: 3px 10px !important;
    border-width: 1px !important;
    border-top: 1px solid #1a3a1a !important;
    border-bottom: none !important;
    box-shadow: none !important;
    background: #050a05 !important;
}
body.terminal-mode .hud-inner {
    display: flex !important;
    flex-wrap: nowrap;
    align-items: center;
    gap: 10px;
    justify-content: flex-start;
}
body.terminal-mode #hudName {
    font-size: 14px !important;
    color: var(--highlight-color) !important;
    white-space: nowrap;
    overflow: visible;
    max-width: 280px;
    flex-shrink: 1;
}
body.terminal-mode .hud-stats {
    display: flex !important;
    flex-wrap: nowrap;
    gap: 12px;
    font-size: 14px !important;
    align-items: center;
    flex: 1;
}
body.terminal-mode .hud-stats span {
    white-space: nowrap;
    font-size: 14px !important;
}
/* On mobile the desktop HUD is hidden — mobileHud takes over */
@media (max-width: 768px) {
    body.terminal-mode #hud { display: none !important; }
}


        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 4px;
        }
        .hud-top .hud-name { color: var(--highlight-color); font-size: 18px; }
        .hud-top .hud-gold { color: #FFD700; font-size: 16px; }
        .hud-bars {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }
        .hud-bar-group label {
            color: var(--highlight-color);
            font-size: 14px;
            display: block;
            margin-bottom: 2px;
        }
        .hud-bar-group .bar-nums { color: var(--text-color); font-size: 14px; }
        .progress-bar {
            width: 100%;
            height: 12px;
            background: #111;
            border: 1px solid var(--border-color);
            margin-top: 2px;
        }
        .progress-fill { height: 100%; transition: width 0.35s ease; }
        .hp-bar { background: var(--error-color); }
        .mp-bar { background: #4488ff; }
        .xp-bar { background: var(--text-color); }

        /* ─── scrolling terminal visual styles ─── */
#terminalWindow {
    background: var(--secondary-bg);
    border: 2px solid var(--border-color);
    border-top: 1px solid #333;
    padding: 8px 10px;
    box-shadow: inset 0 0 40px rgba(0,255,0,0.07);
    /* NOTE: no scroll-behavior:smooth — it fights with programmatic scrollTop on mobile */
}

        .term-line {
            padding: 2px 0;
            font-size: 16px;
            color: var(--text-color);
            line-height: 1.3;
        }
        .term-line.term-dim       { color: #3a7a3a; }
        .term-line.term-highlight { color: var(--highlight-color); }
        .term-line.term-enemy     { color: var(--border-color); font-size: 17px; }
        .term-line.term-loot      { font-size: 17px; }
        .term-line.term-system    { color: #888; font-style: italic; }
        .term-line.term-separator { margin-top: 6px; padding-top: 6px; border-top: 1px solid #2a4a2a; }

        /* ─── action bar visual styles ─── */
#actionBar {
    background: var(--secondary-bg);
    border-top: 2px solid var(--border-color);
    padding: 5px 6px;
    gap: 4px;
}


        #actionBar button {
            background: linear-gradient(180deg, #1a1a1a 0%, #0a0a0a 100%);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            padding: 6px 8px;
            font-family: 'VT323', monospace;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.15s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            min-width: 0;
            min-height: 0;
            box-sizing: border-box;
        }
        
        /* Combat action buttons — one tight row */
        .action-icon-btn {
            flex: 1 1 0;
            min-width: 0 !important;
            padding: 6px 4px !important;
            text-align: center;
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
        }
        
        /* Target selection buttons */
        .target-btn {
            flex: 1 1 0;
            min-width: 0 !important;
            padding: 6px 5px !important;
            background: linear-gradient(180deg, #0a2a0a 0%, #051505 100%) !important;
            border-color: var(--text-color) !important;
        }
        
        .target-btn:hover:not(:disabled) {
            background: linear-gradient(180deg, #0f3f0f 0%, #0a2a0a 100%) !important;
            border-color: var(--highlight-color) !important;
            color: var(--highlight-color) !important;
        }
        
        /* Spell selection buttons */
        .spell-btn {
            flex: 1 1 0;
            min-width: 0 !important;
            padding: 6px 4px !important;
            background: linear-gradient(180deg, #1a1a2a 0%, #0a0a15 100%) !important;
            border-color: #4488ff !important;
            font-size: 13px;
            line-height: 1.2;
        }
        
        .spell-btn:hover:not(:disabled) {
            background: linear-gradient(180deg, #2a2a4a 0%, #1a1a2a 100%) !important;
            border-color: #88bbff !important;
            color: #88bbff !important;
        }

        /* ── PIP COOLDOWN SWEEP (Diablo/WoW style) ───────────────────── */
        .pip-btn {
            position: relative;
            overflow: hidden;
            isolation: isolate;
        }
        .pip-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            background: conic-gradient(
                rgba(0,255,136,0.25) var(--pip-pct, 0%),
                transparent           var(--pip-pct, 0%)
            );
            pointer-events: none;
            z-index: 1;
            transition: none;
        }
        .pip-btn > *, .pip-btn span { position: relative; z-index: 2; }
        .pip-btn.cooling {
            border-color: #ff8c00 !important;
            box-shadow: 0 0 8px rgba(255,140,0,0.35) !important;
        }
        .pip-btn.all-ready {
            border-color: #00ff88 !important;
            box-shadow: 0 0 10px rgba(0,255,136,0.5) !important;
        }
        /* Overload animation must beat .all-ready's !important green — higher specificity */
        #pipBtn-attack.pip-btn.all-ready[style*="runeOverloadPulse"],
        #pipBtn-attack.all-ready[style*="runeOverloadPulse"] {
            border-color: #FF4400 !important;
            box-shadow: 0 0 12px 4px #FF3300, inset 0 0 10px rgba(255,60,0,0.4) !important;
            background: #1a0000 !important;
            animation: runeOverloadPulse 0.65s ease-in-out infinite !important;
        }
        .pip-badge {
            position: absolute;
            top: 2px; right: 4px;
            font-size: 10px; line-height: 1;
            color: #ff8c00;
            z-index: 3;
            pointer-events: none;
        }

        #actionBar button:hover {
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
            color: var(--highlight-color);
            border-color: var(--highlight-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 255, 0, 0.3);
        }
        #actionBar button:active {
            transform: translateY(0);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.8);
        }
        #actionBar button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }



        .term-line.term-victory   { color: var(--border-color); font-size: 22px; }
        .term-line.term-loot      { color: #FFD700; }
        .term-line.term-error     { color: var(--error-color); }
        .term-line.term-separator { border-top: 1px solid #2a5a2a; margin: 6px 0 4px; padding-top: 4px; }
        .enemy-card {
            border: 2px solid var(--error-color);
            padding: 8px 12px;
            margin: 6px 0;
            background: rgba(255,0,0,0.05);
            display: inline-block;
            min-width: 260px;
            vertical-align: top;
        }
        .enemy-card.is-target { border-color: var(--highlight-color); }
        .enemy-card .ec-name  { font-size: 21px; margin-bottom: 4px; }
        .enemy-card .ec-hp    { font-size: 18px; color: var(--text-color); }

   
   
/* stale actionBar block removed */





        #actionBar .action-label { color: var(--highlight-color); font-size: 18px; margin-bottom: 6px; }
        #actionBar .timer-line   { color: var(--highlight-color); font-size: 19px; margin-bottom: 4px; }

        /* ─── legacy helpers for shop / inventory / town ─── */
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid var(--border-color);
            background: rgba(0,128,0,0.1);
        }
        .stat       { color: var(--text-color); }
        .stat-label { color: var(--highlight-color); }
        .message {
            padding: 10px;
            margin: 10px 0;
            border-left: 3px solid var(--border-color);
        }
        .combat-message  { color: var(--highlight-color); font-weight: bold; }
        .error-message   { color: var(--error-color); }
        .success-message { color: var(--border-color); }

        button {
            background: var(--secondary-bg);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            padding: 10px 20px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) {
            background: var(--primary-bg);
            color: var(--highlight-color);
            box-shadow: 0 0 10px var(--border-color);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        input {
            background: var(--secondary-bg);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            padding: 10px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            width: 100%;
            margin: 10px 0;
        }

        .character-select {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .class-card {
            border: 2px solid var(--border-color);
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--secondary-bg);
        }

        .class-card:hover {
            background: var(--primary-bg);
            box-shadow: 0 0 15px var(--border-color);
            transform: scale(1.05);
        }

        .class-card.selected {
            border-color: var(--highlight-color);
            background: var(--primary-bg);
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .item-card {
            border: 1px solid var(--border-color);
            padding: 10px;
            background: rgba(0, 128, 0, 0.05);
        }

        .equipped {
            border-color: var(--highlight-color);
            background: rgba(255, 255, 0, 0.1);
        }

        .cursor {
            display: inline-block;
            width: 10px;
            height: 20px;
            background: var(--text-color);
            animation: blink 1s infinite;
            margin-left: 5px;
        }

        .location-header {
            font-family: 'Press Start 2P', monospace;
            font-size: 16px;
            color: var(--border-color);
            text-align: center;
            padding: 10px;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: 15px;
        }

        .enemy-display {
            text-align: center;
            padding: 20px;
            border: 2px solid var(--error-color);
            margin: 15px 0;
            background: rgba(255, 0, 0, 0.05);
        }

        .ascii-art {
            font-family: monospace;
            font-size: 14px;
            line-height: 1.2;
            white-space: pre;
            color: var(--text-color);
        }

        /* SYSOP Terminal Styles */
        .terminal-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--secondary-bg);
            border-top: 3px solid var(--error-color);
            padding: 10px 20px;
            z-index: 999;
            max-height: 300px;
            overflow-y: auto;
            display: none;
            box-shadow: 0 -5px 20px rgba(255, 0, 0, 0.5);
        }

        .terminal-container.active {
            display: block;
            animation: terminalSlideUp 0.3s;
        }

        @keyframes terminalSlideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        .terminal-header {
            color: var(--error-color);
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            margin-bottom: 10px;
            text-align: center;
            border-bottom: 1px solid var(--error-color);
            padding-bottom: 5px;
        }

        .terminal-output {
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
            color: var(--text-color);
        }

        .terminal-line {
            margin: 3px 0;
        }

        .terminal-error {
            color: var(--error-color);
        }

        .terminal-success {
            color: var(--border-color);
        }

        .terminal-warning {
            color: var(--highlight-color);
        }

        .terminal-input-line {
            display: flex;
            align-items: center;
        }

        .terminal-prompt {
            color: var(--error-color);
            margin-right: 10px;
        }

        .terminal-input {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--text-color);
            font-family: 'VT323', monospace;
            font-size: 20px;
            outline: none;
        }

        .sysop-badge {
            position: fixed;
            top: 10px;
            right: 10px;
            background: var(--error-color);
            color: var(--secondary-bg);
            padding: 5px 10px;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            border: 2px solid var(--highlight-color);
            z-index: 998;
            display: none;
            animation: badgePulse 2s infinite;
        }

        .sysop-badge.active {
            display: block;
        }

        @keyframes badgePulse {
            0%, 100% { box-shadow: 0 0 5px var(--error-color); }
            50% { box-shadow: 0 0 20px var(--error-color); }
        }

        /* quit button is now a plain .menu-option */

        /* ─── Full-screen SYSOP Overlay ──────────────────────────────── */
        #sysopOverlay {
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 2000;
            display: none;
            flex-direction: column;
            overflow: hidden;
            height: 100%;
            width: 100%;
        }
        #sysopOverlay.open { display: flex; }

        /* Sticky header — never scrolls away */
        #sysopOverlayHeader {
            flex: 0 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 2px solid #ff4444;
            padding: 8px 12px;
            background: #000;
        }

        /* Scrollable content area — gets all remaining height */
        #sysopOverlayInner {
            flex: 1 1 0;
            min-height: 0;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 10px 12px 30px;
        }

        /* .syo-header replaced by #sysopOverlayHeader (fixed, outside scroll) */
        .syo-title {
            color: #ff4444;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            letter-spacing: 1px;
        }
        .syo-close {
            background: none;
            border: 1px solid #ff4444;
            color: #ff4444;
            font-family: 'VT323', monospace;
            font-size: 20px;
            padding: 2px 10px;
            cursor: pointer;
        }

        /* Output log */
        .syo-log {
            background: #050505;
            border: 1px solid #1a3a1a;
            color: #00FF41;
            font-family: 'VT323', monospace;
            font-size: 15px;
            padding: 6px 8px;
            max-height: 100px;
            overflow-y: auto;
            margin-bottom: 10px;
            white-space: pre-wrap;
            line-height: 1.3;
        }

        /* Section */
        .syo-section { margin-bottom: 12px; }
        .syo-section-title {
            color: #ff8c00;
            font-family: 'Press Start 2P', monospace;
            font-size: 9px;
            letter-spacing: 1px;
            margin-bottom: 6px;
            padding-bottom: 3px;
            border-bottom: 1px solid #2a2a00;
        }

        /* Button grid */
        .syo-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        .syo-grid.cols3 { grid-template-columns: 1fr 1fr 1fr; }
        .syo-btn {
            background: #050505;
            border: 1px solid #2a4a2a;
            color: #00FF41;
            font-family: 'VT323', monospace;
            font-size: 18px;
            padding: 10px 6px;
            cursor: pointer;
            text-align: center;
            transition: background 0.1s;
        }
        .syo-btn:active  { background: #0a1a0a; }
        .syo-btn.red     { border-color:#ff4444; color:#ff4444; }
        .syo-btn.orange  { border-color:#ff8c00; color:#ff8c00; }
        .syo-btn.yellow  { border-color:#FFD700; color:#FFD700; }
        .syo-btn.full    { grid-column: 1 / -1; }

        /* Sub form */
        .syo-sub {
            border: 1px solid #1a3a1a;
            padding: 10px;
            margin-top: 8px;
            background: #020a02;
        }
        .syo-sub-title {
            color: #00FF41;
            font-size: 13px;
            margin-bottom: 6px;
            font-family: 'VT323', monospace;
        }
        .syo-label {
            color: #5a8a5a;
            font-family: 'VT323', monospace;
            font-size: 15px;
            margin: 4px 0 2px;
        }
        .syo-input {
            width: 100%;
            background: #000;
            border: 1px solid #2a4a2a;
            color: #00FF41;
            font-family: 'VT323', monospace;
            font-size: 20px;
            padding: 6px 8px;
            box-sizing: border-box;
            margin-bottom: 6px;
            outline: none;
        }
        .syo-input:focus { border-color: #00FF41; }
        select.syo-input { font-size: 16px; }

        /* ── Sysop list panel ──────────────────────────────────────── */
        .syo-list-panel {
            border: 1px solid #1a3a1a;
            background: #020a02;
            margin-top: 8px;
        }
        .syo-list-search {
            display: flex;
            gap: 6px;
            padding: 8px 8px 0;
        }
        .syo-list-search input {
            flex: 1;
            background: #000;
            border: 1px solid #00FF41;
            color: #00FF41;
            font-family: 'VT323', monospace;
            font-size: 20px;
            padding: 4px 8px;
            outline: none;
        }
        .syo-list-body {
            max-height: 340px;
            overflow-y: auto;
            padding: 6px 8px 10px;
        }
        .syo-list-row {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 5px 4px;
            border-bottom: 1px solid #0d1f0d;
            cursor: pointer;
            transition: background 0.1s;
        }
        .syo-list-row:hover { background: #0a1a0a; }
        .syo-list-key {
            color: #ff8c00;
            font-family: 'VT323', monospace;
            font-size: 14px;
            min-width: 140px;
            word-break: break-all;
        }
        .syo-list-name {
            color: #00FF41;
            font-family: 'VT323', monospace;
            font-size: 16px;
            flex: 1;
        }
        .syo-list-meta {
            color: #5a8a5a;
            font-family: 'VT323', monospace;
            font-size: 14px;
            text-align: right;
            min-width: 80px;
        }
        .syo-list-count {
            color: #5a8a5a;
            font-family: 'VT323', monospace;
            font-size: 13px;
            padding: 4px 8px 0;
        }

        /* Login form */
        .syo-login-art {
            color: #ff4444;
            font-family: 'Press Start 2P', monospace;
            font-size: 9px;
            text-align: center;
            line-height: 1.6;
            margin: 10px 0 14px;
            letter-spacing: 1px;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1001;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: var(--secondary-bg);
            border: 3px solid var(--error-color);
            padding: 20px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 30px var(--error-color);
        }


        .action-icon-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 2px solid var(--border-color);
            background: var(--secondary-bg);
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .action-icon-btn:hover:not(:disabled) {
            background: var(--primary-bg);
            border-color: var(--highlight-color);
            transform: scale(1.05);
        }
        
        .action-icon-btn:active:not(:disabled) {
            transform: scale(0.95);
        }
        
        .action-icon-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* ═══════════════════════════════════════════════════════════════
           RESPONSIVE — mobile first, clean
           ═══════════════════════════════════════════════════════════════ */

        /* All phones/tablets ≤768px */
        @media (max-width: 768px) {
            body { font-size: 15px; }

            /* Menu screen */
            #menuContainer { padding: 4px; }
            .header { padding: 5px 6px; margin-bottom: 3px; }
            .header h1 { font-size: 15px; margin-bottom: 2px; }
            .screen { padding: 8px; }

            /* Desktop HUD: hidden on mobile — status bars replace it */
            body.terminal-mode #hud { display: none !important; }

            /* Terminal: smallest still-readable text, maximise screen space */
            #terminalWindow { padding: 3px 5px; }
            .term-line { font-size: 13px; line-height: 1.2; margin: 0; padding: 0; }

            /* Action bar — taller buttons on mobile for easier tapping */
            #actionBar { padding: 4px 3px 2px; }
            #actionBar button { font-size: 18px; padding: 6px 7px; min-height: 46px; border-radius: 5px; }
            .action-icon-btn { font-size: 20px; padding: 6px 6px !important; min-height: 46px; }
            .spell-btn  { font-size: 12px; padding: 4px 5px !important; }
            .target-btn { font-size: 13px; padding: 5px 6px !important; }

            /* Status bars — slightly taller on small screens for visibility */
            #sbHpMpRow { height: 8px; }
            #sbXpTrack { height: 28px; }

            /* Other UI */
            .menu-option { padding: 8px; font-size: 16px; margin: 4px 0; }
            button { padding: 7px 10px; font-size: 14px; margin: 3px 1px; }
            .character-select { grid-template-columns: 1fr; gap: 8px; }
            .inventory-grid { grid-template-columns: repeat(2, 1fr); gap: 6px; }
            .item-card { padding: 6px; font-size: 13px; }
            .ascii-art { font-size: 9px; line-height: 1.1; }
        }

        /* Very small phones ≤390px */
        @media (max-width: 390px) {
            .term-line { font-size: 12px; line-height: 1.15; }
            #actionBar { padding: 3px 2px 1px; }
            #actionBar button { font-size: 17px; padding: 5px 5px; min-height: 42px; }
            .action-icon-btn { font-size: 19px; padding: 5px 4px !important; min-height: 42px; }
        }

        /* Landscape tablets */
        @media (min-width: 769px) and (max-width: 1024px) {
            #menuContainer { max-width: 95%; padding: 12px; }
            .character-select { grid-template-columns: repeat(2, 1fr); }
            .inventory-grid { grid-template-columns: repeat(3, 1fr); }
        }

        /* ── Keyboard shortcut hints on action buttons (desktop only) ── */
        .kb-hint {
            display: none;  /* hidden by default, shown on desktop below */
            position: absolute;
            bottom: 2px;
            right: 3px;
            font-size: 9px;
            line-height: 1;
            color: #556655;
            font-family: monospace;
            pointer-events: none;
            z-index: 3;
        }
        /* Show hints on devices with a real pointer (desktop) */
        @media (hover: hover) and (pointer: fine) {
            .kb-hint { display: block; }
            .action-icon-btn { position: relative; }
        }
        /* Touch: no hover lift, tap highlight */
        @media (hover: none) and (pointer: coarse) {
            button, .menu-option, .class-card, .item-card {
                -webkit-tap-highlight-color: rgba(0,255,0,0.2);
                user-select: none; -webkit-user-select: none;
            }
            #actionBar button:hover { transform: none; box-shadow: none; }
            .action-icon-btn:hover:not(:disabled) { transform: none; }
        }

       
/* ─────────────────────────────────────────
   TERMINAL MODE – show/hide rules
   (layout is handled by #gameWrapper fixed-position rules above)
   ───────────────────────────────────────── */

/* Hide menu container in terminal mode */
body.terminal-mode #menuContainer {
    display: none;
}



/* ── Install modal overlay ──────────────────────────────────────────── */
#installModal.open { display: flex !important; }
#installModalBox .install-step {
    padding: 6px 0;
    font-size: 17px;
    border-bottom: 1px solid #0d1f0d;
    line-height: 1.35;
}
#installModalBox .install-step:last-child { border-bottom: none; }
#installModalBox .install-highlight { color: var(--highlight-color); }
#installModalBox .install-icon { font-size: 22px; margin-right: 6px; }


        
    /* ═══════════════════════════════════════════════════════════════════
       CHRONICLE — Full-screen parchment overlay
       Deliberately breaks from the CRT terminal palette to feel ancient.
       ═══════════════════════════════════════════════════════════════════ */

    #chronicle-overlay {
        display: none;
        position: fixed;
        inset: 0;
        z-index: 4000;
        background: rgba(0,0,0,0.92);
        align-items: center;
        justify-content: center;
        font-family: 'Georgia', 'Times New Roman', serif;
    }
    #chronicle-overlay.open {
        display: flex;
    }

    /* The book itself */
    .chronicle-book {
        position: relative;
        width: min(96vw, 680px);
        max-height: 92vh;
        display: flex;
        flex-direction: column;
        background: #1a120a;
        border: 3px solid #7a5a2a;
        border-radius: 4px;
        box-shadow:
            0 0 0 1px #3a2810,
            0 0 40px rgba(200,140,40,0.25),
            inset 0 0 60px rgba(0,0,0,0.6);
        overflow: hidden;
    }

    /* Parchment texture via gradient */
    .chronicle-book::before {
        content: '';
        position: absolute;
        inset: 0;
        background:
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 28px,
                rgba(120,80,20,0.06) 28px,
                rgba(120,80,20,0.06) 29px
            );
        pointer-events: none;
        z-index: 0;
    }

    /* Header bar */
    .chronicle-header {
        position: relative;
        z-index: 1;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 18px 10px;
        background: linear-gradient(180deg, #2a1a08 0%, #1a120a 100%);
        border-bottom: 2px solid #5a3a18;
    }
    .chronicle-title {
        font-size: 20px;
        color: #d4a840;
        letter-spacing: 3px;
        text-transform: uppercase;
        font-weight: bold;
        text-shadow: 0 0 12px rgba(200,140,40,0.5);
    }
    .chronicle-subtitle {
        font-size: 13px;
        color: #7a5a30;
        letter-spacing: 1px;
        margin-top: 2px;
    }
    .chronicle-close {
        background: none;
        border: 1px solid #5a3a18;
        color: #7a5a30;
        font-size: 18px;
        width: 32px;
        height: 32px;
        cursor: pointer;
        border-radius: 2px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.15s;
        font-family: monospace;
    }
    .chronicle-close:hover {
        border-color: #d4a840;
        color: #d4a840;
        background: rgba(212,168,64,0.1);
    }

    /* Tab bar (Chronicle / Bestiary) */
    .chronicle-tabs {
        position: relative;
        z-index: 1;
        display: flex;
        border-bottom: 2px solid #5a3a18;
        background: #120d06;
    }
    .chronicle-tab {
        flex: 1;
        padding: 9px 12px;
        text-align: center;
        font-size: 14px;
        letter-spacing: 1px;
        color: #5a3a18;
        cursor: pointer;
        transition: all 0.15s;
        border: none;
        background: none;
        font-family: 'Georgia', serif;
        text-transform: uppercase;
        position: relative;
    }
    .chronicle-tab:hover { color: #9a7a40; background: rgba(120,80,20,0.1); }
    .chronicle-tab.active {
        color: #d4a840;
        background: rgba(120,80,20,0.15);
        border-bottom: 2px solid #d4a840;
        margin-bottom: -2px;
    }
    /* Notification badge on tab */
    .chronicle-tab .tab-badge {
        display: none;
        position: absolute;
        top: 4px;
        right: 8px;
        background: #c04020;
        color: #fff;
        font-size: 10px;
        font-family: monospace;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        align-items: center;
        justify-content: center;
        font-weight: bold;
    }
    .chronicle-tab .tab-badge.visible { display: flex; }

    /* Scrollable content area */
    .chronicle-body {
        position: relative;
        z-index: 1;
        flex: 1;
        overflow-y: auto;
        padding: 0;
        min-height: 0;
        scrollbar-width: thin;
        scrollbar-color: #5a3a18 #120d06;
    }
    .chronicle-body::-webkit-scrollbar { width: 6px; }
    .chronicle-body::-webkit-scrollbar-track { background: #120d06; }
    .chronicle-body::-webkit-scrollbar-thumb { background: #5a3a18; border-radius: 3px; }

    /* ── CHRONICLE ENTRY LIST (left panel feel) ── */
    .chronicle-entry-list {
        display: flex;
        flex-direction: column;
        gap: 0;
        padding: 8px 0;
    }
    .chronicle-entry-row {
        display: flex;
        align-items: flex-start;
        gap: 10px;
        padding: 10px 18px;
        cursor: pointer;
        border-bottom: 1px solid rgba(90,58,24,0.3);
        transition: background 0.1s;
        position: relative;
    }
    .chronicle-entry-row:hover { background: rgba(120,80,20,0.15); }
    .chronicle-entry-row.active { background: rgba(120,80,20,0.25); }
    .chronicle-entry-row.unread::before {
        content: '';
        position: absolute;
        left: 6px;
        top: 50%;
        transform: translateY(-50%);
        width: 5px;
        height: 5px;
        border-radius: 50%;
        background: #d4a840;
        box-shadow: 0 0 6px #d4a840;
    }
    .chronicle-entry-icon {
        font-size: 18px;
        flex-shrink: 0;
        margin-top: 1px;
        opacity: 0.8;
    }
    .chronicle-entry-meta {
        flex: 1;
        min-width: 0;
    }
    .chronicle-entry-title {
        font-size: 15px;
        color: #c8a050;
        font-weight: bold;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .chronicle-entry-row.unread .chronicle-entry-title { color: #e8c870; }
    .chronicle-entry-hint {
        font-size: 12px;
        color: #5a4020;
        margin-top: 2px;
        font-style: italic;
    }
    .chronicle-entry-level {
        font-size: 11px;
        color: #4a3015;
        font-family: monospace;
        flex-shrink: 0;
        margin-top: 3px;
    }

    /* ── CHRONICLE ENTRY READER ── */
    .chronicle-reader {
        display: none;
        flex-direction: column;
        height: 100%;
    }
    .chronicle-reader.open { display: flex; }
    .chronicle-reader-back {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px 18px;
        border-bottom: 1px solid rgba(90,58,24,0.4);
        cursor: pointer;
        color: #7a5a30;
        font-size: 13px;
        letter-spacing: 1px;
        transition: color 0.15s;
        background: rgba(0,0,0,0.2);
    }
    .chronicle-reader-back:hover { color: #d4a840; }

    /* The parchment page itself */
    .chronicle-page {
        flex: 1;
        padding: 28px 28px 32px;
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: #5a3a18 transparent;
        background: radial-gradient(ellipse at 50% 0%, rgba(80,50,10,0.12) 0%, transparent 70%);
    }
    .chronicle-page::-webkit-scrollbar { width: 4px; }
    .chronicle-page::-webkit-scrollbar-thumb { background: #5a3a18; }

    .chronicle-page-ornament {
        text-align: center;
        color: #5a3a18;
        font-size: 18px;
        letter-spacing: 8px;
        margin-bottom: 18px;
        opacity: 0.7;
    }
    .chronicle-page-title {
        text-align: center;
        font-size: 22px;
        color: #d4a840;
        font-weight: bold;
        margin-bottom: 4px;
        text-shadow: 0 0 20px rgba(212,168,64,0.3);
        line-height: 1.3;
    }
    .chronicle-page-label {
        text-align: center;
        font-size: 12px;
        color: #5a4020;
        letter-spacing: 2px;
        text-transform: uppercase;
        margin-bottom: 24px;
    }
    .chronicle-page-divider {
        text-align: center;
        color: #5a3a18;
        font-size: 14px;
        letter-spacing: 4px;
        margin: 20px 0;
        opacity: 0.6;
    }
    .chronicle-page-body {
        font-size: 16px;
        color: #c8a878;
        line-height: 1.75;
        font-style: italic;
    }
    .chronicle-page-body p {
        margin: 0 0 16px 0;
        text-indent: 1.5em;
    }
    .chronicle-page-body p:first-child { text-indent: 0; }
    /* Drop cap on first letter */
    .chronicle-page-body p:first-child::first-letter {
        font-size: 3em;
        float: left;
        line-height: 0.75;
        margin: 4px 8px 0 0;
        color: #d4a840;
        text-shadow: 0 0 10px rgba(212,168,64,0.4);
        font-style: normal;
        font-weight: bold;
    }

    /* ── Animated chronicle segments ──────────────────────────────── */
    /* Each p, callout, epithet starts hidden and fades in */
    .chron-seg {
        opacity: 0;
        transform: translateY(6px);
        transition: opacity 0.7s ease, transform 0.7s ease;
    }
    .chron-seg.visible {
        opacity: 1;
        transform: translateY(0);
    }
    /* Skip button inside the reader */
    .chron-skip-btn {
        display: block;
        text-align: center;
        margin: 8px 0 0;
        padding: 0;
        background: none;
        border: none;
        color: #3a2810;
        font-size: 12px;
        font-family: monospace;
        letter-spacing: 1px;
        cursor: pointer;
        transition: color 0.15s;
    }
    .chron-skip-btn:hover { color: #7a5a30; }
    /* Player name highlight */
    .chronicle-name {
        color: #e8d090;
        font-style: normal;
        font-weight: bold;
    }
    /* Epithet reveal */
    .chronicle-epithet {
        display: block;
        text-align: center;
        font-size: 18px;
        color: #d4a840;
        font-style: normal;
        letter-spacing: 2px;
        margin: 24px 0 8px;
        text-shadow: 0 0 16px rgba(212,168,64,0.5);
    }
    /* World lore callout box */
    .chronicle-callout {
        background: rgba(80,50,10,0.2);
        border-left: 3px solid #7a5a2a;
        padding: 12px 16px;
        margin: 16px 0;
        font-style: normal;
        font-size: 14px;
        color: #9a7a50;
        letter-spacing: 0.5px;
    }
    /* Navigation between entries */
    .chronicle-page-nav {
        display: flex;
        justify-content: space-between;
        padding: 12px 18px;
        border-top: 1px solid rgba(90,58,24,0.4);
        background: rgba(0,0,0,0.2);
    }
    .chronicle-nav-btn {
        background: none;
        border: 1px solid #3a2810;
        color: #5a4020;
        font-family: 'Georgia', serif;
        font-size: 13px;
        padding: 6px 12px;
        cursor: pointer;
        transition: all 0.15s;
        border-radius: 2px;
    }
    .chronicle-nav-btn:hover:not(:disabled) {
        border-color: #d4a840;
        color: #d4a840;
        background: rgba(212,168,64,0.08);
    }
    .chronicle-nav-btn:disabled { opacity: 0.25; cursor: default; }

    /* ── BESTIARY PANEL ── */
    .bestiary-entry-row {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px 18px;
        border-bottom: 1px solid rgba(90,58,24,0.3);
        cursor: pointer;
        transition: background 0.1s;
    }
    .bestiary-entry-row:hover { background: rgba(120,80,20,0.15); }
    .bestiary-entry-row.active { background: rgba(120,80,20,0.25); }
    .bestiary-monster-icon {
        font-size: 22px;
        flex-shrink: 0;
        width: 32px;
        text-align: center;
        filter: grayscale(0.4);
    }
    .bestiary-monster-icon.undiscovered { filter: grayscale(1) brightness(0.3); }
    .bestiary-monster-name {
        flex: 1;
        font-size: 15px;
        color: #c8a050;
        font-weight: bold;
    }
    .bestiary-monster-name.undiscovered { color: #3a2810; }
    .bestiary-tier-badge {
        font-size: 11px;
        font-family: monospace;
        padding: 2px 6px;
        border-radius: 2px;
        border: 1px solid;
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    .bestiary-tier-none     { color: #3a2810; border-color: #3a2810; }
    .bestiary-tier-seen     { color: #607848; border-color: #607848; }
    .bestiary-tier-studying { color: #8a7040; border-color: #8a7040; }
    .bestiary-tier-known    { color: #c8a050; border-color: #c8a050; }
    .bestiary-tier-hunter   { color: #e8c870; border-color: #e8c870;
                              box-shadow: 0 0 6px rgba(232,200,112,0.3); }
    .bestiary-kill-count {
        font-size: 12px;
        color: #5a4020;
        font-family: monospace;
    }

    /* Bestiary detail page */
    .bestiary-detail { padding: 24px 24px 28px; }
    .bestiary-detail-name {
        font-size: 24px;
        color: #d4a840;
        font-weight: bold;
        margin-bottom: 4px;
        text-shadow: 0 0 16px rgba(212,168,64,0.3);
    }
    .bestiary-detail-class {
        font-size: 12px;
        color: #5a4020;
        letter-spacing: 2px;
        text-transform: uppercase;
        margin-bottom: 18px;
    }
    .bestiary-stat-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 6px 16px;
        margin: 16px 0;
        padding: 14px;
        background: rgba(0,0,0,0.3);
        border: 1px solid rgba(90,58,24,0.4);
        border-radius: 2px;
    }
    .bestiary-stat-row { display: flex; justify-content: space-between; align-items: center; }
    .bestiary-stat-label { font-size: 12px; color: #5a4020; letter-spacing: 1px; text-transform: uppercase; }
    .bestiary-stat-value { font-size: 14px; color: #c8a878; font-family: monospace; font-style: normal; }
    .bestiary-locked-stat { color: #3a2810; }
    .bestiary-flavor {
        font-size: 15px;
        color: #a08050;
        line-height: 1.7;
        font-style: italic;
        margin: 16px 0;
    }
    .bestiary-lore-note {
        background: rgba(80,50,10,0.2);
        border-left: 3px solid #7a5a2a;
        padding: 12px 16px;
        margin: 16px 0;
        font-size: 14px;
        color: #9a7a50;
        font-style: italic;
    }
    .bestiary-hunters-note {
        background: rgba(40,60,20,0.2);
        border-left: 3px solid #4a6a2a;
        padding: 12px 16px;
        margin: 16px 0;
        font-size: 14px;
        color: #7a9a60;
        font-style: italic;
    }
    .bestiary-legacy-tag {
        display: inline-block;
        font-size: 10px;
        color: #7a5a30;
        border: 1px solid #3a2810;
        padding: 1px 6px;
        border-radius: 2px;
        letter-spacing: 1px;
        text-transform: uppercase;
        margin-left: 8px;
        vertical-align: middle;
        font-style: normal;
    }

    /* Chronicle button in character stats */
    .chronicle-open-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        width: 100%;
        padding: 13px;
        margin-top: 14px;
        background: linear-gradient(135deg, #1a1005 0%, #120d06 100%);
        border: 2px solid #5a3a18;
        color: #c8a050;
        font-family: 'Georgia', serif;
        font-size: 17px;
        letter-spacing: 2px;
        cursor: pointer;
        transition: all 0.2s;
        position: relative;
        text-transform: uppercase;
    }
    .chronicle-open-btn:hover {
        border-color: #d4a840;
        color: #e8c870;
        background: linear-gradient(135deg, #2a1a08 0%, #1a1005 100%);
        box-shadow: 0 0 16px rgba(212,168,64,0.2);
    }
    .chronicle-open-btn .btn-badge {
        display: none;
        position: absolute;
        top: -6px;
        right: -6px;
        background: #c04020;
        color: #fff;
        font-size: 11px;
        font-family: monospace;
        min-width: 20px;
        height: 20px;
        border-radius: 10px;
        align-items: center;
        justify-content: center;
        padding: 0 4px;
        font-weight: bold;
    }
    .chronicle-open-btn .btn-badge.visible { display: flex; }


        /* ═══════════════════════════════════════════════════════════════
           WELCOME / INTRO SCREEN
           Cinematic full-screen shown once after character creation.
           Parchment-warm, distinct from the CRT terminal.
           ═══════════════════════════════════════════════════════════════ */

        #welcome-overlay {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 5000;
            background: #0a0805;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Georgia', 'Times New Roman', serif;
        }
        #welcome-overlay.open { display: flex; }

        .welcome-scroll {
            position: relative;
            width: min(96vw, 640px);
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            background: #140e06;
            border: 2px solid #5a3a18;
            box-shadow: 0 0 60px rgba(180,120,30,0.15), inset 0 0 40px rgba(0,0,0,0.5);
        }
        /* Candlelight glow at top */
        .welcome-scroll::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 120px;
            background: radial-gradient(ellipse at 50% 0%, rgba(200,140,40,0.12) 0%, transparent 70%);
            pointer-events: none;
        }

        .welcome-header {
            text-align: center;
            padding: 28px 24px 16px;
            border-bottom: 1px solid rgba(90,58,24,0.4);
            position: relative;
        }
        .welcome-dragon-icon {
            font-size: 40px;
            display: block;
            margin-bottom: 10px;
            filter: drop-shadow(0 0 12px rgba(200,80,20,0.6));
            animation: dragonPulse 3s ease-in-out infinite;
        }
        @keyframes dragonPulse {
            0%, 100% { filter: drop-shadow(0 0 12px rgba(200,80,20,0.5)); }
            50%       { filter: drop-shadow(0 0 24px rgba(200,80,20,0.9)); }
        }
        .welcome-title {
            font-size: 11px;
            letter-spacing: 4px;
            text-transform: uppercase;
            color: #5a4020;
            margin-bottom: 6px;
        }
        .welcome-name {
            font-size: 26px;
            color: #e8c870;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(232,200,112,0.4);
            letter-spacing: 2px;
        }
        .welcome-class {
            font-size: 13px;
            color: #7a5a30;
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-top: 4px;
        }

        .welcome-body {
            flex: 1;
            overflow-y: auto;
            padding: 28px 32px;
            scrollbar-width: thin;
            scrollbar-color: #5a3a18 transparent;
        }
        .welcome-body::-webkit-scrollbar { width: 4px; }
        .welcome-body::-webkit-scrollbar-thumb { background: #5a3a18; }

        /* Typewriter-style paragraphs */
        .welcome-para {
            font-size: 16px;
            color: #c8a878;
            line-height: 1.8;
            margin: 0 0 18px 0;
            font-style: italic;
            opacity: 0;
            transform: translateY(6px);
            transition: opacity 0.6s ease, transform 0.6s ease;
        }
        .welcome-para.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .welcome-para:first-child::first-letter {
            font-size: 3em;
            float: left;
            line-height: 0.75;
            margin: 4px 8px 0 0;
            color: #d4a840;
            font-style: normal;
            font-weight: bold;
        }

        .welcome-callout {
            background: rgba(80,50,10,0.25);
            border-left: 3px solid #7a5a2a;
            padding: 14px 18px;
            margin: 20px 0;
            font-size: 15px;
            color: #9a7a50;
            font-style: normal;
            line-height: 1.65;
            opacity: 0;
            transition: opacity 0.8s ease;
        }
        .welcome-callout.visible { opacity: 1; }

        .welcome-divider {
            text-align: center;
            color: #5a3a18;
            letter-spacing: 6px;
            margin: 20px 0;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.6s ease;
        }
        .welcome-divider.visible { opacity: 0.6; }

        /* The "you begin in..." closing line */
        .welcome-town-line {
            text-align: center;
            padding: 16px 24px 20px;
            opacity: 0;
            transition: opacity 1s ease;
        }
        .welcome-town-line.visible { opacity: 1; }
        .welcome-town-top {
            font-size: 12px;
            letter-spacing: 3px;
            text-transform: uppercase;
            color: #5a4020;
            margin-bottom: 6px;
        }
        .welcome-town-name {
            font-size: 22px;
            color: #e8c870;
            letter-spacing: 2px;
            font-weight: bold;
            text-shadow: 0 0 16px rgba(232,200,112,0.4);
        }

        .welcome-footer {
            padding: 14px 24px 18px;
            border-top: 1px solid rgba(90,58,24,0.4);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }
        .welcome-skip {
            font-size: 12px;
            color: #3a2810;
            cursor: pointer;
            font-family: monospace;
            letter-spacing: 1px;
            background: none;
            border: none;
            transition: color 0.15s;
        }
        .welcome-skip:hover { color: #7a5a30; }
        .welcome-begin-btn {
            background: linear-gradient(135deg, #2a1a08 0%, #1a1005 100%);
            border: 2px solid #5a3a18;
            color: #c8a050;
            font-family: 'Georgia', serif;
            font-size: 15px;
            letter-spacing: 2px;
            padding: 10px 24px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            opacity: 0;
            pointer-events: none;
        }
        .welcome-begin-btn.ready {
            opacity: 1;
            pointer-events: auto;
        }
        .welcome-begin-btn:hover {
            border-color: #d4a840;
            color: #e8c870;
            box-shadow: 0 0 16px rgba(212,168,64,0.2);
        }


        /* ═══════════════════════════════════════════════════════════════
           LEVEL-UP FLASH + ANNOUNCEMENT
           ═══════════════════════════════════════════════════════════════ */

        /* Full-screen white flash */
        #levelup-flash {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 9000;
            background: white;
            pointer-events: none;
            animation: levelFlash 0.55s ease-out forwards;
        }
        @keyframes levelFlash {
            0%   { opacity: 0; }
            15%  { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Big dramatic announcement overlay */
        #levelup-announce {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 8900;
            background: rgba(0,0,0,0.85);
            align-items: center;
            justify-content: center;
            flex-direction: column;
            pointer-events: none;
        }
        #levelup-announce.show { display: flex; }

        .levelup-burst {
            text-align: center;
            animation: levelBurst 0.5s cubic-bezier(0.175,0.885,0.32,1.275) forwards;
            transform: scale(0.4);
            opacity: 0;
        }
        @keyframes levelBurst {
            0%   { transform: scale(0.4); opacity: 0; }
            60%  { transform: scale(1.08); opacity: 1; }
            100% { transform: scale(1);    opacity: 1; }
        }
        .levelup-stars {
            font-size: 36px;
            letter-spacing: 8px;
            margin-bottom: 8px;
            filter: drop-shadow(0 0 16px rgba(255,215,0,0.9));
        }
        .levelup-headline {
            font-family: 'Georgia', serif;
            font-size: clamp(36px, 8vw, 64px);
            font-weight: bold;
            color: #FFD700;
            text-shadow:
                0 0 20px rgba(255,215,0,0.9),
                0 0 40px rgba(255,165,0,0.6),
                0 0 80px rgba(255,100,0,0.3);
            letter-spacing: 6px;
            text-transform: uppercase;
            line-height: 1;
            margin-bottom: 10px;
        }
        .levelup-number {
            font-family: 'Georgia', serif;
            font-size: clamp(56px, 14vw, 100px);
            font-weight: bold;
            color: #FFF;
            text-shadow:
                0 0 30px rgba(255,255,255,1),
                0 0 60px rgba(255,215,0,0.8),
                0 0 100px rgba(255,165,0,0.5);
            line-height: 1;
            margin-bottom: 12px;
        }
        .levelup-subtitle {
            font-family: 'Georgia', serif;
            font-size: clamp(14px, 3vw, 20px);
            color: #c8a050;
            letter-spacing: 3px;
            text-transform: uppercase;
        }
        .levelup-fade-out {
            animation: levelFadeOut 0.6s ease-in forwards !important;
        }
        @keyframes levelFadeOut {
            0%   { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.92); }
        }

        /* ═══════════════════════════════════════════════════════════════
           POST-COMBAT CHRONICLE CINEMATIC
           Reuses the welcome-overlay parchment but with its own header
           ═══════════════════════════════════════════════════════════════ */
        .chronicle-cinematic-header .welcome-title {
            font-size: 10px;
            letter-spacing: 5px;
        }
        .chronicle-cinematic-header .welcome-name {
            font-size: 22px;
        }

    </style>
</head>
<body>
    <div class="scanline"></div>

    <!-- Fullscreen toggle (mobile only) -->


    <!-- Install modal (replaces old bottom-strip banner) -->
    <div id="installModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.88);z-index:3000;align-items:center;justify-content:center;">
        <div id="installModalBox" style="
            background:#050a05;border:2px solid var(--border-color);
            max-width:420px;width:90%;padding:20px 22px 18px;
            font-family:'VT323',monospace;color:var(--text-color);
            box-shadow:0 0 40px rgba(0,255,65,0.2);
            position:relative;box-sizing:border-box;">
            <div style="font-size:22px;color:var(--highlight-color);margin-bottom:14px;border-bottom:1px solid #1a3a1a;padding-bottom:8px;">
                📱 INSTALL DUNGEON QUEST
            </div>
            <div id="installModalBody"></div>
            <button onclick="closeInstallModal()" style="margin-top:14px;width:100%;font-size:18px;border-color:#555;">✕ CLOSE</button>
        </div>
    </div>
    
    <!-- MENU WRAPPER (town/shop/etc) -->
    <div class="container" id="menuContainer">
        <div class="header">
            <h1>⚔️ DUNGEON QUEST ⚔️</h1>
            <div style="color: var(--border-color);">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</div>
            <div style="color: var(--menu-color); font-size: 16px;">A Classic Text Adventure</div>
        </div>
        <div class="screen" id="mainScreen">
            <!-- Menu / town content -->
        </div>
    </div>

<!-- GAMEPLAY WRAPPER — lives at body level, full viewport -->
<div id="gameWrapper">

    <!-- HUD (desktop: top of screen) -->
    <div id="hud">
        <div class="hud-inner">
            <div id="hudName"></div>
            <div class="hud-stats">
                <span id="hudHpNums"></span>
                <span id="hudMpNums"></span>
                <span id="hudXpNums"></span>
                <span id="hudGold"></span>
            </div>
        </div>
    </div>

    <!-- TERMINAL — fills all remaining space -->
    <div id="terminalWindow"></div>

    <!-- MOBILE HUD text strip — desktop name/gold only, hidden on mobile in terminal mode -->
    <div id="mobileHud">
        <span id="mhHp"></span>
        <span id="mhMp"></span>
        <span id="mhXp" class="mhud-xp"></span>
        <span id="mhGold" class="mhud-gold"></span>
    </div>

    <!-- BOTTOM HUD (legacy, kept for compatibility) -->
    <div id="bottomHud">
        <span id="bottomHudName"></span>
        <span id="bottomHudHp"></span>
        <span id="bottomHudMp"></span>
        <span id="bottomHudXp"></span>
        <span id="bottomHudGold"></span>
    </div>

    <!-- ACTION BAR -->
    <div id="actionBar"></div>

    <!-- STATUS BARS — HP/MP bars, order:2 places them above actionBar visually -->
    <div id="statusBars">
        <!-- HP + MP side by side -->
        <div id="sbHpMpRow">
            <div id="sbHpTrack"><div id="sbHpFill"></div><div id="sbHpLabel">HP</div></div>
            <div id="sbMpTrack"><div id="sbMpFill"></div><div id="sbMpLabel">MP</div></div>
        </div>
    </div>

    <!-- XP BAR — below action bar -->
    <div id="sbXpBar">
        <div id="sbXpTrack"><div id="sbXpFill"></div><div id="sbXpLabel">XP</div></div>
    </div>

</div>    

    <!-- SYSOP Terminal -->
    <div class="sysop-badge" id="sysopBadge">⚠ SYSOP MODE ⚠</div>
    <div class="terminal-container" id="terminalContainer">
        <div class="terminal-header">═══ SYSOP TERMINAL ═══</div>
        <div class="terminal-output" id="terminalOutput"></div>
        <div id="termHints" style="display:none;font-family:'VT323',monospace;font-size:14px;padding:3px 8px;border-top:1px solid #1a3a1a;border-bottom:1px solid #1a3a1a;background:#020a02;max-height:80px;overflow-y:auto;line-height:1.4;"></div>
        <div class="terminal-input-line">
            <span class="terminal-prompt">root@dungeon:~#</span>
            <input type="text" class="terminal-input" id="terminalInput" autocomplete="off" spellcheck="false" autocorrect="off">
        </div>
    </div>

    <!-- SYSOP Full-Screen Overlay -->
    <div id="sysopOverlay">
        <!-- Header is fixed — never scrolls -->
        <div id="sysopOverlayHeader">
            <span class="syo-title">⚠ SYSOP TERMINAL ⚠</span>
            <button class="syo-close" onclick="closeSysopOverlay()">✕ CLOSE</button>
        </div>
        <!-- Scrollable content -->
        <div id="sysopOverlayInner">
            <div id="sysopOverlayContent"></div>
        </div>
    </div>

    <!-- Modal for forms -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal-content" id="modalContent"></div>
    </div>

    <!-- External Game Data Files -->
    <script src="gameversion.js"></script>
    <script src="dungeon-data.js"></script>
    <script src="Dungeon1.js"></script>
    <script src="town1.js"></script>
    <script src="town2.js"></script>
    <script src="monsters-expanded.js"></script>

    <script src="weapons.js"></script>
    <script src="armor.js"></script>
    <script src="items.js"></script>

    <script src="class-masters.js"></script>
    <script src="class-spells.js"></script>
    <script src="status-effects.js"></script>
    <script src="weapon-drops.js"></script>
    <script src="exploration-zones.js"></script>
    <script src="adventures.js"></script>
    <script src="hunter-pets.js"></script>

    <!-- ── Lore: inlined for reliability. Edit lore-*.js files then re-inline. ── -->
    <script>
// ── lore-world.js ──
// ═══════════════════════════════════════════════════════════════════════
// lore-world.js  —  World lore entries, shared by all classes
// Unlocked at levels: 1, 5, 8, 13, 18, 23, 25
// ═══════════════════════════════════════════════════════════════════════

if (typeof CHRONICLE_CONTENT === 'undefined') window.CHRONICLE_CONTENT = {};

Object.assign(CHRONICLE_CONTENT, {

    world_1: {
        cls:'all', level:1, icon:'🌍',
        title:()=>'The Calamity Dragon',
        label:'World Lore · Entry I',
        hint:'What is coming.',
        body:()=>`
            <p>A thousand years ago, the world almost ended.</p>
            <p>A dragon unlike any other emerged from the deep places of the earth — not a creature of hunger or territory, but something older and more terrible. Azrath the Calamity Dragon. Where it flew, civilizations burned. Where it landed, the land itself became poisoned, twisted, wrong. Armies broke against its scales like water against stone. The greatest heroes of the age died trying to slow it down.</p>
            <div class="chronicle-callout">One person stopped it. A warrior named Brennan the Unbroken, last of an ancient dragon-hunting bloodline, drove Azrath back from the edge of annihilation. He could not kill it — nothing could. But he could bind it. He sealed it deep beneath the earth in a prison of ancient making, and the world exhaled and began to rebuild.</div>
            <p>The seal was never meant to be permanent. Brennan knew that. He spent the rest of his life preparing for the day it would fail — hiding talismans in elemental dungeons, writing journals, trusting that his bloodline would hold and that someone would be ready when the time came.</p>
            <p>The ground has been shaking for three weeks. The scholars call it geological instability. The farmers call it the Season Sickness. The people who know what it means call it the Waking.</p>
            <p>Azrath is nearly free. The dungeons ahead are not adventures — they are training grounds. The time to prepare is now.</p>`,
    },

    world_2: {
        cls:'all', level:5, icon:'🗿',
        title:()=>'The Seal and the Thousand Years',
        label:'World Lore · Entry II',
        hint:'Why the seal is failing.',
        body:()=>`
            <p>The seal Brennan built was a masterwork — layers of ancient binding compressed into the stone of the deep places, keyed to his bloodline, maintained by the weight of the earth above it.</p>
            <p>For nine hundred and fifty years it held perfectly. Then, slowly, it began to crack.</p>
            <div class="chronicle-callout">The scholars who study such things describe the seal's decay as inevitable — not because it was poorly made, but because Azrath is patient in a way that living things cannot fully comprehend. A thousand years of constant pressure, applied without urgency, without frustration, simply as a fact of what Azrath is, has found the seams.</div>
            <p>The tremors are the result. Each time the seal cracks further, the earth shakes. Each tremor is worse than the last. The scholars have calculated a timeline. Nobody is publishing it because the timeline is soon.</p>
            <p>The dungeons across the land have become more dangerous as the seal weakens — creatures displaced from the deep places by the tremors, driven upward and outward, agitated by the same energy cracking Azrath's prison. Training in them is harder than it was a year ago.</p>
            <p>That difficulty is the point. The person who faces Azrath needs to be forged in exactly this kind of adversity.</p>`,
    },

    world_3: {
        cls:'all', level:8, icon:'🏛️',
        title:()=>'The Crossroads',
        label:'World Lore · Entry III',
        hint:'Where the called ones gather.',
        body:()=>`
            <p>In every cycle — every thousand years when Azrath stirs or wakes — the world produces people who are called to respond. Not summoned, not conscripted. Simply called, by instinct or prophecy or the particular shape of their life up to that point, toward the same place.</p>
            <p>That place is the Crossroads.</p>
            <div class="chronicle-callout">The Crossroads is older than any nation currently on the map. Built at the end of the last cycle by Brennan and the allies who survived with him, it serves as a gathering point for the next time. Every cycle since has added to it — new buildings over old foundations, new knowledge layered over old records. It is simultaneously a waystation, a library, a training ground, and a monument to every generation that faced the Calamity and kept the world going.</div>
            <p>People arriving there come from every direction and every background. Warriors and mages. Rogues and rangers. Clerics and runesmiths. Each with their own reason for being there, their own road that led to this convergence.</p>
            <p>The four elemental dungeons — Wind, Fire, Earth, Water — begin at the Crossroads. Each holds a talisman that Brennan hid there a thousand years ago. Together they are the key to the final fight.</p>`,
    },

    world_4: {
        cls:'all', level:13, icon:'⚔️',
        title:()=>'The Four Talismans',
        label:'World Lore · Entry IV',
        hint:'What Brennan left behind.',
        body:()=>`
            <p>In the fifty years after he sealed Azrath, Brennan the Unbroken did one thing above all others: he prepared.</p>
            <p>He could not know exactly who would need to face Azrath when the seal failed. What he could do was leave tools — instruments of power hidden in dungeons, designed to reveal themselves to someone who had earned the right to hold them.</p>
            <div class="chronicle-callout">The four talismans correspond to the four elemental forces Azrath's power draws from: Wind (its speed), Fire (its destruction), Earth (its endurance), Water (its adaptability). Each talisman counters one aspect of the dragon. Together they make a confrontation possible that would otherwise be suicide.<br><br>Each dungeon tests something different — not strength, but character. What you believe, why you are fighting, who you have become in the making of yourself. The talismans do not simply reward power. They reward purpose.</div>
            <p>Every class that arrives at the Crossroads will attempt all four dungeons. The tests will look different depending on who you are. The talismans respond to who you have become, not what class you chose at the start.</p>`,
    },

    world_5: {
        cls:'all', level:18, icon:'🔥',
        title:()=>'Azrath the Calamity Dragon',
        label:'World Lore · Entry V',
        hint:'Know your enemy.',
        body:()=>`
            <p>Azrath does not hate. It does not want anything in the way that living creatures want things. It is not angry, not territorial, not hungry in any sense that maps onto the creatures you have been fighting.</p>
            <p>It is the Calamity. That is what it is, not what it does. Its existence is a force of destruction the way a storm is a force of destruction — not malicious, simply an expression of what it fundamentally is.</p>
            <div class="chronicle-callout">Brennan's first journal contains seventeen pages about Azrath's behavior and capabilities, written over fifty years of observation. The consistent thread: Azrath cannot be reasoned with, cannot be frightened, cannot be distracted, and cannot be exhausted. It does not retreat. It does not reconsider. The only thing that has ever stopped it is being physically stopped.<br><br>The seal bought a thousand years. The talismans make a permanent solution possible. But the person who stands in front of Azrath must be, in every meaningful sense, ready for something that will not stop until it is stopped.</div>
            <p>You have been training for this since level one. Every dungeon, every fight, every piece of yourself you have sharpened — it was not for the journey. It was for this moment.</p>`,
    },

    world_6: {
        cls:'all', level:23, icon:'⏳',
        title:()=>'The Last Days of the Seal',
        label:'World Lore · Entry VI',
        hint:'The window is closing.',
        body:()=>`
            <p>The seal is failing.</p>
            <p>Not completely — not yet — but what remains is a formality. The deep tremors have become constant. The sky in the direction of the sealing site has been wrong for days. Creatures that were contained in the deep places are surfacing in numbers the surface world cannot manage.</p>
            <div class="chronicle-callout">Azrath stirs in its prison, pressing against walls that no longer have the strength to hold. Every hour that passes, the prison weakens further. The world can feel it — not as a mystical sensation but as a physical fact. The temperature drops. The wildlife goes silent. People who do not know what is happening feel a dread they cannot name.</div>
            <p>You are level twenty-three. Two levels from where you need to be. The Crossroads is quiet now — everyone has found their road to this endpoint.</p>
            <p>The four talismans are ready. You are nearly ready. The world has given you everything it had to give.</p>
            <p>Two levels. Move.</p>`,
    },

    world_7: {
        cls:'all', level:25, icon:'✦',
        title:()=>'The Reckoning',
        label:'World Lore · Entry VII',
        hint:'The final page.',
        body:(name)=>`
            <p>This is the last page of the world lore.</p>
            <p>Not because the story ends here — stories do not end. But this particular chapter closes with you, at level twenty-five, standing at the point where everything converges.</p>
            <div class="chronicle-callout">A thousand years ago, Brennan the Unbroken stood where you are standing. He did not have the talismans — he built them after, so whoever came next would have what he had to improvise. He did not have a Crossroads — he built that after too. He did everything he could with what he had, and then spent fifty years making sure the next person would have more.</div>
            <p>Every person at the Crossroads, every fighter who faced the creatures of the Waking and kept moving — they all led to this. Different roads. The same destination.</p>
            <p>The seal is gone. Azrath is free. And you are standing here with everything you needed, because a man who lived a thousand years ago trusted that someone would be ready.</p>
            <p>Go, <span class="chronicle-name">${name}</span>. The world is waiting to find out who you are.</p>`,
    },

});

// ── lore-warrior.js ──
// ═══════════════════════════════════════════════════════════════════════
// lore-warrior.js  —  Warrior class chronicle entries
// Unlocked at levels: 1, 3, 8, 13, 15, 18, 20, 23, 25
// Warrior arc: Last of Brennan's bloodline. The destiny was always theirs.
// ═══════════════════════════════════════════════════════════════════════

if (typeof CHRONICLE_CONTENT === 'undefined') window.CHRONICLE_CONTENT = {};

Object.assign(CHRONICLE_CONTENT, {

    warrior_1: {
        cls:'warrior', level:1, icon:'⚔️',
        title:(n)=>`${n}'s Chronicle`,
        label:'The Warrior · Entry I',
        hint:'The blood remembers.',
        body:(n)=>`
            <p>The ground has been shaking for three weeks.</p>
            <p>Not the kind of trembling that comes from a collapsing mine or a landslide in the high passes. This is deeper — a rumble that comes up through the soles of your boots and settles in your chest, steady and rhythmic, like something enormous breathing in its sleep far beneath the world. The farmers are calling it the Season Sickness. The scholars are calling it geological instability. Your family has another name for it.</p>
            <p>They call it the Waking.</p>
            <div class="chronicle-callout">A thousand years ago, a warrior named Brennan the Unbroken stood alone against a dragon called Azrath — the Calamity Dragon — and drove it back from the edge of annihilation. He could not kill it. Nothing could. But he was strong enough, clever enough, and had bled enough to bind it. To seal it in a prison of ancient making that would hold as long as the world held its breath.<br><br>That seal is breaking. The tremors are the proof.</div>
            <p>You grew up hearing this story. Every child of Brennan's line does. Your grandmother told it like a warning dressed as a legend — Azrath will return, and when it does, the blood of Brennan will be called. You thought it was the kind of story families tell to make themselves feel important.</p>
            <p>Then the ground started shaking.</p>
            <p>You are <span class="chronicle-name">${n}</span>. You are the last of the bloodline. And somewhere beneath the trembling earth, something old and enormous and furious is nearly free.</p>
            <p>The dungeons ahead are not adventures. They are training. Every level you earn, every fight you survive, every piece of yourself you sharpen — it is preparation for one moment that has been a thousand years in the making.</p>
            <p>You have until level twenty-five to be ready for it.</p>`,
    },

    warrior_2: {
        cls:'warrior', level:3, icon:'⚔️',
        title:(n)=>`${n}'s Chronicle`,
        label:'The Warrior · Entry II',
        hint:"What Brennan left behind.",
        body:(n)=>`
            <p>Your grandmother kept a chest at the foot of her bed that you were never allowed to open as a child. She told you it contained old things, family things, nothing interesting. You believed her the way children believe things they are not supposed to question.</p>
            <p>After the first tremor, she opened it herself. She set the contents on the table one by one without speaking: a journal with cracked leather binding, a fragment of chain so old it had gone grey, and a map so faded you could only make out coastlines and mountain ranges — and in the center, marked in ink that had once been red, a single location labeled in a language you do not recognize.</p>
            <div class="chronicle-callout">She said: Brennan wrote down everything he learned about Azrath. The weaknesses, the patterns, the way it fights, the way it thinks. He spent fifty years hunting it before he cornered it. The journal is what he knew at the end.<br><br>Then she said: It took him until level twenty-five. He was not chosen because of his bloodline. He became the bloodline by surviving long enough to learn what needed to be learned.</div>
            <p>You have been reading the journal every night. Brennan's handwriting is cramped and practical — the writing of someone more comfortable with a sword than a pen. He does not dramatize. He observes. He records. He is wrong about some things and admits it in the margins in a different ink, years later.</p>
            <p>The man who sealed Azrath was not a legend when he started. He was someone who did not stop.</p>
            <p><span class="chronicle-name">${n}</span> — the journal is yours now. The chest is empty. The training has begun.</p>`,
    },

    warrior_3: {
        cls:'warrior', level:8, icon:'⚔️',
        title:(n)=>`${n}'s Chronicle`,
        label:'The Warrior · Entry III',
        hint:'The world is already moving.',
        body:(n)=>`
            <p>You are not the only one.</p>
            <p>This took longer to understand than it should have. You have been thinking of this as a personal matter — bloodline, destiny, the weight of a name passed down a thousand years. And it is personal. But the tremors are not personal. Azrath's return does not care about your family history. It is coming for everything.</p>
            <p>The proof arrived in the form of a rider from the eastern provinces who stopped at the same inn last night. A mage — you could tell by the way she catalogued the room when she walked in. Over dinner she told you that the Academy had been tracking the seal's degradation for six months. That scholars across the continent were independently arriving at the same timeline.</p>
            <div class="chronicle-callout">She said there were others already moving. A ranger who had been watching the northern forests die along the ley lines. A cleric whose prayers had begun bouncing back wrong. A runesmith who kept waking with tools in his hands he did not remember picking up.<br><br>She said there was a place — an old place, used in past cycles — where people like this were supposed to find each other. A Crossroads. She did not know exactly where yet. Neither do you.</div>
            <p>The dungeons you have been training in are harder now. The creatures in them are agitated, displaced, pushed out of their deep places toward the surface. The tremors are waking things that were comfortable asleep.</p>
            <p>Two more levels and you will be strong enough to find the Crossroads properly.</p>
            <p><span class="chronicle-name">${n}</span> — Brennan worked alone because there was no one else. You will not have to.</p>`,
    },

    warrior_4: {
        cls:'warrior', level:13, icon:'⚔️',
        title:(n)=>`${n}'s Chronicle`,
        label:'The Warrior · Entry IV',
        hint:'The Crossroads.',
        body:(n)=>`
            <p><span class="chronicle-epithet">✦ The Last of Brennan's Blood ✦</span></p>
            <p>You heard the Crossroads before you saw it. Voices — dozens of them, in languages you recognize and languages you do not, all arriving from different roads at the same point. You crested the ridge and stopped.</p>
            <p>The valley below was chaos. Controlled, purposeful chaos, but chaos nonetheless. Warriors sharpening blades beside mages who had set up open-air research stations. Rogues comparing notes with rangers. A necromancer and a cleric sitting across a fire from each other with the careful courtesy of people who disagree about everything except the thing that brought them here. All of them converging on a town built recently around very old foundations.</p>
            <div class="chronicle-callout">An old man at the gate looked at you for a long moment before you said a word. Then he said: Brennan's blood. I wondered when you would arrive. There is something here that was left for you.<br><br>He led you to a locked room in the oldest building at the Crossroads. On a stone pedestal, sealed in a case that opened at your touch and no one else's, was the second half of Brennan's journal — the pages he did not trust to family. The pages about what happens next.</div>
            <p>The four talismans — Wind, Fire, Earth, Water — are scattered in the elemental dungeons beyond this valley. They were placed there a thousand years ago by Brennan himself. Everyone here is searching for them. But Brennan's bloodline carries the one thing the talismans are keyed to recognize.</p>
            <p><span class="chronicle-name">${n}</span> — you are the reason the Crossroads was built.</p>`,
    },

    warrior_5: {
        cls:'warrior', level:15, icon:'⚔️',
        title:(n)=>`${n}'s Chronicle`,
        label:'The Warrior · Entry V',
        hint:'The first talisman.',
        body:(n)=>`
            <p>Brennan's second journal was more specific than the first. He wrote about each of the four elemental dungeons — not as a guide, but as a record of what each one demanded. What it cost him. What he had to understand about himself before the talisman would accept his touch.</p>
            <p>He wrote: <em>The Wind dungeon did not test my strength. It tested whether I knew why I was fighting. It put the question to me in the dark, in a chamber where the air moved like it was alive, and I had to answer honestly. The talisman accepted that.</em></p>
            <div class="chronicle-callout">You have retrieved the first talisman now. You understand what he meant. The dungeon was not a test of combat — you handled the combat. It was a test of something harder to train for than swordsmanship.<br><br>The talisman sits in your pack and hums faintly. Not with magic exactly. More with recognition. Like it has been waiting a thousand years for the right hand.</div>
            <p>Three more to find. The Fire dungeon to the south, the Earth dungeon in the deep mountains, the Water dungeon at the coastal cliffs. He left one note consistent across all four entries: <em>Each one is harder than the last. Not because the enemies are stronger. Because it asks more of you each time.</em></p>
            <p><span class="chronicle-name">${n}</span> — one down. Three to go.</p>`,
    },

    warrior_6: {
        cls:'warrior', level:18, icon:'⚔️',
        title:(n)=>`${n}'s Chronicle`,
        label:'The Warrior · Entry VI',
        hint:'All four. One purpose.',
        body:(n)=>`
            <p>All four talismans. You set them out on the table in your room at the Crossroads and looked at them for a long time.</p>
            <p>Wind — light as a held breath, shifts when you are not watching it directly. Fire — warm to the touch regardless of room temperature, never hot enough to burn but always present. Earth — heavier than its size should allow, completely steady. Water — the last one, the hardest dungeon, the one Brennan's journal described with the fewest words and the most crossed-out sentences. It looks like glass. It shows you something different every time you pick it up.</p>
            <div class="chronicle-callout">The old man at the Crossroads gate examined them together and confirmed what the journal predicted: four separate instruments that function as a single key. Designed to work in the hands of Brennan's bloodline because Brennan built them that way. He did not trust any other lock. He did not trust any other hand.<br><br>He trusted yours, a thousand years before you were born.</div>
            <p>The tremors are worse now. Deeper. The kind of shaking that feels like something testing a wall rather than a random earthquake. Purposeful. Almost impatient.</p>
            <p><span class="chronicle-name">${n}</span> — Brennan had to improvise when he sealed Azrath. He made the talismans so you would not have to. Seven more levels. Use them well.</p>`,
    },

    warrior_7: {
        cls:'warrior', level:20, icon:'⚔️',
        title:(n)=>`${n}'s Chronicle`,
        label:'The Warrior · Entry VII',
        hint:"What Brennan's journal says about the end.",
        body:(n)=>`
            <p>The last entry in Brennan's second journal is short. Four pages, where every other entry ran to twenty or thirty. The handwriting is steadier than the earlier entries, which surprised you. You expected urgency. What you found was calm.</p>
            <p>He wrote: <em>I am going tomorrow. I have been ready for three days but kept finding reasons to wait. I think I was waiting for fear. Fear never came. What came instead was a sense of the thing being what it is, and myself being what I am, and those two facts pointing toward a single moment. I am going toward the moment. That is all.</em></p>
            <div class="chronicle-callout">He wrote one more paragraph. He wrote: If you are reading this, my line held. A thousand years is a long time to trust blood you have not met. I hope you are ready. I hope the training was enough. I hope the world gave you people around you, because I did not do this alone even though the histories will say I did.<br><br>He signed it with his name, the date, and nothing else.</div>
            <p>You are level twenty. Five levels from where Brennan was when he wrote those words. The tremors are frequent enough that people outside the valley are beginning to understand something is wrong. Armies are mobilizing — forces that will be entirely useless against what is coming, but moving because they have to do something.</p>
            <p>You have something more useful than armies. You have four talismans, a bloodline, and twenty levels of training that took Brennan fifty years.</p>
            <p><span class="chronicle-name">${n}</span> — five levels. Read his words again. Then go earn them.</p>`,
    },

    warrior_8: {
        cls:'warrior', level:23, icon:'⚔️',
        title:(n)=>`${n}'s Chronicle`,
        label:'The Warrior · Entry VIII',
        hint:'The seal breaks.',
        body:(n)=>`
            <p>The seal broke three days ago.</p>
            <p>Not completely — a partial fracture, a crack wide enough that things are already coming through. The creatures in the deep dungeons have become frantic. The tremors are now constant, a background vibration people have stopped mentioning because mentioning it does not help. The sky to the northeast has been wrong since dawn on the second day — a darkness that is not cloud cover, a color with no clean name.</p>
            <p>The Crossroads is quieter than it has been in weeks. Not because people have left. Because everyone understands that the time for preparing is ending and the time for what the preparation was for is arriving.</p>
            <div class="chronicle-callout">You went through the second journal again last night, looking for anything you had missed. There was a line in the Fire dungeon entry you had read a dozen times without fully understanding: <em>When it is time, you will not feel ready. Readiness is not a feeling. It is the sum of everything you did when you did not feel ready.</em><br><br>Two levels. You will have them before Azrath is fully free. The timeline is going to be close but it will be enough.</div>
            <p>The old man at the gate found you this morning and said nothing. He just looked at you the way he looked at you the first day — then nodded once and walked away. You think that was his version of encouragement.</p>
            <p>The talismans have been warm for three days. Not the way the Fire one is always warm. Warm the way something gets when it knows its purpose is close.</p>
            <p><span class="chronicle-name">${n}</span> — two levels. Brennan is counting on you. He has been for a thousand years.</p>`,
    },

    warrior_9: {
        cls:'warrior', level:25, icon:'⚔️',
        title:(n)=>`${n}'s Chronicle`,
        label:'The Warrior · Entry IX',
        hint:'The last entry.',
        body:(n)=>`
            <p>This is the last entry.</p>
            <p>You are level twenty-five. The seal is gone. Azrath is awake and the sky confirms it — a darkness spreading from the northeast that swallows light without producing shadow, that makes the air taste like something ancient and cold and vast beyond imagining.</p>
            <p>The four talismans are with you. Wind circling your left shoulder, Earth grounded at your feet, Fire at your right hand, Water at your back. They know. They have always known. Brennan built them to recognize this moment the way a key recognizes a lock.</p>
            <div class="chronicle-callout">His last journal entry said he did not feel fear at the end. Only the sense of a thing being what it is, and himself being what he is, and those two facts pointing toward a single moment.<br><br>You understand that now. You are the last of his blood, standing at the end of a thousand years of consequence, and you do not feel fear. You feel the weight of everything you have trained through, survived, and learned — and it is exactly enough. It was always going to be exactly enough. He made sure of that too.</div>
            <p>Azrath the Calamity Dragon is coming.</p>
            <p>You are the only person alive with the bloodline to finish what Brennan started. The only person with all four talismans, earned through dungeons that tested not just your strength but your character. The only person who has read both halves of a journal written a thousand years ago by someone who trusted their blood to produce exactly this.</p>
            <p>The others at the Crossroads will witness it. They have their own reasons for being here, their own roads that led to this valley. They will remember what they saw.</p>
            <p>But this part — this is yours.</p>
            <p>Go, <span class="chronicle-name">${n}</span>.</p>
            <p>Brennan is waiting to see how his line ends.</p>`,
    },

});

// ── lore-mage.js ──
// lore-mage.js  —  Mage class chronicle entries
// STATUS: Stub — content being written
// Levels: 1, 3, 8, 13, 15, 18, 20, 23, 25

if (typeof CHRONICLE_CONTENT === 'undefined') window.CHRONICLE_CONTENT = {};

Object.assign(CHRONICLE_CONTENT, {
    mage_1: {
        cls:'mage', level:1, icon:'🔮',
        title:(n)=>n+"'s Notes",
        label:'The Mage · Entry I',
        hint:'The numbers do not lie.',
        body:(n)=>`
            <p>The seal's degradation curve is not theoretical. You have been plotting it for six months — longer than the Academy has been willing to admit the problem exists — and the numbers are unambiguous. The rate of decay has accelerated three times since your first measurement. Every new data point compresses the timeline further.</p>
            <p>The Academy calls it a modeling artifact. Your instruments are miscalibrated, your methodology flawed, your conclusions alarmist. You have checked your methodology four times. The instruments are fine. The conclusions are correct.</p>
            <div class="chronicle-callout">A dragon called Azrath was sealed beneath the earth a thousand years ago by a warrior named Brennan the Unbroken. The seal is a masterwork — layered binding compressed into deep stone, maintained by the weight of the world above it.<br><br>It is failing. Not because it was poorly made, but because Azrath is patient in a way that living things cannot fully comprehend. A thousand years of constant pressure has found the seams.</div>
            <p>The tremors are the proof. Each one corresponds exactly to a spike in the degradation readings. The ground shakes when another layer of binding gives way. The frequency is increasing.</p>
            <p>You are <span class="chronicle-name">${n}</span>. The Academy dismissed you. The evidence did not change. You are training now — not because the institution approved it, but because the evidence requires it. Every level you earn is another tool in the fight the data has been predicting.</p>
            <p>You have until level twenty-five. The numbers say so.</p>`,
    },
    mage_2: {
        cls:'mage', level:3, icon:'🔮',
        title:(n)=>n+"'s Notes",
        label:'The Mage · Entry II',
        hint:'What the library found.',
        body:(n)=>`
            <p>The restricted archive had three texts you were not supposed to access without faculty approval. You accessed them anyway. Two were useless. The third was a survey of binding theory written fifty years after the sealing by someone who had spoken to Brennan directly.</p>
            <div class="chronicle-callout">The author wrote: <em>Brennan understood the mechanics of the binding only in the sense that a smith understands fire — practically, instinctively, without the formal apparatus to explain what he knew. What he built should not have worked as well as it did. The fact that it held suggests either that intuitive knowledge exceeds formal knowledge in certain extreme applications, or that Brennan was considerably more capable than he appeared.</em><br><br>The survey described the binding's architecture in enough technical detail that you spent two days verifying it against your own models. The architecture is correct. And there is a flaw — not in Brennan's work, but in the nature of the seal itself. It was designed to hold. It was not designed to hold forever.</div>
            <p>Brennan knew this. The survey's final section describes a conversation where he said plainly that the seal was a delay, not a solution, and that he had spent the last decade of his life preparing for the delay's end.</p>
            <p>The preparation included talismans — instruments of elemental countering, placed in dungeons, keyed to survive a thousand years and respond to the right person's touch.</p>
            <p><span class="chronicle-name">${n}</span> — the theoretical framework for those talismans is the most elegant binding architecture you have ever encountered. You want to study them. First you have to be strong enough to reach them.</p>`,
    },
    mage_3: {
        cls:'mage', level:8, icon:'🔮',
        title:(n)=>n+"'s Notes",
        label:'The Mage · Entry III',
        hint:'Others who noticed.',
        body:(n)=>`
            <p>A rider from the northern college arrived while you were reviewing your latest readings. She introduced herself as a fellow researcher — different specialization, same conclusion. The Academy dismissed her three months before they dismissed you.</p>
            <div class="chronicle-callout">There is a place called the Crossroads. Old records describe it as a gathering point built by Brennan himself after the last Azrath cycle. In every cycle, the world produces people who independently arrive at the same conclusion from different directions. The Crossroads exists to give them somewhere to find each other.<br><br>She had triangulated its location from three separate historical accounts. The data puts it at around level ten to twelve in terms of what the surrounding terrain requires to navigate safely. You are level eight. The road is almost open.</div>
            <p>She also told you something the historical accounts confirmed but your modeling had not captured: the elemental dungeons near the Crossroads are not naturally occurring. They were constructed. The binding architectures inside them are intentional — tests, not obstacles. Brennan built them to evaluate the people who attempted them.</p>
            <p>A dungeon designed by the man who built the original seal. You have been thinking about the talismans as objects to retrieve. You are starting to understand they are problems to solve.</p>
            <p><span class="chronicle-name">${n}</span> — you are going to find the elemental dungeons fascinating. First you have to be strong enough for them to let you in.</p>`,
    },
    mage_4: {
        cls:'mage', level:13, icon:'🔮',
        title:(n)=>n+"'s Notes",
        label:'The Mage · Entry IV',
        hint:'The Crossroads.',
        body:(n)=>`
            <p><span class="chronicle-epithet">✦ Keeper of the Degradation Curve ✦</span></p>
            <p>The valley is exactly where the triangulated data said it would be. You arrived to find it already full — warriors and rogues and rangers and clerics, all converging from different roads. The people here are not adventurers. They are professionals called by their particular expertise to the same endpoint.</p>
            <div class="chronicle-callout">The library at the Crossroads is better than you expected. Records from every previous cycle, annotated by the researchers of each generation, with cross-references you would have needed decades to compile independently.<br><br>The binding architecture of the elemental dungeons is documented in detail. Wind tests clarity of purpose. Fire tests commitment. Earth tests foundation. Water tests adaptability. A mage who cannot articulate why they are fighting will not pass the Wind dungeon. The talisman simply waits until the answer becomes honest.</div>
            <p>You can articulate it. You have been articulating it in your research notes for months. The answer is the same every time: the data requires it.</p>
            <p><span class="chronicle-name">${n}</span> — the library will still be here when you return. Go do the work the data requires.</p>`,
    },
    mage_5: {
        cls:'mage', level:15, icon:'🔮',
        title:(n)=>n+"'s Notes",
        label:'The Mage · Entry V',
        hint:'The first talisman.',
        body:(n)=>`
            <p>The Wind talisman is architecturally extraordinary. You are writing this down before the details fade, because what you observed is exactly what the library described and also completely unlike what the description prepared you for.</p>
            <p>The binding structure is recursive — layers of elemental attunement that reference each other in a closed loop, self-sustaining for exactly the duration Brennan designed. A thousand years of stability, and it shows: not a single seam has drifted.</p>
            <div class="chronicle-callout">The dungeon asked you why you were doing this. Not in words — the mechanism is environmental. The air pressure in the final chamber changed based on the coherence of your intent. When you were uncertain, the chamber resisted. When you were clear, it opened.<br><br>You were clear. Six months of dismissed data, a road that led here instead of anywhere else. The talisman accepted the answer without ceremony. It simply became available to take. The hum it makes is not magical resonance. It is the sound of a thousand-year-old lock recognizing that the right key has arrived.</div>
            <p>Three more. The Fire dungeon will ask about commitment — how far you will go, without flinching from the answer. You have thought about this. The answer is: as far as the evidence requires.</p>
            <p><span class="chronicle-name">${n}</span> — one down. The architecture of the next one is in the library notes. You have already read them twice.</p>`,
    },
    mage_6: {
        cls:'mage', level:18, icon:'🔮',
        title:(n)=>n+"'s Notes",
        label:'The Mage · Entry VI',
        hint:'All four. A complete system.',
        body:(n)=>`
            <p>All four talismans. You have examined each individually and spent two days examining them as a system, and the system is more elegant than any single component suggested.</p>
            <p>Wind: recursive elemental attunement, self-sustaining, extraordinary stability. Fire: thermal binding with controlled release architecture. Earth: gravitational anchoring with layered resonance dampening. Water: the most complex — adaptive binding that rewrites its own outer parameters while maintaining core integrity.</p>
            <div class="chronicle-callout">Together they form a closed system of elemental countering that addresses each of Azrath's fundamental properties simultaneously. No single talisman could accomplish this. The interaction effects between all four create capabilities the individual components do not have.<br><br>Brennan designed them to work together from the beginning. The solo tests were calibration steps — each talisman was learning about the person carrying it, so that when combined, the system would be tuned to that specific individual. You are the instrument the system was calibrating for.</div>
            <p>The degradation curve has accelerated again. Seven more levels. The numbers have always said twenty-five.</p>
            <p><span class="chronicle-name">${n}</span> — the system is complete. Now you have to be complete enough to use it.</p>`,
    },
    mage_7: {
        cls:'mage', level:20, icon:'🔮',
        title:(n)=>n+"'s Notes",
        label:'The Mage · Entry VII',
        hint:'What the final data says.',
        body:(n)=>`
            <p>The Crossroads library has records from previous cycles. In each complete record, the person who faced Azrath was not the most powerful individual of their generation. They were the most prepared. The distinction matters.</p>
            <div class="chronicle-callout">Brennan's own record is the most detailed. His final entry, written two years before his death, summarizes everything he learned:<br><br><em>I sealed it. I did not understand it when I did. I have spent fifty years trying to understand it, and I understand it better now but not completely. What I know with certainty: it cannot be reasoned with, frightened, or exhausted. It can only be stopped. The talismans I built are designed to make stopping possible. Whether they are sufficient depends on the person using them, not on their construction.</em><br><br>The person using them. That is the variable he could not control for.</div>
            <p>You are level twenty. Five more levels. Your degradation curve is accurate to within three percent. The seal will fail at approximately the moment you reach twenty-five, assuming your training pace holds.</p>
            <p>It is not a coincidence. Brennan engineered the timeline. The seal was designed to hold long enough for the right person to be ready.</p>
            <p><span class="chronicle-name">${n}</span> — you are the variable he built the timeline around. Do not waste the calibration.</p>`,
    },
    mage_8: {
        cls:'mage', level:23, icon:'🔮',
        title:(n)=>n+"'s Notes",
        label:'The Mage · Entry VIII',
        hint:'Terminal phase.',
        body:(n)=>`
            <p>The seal entered terminal phase four days ago. The readings confirm it — not theoretical terminal, but active terminal. The binding layers are failing faster than the curve projected, which means your margin was on the optimistic side.</p>
            <p>You have two levels. The revised projection gives you slightly less time than you thought. Not dramatically less. Enough.</p>
            <div class="chronicle-callout">The Crossroads has gone quiet in the way that places go quiet before something large happens. The conversations have changed — nobody is discussing theory anymore. The discussions are operational: what to do when, who will be where, what the signals are that indicate the final phase has begun.<br><br>You updated your model this morning. The revised curve is precise to within forty-eight hours. Two other researchers checked your methodology. They did not find errors.</div>
            <p>The talismans are active in a way they were not before. The Wind one has been making a different sound — not the thousand-year resonance hum, but something with more urgency. The Water one shows you the same image every time you pick it up: a clear sky over an open field, with nothing moving in it. You are choosing to interpret that as the outcome rather than the alternative.</p>
            <p><span class="chronicle-name">${n}</span> — two levels. The model says you have time. Make the model right.</p>`,
    },
    mage_9: {
        cls:'mage', level:25, icon:'🔮',
        title:(n)=>n+"'s Notes",
        label:'The Mage · Entry IX',
        hint:'Final entry.',
        body:(n)=>`
            <p>The seal is gone. The terminal phase completed at 04:17 this morning — you were awake, monitoring the readings, and watched the last binding layer fail in real time. The degradation curve was accurate to within six hours. You consider that a successful prediction.</p>
            <p>Azrath is awake. The atmospheric distortion you predicted three months ago is present and measurable at the bearing you calculated. Your instruments are not wrong. They were never wrong.</p>
            <div class="chronicle-callout">The Academy dismissed you because your conclusions were inconvenient. The conclusion was always the same: the seal will fail, Azrath will return, and the world will need someone who understood what was happening well enough to do something about it.<br><br>You understood what was happening. You did something about it. You trained, you studied, you retrieved the talismans, you did not stop when the institution failed you, and you are standing here at level twenty-five with a complete elemental countering system and a precise technical understanding of what you are about to face.<br><br>That is what the data required.</div>
            <p>Brennan's final record says: <em>Whether the talismans are sufficient depends on the person using them, not on their construction.</em></p>
            <p>You are the person using them. The construction is flawless. The person has been tested across twenty-five levels and found sufficient.</p>
            <p>Go, <span class="chronicle-name">${n}</span>. Prove the model right.</p>`,
    },
});

// ── lore-rogue.js ──
// lore-rogue.js  —  Rogue class chronicle entries
// STATUS: Stub — content being written
// Levels: 1, 3, 8, 13, 15, 18, 20, 23, 25

if (typeof CHRONICLE_CONTENT === 'undefined') window.CHRONICLE_CONTENT = {};

Object.assign(CHRONICLE_CONTENT, {
    rogue_1: {
        cls:'rogue', level:1, icon:'🗡️',
        title:(n)=>n+"'s Account",
        label:'The Rogue · Entry I',
        hint:'What the networks know.',
        body:(n)=>`
            <p>You have survived by knowing things other people do not. Information is your currency, your weapon, your escape route. And what you know right now — what every shadow network from the ports to the mountain passes is whispering — is that the earth is wrong.</p>
            <p>The tremors. The dead rising near the old pillar routes. The creature migrations pushing everything out of the deep places toward the surface. Every fence, every information broker, every person who makes their living knowing things before others do — they all say the same thing. Something is coming. Something that makes kings irrelevant and armies useless.</p>
            <div class="chronicle-callout">Azrath the Calamity Dragon was sealed beneath the earth a thousand years ago by a warrior named Brennan the Unbroken. The seal is breaking. The tremors are the proof, and the people who move in the shadows of this world have known it longer than the scholars have been willing to admit.<br><br>The Calamity does not distinguish between the powerful and the powerless. It does not negotiate. It does not accept bribes, or change its plans based on intelligence, or have informants that can be turned. The only counter is the one Brennan left behind — and it requires someone who has earned twenty-five levels of capability to use it.</div>
            <p>You are <span class="chronicle-name">${n}</span>. You have heard the whisper. Every dungeon ahead is a training ground — every skill sharpened, every level earned. The skills you have spent your life building are exactly what the fight ahead requires.</p>
            <p>The networks know something is coming. You are going to be the person who does something about it.</p>`,
    },
    rogue_2: {
        cls:'rogue', level:3, icon:'🗡️',
        title:(n)=>n+"'s Account",
        label:'The Rogue · Entry II',
        hint:'A contact in the right place.',
        body:(n)=>`
            <p>The information arrived through three separate handlers, none of whom knew about the others. You paid for the first two. The third came as a gift, which meant whoever sent it wanted you to have it and had reasons they were not disclosing. You verified all three independently before you acted on any of it.</p>
            <div class="chronicle-callout">There is a place called the Crossroads. It appears in records from previous cycles — not prominently, not obviously, but if you know how to read what is not said in a document, it is there. A gathering point. A place where the people called to respond to each cycle of the Calamity find each other.<br><br>Every network has it as a blank spot. Not an absence — a deliberate omission. The kind of gap that appears in records not when people do not know about a thing, but when they have collectively agreed not to write it down. That kind of blank spot means the place is real and the people who protect it have reach.</div>
            <p>You also found a reference to Brennan's preparation — the talismans he hid in elemental dungeons, the journal he left for his bloodline, the Crossroads he built as a convergence point. The architecture of the preparation is more sophisticated than any single-generation plan. He built it to survive a thousand years of entropy. It has.</p>
            <p><span class="chronicle-name">${n}</span> — the information says the Crossroads opens at around level ten. Train. You need to be worth what you find there.</p>`,
    },
    rogue_3: {
        cls:'rogue', level:8, icon:'🗡️',
        title:(n)=>n+"'s Account",
        label:'The Rogue · Entry III',
        hint:'The value of what you know.',
        body:(n)=>`
            <p>Three more contacts in the last two weeks, all independently confirming the same thing: the seal is in active failure, not gradual degradation. The distinction matters. Gradual degradation gives you time. Active failure gives you a deadline.</p>
            <p>You have also been watching the creature movements more carefully. The migrations from the deep places follow specific routes — not random displacement, but purposeful evacuation. Something down there is organizing the retreat, or at minimum broadcasting a signal strong enough that animals with no language are responding to it coherently.</p>
            <div class="chronicle-callout">The mage you met on the road last week had data that confirmed your field observations from a different angle. Her degradation curve matches your timeline estimates within a reasonable margin. She is also heading toward the Crossroads. She mentioned others — a ranger tracking the forest deaths, a cleric whose prayers had gone wrong, a runesmith waking up with tools in their hands.<br><br>The people who are going to do something about this are already moving. The Crossroads is where they are going to find each other. You have two levels before the terrain opens up enough to get there safely.</div>
            <p>You have never worked well with others. You have also never faced something that could not be handled alone. This may be the first time both of those things are true simultaneously.</p>
            <p><span class="chronicle-name">${n}</span> — the networks say the fight requires every kind of skill. Yours specifically. Trust the networks this once.</p>`,
    },
    rogue_4: {
        cls:'rogue', level:13, icon:'🗡️',
        title:(n)=>n+"'s Account",
        label:'The Rogue · Entry IV',
        hint:'The Crossroads.',
        body:(n)=>`
            <p><span class="chronicle-epithet">✦ Reader Between the Lines ✦</span></p>
            <p>You arrived at the Crossroads the way you arrive everywhere — quietly, from a direction nobody was watching, having already spent two hours surveying the perimeter before you walked through the gate. The old man there did not react, which meant he had seen you during the survey and chose not to say anything. You respected that.</p>
            <div class="chronicle-callout">The Crossroads is harder to read than you expected. The people here are from every background and every kind of expertise, and they are all operating with partial information about each other, which means the social dynamics are complex in ways that your usual methods do not simplify cleanly.<br><br>What you did find: the library has operational records from previous cycles, including after-action documentation on what worked and what did not. The elemental dungeons are documented in enough detail to plan an approach. The talismans require something from the person retrieving them — not information, but honesty about what that information is for. You are going to have to be genuine in there. That is not a skill you practice often.</div>
            <p>The Wind dungeon tests why you are doing this. You have been thinking about your answer. It is not simple, and it does not reduce to a clean sentence, and you are not sure a talisman built by a legendary warrior is going to accept nuance.</p>
            <p>You are going to find out.</p>
            <p><span class="chronicle-name">${n}</span> — the Crossroads is the most information-dense environment you have ever been in. Use it.</p>`,
    },
    rogue_5: {
        cls:'rogue', level:15, icon:'🗡️',
        title:(n)=>n+"'s Account",
        label:'The Rogue · Entry V',
        hint:'The first talisman.',
        body:(n)=>`
            <p>The Wind dungeon asked you why you were doing this, and you gave it the honest answer, which is complicated and not flattering in every part. You are doing this because you heard the whisper and you are constitutionally incapable of ignoring a threat once you have confirmed it. You are doing this because every network you trust says this is where the important thing is happening, and you go where the important things are. You are doing this because the alternative — knowing and not acting — has never once been something you could live with.</p>
            <div class="chronicle-callout">The chamber accepted that. It did not require the answer to be noble. It required the answer to be true.<br><br>The talisman is lighter than you expected. It shifts slightly in your grip when you are not paying attention to it, like it is adjusting its position based on information you are not consciously processing. You are choosing to find that useful rather than unsettling. A tool that is always orienting itself correctly is a tool worth carrying.</div>
            <p>Three more. You have read the documentation on all of them. The Fire dungeon asks about commitment, which is going to require you to be honest about how far you will actually go rather than how far you prefer to claim you will go. Those are different numbers. You know what the honest answer is.</p>
            <p><span class="chronicle-name">${n}</span> — the talisman is already learning you. Three more calibration steps.</p>`,
    },
    rogue_6: {
        cls:'rogue', level:18, icon:'🗡️',
        title:(n)=>n+"'s Account",
        label:'The Rogue · Entry VI',
        hint:'All four.',
        body:(n)=>`
            <p>All four talismans, and you have had time to study how they behave when carried together. The individual behaviors you noted — the Wind one adjusting its position, the Fire one warming when your resolve is clear, the Earth one going heavier when you are on uncertain ground, the Water one showing you information you did not ask for — combine into something that reads as a system.</p>
            <div class="chronicle-callout">The system is watching you the same way you watch everything. Observing, recording, calibrating. Brennan built intelligence into these things — not a consciousness, but something like professional attentiveness. The four talismans together are more aware of you than you are comfortable with, and you are a person who is comfortable with very little surveillance.<br><br>You have decided to reframe it: you are not being watched, you are being equipped. The talismans are learning everything they need to know about the specific person who will use them, because the use requires precision that cannot be achieved without that knowledge. You are being studied because the study is necessary.</div>
            <p>The tremors are worsening. Seven more levels. The networks have gone quieter than usual, which is what happens when people who trade in information are out of information to trade. The situation has moved past the point where intelligence is the primary resource.</p>
            <p><span class="chronicle-name">${n}</span> — you have everything you need. The talismans have everything they need. Seven levels.</p>`,
    },
    rogue_7: {
        cls:'rogue', level:20, icon:'🗡️',
        title:(n)=>n+"'s Account",
        label:'The Rogue · Entry VII',
        hint:'What the silence means.',
        body:(n)=>`
            <p>The networks have stopped talking. That has happened twice in your career — once during a war that everyone knew was coming and nobody wanted to acknowledge, and once during the collapse of a city that the people inside it refused to admit was happening until it was over.</p>
            <p>Both times, the silence preceded something that could not be addressed by information alone. Both times, the silence ended when the event ended.</p>
            <div class="chronicle-callout">This silence is different. It is not the silence of denial. It is the silence of everyone who trades in information simultaneously realizing that the situation has moved into a domain where information is no longer the primary resource. What is required now is action by specific people with specific capabilities, and no amount of intelligence work changes what those people need to do.<br><br>You are one of those specific people. Your specific capabilities — the ability to move unseen, to read environments before committing to them, to act at exactly the right moment with exactly the right precision — are not secondary to this fight. They are structural to it. Brennan's preparation did not account for a warrior and nothing else. It accounted for every kind of strength the world could produce.</div>
            <p>Five more levels. The silence will end when the event ends. You intend to be one of the reasons it ends correctly.</p>
            <p><span class="chronicle-name">${n}</span> — the networks are quiet. Go be loud where it matters.</p>`,
    },
    rogue_8: {
        cls:'rogue', level:23, icon:'🗡️',
        title:(n)=>n+"'s Account",
        label:'The Rogue · Entry VIII',
        hint:'Two levels.',
        body:(n)=>`
            <p>The seal fractured three days ago. You know this not from official announcements — there have been none — but from the movement patterns of every creature in a fifty-mile radius simultaneously changing direction. That kind of coordinated behavioral shift does not happen without a shared cause. The cause is pressure from below getting suddenly, significantly worse.</p>
            <div class="chronicle-callout">The Crossroads has gone operational. Conversations are short and purposeful. People who were still debating approach two weeks ago are not debating anymore. The theoretical phase is over. Everyone here has made their peace with what is coming and is focusing on what they can actually affect.<br><br>You spent this morning doing what you always do before something important: checking every assumption, verifying every piece of information, confirming that the picture you have built is accurate and complete. It is. The talismans are ready. You are two levels from where you need to be. The timeline is going to be close.</div>
            <p>Close is fine. You have worked with close margins before. Close is not the same as too late.</p>
            <p>The Water talisman showed you something when you picked it up this morning. Not the usual information — something specific. You are choosing not to write it down, because writing it down would require you to process it, and processing it right now would take time you need for the two levels.</p>
            <p><span class="chronicle-name">${n}</span> — two levels. Then the information you have been carrying your whole career finally gets used for what it was always for.</p>`,
    },
    rogue_9: {
        cls:'rogue', level:25, icon:'🗡️',
        title:(n)=>n+"'s Account",
        label:'The Rogue · Entry IX',
        hint:'Final account.',
        body:(n)=>`
            <p>Seal down. Azrath awake. Sky confirms it in three different ways that you have been watching for, and all three are present.</p>
            <p>This is the last entry. Not because there will be nothing to record after — there will be, one way or another — but because the recording phase is over. What you know is what you know. The information has been gathered, verified, and acted upon to the extent that information can be acted upon. The rest is not an intelligence problem.</p>
            <div class="chronicle-callout">You have spent your career moving through the world quietly, knowing things before other people knew them, being in position before events required it. Every network, every contact, every careful conversation and patient observation was, in retrospect, preparation for this.<br><br>Not because you planned it that way. Because the skills that let you survive in the shadow world are the same skills that let you get here at level twenty-five with four talismans and a complete picture of what you are walking into. Brennan's preparation accounted for someone like you. He needed every kind of strength. He needed yours specifically.</div>
            <p>The talismans are settled. All four oriented correctly without you asking them to.</p>
            <p>Go, <span class="chronicle-name">${n}</span>.</p>
            <p>You already know everything you need to know. You have always known this was where you were going.</p>`,
    },
});

// ── lore-ranger.js ──
// lore-ranger.js  —  Ranger class chronicle entries
// STATUS: Stub — content being written
// Levels: 1, 3, 8, 13, 15, 18, 20, 23, 25

if (typeof CHRONICLE_CONTENT === 'undefined') window.CHRONICLE_CONTENT = {};

Object.assign(CHRONICLE_CONTENT, {
    ranger_1: {
        cls:'ranger', level:1, icon:'🏹',
        title:(n)=>n+"'s Field Notes",
        label:'The Ranger · Entry I',
        hint:'What the land already knew.',
        body:(n)=>`
            <p>The forest has been wrong for three months before the tremors started. You noticed it the way you notice everything — not as a sudden revelation but as an accumulation of observations that eventually demanded an explanation. The migration routes shifted. Silence appeared in places that should have been full of sound. Animals you had tracked for years abandoned territories they had held for generations, not fleeing predators but moving with the deliberate calm of creatures following a signal you could not hear.</p>
            <p>Then the tremors came, and the signal became audible to everyone. By then you had already started training.</p>
            <div class="chronicle-callout">Azrath the Calamity Dragon was sealed beneath the earth a thousand years ago. The seal is breaking. The tremors are how the surface world experiences it, but the deep world — the root systems, the underground water, the creatures that live in the soil and stone — has been feeling it for far longer. The natural world knew before the scholars did. You read the natural world. You knew when it did.</div>
            <p>You are <span class="chronicle-name">${n}</span>. The land told you what was coming. The dungeons ahead are training grounds — every level earned, every skill sharpened, every hour in difficult terrain that makes the next terrain less impossible. You are not preparing for adventure. You are preparing to answer what the forest has been trying to say.</p>`,
    },
    ranger_2: {
        cls:'ranger', level:3, icon:'🏹',
        title:(n)=>n+"'s Field Notes",
        label:'The Ranger · Entry II',
        hint:'Reading what runs.',
        body:(n)=>`
            <p>You have been mapping the creature migrations for six weeks now. Not because anyone asked you to — because the patterns are speaking and you want to understand what they are saying before the conversation ends.</p>
            <div class="chronicle-callout">The migrations are not random. The routes have consistent directionality away from a central bearing — southeast, specifically, which corresponds to where the tremors originate when you track their epicenters carefully. Every species responds differently: birds leave first, mammals second, insects third, and the things that live deepest in the earth do not leave at all because there is nowhere for them to go. The ones that surface are not migrating. They are being forced up.<br><br>There is a secondary pattern that took longer to identify: some creatures are not fleeing. Some are converging. Moving toward the Crossroads — a place you found referenced in a notation on an old map, circled in a hand that was not the map's original author. The notation simply says: <em>gather here.</em></div>
            <p>You are going to find the Crossroads. The creatures are already ahead of you.</p>
            <p><span class="chronicle-name">${n}</span> — the land has been giving you the route since before you knew you needed one. Follow it.</p>`,
    },
    ranger_3: {
        cls:'ranger', level:8, icon:'🏹',
        title:(n)=>n+"'s Field Notes",
        label:'The Ranger · Entry III',
        hint:'The silence has a source.',
        body:(n)=>`
            <p>You identified the source of the silence three days ago. Not Azrath directly — the dragon is still sealed, though the seal is failing — but the overflow energy from the cracking binding. It saturates the soil at certain depths and creates a resonance that predators interpret as a rival apex presence and prey interpret as a trap. The result is what you have been observing: vacated territories, abandoned routes, the particular stillness of a landscape waiting for something to pass.</p>
            <div class="chronicle-callout">A mage you shared a campfire with last week had data that confirmed your field observations from a theoretical angle. Her degradation curve matches your timeline estimates. She mentioned others already moving toward the Crossroads — the same convergence point the secondary migration pattern was pointing toward.<br><br>The Crossroads sits in a valley where the overflow energy is dampened — natural formations that interrupt the resonance. It is the only zone in a hundred-mile radius where the land feels normal. That is why the old records chose it as a gathering point. That is why even the animals navigate around it rather than through it. It is a quiet place in a loud situation.</div>
            <p>Two more levels and the terrain between here and there opens up. The forest is already showing you the path — you just need to be strong enough to walk it.</p>
            <p><span class="chronicle-name">${n}</span> — the land chose the meeting place. Trust it.</p>`,
    },
    ranger_4: {
        cls:'ranger', level:13, icon:'🏹',
        title:(n)=>n+"'s Field Notes",
        label:'The Ranger · Entry IV',
        hint:'The Crossroads.',
        body:(n)=>`
            <p><span class="chronicle-epithet">✦ Voice of the Waking Land ✦</span></p>
            <p>The half-mile radius of stillness before the Crossroads is unlike anything you have encountered. Not the stillness of a predator's territory or a toxic zone or a drought-struck forest. The stillness of a place that has been deliberately set apart — held quiet by something older than the current crisis, by design rather than accident.</p>
            <div class="chronicle-callout">The valley itself is remarkable. The geology is wrong for the region — too stable, too balanced, too precisely arranged to be natural. Someone shaped this place. You spent the first morning walking its perimeter and reading what the land had to say, and what the land said was: this was made. A thousand years ago, by someone who understood how to work with terrain rather than against it.<br><br>The elemental dungeons radiate from the Crossroads like spokes from a hub. Each one is positioned to maximize its particular elemental character — the Wind dungeon at the valley's highest point, the Fire dungeon at a geothermal feature, the Earth dungeon at the deepest stable rock formation, the Water dungeon at the coastal convergence. Brennan knew what he was doing with landscape. You recognize the methodology even if the scale is beyond anything you have attempted.</div>
            <p>The talismans are waiting at the end of those spokes. The forest is quiet. The path is clear. You know what to do with a clear path.</p>
            <p><span class="chronicle-name">${n}</span> — the land has been pointing here the entire time. You are exactly where you are supposed to be.</p>`,
    },
    ranger_5: {
        cls:'ranger', level:15, icon:'🏹',
        title:(n)=>n+"'s Field Notes",
        label:'The Ranger · Entry V',
        hint:'The first talisman.',
        body:(n)=>`
            <p>The Wind dungeon tested something you did not expect to be tested on: patience. Not the patience of waiting for prey — you have that. The patience of holding uncertainty without resolving it prematurely. The dungeon put you in situations where the correct answer was not yet visible and rewarded waiting over guessing. You waited. The talisman recognized it.</p>
            <div class="chronicle-callout">The dungeon also asked, in its environmental way, why you were doing this. You gave it the answer that was true without being complicated: because the land told you to, and you have never in your life ignored what the land tells you, and you do not intend to start now.<br><br>The talisman fits in your hand like it was made for a tracker — balanced, responsive to movement, attuned to direction. You have been carrying it for three days and you are already reading it the way you read animal sign. It has a grammar. You are learning it.</div>
            <p>Three more. The Earth dungeon is the one you are most curious about. You have spent your career reading landscape. A dungeon built to test your relationship with the ground beneath you is the most natural test you have been offered.</p>
            <p><span class="chronicle-name">${n}</span> — one talisman and three more to learn. The land is still teaching.</p>`,
    },
    ranger_6: {
        cls:'ranger', level:18, icon:'🏹',
        title:(n)=>n+"'s Field Notes",
        label:'The Ranger · Entry VI',
        hint:'All four, all speaking.',
        body:(n)=>`
            <p>All four talismans, and they are louder than the individual ones were. Not audibly louder — the hum is the same. Louder in the way that four separate pieces of information are louder than one, when they are all pointing at the same thing.</p>
            <div class="chronicle-callout">The talismans are reading the land the way you read the land. Wind is tracking air patterns you cannot see. Fire is monitoring the thermal activity from the deep places — it has been running hotter for three days, which corresponds to increased geothermal stress from the failing seal. Earth is doing something with the seismic data that you do not fully understand yet but that feels like it is building a picture. Water knows where the water table has shifted in the last month and what that implies about what is moving below it.<br><br>You have been a tracker your whole life. You have never had instruments this sensitive. Brennan built them for a warrior, but they speak the language of the land, and you have been fluent in that language since before you could read words.</div>
            <p>Seven more levels. The talismans will keep reading. You will keep listening.</p>
            <p><span class="chronicle-name">${n}</span> — you and Brennan's instruments are finally speaking the same language.</p>`,
    },
    ranger_7: {
        cls:'ranger', level:20, icon:'🏹',
        title:(n)=>n+"'s Field Notes",
        label:'The Ranger · Entry VII',
        hint:'What the land says now.',
        body:(n)=>`
            <p>The land says: soon. Not in those words — the land does not use words — but in the way it says everything: through pattern, through signal, through the behavior of every living thing that responds to it. You have spent twenty levels learning to read this particular message. You understand it now.</p>
            <div class="chronicle-callout">The convergence patterns have changed in the last week. The creatures that were fleeing the deep-place overflow are no longer running. They have reached whatever distance felt safe to them and stopped there, and they are facing the direction they came from. Waiting. Watching. The forest at the edges of the affected zone is perfectly still in a way that has nothing to do with the silence you documented earlier.<br><br>The land is holding its breath. You have seen this before — before large events, before significant changes in the environment's balance. The land holds its breath and then either the event happens and the breath releases, or the threat passes and the breath releases more slowly. There is no third option. The breath will release.</div>
            <p>Five more levels. The creatures are waiting. The land is waiting. You will not make them wait much longer.</p>
            <p><span class="chronicle-name">${n}</span> — the forest trained you for this. Every season of reading what could not be seen was preparation. You are ready.</p>`,
    },
    ranger_8: {
        cls:'ranger', level:23, icon:'🏹',
        title:(n)=>n+"'s Field Notes",
        label:'The Ranger · Entry VIII',
        hint:'The last migration.',
        body:(n)=>`
            <p>The seal fractured. You felt it in the land before you heard about it from anyone — a deep shudder that was different from the previous tremors, more final, less repetitive. The tremors were a door straining against its hinges. What you felt three days ago was the hinges giving.</p>
            <div class="chronicle-callout">The last migration has started. Not the creature migrations you documented earlier — those are long finished. This one is people. Families from the villages closest to the sealing site, moving away from the bearing you have been tracking all along. They are moving with the particular speed of people who are not sure what they are running from but are certain they need to run.<br><br>You cannot help them by following. You can help them by going the other direction. The talismans know this — they have been oriented toward the bearing consistently for three days, not adjusting, not hesitating. They are pointed at what needs to be done and they are waiting for you to catch up.</div>
            <p>Two more levels. Then you stop tracking and start ending.</p>
            <p><span class="chronicle-name">${n}</span> — two levels. The land has been reading you as carefully as you have been reading it. It believes you are ready. Trust the land.</p>`,
    },
    ranger_9: {
        cls:'ranger', level:25, icon:'🏹',
        title:(n)=>n+"'s Field Notes",
        label:'The Ranger · Entry IX',
        hint:'Last field entry.',
        body:(n)=>`
            <p>The seal is gone. You knew it the moment it happened — the land exhaled, the holding-breath tension of the last month releasing all at once, and then immediately inhaling again in a different way. The old threat was lifting. The new threat was present.</p>
            <p>The sky to the northeast is wrong. Not wrong in any way you can describe with standard observation language — wrong in the way that things are wrong when something fundamentally large is moving through a space not designed to accommodate it.</p>
            <div class="chronicle-callout">You have spent twenty-five levels reading what the land tells you. Here is what it is telling you right now:<br><br>The creatures have stopped moving. Every migration, every evacuation, every behavioral shift of the last several months has reached its endpoint. The land is perfectly still in the way it is still before an apex predator makes its move — not the stillness of absence, but the stillness of everything else yielding to the thing that matters most.<br><br>You are the thing that matters most. The land is yielding to you. It has been yielding to you since level one, showing you the path, teaching you the grammar, pointing you toward this moment. You are the apex presence the silence has been making room for.</div>
            <p>The talismans are oriented and steady. The Wind one has stopped adjusting — it found its bearing and is holding it absolutely.</p>
            <p>Go, <span class="chronicle-name">${n}</span>.</p>
            <p>The forest taught you everything it had to teach. Use it.</p>`,
    },
});

// ── lore-runesmith.js ──
// lore-runesmith.js  —  Runesmith class chronicle entries
// STATUS: Stub — content being written
// Levels: 1, 3, 8, 13, 15, 18, 20, 23, 25

if (typeof CHRONICLE_CONTENT === 'undefined') window.CHRONICLE_CONTENT = {};

Object.assign(CHRONICLE_CONTENT, {
    runesmith_1: {
        cls:'runesmith', level:1, icon:'🔷',
        title:(n)=>n+"'s Working Log",
        label:'The Runesmith · Entry I',
        hint:'Muscle memory from another life.',
        body:(n)=>`
            <p>The hand reached for the tool before you knew you needed it. Not the first time — that has been happening for months, with increasing frequency and decreasing surprise. You wake up with configurations in your hands that you did not choose before sleep. You find yourself halfway through a binding sequence with no memory of starting it. The craft is moving through you rather than being directed by you, and you have stopped fighting it because the configurations are always correct.</p>
            <div class="chronicle-callout">The configurations are binding runes. Ancient ones — not in the sense of old-fashioned, but in the sense of foundational, pre-formal, the kind of working that was done before anyone developed the vocabulary to teach it systematically. You have looked them up. They exist in historical records in incomplete fragments, because the people who knew them fully never wrote them down completely — they passed them through demonstration and muscle memory.<br><br>A warrior named Brennan the Unbroken used configurations matching these to seal a dragon called Azrath a thousand years ago. The seal is breaking. The tremors are the proof. And your hands keep rehearsing the configurations that made the seal in the first place.</div>
            <p>You are <span class="chronicle-name">${n}</span>. Your hands remember something your mind does not. The dungeons ahead are training grounds — every level earned, every technique refined, every ancient configuration your muscle memory shows you integrated into capability rather than reflex. You are not learning the old craft. You are remembering it.</p>
            <p>There is a difference, and it matters.</p>`,
    },
    runesmith_2: {
        cls:'runesmith', level:3, icon:'🔷',
        title:(n)=>n+"'s Working Log",
        label:'The Runesmith · Entry II',
        hint:'What the old texts confirm.',
        body:(n)=>`
            <p>You found three partial texts on pre-formal binding theory in the back of a specialist archive that mostly serves scholars who do not actually practice the craft. The texts are fragmentary and contradictory in places, but the fragments that describe the configurations your hands keep producing are consistent across all three sources and with each other.</p>
            <div class="chronicle-callout">The configurations are specifically designed for the binding of entities whose power exceeds conventional containment parameters — not in the general sense, but in a very specific sense. They are Azrath configurations. Not configurations that happen to work on Azrath. Configurations that were developed, through unknown means, specifically for and in response to Azrath's particular energy signature.<br><br>The third text has a marginal note written in a different hand than the main text, much later: <em>The smith who contributed these configurations claimed to have worked them before. Not in this life. The claim was dismissed at the time as mystical thinking. In retrospect, the precision of the configurations is not consistent with someone learning. It is consistent with someone remembering.</em><br><br>You are not the first person whose hands knew these things before their mind did.</div>
            <p><span class="chronicle-name">${n}</span> — the texts call what you are doing inheritance. Not of blood, but of craft. Something in the practice of the work carries forward when formal memory cannot. You are carrying Brennan's craft forward. The tremors are why it is waking up now.</p>`,
    },
    runesmith_3: {
        cls:'runesmith', level:8, icon:'🔷',
        title:(n)=>n+"'s Working Log",
        label:'The Runesmith · Entry III',
        hint:'The craft is preparing you.',
        body:(n)=>`
            <p>The configurations have become more complex over the last two levels. In the beginning they were fragments — isolated sequences your hands completed before your mind engaged. Now they are assembling into something coherent. You have started writing them down as they come, and the written record shows an architecture emerging: components that reference each other, that build toward something you have not yet seen the completion of.</p>
            <div class="chronicle-callout">A mage you shared a workspace with last week had theoretical models that partially overlapped with what you are building. Her framework is formal and systematic — the kind of work done with instruments and documented methodology. Your framework is intuitive and embodied — the kind of work done with hands and muscle memory.<br><br>They describe the same architecture from different angles. The intersection between them produced two hours of the most productive technical conversation you have had in years. She is heading toward the Crossroads. She mentioned that there are tools there — instruments left by the previous cycle's craftspeople — that no one has been able to use because no one has had the right hands.<br><br>You think you have the right hands.</div>
            <p>Two more levels and the terrain opens. The craft is impatient in a way it has never been before — the configurations are coming faster, clearer, more insistent. Something that has been dormant for a thousand years is waking up because it is needed.</p>
            <p><span class="chronicle-name">${n}</span> — the craft is preparing you. Trust the preparation.</p>`,
    },
    runesmith_4: {
        cls:'runesmith', level:13, icon:'🔷',
        title:(n)=>n+"'s Working Log",
        label:'The Runesmith · Entry IV',
        hint:'The Crossroads.',
        body:(n)=>`
            <p><span class="chronicle-epithet">✦ Hands That Remember ✦</span></p>
            <p>The tools the mage mentioned are in a sealed room in the oldest building at the Crossroads. The room did not open for the ten people who tried before you. It opened for you before you touched it — the lock recognized something in your hands' configuration, the particular way your fingers were positioned from that morning's involuntary working session, and released.</p>
            <div class="chronicle-callout">Inside: instruments unlike anything in current practice. The materials are a thousand years old but perfectly maintained, as if they have been in a preservation field. Some of them you recognize — scaled-up versions of tools you use in standard work. Some of them you have never seen and know immediately how to use. Your hands demonstrate the grip and the motion before your mind finishes processing the tool's shape.<br><br>Brennan worked with a runesmith. The historical records do not say this clearly — they describe him as working alone — but the tools in this room were not made by a warrior. The person who made these spent decades developing a practice specifically in service of what Brennan needed. The Crossroads preserved their work. Your hands recognize it because you are carrying that practice forward.</div>
            <p>The elemental dungeons are constructed with binding architectures. You can read them the way a reader reads text. The talismans inside them are the most sophisticated free-standing binding objects you have ever encountered, and you need to be worthy of retrieving them.</p>
            <p><span class="chronicle-name">${n}</span> — the room opened for you. The tools are yours. Go be worthy of them.</p>`,
    },
    runesmith_5: {
        cls:'runesmith', level:15, icon:'🔷',
        title:(n)=>n+"'s Working Log",
        label:'The Runesmith · Entry V',
        hint:'The first talisman.',
        body:(n)=>`
            <p>The Wind dungeon is built around a recursive binding architecture that your hands identified before your eyes did. Walking through the chambers, your fingers were already tracing the response configurations — not the ones you would use to dismantle it, but the ones you would use to show it that you understood it. That you spoke its language.</p>
            <div class="chronicle-callout">The talisman was not hidden. It was waiting on a central plinth in the final chamber, fully visible, and it was waiting because it had been built to require someone who could demonstrate understanding of its own construction before it could be taken. You demonstrated the understanding. Not by solving a puzzle or defeating a guardian, but by showing your hands to a binding configuration and having the configuration recognize the craft in them.<br><br>The talisman's construction is the work of the smith whose tools are in the Crossroads room. You can feel the maker's grammar in it — the particular rhythm of someone who spent fifty years developing a practice in response to a single problem. You spent that time too, in a different life, and the resonance between those two periods of dedication is what made the talisman available.</div>
            <p>Three more. Each one will ask the same question in a different material language: are you the person who knows this craft? You are. Your hands have always known it.</p>
            <p><span class="chronicle-name">${n}</span> — one down. Three more recognitions to come.</p>`,
    },
    runesmith_6: {
        cls:'runesmith', level:18, icon:'🔷',
        title:(n)=>n+"'s Working Log",
        label:'The Runesmith · Entry VI',
        hint:'All four, a complete working.',
        body:(n)=>`
            <p>All four talismans. You have spread them out on the workbench in the Crossroads tool room and spent a full day reading them as a unified object. They are not four separate instruments that happen to work together. They are four components of a single working that was deliberately divided into pieces because no single component would survive a thousand years intact, but four components in separate stable environments would.</p>
            <div class="chronicle-callout">The reassembly is not physical — you do not combine them into one object. The reassembly is relational: the four components recognize each other when carried by the same person, and that recognition activates the unified working they were designed to produce. Your hands have been demonstrating the activation configuration involuntarily for three days, which is your muscle memory's way of confirming that the reassembly is complete.<br><br>The old smith in the Crossroads room built the components. Brennan designed the unified working. The division into four was a practical solution to a preservation problem, and it has worked exactly as designed. What you are holding is a thousand-year-old masterwork that has been waiting for someone with the right hands to reassemble it.</div>
            <p>Seven more levels. Then you use the working for the purpose it was built for — the purpose that has been written into your hands since before you understood what writing meant.</p>
            <p><span class="chronicle-name">${n}</span> — the working is complete. You are the last component it needed.</p>`,
    },
    runesmith_7: {
        cls:'runesmith', level:20, icon:'🔷',
        title:(n)=>n+"'s Working Log",
        label:'The Runesmith · Entry VII',
        hint:'What the craft has been building toward.',
        body:(n)=>`
            <p>You found the old smith's personal notes in a sealed compartment inside the tool room that you did not notice during your first visit. Small format, dense handwriting, covering forty years of practice. The notes are a record of someone spending a lifetime developing a craft that they understood, from early on, was not primarily for their own use.</p>
            <div class="chronicle-callout">The final entry in the notes is addressed to no one in particular — or to the person who would find them, which amounts to the same thing:<br><br><em>The warrior needed tools that did not exist. I spent forty years making them. I do not know if I have made them correctly because I will not be there to see them used. I know I have made them as correctly as I am capable of making them, which is the only kind of knowing available to a craftsperson. If you are reading this, the tools found someone whose hands were ready for them. That is all I ever asked.</em><br><br>The notes end there. You have read them four times.</div>
            <p>Five more levels. You are going to use these tools correctly. Not because you are certain, but because you have done the work, and that is the only kind of certainty available to a craftsperson.</p>
            <p><span class="chronicle-name">${n}</span> — the smith spent forty years making these for you. Do not waste their decade.</p>`,
    },
    runesmith_8: {
        cls:'runesmith', level:23, icon:'🔷',
        title:(n)=>n+"'s Working Log",
        label:'The Runesmith · Entry VIII',
        hint:'Two levels.',
        body:(n)=>`
            <p>The seal fractured. You felt it in the configuration — the binding sequence your hands have been rehearsing for months shifted, and the part of the sequence corresponding to the existing seal became unnecessary. Your hands dropped it automatically, moving directly to the next phase. The next phase is the one that matters.</p>
            <div class="chronicle-callout">The other craftspeople at the Crossroads can feel it too. There is a particular quality of attention in a workshop when something significant is about to be attempted — a focus that is not nervous but is not casual either. The Crossroads has had that quality for three days. Everyone is working on what they can still prepare, and everyone knows that the preparation time is ending.<br><br>Your hands have been running the activation configuration continuously for the last forty-eight hours. Not involuntarily anymore — deliberately. Practicing. Making sure the motion is as clean and as certain as it needs to be. The talisman system responds to the quality of the working as much as to the working itself. Sloppy craft will not do.</div>
            <p>Two more levels. The craft is ready. The hands are ready. You are becoming ready.</p>
            <p><span class="chronicle-name">${n}</span> — the smith would recognize what you have become. Two levels. Make the craft proud.</p>`,
    },
    runesmith_9: {
        cls:'runesmith', level:25, icon:'🔷',
        title:(n)=>n+"'s Working Log",
        label:'The Runesmith · Entry IX',
        hint:'Final working log entry.',
        body:(n)=>`
            <p>The seal is gone. Your hands knew before the sky showed it — the last remnant of the binding dissolved and the configuration your hands have been rehearsing for months reached its final form, complete and ready and pointed at what comes next.</p>
            <p>This is the last entry in the working log. Not because the work is finished — it is about to reach its most important phase — but because the log serves the preparation, and the preparation is complete.</p>
            <div class="chronicle-callout">Forty years the old smith spent building the tools. A thousand years the tools spent waiting. Twenty-five levels you spent becoming the person whose hands could use them.<br><br>There is a grammar to all of this that feels deliberate. Not predetermined — craft is never predetermined, the maker always has choices and the choices always matter. But deliberate, in the sense that the work was done with purpose, and the purpose pointed consistently at this moment.<br><br>You are the final instrument. The talisman system is complete. The working is loaded and ready. Your hands know exactly what to do.</div>
            <p>Go, <span class="chronicle-name">${n}</span>.</p>
            <p>The smith made the tools. You learned the craft. Now use it.</p>`,
    },
});

// ── lore-cleric.js ──
// lore-cleric.js  —  Cleric class chronicle entries
// STATUS: Stub — content being written
// Levels: 1, 3, 8, 13, 15, 18, 20, 23, 25

if (typeof CHRONICLE_CONTENT === 'undefined') window.CHRONICLE_CONTENT = {};

Object.assign(CHRONICLE_CONTENT, {
    cleric_1: {
        cls:'cleric', level:1, icon:'✨',
        title:(n)=>n+"'s Prayer Log",
        label:'The Cleric · Entry I',
        hint:'When the prayers go wrong.',
        body:(n)=>`
            <p>The silence began six months ago. Not complete silence — the prayers are still answered, occasionally, partially, in the way that a conversation is still happening when one person is shouting from a great distance and the other can only hear fragments. But before six months ago, the connection was clear. Before six months ago, you did not have to work this hard to hear anything at all.</p>
            <p>The order calls it a trial of faith. They say it happens to everyone eventually, a period of distance that tests commitment and produces stronger conviction on the far side. You have kept a log. The silence does not follow the patterns of a faith trial. It follows the patterns of interference.</p>
            <div class="chronicle-callout">Azrath the Calamity Dragon was sealed beneath the earth a thousand years ago. The seal is breaking. The energy overflow from the cracking binding saturates everything it touches — the soil, the water, the air — and the connections between the faithful and whatever they are faithful to are not immune. The silence in your prayers is not divine absence. It is obstruction.<br><br>The interference has a source. The source is the same thing that is causing the tremors. The tremors will stop when the source is stopped, and the prayers will clear, and the conversation you have been straining to hear through static will become audible again.</div>
            <p>You are <span class="chronicle-name">${n}</span>. Your faith has not failed you. Something is standing between you and what your faith reaches toward. The dungeons ahead will make you strong enough to reach through the obstruction. Every level you earn is a step closer to clear signal.</p>`,
    },
    cleric_2: {
        cls:'cleric', level:3, icon:'✨',
        title:(n)=>n+"'s Prayer Log",
        label:'The Cleric · Entry II',
        hint:'What the older records say.',
        body:(n)=>`
            <p>The temple archive has records from the last Azrath cycle — not labeled as such, but identifiable if you know what pattern of disruption to look for. The records describe a period of prayer interference lasting approximately eight years, corresponding exactly with the period of Azrath's active presence above ground. The interference ended when Brennan completed the sealing.</p>
            <div class="chronicle-callout">The archive also contains correspondence between three clerics of that era who independently reached the same conclusion you have: the disruption is not internal, not a test, not a consequence of insufficient faith. It is external, structural, caused by the same force that is devastating the surrounding landscape.<br><br>One of the three wrote something that you have read several times: <em>It would be easier if this were a trial of faith. Trials end. What we are experiencing is obstruction, and obstruction requires removal rather than endurance. The appropriate response is not patience. It is action.</em><br><br>The appropriate response is action. The archive knows what needs to be done. It has known for a thousand years.</div>
            <p><span class="chronicle-name">${n}</span> — the older clerics faced this and chose action over endurance. The choice is the same now. Train. Become capable of the action that is required.</p>`,
    },
    cleric_3: {
        cls:'cleric', level:8, icon:'✨',
        title:(n)=>n+"'s Prayer Log",
        label:'The Cleric · Entry III',
        hint:'Faith sharpened by resistance.',
        body:(n)=>`
            <p>You have noticed something over the last several weeks of training. The harder the conditions, the clearer the partial signals that come through the interference. Not louder — clearer. As if the connection is not distance-limited but difficulty-filtered. As if whatever is on the other side of the obstruction can reach further toward you when you are reaching harder toward it.</p>
            <div class="chronicle-callout">A researcher from the Academy confirmed, inadvertently and from a completely different methodological angle, that the interference is worse in areas of low physical stress and better in areas of high physical stress. Her explanation was technical and involved resonance frequencies and biological signal amplification. Your explanation is that faith responds to effort in kind.<br><br>They are probably both correct from their respective angles.<br><br>She mentioned the Crossroads — a gathering place, two levels ahead in terms of terrain requirements. She mentioned that others were moving there from every direction. You have heard references to it in the older archive materials. A place built specifically for this kind of convergence, where the interference is reportedly lower than anywhere else in the affected radius.</div>
            <p>Two more levels and the road opens. The signals have been getting clearer as you train. The pattern holds.</p>
            <p><span class="chronicle-name">${n}</span> — faith sharpened by resistance is still faith. Keep reaching.</p>`,
    },
    cleric_4: {
        cls:'cleric', level:13, icon:'✨',
        title:(n)=>n+"'s Prayer Log",
        label:'The Cleric · Entry IV',
        hint:'The Crossroads.',
        body:(n)=>`
            <p><span class="chronicle-epithet">✦ Clear Signal Through the Static ✦</span></p>
            <p>The prayers are louder here. Not answered — you have learned over the last year to distinguish between proximity and response — but louder in the sense that the signal is stronger, the interference lower, the partial connection more coherent than it has been anywhere else you have trained.</p>
            <div class="chronicle-callout">The Crossroads has its own archive, maintained continuously across every cycle. The clerical records within it are extensive — detailed accounts of how faith-based practices were affected by each Azrath emergence, what techniques helped maintain connection through the interference, what the experienced practitioners of each generation learned that the next generation needed to know.<br><br>The consistent finding across all cycles: the interference is worst just before and during Azrath's full emergence, and clears completely once Azrath is sealed or destroyed. Every cycle, the clerics who maintained functional connection through the peak interference period did so by accepting that the connection would be partial and working with what was available rather than waiting for full clarity that would not come during the crisis.</div>
            <p>You have been doing this for months. You are more practiced at partial connection than most of your peers. That practice is the preparation. The partial signal is enough to work with. It has been enough the whole time.</p>
            <p><span class="chronicle-name">${n}</span> — the Crossroads prayers are clearer than any you have sent in six months. Send them well.</p>`,
    },
    cleric_5: {
        cls:'cleric', level:15, icon:'✨',
        title:(n)=>n+"'s Prayer Log",
        label:'The Cleric · Entry V',
        hint:'The first talisman.',
        body:(n)=>`
            <p>The Wind dungeon tested your relationship with uncertainty, which is the core practical skill of faith — the capacity to act without full information, trusting that what you cannot see is there. The dungeon removed certainty systematically and watched what you did with its absence. You have been living in uncertainty for a year. The talisman recognized the practice.</p>
            <div class="chronicle-callout">Carrying the first talisman, you noticed something unexpected: the interference in your prayers diminished slightly. Not dramatically — not the full clarity you are working toward — but measurably. The talisman is actively countering some portion of the overflow energy that has been causing the disruption.<br><br>Brennan built these instruments to counter Azrath's power directly. The counter affects everything Azrath's presence distorts, including the faith-connections that the overflow energy has been interfering with. Every talisman you carry is one step closer to full clarity. You are doing the spiritual work and the practical work simultaneously, and they are the same work.</div>
            <p>Three more. Each one will counter more of the interference and require more of you in return. You are learning the exchange rate. It is fair.</p>
            <p><span class="chronicle-name">${n}</span> — the connection is clearer with the talisman than without it. Three more to go.</p>`,
    },
    cleric_6: {
        cls:'cleric', level:18, icon:'✨',
        title:(n)=>n+"'s Prayer Log",
        label:'The Cleric · Entry VI',
        hint:'All four, and something like clarity.',
        body:(n)=>`
            <p>All four talismans. The interference in your prayers is at its lowest point in fourteen months. Not gone — Azrath is not gone, and the overflow energy from the active seal failure is still present — but low enough that you can hear more than fragments. Low enough to work with fully.</p>
            <div class="chronicle-callout">The conversation on the other side of the interference has been continuous the entire time. Not waiting for the obstruction to clear, not pausing when the signal dropped. Continuous. You have been reaching toward something that has been reaching back with equal consistency, and the talismans have cleared enough of the obstruction to make that mutual reaching visible.<br><br>The archive records from previous cycles describe this moment as the point of confirmation — when the cleric carrying all four talismans understands that their faith was never absent, never failing, never a trial. It was always a real connection being interfered with by a real external force. The faith was correct. The obstruction was the problem. The obstruction is almost gone.</div>
            <p>Seven more levels. The clarity will increase as Azrath's presence weakens. The conversation that has been strained for fourteen months will be fully restored when this is finished.</p>
            <p><span class="chronicle-name">${n}</span> — you have been heard the entire time. Now let your actions speak just as clearly.</p>`,
    },
    cleric_7: {
        cls:'cleric', level:20, icon:'✨',
        title:(n)=>n+"'s Prayer Log",
        label:'The Cleric · Entry VII',
        hint:'What prayer sounds like now.',
        body:(n)=>`
            <p>The prayers are clearer than they have been since before the interference started. Not perfect — the seal is still failing and Azrath is still present and the overflow energy is still there — but clear enough to hold a coherent conversation. You spent an hour in the Crossroads chapel this morning doing exactly that.</p>
            <div class="chronicle-callout">The conversation on the other side said nothing that changed the plan. The direction was confirmed, the purpose was confirmed, the path forward is the same as it has been. What was different was the quality of the confirmation — not the strained partial signal of the last year, but a clear voice saying clearly: yes, this is right, you are on the right path, finish what you started.<br><br>You have been on the right path the entire time. You knew this, because you kept the log, and the log showed the interference pattern rather than a faith pattern, and you chose to believe your own careful observation over the institutional explanation. Your careful observation was correct. Your faith was not misplaced. The voice on the other side confirms both.</div>
            <p>Five more levels. The confirmation is clear. The path is clear. You know what faith looks like when the obstruction is removed.</p>
            <p>Go be the person who removes it.</p>
            <p><span class="chronicle-name">${n}</span> — five levels. You have been heard. Now be heard louder.</p>`,
    },
    cleric_8: {
        cls:'cleric', level:23, icon:'✨',
        title:(n)=>n+"'s Prayer Log",
        label:'The Cleric · Entry VIII',
        hint:'The last interference.',
        body:(n)=>`
            <p>The seal partially fractured three days ago. The interference surged — briefly, sharply — and then settled into a new pattern that is worse than before the fracture but clearer than you expected given the fracture's severity. As if something on the other side of the connection is compensating for the increased obstruction. As if the effort to reach you has increased to match the difficulty.</p>
            <div class="chronicle-callout">You have read every account of this moment in the Crossroads archive. The clerics of previous cycles describe the partial fracture phase as the most difficult period — the interference is at its worst while Azrath is between sealed and fully free, caught in the threshold state that produces maximum energy overflow.<br><br>The accounts also describe what happens after the confrontation: the interference clears. Every account says the same thing. The first prayer after the sealing or defeating of Azrath is received clearly and without obstruction, and the response is immediate and unambiguous.<br><br>You are two levels from that prayer. Two levels from the conversation you have been trying to have for fourteen months.</div>
            <p><span class="chronicle-name">${n}</span> — two levels. The voice on the other side has been fighting to reach you through the static for over a year. Give it something worth reaching toward.</p>`,
    },
    cleric_9: {
        cls:'cleric', level:25, icon:'✨',
        title:(n)=>n+"'s Prayer Log",
        label:'The Cleric · Entry IX',
        hint:'Final entry.',
        body:(n)=>`
            <p>The seal is gone. The interference peaked and then broke — a sharp final surge followed by a clarity so sudden and complete that you sat down on the ground and did not move for several minutes. The prayer that came through in that clarity was brief: <em>We see you. Go.</em></p>
            <p>You are going.</p>
            <div class="chronicle-callout">Fourteen months of static. Fourteen months of working with fragments and partial signals and the institutional explanation you refused to accept because your log showed something different. The faith was never failing. The obstruction was never you. The silence was always external, always temporary, always ending at this exact moment when the person on the other end of the connection was finally strong enough and positioned correctly to end it.<br><br>The archive records say the first prayer after the confrontation is the clearest of a practitioner's life. Every cleric who survived the previous cycles documented this. The clarity lasts for hours, sometimes days — as if the connection, having been compressed and obstructed for so long, overflows when the obstruction is removed.</div>
            <p>You have four talismans, twenty-five levels, and a prayer answered clearly for the first time in fourteen months.</p>
            <p>Go, <span class="chronicle-name">${n}</span>.</p>
            <p>The signal is clear. Everything that needed to be said has been said. Now act on it.</p>`,
    },
});

// ── lore-necromancer.js ──
// lore-necromancer.js  —  Necromancer class chronicle entries
// STATUS: Stub — content being written
// Levels: 1, 3, 8, 13, 15, 18, 20, 23, 25

if (typeof CHRONICLE_CONTENT === 'undefined') window.CHRONICLE_CONTENT = {};

Object.assign(CHRONICLE_CONTENT, {
    necromancer_1: {
        cls:'necromancer', level:1, icon:'💀',
        title:(n)=>n+"'s Transcripts",
        label:'The Necromancer · Entry I',
        hint:'Every spirit says the same thing.',
        body:(n)=>`
            <p>Every spirit you have spoken to for the past three months has said the same thing unprompted: <em>It is coming and the dead cannot stop it.</em> Every spirit. Across every session. Across every century they died in. You have conducted sixty-seven sessions since the pattern started. The consistency is not coincidence — it is signal.</p>
            <p>In your practice, when the dead agree about something, they are right. They have no reason to coordinate. They have no shared information source, no ability to compare notes, no incentive to deceive you in the same direction. When they converge on a conclusion independently, the conclusion is accurate.</p>
            <div class="chronicle-callout">Azrath the Calamity Dragon was sealed beneath the earth a thousand years ago. The seal is breaking. The dead can feel it — not as a physical sensation, because they do not have bodies, but as an existential one. Azrath does not distinguish between the living and the dead. What it touches is simply gone — not killed, not transformed. Erased. The dead are afraid of ceasing to have ever existed.<br><br>That is what Azrath does. The dead are not being dramatic. They are describing, with the precision that the long dead acquire, exactly what the threat is.</div>
            <p>You are <span class="chronicle-name">${n}</span>. The dead trust you with information they do not share with everyone. They are sharing this because they need the living to do something about it. Every level you earn in the dungeons ahead is a level closer to being capable of that something.</p>`,
    },
    necromancer_2: {
        cls:'necromancer', level:3, icon:'💀',
        title:(n)=>n+"'s Transcripts",
        label:'The Necromancer · Entry II',
        hint:'The angry dead.',
        body:(n)=>`
            <p>Not all of the dead are afraid. You discovered the exceptions in a session with three spirits from a village that does not exist anymore — erased, according to the spirits, not destroyed. Not burned or flooded or abandoned. Erased.</p>
            <p>Those spirits are not afraid. They are furious.</p>
            <div class="chronicle-callout">The erasure they describe is not death. Death produces spirits. Erasure produces nothing — no trace, no echo, no residual presence. The village was there and then it was not, and the three spirits speaking to you survived only because they happened to have already left their bodies before the erasure reached them. They are, in a practical sense, the only remaining evidence that the village existed.<br><br>They want to exist. More precisely, they want to have existed — to be counted as real, as permanent, as part of the record. Azrath threatens that. Azrath threatens the permanence of everything, including things that have already happened. The dead are afraid of being retroactively unmade. The three spirits from the erased village know exactly what that means and are willing to do anything within their very limited power to prevent it from happening to anyone else.</div>
            <p><span class="chronicle-name">${n}</span> — the dead are counting on you. Not metaphorically. The three spirits have specifically asked me to make sure the living understand what they are fighting for. It is not just the future. It is the permanence of the past.</p>`,
    },
    necromancer_3: {
        cls:'necromancer', level:8, icon:'💀',
        title:(n)=>n+"'s Transcripts",
        label:'The Necromancer · Entry III',
        hint:'What the living are doing about it.',
        body:(n)=>`
            <p>You have been working primarily with the dead for so long that the living-world dimensions of this crisis took longer to map than they should have. A researcher corrected this gap over dinner at a way-station — she had data on the seal's degradation, timeline projections, information about a gathering place called the Crossroads.</p>
            <div class="chronicle-callout">The Crossroads is where the called ones converge. Not a mystical calling — a practical one. People who have independently arrived at the same conclusion from different directions. Researchers with data. Practitioners with skills. Fighters with capability. All moving toward the same valley where, a thousand years ago, someone built a place specifically for this kind of convergence.<br><br>You mentioned the spirits to the researcher. She found it genuinely interesting rather than dismissive, which was refreshing. The dead's consistent messaging — <em>it is coming and we cannot stop it</em> — confirms her data from a completely different angle. The dead and the living are saying the same thing. The appropriate response is action by the living.</div>
            <p>Two more levels and the terrain opens. The dead are watching. They are limited in what they can do directly, but they are paying attention, and their attention matters in ways that are not always obvious until they become obvious.</p>
            <p><span class="chronicle-name">${n}</span> — the dead are with you in every sense they are capable of being with anyone. Train. Get to the Crossroads. Do what the living can do.</p>`,
    },
    necromancer_4: {
        cls:'necromancer', level:13, icon:'💀',
        title:(n)=>n+"'s Transcripts",
        label:'The Necromancer · Entry IV',
        hint:'The Crossroads.',
        body:(n)=>`
            <p><span class="chronicle-epithet">✦ Voice of Those Who Cannot Speak ✦</span></p>
            <p>The dead at the Crossroads are different from the dead anywhere else you have worked. They are at peace in a way that has nothing to do with emptiness — the peace of people who made a deliberate choice about what they were staying for. Every spirit you have consulted here stayed because this place mattered to them, because they had unfinished business with the world that the Crossroads was the right place to tend.</p>
            <div class="chronicle-callout">The oldest spirit in the Crossroads described what happened in the previous cycle. Not abstractly — specifically. She was a practitioner who worked with the Crossroads' own dead during Brennan's active campaign, maintaining the connection between the living fighters and the information the dead carried. The dead know things. Routes Azrath has taken. Vulnerabilities in its previous behavior. Patterns that repeat across cycles.<br><br>She has been waiting for a necromancer to arrive so she can pass this information forward. She waited a thousand years. She is not impatient — the dead are rarely impatient — but she is relieved.</div>
            <p>The information she carries took four sessions to fully transcribe. It is in your pack now. It is the most operationally useful historical intelligence you have ever received, provided by someone who witnessed it firsthand and has had a thousand years to organize it clearly.</p>
            <p><span class="chronicle-name">${n}</span> — the dead waited for you specifically. Use what they gave you.</p>`,
    },
    necromancer_5: {
        cls:'necromancer', level:15, icon:'💀',
        title:(n)=>n+"'s Transcripts",
        label:'The Necromancer · Entry V',
        hint:'The first talisman.',
        body:(n)=>`
            <p>The Wind dungeon tested your relationship with impermanence, which is the core of necromantic practice — accepting that what has ended is ended while maintaining meaningful connection to what it was. The dungeon created situations where things that appeared permanent dissolved, and the question was whether you could continue operating effectively in the face of dissolution. You could. The talisman recognized it.</p>
            <div class="chronicle-callout">The talisman has an interesting property you did not find documented in the Crossroads library: it is perceptible to the dead. Not to all dead — only to spirits who are attentive to the material world, who maintain the kind of ongoing awareness that lets them communicate. The three spirits from the erased village, who you have maintained contact with throughout this journey, confirmed the talisman's presence the moment you retrieved it. They described it as a counter-presence to Azrath's erasure energy — something that reasserts the permanence of what exists against the force that unmakes it.<br><br>The dead find this very reassuring. More reassuring than anything else you have found to tell them.</div>
            <p>Three more. Every talisman you carry increases the counter-presence. The dead are watching. They are counting.</p>
            <p><span class="chronicle-name">${n}</span> — the erased village wants you to know: three more. They are keeping track.</p>`,
    },
    necromancer_6: {
        cls:'necromancer', level:18, icon:'💀',
        title:(n)=>n+"'s Transcripts",
        label:'The Necromancer · Entry VI',
        hint:'All four, and what the dead say.',
        body:(n)=>`
            <p>All four talismans. You consulted the dead at the Crossroads that evening — the settled spirits, the ones who have been watching this situation across multiple lifetimes — and their response was unanimous and immediate: <em>Yes. That is what it was supposed to look like.</em></p>
            <div class="chronicle-callout">The oldest spirit described the last time someone stood in the Crossroads with all four talismans — Brennan, a thousand years ago, in the hours before he went to complete the sealing. She described the same quality of presence you have right now: the counter-presence against erasure, the sense of something that insists on existing against a force that wants to unmake it.<br><br>She said Brennan was afraid. She said this not as criticism but as context — that he was afraid and did it anyway, and that the afraid-and-doing-it-anyway quality was what the talismans needed from him, what they measured and confirmed. She is telling you this because she wants you to know that the talismans have already confirmed you. Whatever you are feeling right now, the dead have already counted you as sufficient.</div>
            <p>Seven more levels. The dead are counting every one.</p>
            <p><span class="chronicle-name">${n}</span> — the oldest spirit at the Crossroads asked me to tell you: she has seen this before. She believes in the outcome. Trust the dead. They have longer perspective than the living.</p>`,
    },
    necromancer_7: {
        cls:'necromancer', level:20, icon:'💀',
        title:(n)=>n+"'s Transcripts",
        label:'The Necromancer · Entry VII',
        hint:'The record.',
        body:(n)=>`
            <p>You have been keeping this transcript since level one. Not because anyone asked you to, but because you are a practitioner who documents, and documentation is how knowledge moves forward past the people who gathered it originally.</p>
            <p>The dead keep their own records. You have had access to those records, and they have had access to yours, and the cross-referencing has been the most productive research of your career.</p>
            <div class="chronicle-callout">The oldest spirit shared her own documentation yesterday — not a formal archive, but the accumulated observation of a thousand years of watching the Crossroads and everyone who has passed through it. Her record includes everyone who attempted this and failed, which is more people than the official histories acknowledge.<br><br>She shares this not to discourage but to contextualize. The people who failed were not weak or stupid or faithless. They were undertrained, underprepared, or arrived at the wrong time in the cycle. You are at the right time, you are trained, and you are prepared. You are also the most extensively briefed person who has ever stood in this valley with all four talismans. The dead made sure of it. They have been working toward this briefing for decades.</div>
            <p>Five more levels. The record will be complete when the work is complete.</p>
            <p><span class="chronicle-name">${n}</span> — the dead have done everything in their power to prepare you. The rest is the living's work. Do it.</p>`,
    },
    necromancer_8: {
        cls:'necromancer', level:23, icon:'💀',
        title:(n)=>n+"'s Transcripts",
        label:'The Necromancer · Entry VIII',
        hint:'Two levels.',
        body:(n)=>`
            <p>The seal fractured three days ago. The dead's messaging changed immediately — from <em>it is coming and we cannot stop it</em> to something more specific. Something more urgent. The message now is: <em>it is almost here and you are almost ready and almost is close enough.</em></p>
            <div class="chronicle-callout">The three spirits from the erased village have been unusually present over the last three days. Not speaking — just present, in the way that the dead are present when they have chosen to witness something. They chose to witness this from the beginning, and they are not leaving before it finishes.<br><br>The oldest spirit at the Crossroads spoke to you last night. She said she has now seen three cycles from this perspective — once as a living practitioner, twice as a spirit who stayed to watch — and this is the one she is most certain about. She did not elaborate on why. The dead choose their certainties carefully; when they express one, it is worth recording without requiring explanation.</div>
            <p>Two more levels. The dead are assembled and watching. The three spirits from the erased village are in the front of that assembly. They want to see how this ends.</p>
            <p><span class="chronicle-name">${n}</span> — they have been waiting a long time. Do not make them wait much longer.</p>`,
    },
    necromancer_9: {
        cls:'necromancer', level:25, icon:'💀',
        title:(n)=>n+"'s Transcripts",
        label:'The Necromancer · Entry IX',
        hint:'Final transcript entry.',
        body:(n)=>`
            <p>The seal is gone. The dead fell silent for exactly four minutes — an unprecedented quiet across every channel you maintain — and then every spirit, simultaneously, said one word: <em>now.</em></p>
            <p>This is the last entry in the transcript. When this is finished, there will be a new transcript beginning — the after-record, the documentation of what happened and what the dead witnessed and what the three spirits from the erased village finally get to say about the permanence of their existence being defended.</p>
            <div class="chronicle-callout">Sixty-seven sessions of the same message: <em>it is coming and we cannot stop it.</em> The dead were right about the coming. They were right that they could not stop it. They were also present throughout everything that happened between that first message and this moment — the training, the talismans, the Crossroads, the preparation. They watched you become someone capable of stopping what they could not.<br><br>The oldest spirit said one final thing before the silence fell: <em>Brennan was afraid. You are not. That is interesting. It may be why the talismans found you first among this cycle's candidates.</em><br><br>She declined to explain further. The dead choose their certainties carefully.</div>
            <p>Go, <span class="chronicle-name">${n}</span>.</p>
            <p>The dead cannot stop it. You can.</p>
            <p>They are watching.</p>`,
    },
});

// ── lore-berserker.js ──
// lore-berserker.js  —  Berserker class chronicle entries
// STATUS: Stub — content being written
// Levels: 1, 3, 8, 13, 15, 18, 20, 23, 25

if (typeof CHRONICLE_CONTENT === 'undefined') window.CHRONICLE_CONTENT = {};

Object.assign(CHRONICLE_CONTENT, {
    berserker_1: {
        cls:'berserker', level:1, icon:'🔥',
        title:(n)=>n+"'s Account",
        label:'The Berserker · Entry I',
        hint:'What happened to your village.',
        body:(n)=>`
            <p>You came back from three days in the high passes to find your village empty. Not attacked — empty. The buildings were intact. The fires were banked. The animals were in their pens. Your grandmother was at her loom, old Davin was at the gate, the children were in the yard. Present. Breathing. Eyes open.</p>
            <p>Gone.</p>
            <div class="chronicle-callout">You have been told, by the first person who understood what you were describing, that this is what Azrath does. The Calamity Dragon — sealed beneath the earth a thousand years ago, breaking free now — does not kill. It empties. It moves through a place and strips the meaning from everything it touches until the things themselves no longer matter enough to remain present. Your people are still alive. They are just no longer there.<br><br>You have also been told that this may be reversible. That if Azrath is stopped before it fully wakes, the emptying stops with it. That the people taken first might come back when the source of the taking is gone. This was not presented as a certainty. It was presented as a possibility worth fighting for.</div>
            <p>You are <span class="chronicle-name">${n}</span>. You do not know if your people can come back. You know that if there is any chance they can, it requires you to reach level twenty-five and be capable of stopping the thing that emptied them. The dungeons ahead are not optional. Nothing is optional anymore.</p>`,
    },
    berserker_2: {
        cls:'berserker', level:3, icon:'🔥',
        title:(n)=>n+"'s Account",
        label:'The Berserker · Entry II',
        hint:'What you found out.',
        body:(n)=>`
            <p>The dockmaster in Ashen Harbor knew what you were describing. You saw it in her eyes the moment you started talking — recognition, and the particular expression of someone deciding how much to say. You stayed until she decided to say all of it.</p>
            <div class="chronicle-callout">Four other villages. The dockmaster has been collecting accounts for three months, since the first one appeared in the harbor records as a merchant complaint: a ship arrived to find its port of origin emptied, the crew not harmed but their home gone in whatever way yours is gone. The four accounts are consistent. The emptying moves in a specific pattern — not random, not spreading outward from a center, but following something. Routes that correspond, the dockmaster believes, to the paths Azrath traveled in the previous cycle.<br><br>The emptying is not fully active. Azrath is not fully awake. What you experienced was overflow — the energy leaking from the failing seal, moving along the old paths by habit or gravity or something that functions like those things. When Azrath fully wakes, the emptying will be complete and systematic rather than partial and patterned.</div>
            <p>There is a Crossroads. There is a way to stop it. There is a window.</p>
            <p><span class="chronicle-name">${n}</span> — you are inside the window. Train. Get strong enough for what the window requires.</p>`,
    },
    berserker_3: {
        cls:'berserker', level:8, icon:'🔥',
        title:(n)=>n+"'s Account",
        label:'The Berserker · Entry III',
        hint:'The fight and what it is for.',
        body:(n)=>`
            <p>You have not told anyone about your grandmother. About old Davin. About the children in the yard. You do not have the words for it — not because the words do not exist, but because saying the words out loud requires you to process what they describe, and processing it in full would slow you down in ways you cannot afford right now.</p>
            <p>What you have done is fight. Every dungeon, every creature, every obstacle between where you were and where you need to be. Not because fighting is easy. Because the alternative to fighting is waiting, and waiting means the window closes, and the window cannot close.</p>
            <div class="chronicle-callout">A mage on the road told you something useful without knowing it. She described Azrath's behavior as non-purposeful — not malicious, not targeted, simply what it is. The emptying of your village was not personal. Azrath did not choose your grandmother specifically. The emptying is structural, not intentional, which means it is also potentially reversible in a structural way.<br><br>She said: the seal stopped the emptying last time. Everything Azrath had done was still done — the deaths, the destruction, the things that could not be undone. But the ongoing emptying stopped. The people who had been emptied but not destroyed, in the places closest to the sealing site, came back within months.<br><br>Your village is close to the sealing site. Your grandmother's loom is still there.</div>
            <p><span class="chronicle-name">${n}</span> — two more levels and you reach the Crossroads. Two levels. Your grandmother is waiting for you to get there.</p>`,
    },
    berserker_4: {
        cls:'berserker', level:13, icon:'🔥',
        title:(n)=>n+"'s Account",
        label:'The Berserker · Entry IV',
        hint:'The Crossroads.',
        body:(n)=>`
            <p><span class="chronicle-epithet">✦ Fire That Refuses to Go Out ✦</span></p>
            <p>The old man at the gate looked at you for a long moment. You expected him to ask your name or your purpose. He asked something else: how many?</p>
            <p>You told him. Five villages that you knew of. More that you did not.</p>
            <p>He nodded the way people nod when they already knew the number and needed to hear it said out loud anyway. Then he said: come in. There is something here that is relevant to you specifically.</p>
            <div class="chronicle-callout">The relevant thing was a section of the Crossroads archive documenting recovery patterns from previous cycles. In the cycle before Brennan, the emptying was more extensive — fewer talismans, less effective sealing, longer period of active Azrath presence. The recovery documentation from that cycle is detailed and consistent: in every case of partial emptying where the source was subsequently sealed or destroyed, the emptied people returned. Not immediately. Over the course of weeks to months after the source was removed. But they returned.<br><br>The archive has names. Dates. Witness accounts. Specific villages. The documentation was collected specifically because the people of that era understood that future cycles would need to know this was possible.</div>
            <p>Your grandmother is in that documentation. Not by name — she was not born yet. But her village is. The village that was partially emptied in the cycle before Brennan, and then recovered, and then survived another thousand years until your grandmother was born and sat down at her loom.</p>
            <p><span class="chronicle-name">${n}</span> — it has happened before. The village recovered. This time, you will be the reason.</p>`,
    },
    berserker_5: {
        cls:'berserker', level:15, icon:'🔥',
        title:(n)=>n+"'s Account",
        label:'The Berserker · Entry V',
        hint:'The first talisman.',
        body:(n)=>`
            <p>The Wind dungeon asked you why you were doing this. You told it. You told it about the loom and old Davin and the children and the emptiness in five villages and the dockmaster's expression and the archive and your grandmother's village that recovered a thousand years ago. You told it everything, in the order it happened, without editing for what sounded acceptable.</p>
            <p>The talisman did not require nobility. It required honesty. Your reasons are honest. They are personal and specific and not at all abstract, and the Wind talisman accepted that immediately.</p>
            <div class="chronicle-callout">The talisman is warm. Not metaphorically warm — it radiates a slight heat, constant, neither increasing nor decreasing. The Fire talisman will be warmer. You are looking forward to it in a way that probably says something about you that you do not feel the need to analyze.<br><br>You have been told the talismans are testing you, learning you, calibrating to your specific qualities. If that is true, then the talisman now knows exactly why you are here and what you are willing to do. It knows about the loom. It knows about old Davin. It knows about the children in the yard. That is what the test produced. The counter-presence against the emptying, carrying the weight of everyone it is fighting for.</div>
            <p>Three more. The Fire dungeon is next and you are ready for it.</p>
            <p><span class="chronicle-name">${n}</span> — the talisman knows why you are here. Three more to tell.</p>`,
    },
    berserker_6: {
        cls:'berserker', level:18, icon:'🔥',
        title:(n)=>n+"'s Account",
        label:'The Berserker · Entry VI',
        hint:'All four, and what they know.',
        body:(n)=>`
            <p>All four talismans, and they are warm in a way that has nothing to do with temperature. They carry the weight of everyone you told them about. Your grandmother. Old Davin. The children. The five villages. The hundred-plus names in the archive documentation that are not your people but are the same kind of people, emptied and recovered and living for another thousand years because someone did this work.</p>
            <div class="chronicle-callout">The archive archivist at the Crossroads — an older man who has dedicated his life to maintaining the records — said something to you yesterday that you have been thinking about since: the people in the recovery documentation did not know they had been emptied. When they came back, they came back to the moment before the emptying, as if no time had passed. Your grandmother will be at her loom. Old Davin will be at the gate. The children will be in the yard.<br><br>They will not know you were gone. They will not know what you did. They will not know that the world held its breath and someone who loved them refused to let the breath out without fighting for them first.<br><br>That is fine. That is how it should be. You know. That is enough.</div>
            <p>Seven more levels. The talismans are ready. You are nearly ready.</p>
            <p><span class="chronicle-name">${n}</span> — your grandmother does not know you are coming. Come anyway.</p>`,
    },
    berserker_7: {
        cls:'berserker', level:20, icon:'🔥',
        title:(n)=>n+"'s Account",
        label:'The Berserker · Entry VII',
        hint:'What you are made of.',
        body:(n)=>`
            <p>You have not been the strongest fighter at the Crossroads. There are warriors here who are more precise, mages who are more powerful, rangers who are more skilled in ways that show more cleanly in training exercises. You are not the most anything, except possibly the most certain about why you are here.</p>
            <div class="chronicle-callout">The certainty has a specific gravity to it. Not confidence — you are not always confident. Not fearlessness — you have been afraid plenty. The certainty is simpler: your grandmother is at her loom and you are going to get her back, and every obstacle between here and that outcome is going to have to be serious enough to actually stop you, because nothing less will. That quality — the quality of someone who cannot be turned aside by anything short of an actual wall — is what the talismans recognized when they calibrated to you. It is what the Wind talisman accepted as the honest answer.<br><br>You are not fighting for abstract reasons. You are fighting for a specific person at a specific loom in a specific village, and three levels down the road from her, there are four more villages with the same situation. And behind those, everything else. The abstract reasons are real. But the loom is what makes them real to you, and the talisman knows the difference.</div>
            <p>Five more levels. The loom is waiting. Your grandmother does not know you are coming, but the talismans do, and they are ready to take you there.</p>
            <p><span class="chronicle-name">${n}</span> — five levels. The certainty has gotten you this far. It will get you the rest of the way.</p>`,
    },
    berserker_8: {
        cls:'berserker', level:23, icon:'🔥',
        title:(n)=>n+"'s Account",
        label:'The Berserker · Entry VIII',
        hint:'Two levels.',
        body:(n)=>`
            <p>The seal fractured three days ago. You felt it not as a tremor but as a change in the quality of the emptiness in your village — the archivist has ways of monitoring this, and he told you immediately. The partial emptying is worse now. More of the village is affected. Your grandmother is still there, still breathing, still at the loom.</p>
            <p>Still not gone. Still recoverable. The window is still open.</p>
            <div class="chronicle-callout">The Crossroads is different now than it was when you arrived. The people here are not training anymore — they are waiting, in the focused way of people who have finished their preparation and are holding it ready. Every conversation is short and purposeful. Nobody asks how you are doing. They ask: two levels, right? You say yes. They nod and move on.<br><br>The archivist found you this morning to update the monitoring data. He did not look worried. He looked like a man who has studied enough cycles to know the difference between a close thing and a lost thing, and what he sees is a close thing. He has been doing this job for forty years. You believe his read of the situation.</div>
            <p>Two more levels. The window is open. Your grandmother is at the loom. The archivist says this is a close thing, not a lost thing.</p>
            <p><span class="chronicle-name">${n}</span> — two levels. The village is waiting. Go get them back.</p>`,
    },
    berserker_9: {
        cls:'berserker', level:25, icon:'🔥',
        title:(n)=>n+"'s Account",
        label:'The Berserker · Entry IX',
        hint:'Final account.',
        body:(n)=>`
            <p>The seal is gone. You know what this means. The emptying has stopped expanding — Azrath is fully awake, which means the overflow that caused the partial emptying has resolved into the direct presence. Worse in one sense. Better in another: direct presence can be directly confronted.</p>
            <p>Your grandmother is at the loom. The archivist confirmed it ten minutes ago.</p>
            <div class="chronicle-callout">You are going to do this, and then it is going to be over, and then you are going to go home. You are going to walk into the village and your grandmother is going to look up from the loom and say something ordinary — ask where you have been, tell you the soup is cold, comment on the state of your equipment. She will not know that anything happened. She will not know about the emptying, the Crossroads, the talismans, the twenty-five levels, the fight that is about to happen.<br><br>That is fine. That is exactly right. The point of all of this is that she gets to not know. The point of all of this is that she gets to sit at her loom in a world that still has her in it, and old Davin gets to be at the gate, and the children get to be in the yard, and none of them ever have to know how close it came to not being that way.</div>
            <p>Go, <span class="chronicle-name">${n}</span>.</p>
            <p>Your grandmother is at the loom.</p>
            <p>Go bring the world back to her.</p>`,
    },
});

    </script>

    <script>

        // 🔑 Prevent UI reset after restore (mobile fix)
// gameState.hasRestoredGame = false;


// ═══════════════════════════════════════════════════════
// RARITY CONFIG
// ═══════════════════════════════════════════════════════
const RARITY_CONFIG = {
    common:    { name: "Common",    color: "#cccccc", multiplier: 1.0, spawnWeight: 60,  dropBonus: 0 },
    uncommon:  { name: "Uncommon",  color: "#4caf50", multiplier: 1.1, spawnWeight: 25,  dropBonus: 1 },
    rare:      { name: "Rare",      color: "#2196f3", multiplier: 1.2, spawnWeight: 10,  dropBonus: 2 },
    epic:      { name: "Epic",      color: "#9c27b0", multiplier: 1.3, spawnWeight: 4,   dropBonus: 3 },
    legendary: { name: "Legendary", color: "#ff9800", multiplier: 1.4, spawnWeight: 0.9, dropBonus: 4 },
    mythic:    { name: "Mythic",    color: "#ff4444", multiplier: 1.5, spawnWeight: 0.1, dropBonus: 5 }
};



// ═══════════════════════════════════════════════════════════════
// GEM SYSTEM — Raw gems drop from enemies, cut at blacksmith,
// socket into weapons for permanent bonuses.
// Tier by enemy level: 1-6=T1, 7-12=T2, 13-18=T3, 19-24=T4
// ═══════════════════════════════════════════════════════════════
const GEM_TYPES = {
    ruby:     { name: 'Ruby',     color: '#FF2244', emoji: '🔴', tier_color: '#FF2244',
                desc: 'Red — Damage & Lifesteal',
                stats: ['weaponDmg','weaponDmg','lifesteal'],
                rolls: { weaponDmg: [2,8], lifesteal: [3,10] } },
    sapphire: { name: 'Sapphire', color: '#2266FF', emoji: '🔵', tier_color: '#2266FF',
                desc: 'Blue — Spell Power & MP',
                stats: ['spellPower','spellPower','mpBonus'],
                rolls: { spellPower: [3,10], mpBonus: [8,25] } },
    topaz:    { name: 'Topaz',    color: '#FFD700', emoji: '🟡', tier_color: '#FFD700',
                desc: 'Yellow — Crit Chance & Lightning Dmg',
                stats: ['critBonus','critBonus','lightningDmg'],
                rolls: { critBonus: [2,6], lightningDmg: [3,9] } },
    emerald:  { name: 'Emerald',  color: '#00CC44', emoji: '🟢', tier_color: '#00CC44',
                desc: 'Green — Poison & STR',
                stats: ['poisonChance','poisonChance','strBonus'],
                rolls: { poisonChance: [5,15], strBonus: [1,4] } },
    amethyst: { name: 'Amethyst', color: '#AA44FF', emoji: '🟣', tier_color: '#AA44FF',
                desc: 'Purple — Defense & HP',
                stats: ['defenseBonus','defenseBonus','hpBonus'],
                rolls: { defenseBonus: [2,7], hpBonus: [10,30] } },
    onyx:     { name: 'Onyx',     color: '#888888', emoji: '⬛', tier_color: '#888888',
                desc: 'Black — Armor Pierce & Speed',
                stats: ['armorPierce','armorPierce','speedBonus'],
                rolls: { armorPierce: [3,10], speedBonus: [2,5] } },
    opal:     { name: 'Opal',     color: '#AADDFF', emoji: '🔷', tier_color: '#AADDFF',
                desc: 'White — Luck & Gold Find',
                stats: ['lckBonus','lckBonus','goldFind'],
                rolls: { lckBonus: [1,4], goldFind: [5,15] } },
    garnet:   { name: 'Garnet',   color: '#CC1133', emoji: '🟤', tier_color: '#CC1133',
                desc: 'Garnet — STR & CON',
                stats: ['strBonus','conBonus','strBonus'],
                rolls: { strBonus: [1,4], conBonus: [1,4] } },

    // ── EXPANSION GEMS ────────────────────────────────────────────
    bloodstone: { name: 'Bloodstone', color: '#880022', emoji: '🩸', tier_color: '#880022',
                desc: 'Dark Red — Max HP & HP Regeneration',
                stats: ['hpBonus','hpBonus','hpRegen'],
                rolls: { hpBonus: [15,40], hpRegen: [1,4] } },

    moonstone:  { name: 'Moonstone',  color: '#CCEEFF', emoji: '🌙', tier_color: '#CCEEFF',
                desc: 'Silver-White — MP Regen & Spell Cooldown',
                stats: ['mpRegen','mpRegen','cdReduce'],
                rolls: { mpRegen: [2,6], cdReduce: [3,8] } },

    sunstone:   { name: 'Sunstone',   color: '#FF7700', emoji: '☀️', tier_color: '#FF7700',
                desc: 'Amber — Fire Damage & STR (universal)',
                stats: ['fireDmg','fireDmg','strBonus'],
                rolls: { fireDmg: [4,12], strBonus: [1,3] } },

    voidstone:  { name: 'Voidstone',  color: '#6600BB', emoji: '🔮', tier_color: '#6600BB',
                desc: 'Dark Purple — Spell Leech & WIS',
                stats: ['spellLeech','spellLeech','wisBonus'],
                rolls: { spellLeech: [3,10], wisBonus: [1,3] } },

    ironheart:  { name: 'Ironheart',  color: '#AAAAAA', emoji: '🩶', tier_color: '#AAAAAA',
                desc: 'Iron-Grey — Defense & CON',
                stats: ['defenseBonus','defenseBonus','conBonus'],
                rolls: { defenseBonus: [3,9], conBonus: [1,4] } },

    stormglass: { name: 'Stormglass', color: '#44DDFF', emoji: '⛈️', tier_color: '#44DDFF',
                desc: 'Ice-Blue — Lightning & Frost (universal, both elements stack)',
                stats: ['lightningDmg','frostDmg','lightningDmg'],
                rolls: { lightningDmg: [4,12], frostDmg: [3,10] } },
};

// Gem tier multiplier for rolls (higher tier = stronger bonuses)
const GEM_TIER_MULT = { 1: 1.0, 2: 1.5, 3: 2.2, 4: 3.2 };

// Get tier from enemy level
function getGemTier(enemyLevel) {
    if (enemyLevel <= 6)  return 1;
    if (enemyLevel <= 12) return 2;
    if (enemyLevel <= 18) return 3;
    return 4;
}

// Gem types as an array for random selection
const GEM_KEYS = Object.keys(GEM_TYPES);

// Cut a raw gem into a finished gem with permanent random stats
function cutGem(gemKey) {
    const tier = gemKey.includes('_t') ? parseInt(gemKey.split('_t')[1]) : 1;
    const typeKey = gemKey.replace(/_t\d+$/, '').replace('raw_','');
    const gemDef = GEM_TYPES[typeKey];
    if (!gemDef) return null;
    const mult = GEM_TIER_MULT[tier] || 1.0;
    // Roll 2 stats from the gem's stat pool
    const statPool = [...gemDef.stats];
    const chosen = [];
    const statValues = {};
    // Pick up to 2 unique stats
    const shuffled = statPool.sort(() => Math.random()-0.5);
    const picked = [...new Set(shuffled)].slice(0, 2);
    for (const stat of picked) {
        const [lo, hi] = gemDef.rolls[stat];
        const val = Math.floor((lo + Math.random()*(hi-lo+1)) * mult);
        statValues[stat] = (statValues[stat] || 0) + val;
    }
    return {
        id: `gem_${typeKey}_t${tier}_${Date.now()}`,
        type: typeKey,
        tier,
        name: `${['','T1 ','T2 ','T3 ','T4 '][tier]}${gemDef.name}`,
        color: gemDef.color,
        emoji: gemDef.emoji,
        cut: true,
        stats: statValues,
        description: describeGemStats(statValues)
    };
}

function describeGemStats(stats) {
    const labels = {
        weaponDmg:    'Weapon DMG',   lifesteal:    'Lifesteal %',
        spellPower:   'Spell Power',  mpBonus:      'Max MP',
        critBonus:    'Crit %',       lightningDmg: 'Lightning DMG',
        poisonChance: 'Poison %',     strBonus:     'STR',
        conBonus:     'CON',          defenseBonus: 'Defense',
        hpBonus:      'Max HP',       armorPierce:  'Armor Pierce %',
        speedBonus:   'Speed',        lckBonus:     'LCK',
        goldFind:     'Gold Find %',
        // New gem stats
        hpRegen:      'HP Regen/turn', mpRegen:     'MP Regen/turn',
        cdReduce:     'Cooldown %',    fireDmg:     'Fire DMG',
        frostDmg:     'Frost DMG',     spellLeech:  'Spell Leech %',
        wisBonus:     'WIS',
    };
    return Object.entries(stats).map(([k,v]) => `+${v} ${labels[k]||k}`).join(', ');
}

// How many gem slots does a weapon quality get?
// Shop-bought gear (normal/poor) has no slots — slots are a perk of dropped gear.
// Drops come with quality from the drop system: rare=1, epic=2, legendary=3, godly=4.
function getGemSlots(quality) {
    const map = { poor:0, normal:0, uncommon:1, rare:1, epic:2, legendary:3, godly:4 };
    return map[quality] || 0;
}

// Apply socketed gem stats to player during combat (additive bonuses)
function applyGemBonuses(player, weapon) {
    const armorObj = player.armor ? ARMOR[player.armor] : null;
    const allGems = [...(weapon?.gems || []), ...((armorObj?.gems) || [])];
    if (allGems.length === 0) return;
    for (const gem of allGems) {
        if (!gem || !gem.stats) continue;
        const s = gem.stats;
        if (s.hpBonus)      player._gemHpBonus  = (player._gemHpBonus  || 0) + s.hpBonus;
        if (s.mpBonus)      player._gemMpBonus  = (player._gemMpBonus  || 0) + s.mpBonus;
        if (s.strBonus)     player._gemStr      = (player._gemStr      || 0) + s.strBonus;
        if (s.conBonus)     player._gemCon      = (player._gemCon      || 0) + s.conBonus;
        if (s.lckBonus)     player._gemLck      = (player._gemLck      || 0) + s.lckBonus;
        if (s.defenseBonus) player._gemDef      = (player._gemDef      || 0) + s.defenseBonus;
        if (s.critBonus)    player._gemCrit     = (player._gemCrit     || 0) + s.critBonus;
        if (s.weaponDmg)    player._gemWepDmg   = (player._gemWepDmg   || 0) + s.weaponDmg;
        if (s.spellPower)   player._gemSpell    = (player._gemSpell    || 0) + s.spellPower;
        if (s.lifesteal)    player._gemLifesteal= (player._gemLifesteal|| 0) + s.lifesteal;
        if (s.armorPierce)  player._gemPierce   = (player._gemPierce   || 0) + s.armorPierce;
        if (s.goldFind)     player._gemGold     = (player._gemGold     || 0) + s.goldFind;
        if (s.poisonChance) player._gemPoison   = (player._gemPoison   || 0) + s.poisonChance;
    }
}

// ── Recalculate player's gem-sourced HP and MP bonuses ──────────────────
// Called on equip/unequip. Stores the delta in player._gemHpBonus so that
// p.maxHp always reflects the current socketed gem configuration.
function recalcGemStats(player) {
    const weapon   = player.weapon ? WEAPONS[player.weapon]  : null;
    const armorObj = player.armor  ? ARMOR[player.armor]     : null;
    const allGems  = [...(weapon?.gems || []), ...(armorObj?.gems || [])];

    let hpBonus  = 0, mpBonus  = 0, defBonus = 0;
    for (const gem of allGems) {
        if (!gem?.stats) continue;
        hpBonus  += gem.stats.hpBonus      || 0;
        mpBonus  += gem.stats.mpBonus      || 0;
        defBonus += gem.stats.defenseBonus || 0;
    }

    // Remove old gem bonus from maxHp/maxMp before applying new total
    const oldHp  = player._gemHpBonus  || 0;
    const oldMp  = player._gemMpBonus  || 0;

    player.maxHp = Math.max(1, player.maxHp - oldHp + hpBonus);
    player.maxMp = Math.max(0, player.maxMp - oldMp + mpBonus);
    // Clamp current HP/MP so they don't exceed the new max
    player.hp    = Math.min(player.hp,  player.maxHp);
    player.mp    = Math.min(player.mp,  player.maxMp);

    // Store new totals for next recalc
    player._gemHpBonus  = hpBonus;
    player._gemMpBonus  = mpBonus;
    player._gemDefBonus = defBonus;   // used in HUD display
}

function updateTerminalSafeArea() {
    // No-op: layout handled by fixed-position flex column.
    // Terminal fills remaining space; actionBar sits below it naturally.
}



// ─────────────────────────────────────────
// Direction helpers
// ─────────────────────────────────────────

const OPPOSITE_DIR = {
    N: 'South',
    S: 'North',
    E: 'West',
    W: 'East',
    NE: 'Southwest',
    NW: 'Southeast',
    SE: 'Northwest',
    SW: 'Northeast'
};



        // Game Data Structures
        const CLASSES = {
            warrior: {
                name: 'Warrior',
                hp: 120,
                mp: 20,
                strength: 15,
                defense: 12,
                magic: 3,
                speed: 7,
                description: 'Master of melee combat with high HP and defense',
                startWeapon: 'iron_sword',
                startArmor: 'leather_armor'
            },
            rogue: {
                name: 'Rogue',
                hp: 80,
                mp: 30,
                strength: 10,
                defense: 6,
                magic: 5,
                speed: 15,
                description: 'Swift and deadly, strikes first with critical hits',
                startWeapon: 'rusty_shiv',
                startArmor: 'leather_vest'
            },
            paladin: {
                name: 'Paladin',
                hp: 100,
                mp: 50,
                strength: 12,
                defense: 10,
                magic: 8,
                speed: 8,
                description: 'Holy warrior with healing magic and strong defense',
                startWeapon: 'mace',
                startArmor: 'chain_mail'
            },
            mage: {
                name: 'Mage',
                hp: 60,
                mp: 100,
                strength: 5,
                defense: 4,
                magic: 18,
                speed: 9,
                description: 'Powerful spellcaster with devastating magic',
                startWeapon: 'staff',
                startArmor: 'cloth_robes'
            },
            cleric: {
                name: 'Cleric',
                hp: 90,
                mp: 100,
                strength: 8,
                defense: 8,
                magic: 12,
                speed: 7,
                description: 'Divine healer with support spells and moderate combat',
                startWeapon: 'mace',
                startArmor: 'leather_armor'
            },
            //ranger: {
            //    name: 'Ranger',
            //    hp: 85,
            //    mp: 40,
            //   strength: 11,
            //    defense: 7,
            //    magic: 6,
            //    speed: 13,
            //    description: 'Skilled archer with nature magic and tracking',
            //    startWeapon: 'bow',
            //    startArmor: 'leather_armor'
            // },

            hunter: {
                name: 'Hunter',
                hp: 85,
                mp: 40,
                strength: 11,
                defense: 7,
                magic: 6,
                speed: 13,
                description: 'Skilled archer with nature magic and tracking',
                startWeapon: 'bow',
                startArmor: 'leather_armor'
            },

            
            warlock: {
                name: 'Warlock',
                hp: 70,
                mp: 90,
                strength: 6,
                defense: 5,
                magic: 16,
                speed: 8,
                description: 'Dark mage who drains life from enemies with shadow magic',
                startWeapon: 'staff',
                startArmor: 'cloth_robes'
            },
            runesmith: {
                name: 'Runesmith',
                hp: 95,
                mp: 70,
                strength: 12,
                defense: 9,
                magic: 10,
                speed: 8,
                description: 'Cast 3 runes to charge Overload — then strike for devastating armor-piercing damage. Master of hybrid physical/arcane combat.',
                startWeapon: 'chipped_mattock',
                startArmor: 'leather_armor'
            }
        };


        // ═══════════════════════════════════════════════════════════════
        // STAT SYSTEM
        // ═══════════════════════════════════════════════════════════════
        const STAT_BUDGET  = 10;
        const STAT_NAMES   = ['str','dex','wis','cha','con','lck'];
        const STAT_LABELS  = { str:'STR', dex:'DEX', wis:'WIS', cha:'CHA', con:'CON', lck:'LCK' };
        const STAT_DESCS   = {
            str:'Physical damage & multi-hit',
            dex:'Dodge chance & flee success',
            wis:'Spell power & magic resist',
            cha:'Shop prices & negotiation',
            con:'Max HP bonus & defense',
            lck:'Crit chance & loot luck'
        };
        // Opposed pairs: reroll engine biases against extremes in both.
        // Paladin is EXEMPT from str<->wis opposition.
        const OPPOSED_PAIRS = [['str','wis'],['dex','cha'],['con','lck']];

        const CLASS_STAT_PRESETS = {
            // Sums to exactly 10; biased toward class identity, min 0
            warrior : { str:3, dex:1, wis:0, cha:1, con:3, lck:2 },
            rogue   : { str:1, dex:4, wis:0, cha:1, con:1, lck:3 },
            paladin : { str:2, dex:1, wis:3, cha:2, con:2, lck:0 },
            mage    : { str:0, dex:1, wis:4, cha:1, con:1, lck:3 },
            cleric  : { str:1, dex:0, wis:4, cha:2, con:2, lck:1 },
            ranger  : { str:1, dex:3, wis:1, cha:1, con:2, lck:2 },
            hunter  : { str:1, dex:3, wis:1, cha:1, con:2, lck:2 },
            warlock : { str:0, dex:1, wis:4, cha:2, con:1, lck:2 },
            runesmith: { str:2, dex:0, wis:3, cha:1, con:3, lck:1 }
        };
        const CLASS_AFFINITIES = {
            warrior :['str','con'],
            rogue   :['dex','lck'],
            paladin :['str','wis','cha'],
            mage    :['wis','lck'],
            cleric  :['wis','cha'],
            hunter  :['dex','lck'],
            ranger  :['dex','lck'],
            warlock :['wis','cha'],
            runesmith:['str','wis']
        };

        // ── derived-stat helpers ──────────────────────────────────────
        // Compute quality bonus as a % of the weapon/armor base damage/defense
        // QUALITY_CONFIG now uses bonusPct instead of a flat bonus
        function getQualityBonus(quality, baseStat) {
            const cfg = QUALITY_CONFIG[quality];
            if (!cfg) return 0;
            // Support old flat bonus saves gracefully
            if (cfg.bonusPct !== undefined) return Math.floor(baseStat * cfg.bonusPct);
            return cfg.bonus || 0;
        }

                function calcPlayerHits(p) {
            const baseClass = p.baseClass || p.class;
            
            // ALL CLASSES: Pip progression — Lv1=1  Lv5=2  Lv10=3  Lv15=4  (hard cap 4)
            // Rogue pips also fire twice (double-strike with daggers)
            if (p.level >= 15) return 4;
            if (p.level >= 10) return 3;
            if (p.level >= 5)  return 2;
            return 1;
        }
        function calcChaDiscount(cha) { return Math.min(30, (cha||0) * 2); }   // buy %  off
        
        // ═══════════════════════════════════════════════════════════════
        // CLASS EQUIPMENT RESTRICTIONS
        // ═══════════════════════════════════════════════════════════════
        

        // ── Build gem slot display for a weapon card ──────────────────
        function buildGemSlotHtml(weapon) {
            if (!weapon) return '';
            // Ensure quality fallback — drop weapons may not have quality set yet
            const quality = weapon.quality || 'normal';
            const slots = getGemSlots(quality);
            if (slots === 0) return '';
            if (!weapon.gems) weapon.gems = [];  // initialize if missing
            const socketed = weapon.gems;
            const filledCount = socketed.length;
            let html = `<div style="margin-top:5px;font-size:11px;line-height:1.6;">`;
            for (let i = 0; i < slots; i++) {
                const gem = socketed[i];
                if (gem && gem.cut) {
                    // Filled slot — colored gem circle + stat text
                    html += `<div style="display:flex;align-items:center;gap:5px;flex-wrap:wrap;">
                        <span style="color:${gem.color};font-size:15px;line-height:1;">⬤</span>
                        <span style="color:${gem.color};font-weight:bold;">${gem.emoji} ${gem.name}</span>
                        <span style="color:#888;font-size:10px;">${gem.description}</span>
                    </div>`;
                } else {
                    // Empty slot — dark circle
                    html += `<div style="display:flex;align-items:center;gap:5px;">
                        <span style="color:#1a1a1a;font-size:15px;line-height:1;text-shadow:0 0 1px #555;">⬤</span>
                        <span style="color:#3a3a3a;font-size:10px;font-style:italic;">empty socket</span>
                    </div>`;
                }
            }
            if (slots > 1) {
                html += `<div style="color:#555;font-size:10px;margin-top:2px;">${filledCount}/${slots} gems socketed</div>`;
            }
            html += '</div>';
            return html;
        }

        // ── Build damage line for a weapon (MELEE / MAGIC clearly split) ──
        function buildWeaponDmgLine(weapon, quality) {
            const qc = QUALITY_CONFIG[quality || weapon.quality];
            const qb = getQualityBonus(weapon.quality, weapon.baseDamage);
            const tMin = weapon.baseDamage + qb;
            const tMax = weapon.maxDamage ? weapon.maxDamage + getQualityBonus(weapon.quality, weapon.maxDamage - weapon.baseDamage) : tMin;
            const tMag = (weapon.baseMagicDamage || 0) + Math.floor((weapon.baseMagicDamage || 0) * (qc?.bonusPct || 0));
            let line = `<span style="color:#ffcc88;">MELEE: ${tMin}${tMax > tMin ? '-'+tMax : ''}</span>`;
            if (tMag > 0) {
                line += ` <span style="color:#88aaff;">| MAGIC: +${tMag}</span>`;
            }
            return line;
        }

        function canUseWeapon(playerClass, weapon) {
            // Bare fists — always usable by everyone
            if (weapon.unarmed) return true;
            // If weapon has allowedClasses, check it
            if (weapon.allowedClasses) {
                return weapon.allowedClasses.includes(playerClass);
            }
            // RUNESMITH: can use staves, hammers, maces, and swords — the hybrid fighter/caster
            if (playerClass === 'runesmith') {
                if (!weapon.name) return false;
                const wn = weapon.name.toLowerCase();
                return weapon.weaponSubtype === 'staff'
                    || wn.includes('staff')
                    || wn.includes('hammer')
                    || wn.includes('mace')
                    || wn.includes('sword')
                    || wn.includes('mattock')
                    || wn.includes('maul')
                    || wn.includes('axe')
                    || weapon.type === 'hammer'
                    || weapon.type === 'staff'
                    || weapon.type === 'sword';
            }
            
            // ROGUE: daggers only — no exceptions
            // Also allow dropped weapons with type 'dagger' or 'poison_dagger' / 'assassin_blade' etc.
            if (playerClass === 'rogue') {
                const isDagger = weapon.classRestriction === 'rogue'
                    || weapon.type === 'dagger'
                    || weapon.type === 'poison_dagger'
                    || weapon.type === 'assassin_blade'
                    || weapon.type === 'short_sword'
                    || (weapon.name && weapon.name.toLowerCase().includes('dagger'))
                    || (weapon.name && weapon.name.toLowerCase().includes('shiv'))
                    || (weapon.name && weapon.name.toLowerCase().includes('stiletto'))
                    || (weapon.name && weapon.name.toLowerCase().includes('dirk'))
                    || (weapon.name && weapon.name.toLowerCase().includes('blade'));
                return isDagger;
            }

            // Default restrictions based on weapon type/name
            const weaponName = weapon.name.toLowerCase();
            const SPELL_CLASSES = ['mage', 'warlock', 'cleric', 'acolyte', 'necrolyte', 'druid', 'sorceror', 'runesmith'];
            
            // Staffs - magic users only
            if (weaponName.includes('staff') || weapon.weaponSubtype === 'staff') {
                return SPELL_CLASSES.includes(playerClass);
            }
            
            // Wands - magic users only (but also accessible from shop for magic classes)
            if (weaponName.includes('wand') || weapon.weaponSubtype === 'wand') {
                return SPELL_CLASSES.includes(playerClass);
            }
            
            // Also catch high-magic weapons by baseMagicDamage ratio
            if (weapon.baseMagicDamage > weapon.baseDamage) {
                return SPELL_CLASSES.includes(playerClass);
            }

            // Tomes, orbs, shadow_orb — magic users only (drop types with no keyword in name)
            if (weapon.type === 'tome' || weapon.type === 'orb' || weapon.type === 'shadow_orb'
                || weaponName.includes('tome') || weaponName.includes(' orb')) {
                return SPELL_CLASSES.includes(playerClass);
            }
            
            // Bows - rangers and archers only
            if (weaponName.includes('bow') || weapon.weaponSubtype === 'bow') {
                return ['ranger', 'archer', 'hunter'].includes(playerClass);
            }
            
            // Daggers - rogues handled above; rangers/hunters can use too
            if (weaponName.includes('dagger') || weapon.classRestriction === 'rogue'
                || weapon.weaponSubtype === 'dagger') {
                return ['ranger', 'hunter'].includes(playerClass);
            }
            
            // Maces - paladins, clerics, warriors, runesmith
            if (weaponName.includes('mace') || weaponName.includes('club')
                || weaponName.includes('scepter') || weaponName.includes('crusher')
                || weaponName.includes('judgment') || weaponName.includes('templar')
                || weaponName.includes('thundermace') || weaponName.includes('wrath')
                || weapon.weaponSubtype === 'mace') {
                return ['paladin', 'cleric', 'acolyte', 'warrior', 'runesmith'].includes(playerClass);
            }
            
            // Hammers - warriors, paladins, runesmith
            if (weaponName.includes('hammer') || weaponName.includes('maul')
                || weaponName.includes('mjolnite') || weaponName.includes('earthshaker')
                || weaponName.includes('skullcracker') || weaponName.includes('siegebreaker')
                || weaponName.includes('ragnarok') || weaponName.includes('colossus')
                || weaponName.includes('voidhammer') || weaponName.includes('oblivion hammer')
                || weapon.weaponSubtype === 'hammer') {
                return ['warrior', 'paladin', 'runesmith'].includes(playerClass);
            }
            
            // Axes - warriors, runesmith
            if (weaponName.includes('axe') || weaponName.includes('cleaver')
                || weaponName.includes('soulcleaver') || weaponName.includes('warbringer')
                || weaponName.includes('ruinbringer') || weaponName.includes('sundering')
                || weapon.weaponSubtype === 'axe') {
                return ['warrior', 'paladin', 'runesmith'].includes(playerClass);
            }
            
            // Swords - warriors, paladins (specific sword names)
            if (weaponName.includes('sword') || weaponName.includes('blade')
                || weaponName.includes('greatsword') || weaponName.includes('excalibur')) {
                return ['warrior', 'paladin'].includes(playerClass);
            }
            
            // Default: everyone except rogue can use
            return true;
        }
        
        function canUseArmor(playerClass, armor) {
            // No Armor — always usable by everyone
            if (armor.unarmored) return true;
            // If armor has allowedClasses, check it
            if (armor.allowedClasses) {
                return armor.allowedClasses.includes(playerClass);
            }
            
            // Default restrictions based on armor type/name
            const armorName = armor.name.toLowerCase();
            
            // Robes - magic users only (runesmith cannot — too fragile for frontline)
            if (armorName.includes('robe')) {
                return ['mage', 'warlock', 'cleric', 'acolyte', 'necrolyte', 'druid', 'sorceror'].includes(playerClass);
            }
            
            // Plate armor - heavy fighters only (runesmith cannot — too restrictive for rune casting)
            if (armorName.includes('plate')) {
                return ['warrior', 'paladin'].includes(playerClass);
            }
            
            // Chainmail - medium armor (runesmith can wear — mobile enough for rune work)
            if (armorName.includes('chain')) {
                return ['warrior', 'paladin', 'cleric', 'ranger', 'runesmith'].includes(playerClass);
            }
            
            // Scale / hide / studded — medium-heavy, runesmith fits here
            if (armorName.includes('scale') || armorName.includes('hide') || armorName.includes('studded')) {
                return ['warrior', 'paladin', 'cleric', 'ranger', 'hunter', 'runesmith'].includes(playerClass);
            }
            
            // Leather - light armor, most classes
            if (armorName.includes('leather')) {
                return ['warrior', 'rogue', 'ranger', 'hunter', 'cleric', 'paladin', 'runesmith'].includes(playerClass);
            }
            
            // Cloth - everyone can wear
            return true;
        }
        function calcChaSellBonus(cha){ return Math.min(15, (cha||0) * 1); }   // sell %  bonus
        function calcInnCost(cha)     { return Math.max(20, 50 - (cha||0)); }
        function calcCritChance(lck, player)  { 
            // Base: 3% + 0.5% per LCK (not 1%) — prevents LCK-dumping giving 30%+ at level 1
            let baseCrit = 3 + Math.floor((lck || 0) * 0.5);
            
            if (player) {
                const baseClass = player.baseClass || player.class;
                const lvl = player.level || 1;
                if (baseClass === 'rogue') {
                    // Rogue: 5% base + 0.75% per LCK + 1% per 2 levels
                    // This gives ~15% at level 3 with 17 LCK (fun but not broken)
                    // and scales to ~50% at level 20 (exciting endgame)
                    baseCrit = 5 + Math.floor((lck || 0) * 0.75) + Math.floor(lvl / 2);
                }
            }
            
            const cap = (player && (player.baseClass || player.class) === 'rogue') ? 75 : 30;
            return Math.min(cap, baseCrit);
        }  // %
        function calcDodgeChance(dex) { return Math.min(40, (dex||0) * 2); }   // %
        function calcLootBonus(lck)   { return Math.min(25, (lck||0) * 2); }   // extra %

        // random reroll: scatter STAT_BUDGET among 6 stats (min 1 each)
        function rerollStats(classKey) {
            const s = { str:0, dex:0, wis:0, cha:0, con:0, lck:0 };
            let rem = STAT_BUDGET;  // all 10 points distributed randomly
            while (rem-- > 0) s[STAT_NAMES[Math.floor(Math.random()*6)]]++;
            return s;
        }

        // ═══════════════════════════════════════════════════════════════
        // RUNESTONES — World-progression keystones, one per major arc.
        // Each runestone unlocks a portal, a region, or a world secret.
        // Colors: white, yellow, green, blue, purple, brown, black, red
        // ═══════════════════════════════════════════════════════════════
        const RUNESTONES = {
            white_runestone: {
                id:          'white_runestone',
                name:        'White Runestone',
                color:       '#FFFFFF',
                badgeSymbol: '✦',
                description: 'A pale stone humming with quiet energy. It unlocks passage to Ashen Harbor.',
                lore:        'Found at the heart of Dungeon1. Its surface is smooth and cold as winter.',
                unlocksPortal: { from: 'town1', to: 'town2' }
            },
            yellow_runestone: {
                id:          'yellow_runestone',
                name:        'Yellow Runestone',
                color:       '#FFD700',
                badgeSymbol: '✦',
                description: 'A warm golden stone radiating faint heat. Its purpose is not yet known.',
                lore:        'Ancient texts speak of a sunken city where this stone once served as a key.',
                unlocksPortal: null  // destination TBD
            },
            green_runestone: {
                id:          'green_runestone',
                name:        'Green Runestone',
                color:       '#00FF88',
                badgeSymbol: '✦',
                description: 'A mossy stone pulsing with natural energy. The forest seems to breathe around it.',
                lore:        'Those who carry it claim to hear the Whispering Forest even in silence.',
                unlocksPortal: null
            },
            blue_runestone: {
                id:          'blue_runestone',
                name:        'Blue Runestone',
                color:       '#44AAFF',
                badgeSymbol: '✦',
                description: 'A cool blue stone that drips condensation even in dry air.',
                lore:        'Said to be a fragment of a glacier that froze during the Age of Storms.',
                unlocksPortal: null
            },
            purple_runestone: {
                id:          'purple_runestone',
                name:        'Purple Runestone',
                color:       '#BB66FF',
                badgeSymbol: '✦',
                description: 'A violet stone swirling with arcane light. It vibrates in the presence of magic.',
                lore:        'Mages covet these. Some have gone mad trying to decode what it whispers.',
                unlocksPortal: null
            },
            brown_runestone: {
                id:          'brown_runestone',
                name:        'Brown Runestone',
                color:       '#CC8844',
                badgeSymbol: '✦',
                description: 'A rough earthen stone worn smooth by centuries. It feels impossibly heavy.',
                lore:        'Dwarven records suggest an entire mountain was carved to produce one of these.',
                unlocksPortal: null
            },
            black_runestone: {
                id:          'black_runestone',
                name:        'Black Runestone',
                color:       '#888888',
                badgeSymbol: '✦',
                description: 'A void-black stone that seems to absorb the light around it. Cold to the touch.',
                lore:        'No one knows where it came from. No one who has seen where it goes has returned.',
                unlocksPortal: null
            },
            red_runestone: {
                id:          'red_runestone',
                name:        'Red Runestone',
                color:       '#FF3333',
                badgeSymbol: '✦',
                description: 'A blood-red stone that pulses like a heartbeat. It grows warm when danger is near.',
                lore:        'The last bearer scratched a single word on the wall before vanishing: "Run."',
                unlocksPortal: null
            }
        };

        const SPELLS = {
    heal: {
        name: 'Heal',
        mpCost: 15,
        pipCost: 1,
        power: 30,
        type: 'heal',
        level: 1,
        description: 'Restore HP'
    },
    fireball: {
        name: 'Fireball',
        mpCost: 20,
        pipCost: 1,
        power: 35,
        type: 'attack',
        level: 2,
        description: 'Fiery attack'
    },
    lightning: {
        name: 'Lightning',
        mpCost: 25,
        pipCost: 2,
        power: 45,
        type: 'attack',
        level: 4,
        description: 'Electric damage'
    },
    greater_heal: {
        name: 'Greater Heal',
        mpCost: 30,
        pipCost: 2,
        power: 60,
        type: 'heal',
        level: 5,
        description: 'Major healing'
    },
    ice_storm: {
        name: 'Ice Storm',
        mpCost: 35,
        pipCost: 2,
        power: 55,
        type: 'attack',
        level: 6,
        description: 'Freezing assault'
    },
    holy_light: {
        name: 'Holy Light',
        mpCost: 20,
        pipCost: 1,
        power: 25,
        type: 'attack',
        level: 3,
        description: 'Divine damage'
    },
    meteor: {
        name: 'Meteor',
        mpCost: 50,
        pipCost: 3,
        power: 80,
        type: 'attack',
        level: 8,
        description: 'Devastating spell'
    }
};

// ═══════════════════════════════════════════════════════════════
// SPELL HELPER - Dynamically add spells from CLASS_SPELL_TREES
// ═══════════════════════════════════════════════════════════════
function ensureSpellExists(spellKey) {
    // If spell already exists, return it
    if (SPELLS[spellKey]) return SPELLS[spellKey];
    
    // Try to find it in CLASS_SPELL_TREES
    if (typeof CLASS_SPELL_TREES === 'undefined') return null;
    
    for (const classKey in CLASS_SPELL_TREES) {
        const classTree = CLASS_SPELL_TREES[classKey];
        if (classTree.spellTree && classTree.spellTree[spellKey]) {
            const spell = classTree.spellTree[spellKey];
            // Add it to SPELLS with pipCost
            SPELLS[spellKey] = {
                ...spell,
                pipCost: 1 // Default pip cost
            };
            console.log(`✅ Dynamically added spell '${spellKey}' to SPELLS`);
            return SPELLS[spellKey];
        }
    }
    
    return null;
}

// Load all spells from CLASS_SPELL_TREES into SPELLS
function loadAllClassSpells() {
    if (typeof CLASS_SPELL_TREES === 'undefined') {
        console.warn('⚠️ CLASS_SPELL_TREES not loaded yet');
        return;
    }
    
    let count = 0;
    for (const classKey in CLASS_SPELL_TREES) {
        const classTree = CLASS_SPELL_TREES[classKey];
        if (classTree.spellTree) {
            for (const spellKey in classTree.spellTree) {
                if (!SPELLS[spellKey]) {
                    const spell = classTree.spellTree[spellKey];
                    SPELLS[spellKey] = {
                        ...spell,
                        pipCost: 1
                    };
                    count++;
                }
            }
        }
    }
    
    if (count > 0) {
        console.log(`✅ Loaded ${count} class spells into SPELLS object`);
    }
}



        const LOCATIONS = {
    town: {
        name: 'Silverdale Town',
        description: 'A peaceful town with shops and an inn. Your adventure begins here.',
        canRest: true,
        hasShop: true
    },
    
  

    forest: {
        name: 'Whispering Forest',
        description: 'A dark forest filled with minor creatures.',
        enemyLevelRange: [1, 5],
        encounters: ['goblin', 'wolf', 'giant_spider'],
        requiredLevel: 1,
        locked: false
    },

  riverside: {
        name: 'Misty Riverside',
        description: 'A foggy riverbank where strange creatures lurk in the shallows.',
        enemyLevelRange: [4, 6],
        encounters: ['river_troll', 'swamp_lurker', 'giant_frog', 'water_snake', 'bandit',
                     'mudskipper', 'river_pirate', 'snapping_turtle', 'kelp_strangler', 'bog_witch',
                     'harpy', 'gnoll', 'lizardfolk', 'giant_wasp', 'bandit_scout'],
        requiredLevel: 4,
        locked: true,
        town: 'town1',
        unlockMessage: 'Defeat your class master in the forest to unlock this area!',
        
    },

    plains: {
        name: 'Endless Plains',
        description: 'Open grasslands with roaming beasts.',
        enemyLevelRange: [6, 10],
        encounters: ['orc', 'dire_wolf', 'bandit'],
        requiredLevel: 6,
        locked: true,
        unlockMessage: 'Defeat your class master in the forest to unlock this area!'
    },

    cave: {
        name: 'Shadow Cavern',
        description: 'A dungeon filled with dangerous monsters.',
        enemyLevelRange: [11, 15],
        encounters: ['troll', 'skeleton_warrior', 'dark_mage'],
        requiredLevel: 11,
        locked: true,
        unlockMessage: 'Defeat your class master in the plains to unlock this area!'
    },

    crypt: {
        name: 'Ancient Crypt',
        description: 'An ancient tomb haunted by the undead.',
        enemyLevelRange: [16, 20],
        encounters: ['lich', 'death_knight', 'wraith'],
        requiredLevel: 16,
        locked: true,
        unlockMessage: 'Defeat your class master in the cave to unlock this area!'
    },

    volcano: {
        name: 'Volcanic Wastes',
        description: 'A scorched wasteland of fire and ash.',
        enemyLevelRange: [21, 25],
        encounters: ['fire_elemental', 'lava_golem', 'phoenix'],
        requiredLevel: 21,
        locked: true,
        unlockMessage: 'Defeat your class master in the crypt to unlock this area!'
    },

    fireMountain: {
        name: 'Fire Mountain',
        description: 'A volcanic peak home to fierce creatures.',
        enemyLevelRange: [8, 12],
        encounters: ['fire_elemental', 'red_dragon', 'demon'],
        requiredLevel: 12,
        locked: true,
        unlockMessage: 'Defeat your class master in the crypt to unlock this area!'
    }
};

// ═══════════════════════════════════════════════════════════════
// MERGE EXPANDED ZONES (if exploration-zones.js is loaded)
// ═══════════════════════════════════════════════════════════════
if (typeof EXPLORATION_ZONES !== 'undefined') {
    // Merge new zones while keeping custom zones
    Object.assign(LOCATIONS, EXPLORATION_ZONES);
    console.log('✅ Loaded expanded exploration zones');
}

// ═══════════════════════════════════════════════════════════════
// MERGE ZONE MONSTERS (if exploration-zones.js is loaded)
// ═══════════════════════════════════════════════════════════════
if (typeof ZONE_MONSTERS !== 'undefined') {
    Object.assign(ENEMIES, ZONE_MONSTERS);
    console.log('✅ Loaded zone-specific monsters');
}

// ═══════════════════════════════════════════════════════════════
// MERGE ADVENTURE ENEMIES (if adventures.js is loaded)
// ═══════════════════════════════════════════════════════════════
if (typeof ADVENTURE_ENEMIES !== 'undefined') {
    Object.assign(ENEMIES, ADVENTURE_ENEMIES);
    console.log('✅ Loaded adventure enemies');
}



        // ═══════════════════════════════════════════════════════════════
        // MODEM SPEED SIMULATION
        // ═══════════════════════════════════════════════════════════════
        
        const MODEM_SPEEDS = {
            '56k': 7,      // ~7 characters per frame (56k modem - fast)
            '28.8k': 4,    // ~4 characters per frame (28.8k modem - medium)
            '14.4k': 2,    // ~2 characters per frame (14.4k modem - slow)
            '9600': 1,     // ~1 character per frame (9600 baud - very slow)
            '4800': 0.5,   // ~0.5 characters per frame (4800 baud - ultra slow)
            'instant': -1  // No delay
        };
        
        let currentModemSpeed = '14.4k'; // Default to 14.4k modem (authentic BBS experience)
        let isStreaming = false;
        let streamCancelled = false;
        
        function streamText(element, html, callback) {
           if (currentModemSpeed === 'instant') {
    line.innerHTML = html;

    // ✅ STEP 3A: scroll AFTER line is fully rendered
    if (shouldAutoScroll) {
        tw.scrollTop = tw.scrollHeight;
    }

line.innerHTML =
    sliceToVisible(html, visibleCount) +
    '<span style="animation:blink 1s infinite;">_</span>';


    if (onDone) onDone();
    termDrain();
    return;
}

            
            isStreaming = true;
            streamCancelled = false;
            
            // Strip HTML tags for character counting but keep them for display
            const charsPerFrame = MODEM_SPEEDS[currentModemSpeed];
            let currentIndex = 0;
            
            const interval = setInterval(() => {
                if (streamCancelled) {
                    clearInterval(interval);
                    element.innerHTML = html;
                    isStreaming = false;
                    if (callback) callback();
                    return;
                }
                
                currentIndex += charsPerFrame;
                
                if (currentIndex >= html.length) {
                    clearInterval(interval);
                    element.innerHTML = html;
                    isStreaming = false;
                    if (callback) callback();
                } else {
                    // Display partial HTML up to current index
                    element.innerHTML = html.substring(0, currentIndex) + '<span style="animation: blink 1s infinite;">_</span>';
                }
            }, 16); // ~60fps
        }
        
        function cancelStream() {
            streamCancelled = true;
        }

        // ═══════════════════════════════════════════════════════════════
        // SAVE FILE ENCRYPTION (Anti-Cheat)
        // ═══════════════════════════════════════════════════════════════
        
        // Simple but effective encryption key (obfuscated in code)
        const SAVE_KEY = 'DQ_' + btoa('DUNGEON_QUEST_2026').split('').reverse().join('');
        
        function encryptSave(data) {
            try {
                const jsonStr = JSON.stringify(data);
                const encoded = btoa(encodeURIComponent(jsonStr));
                
                // Add checksum to detect tampering
                const checksum = generateChecksum(jsonStr);
                
                // XOR cipher with key
                let encrypted = '';
                for (let i = 0; i < encoded.length; i++) {
                    encrypted += String.fromCharCode(
                        encoded.charCodeAt(i) ^ SAVE_KEY.charCodeAt(i % SAVE_KEY.length)
                    );
                }
                
                return btoa(JSON.stringify({
                    v: 1, // version
                    d: btoa(encrypted), // data
                    c: checksum // checksum
                }));
            } catch (e) {
                console.error('Encryption failed:', e);
                return null;
            }
        }
        
        function decryptSave(encryptedData) {
            try {
                const wrapper = JSON.parse(atob(encryptedData));
                
                if (wrapper.v !== 1) {
                    throw new Error('Invalid save version');
                }
                
                const encrypted = atob(wrapper.d);
                
                // XOR decipher
                let decoded = '';
                for (let i = 0; i < encrypted.length; i++) {
                    decoded += String.fromCharCode(
                        encrypted.charCodeAt(i) ^ SAVE_KEY.charCodeAt(i % SAVE_KEY.length)
                    );
                }
                
                const jsonStr = decodeURIComponent(atob(decoded));
                
                // Verify checksum
                const calculatedChecksum = generateChecksum(jsonStr);
                if (calculatedChecksum !== wrapper.c) {
                    throw new Error('Save file has been tampered with!');
                }
                
                return JSON.parse(jsonStr);
            } catch (e) {
                console.error('Decryption failed:', e);
                throw new Error('Invalid or corrupted save file');
            }
        }
        
        function generateChecksum(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return hash.toString(36);
        }
        
        function downloadSaveFile() {
            try {
                const snapshot = buildSaveSnapshot();
                if (!snapshot) {
                    alert('No character data to save!');
                    return;
                }
                
                const encrypted = encryptSave(snapshot);
                if (!encrypted) {
                    alert('Failed to encrypt save file!');
                    return;
                }
                
                // Create filename with character name and timestamp
                const timestamp = new Date().toISOString().slice(0, 10);
                const filename = `DungeonQuest_${snapshot.characterName}_${timestamp}.dqsave`;
                
                // Create blob and download
                const blob = new Blob([encrypted], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert(`✅ Save file downloaded: ${filename}`);
            } catch (e) {
                console.error('Download failed:', e);
                alert('Failed to download save file!');
            }
        }
        
        function loadFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.dqsave';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const encryptedData = event.target.result;
                        const data = decryptSave(encryptedData);
                        
                        // Validate the save data
                        if (!data.player || !data.characterId) {
                            throw new Error('Invalid save file structure');
                        }
                        
                        // Save to localStorage
                        const key = `dq_save_${data.characterId}`;
                        localStorage.setItem(key, JSON.stringify(data));
                        
                        // Update character list
                        updateCharacterList(data);
                        
                        alert(`✅ Character "${data.characterName}" loaded successfully!`);
                        
                        // Load the character
                        loadCharacter(data.characterId);
                    } catch (e) {
                        console.error('Load failed:', e);
                        alert('❌ Failed to load save file: ' + e.message);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        // ── Version check and revision history live in gameversion.js ──
        // GAME_VERSION and REVISION_HISTORY are loaded from that file.
        // checkGameVersion() is also defined there.

        // Game State
        let gameState = {
            player: null,
            currentLocation: 'town',
            currentTown: 'town1',   // which town hub the player is in
            combatState: null,
            combatTimer: null,
            lastAction: null,
            restState: {
                hpRegenTimer: null,    // ticks HP outside combat
                mpRegenTimer: null,    // ticks MP after 15s inactivity
                mpLastAction: 0        // timestamp of last attack/spell; 0 = never
            },
            sysop: {
                authenticated: false,
                username: null,
                terminalActive: false,
                commandHistory: []
            }
        };

        // ═══════════════════════════════════════════════════════════════
        // PASSIVE REGENERATION SYSTEM
        //
        // HP REGEN  — ticks every 8s when NOT in combat.
        //             Restores 5% maxHP per tick (min 1).
        //             Stops when combat begins; resumes when it ends.
        //
        // MP REGEN  — single long-running interval (3s tick).
        //             In town:  ticks immediately, no inactivity wait.
        //             In field: waits 15s of no attacks/spells first.
        //             5% maxMP per tick (min 1).
        // ═══════════════════════════════════════════════════════════════

        // ── Called whenever the player fires an attack or casts a spell ─
        function markMpAction() {
            gameState.restState.mpLastAction = Date.now();
        }

        // ── HP regen: (re)start ticking. Safe to call multiple times ────
        function startHpRegen(isTown = false) {
            // Always clear and restart so rate can change (town vs field)
            if (gameState.restState.hpRegenTimer) {
                clearInterval(gameState.restState.hpRegenTimer);
                gameState.restState.hpRegenTimer = null;
            }

            const TICK_MS = isTown ? 6000 : 8000;  // town: 6s, field: 8s

            gameState.restState.hpRegenTimer = setInterval(() => {
                const p = gameState.player;
                if (!p) return;

                // Pause if in active combat
                if (gameState.combatState) return;

                // Already full
                if (p.hp >= p.maxHp) {
                    p.hp = p.maxHp;
                    updateHud();
                    _refreshTownStats();
                    return;
                }

                // 5% maxHP per tick, minimum 1
                const restore = Math.max(1, Math.ceil(p.maxHp * 0.05));
                p.hp = Math.min(p.maxHp, p.hp + restore);
                updateHud();
                _refreshTownStats();
            }, TICK_MS);
        }

        // ── MP regen: (re)start. isTown = tick immediately, no cooldown ─
        function startMpRegen(isTown = false) {
            // Always restart so town/field rate can differ
            if (gameState.restState.mpRegenTimer) {
                clearInterval(gameState.restState.mpRegenTimer);
                gameState.restState.mpRegenTimer = null;
            }

            // In town: reset action clock so MP ticks right away
            if (isTown) {
                gameState.restState.mpLastAction = 0;
            }

            const MP_COOLDOWN = isTown ? 0      : 15000;  // town: instant, field: 15s after last spell
            const MP_TICK_MS  = isTown ? 4000   : 3000;   // town: 4s tick, field: 3s

            gameState.restState.mpRegenTimer = setInterval(() => {
                const p = gameState.player;
                if (!p) return;
                if (p.mp >= p.maxMp) return;

                const idle = Date.now() - (gameState.restState.mpLastAction || 0);
                if (idle < MP_COOLDOWN) return;

                const restore = Math.max(1, Math.ceil(p.maxMp * 0.05));
                p.mp = Math.min(p.maxMp, p.mp + restore);
                updateHud();
                _refreshTownStats();
            }, MP_TICK_MS);
        }

        // ── Refresh HP/MP display in the town screen (static HTML panel) ─
        function _refreshTownStats() {
            // Only relevant when on the town screen (no terminal-mode)
            if (document.body.classList.contains('terminal-mode')) return;
            const p = gameState.player;
            if (!p) return;
            const hpEl = document.getElementById('townHp');
            const mpEl = document.getElementById('townMp');
            if (hpEl) hpEl.textContent = `${p.hp}/${p.maxHp}`;
            if (mpEl) mpEl.textContent = `${p.mp}/${p.maxMp}`;
        }

        // ── Legacy shim ───────────────────────────────────────────────────
        function startResting(isTown = false) {
            startHpRegen(isTown);
        }

        // ── Stop HP regen only (called when combat starts) ─────────────
        function stopResting() {
            if (gameState.restState.hpRegenTimer) {
                clearInterval(gameState.restState.hpRegenTimer);
                gameState.restState.hpRegenTimer = null;
            }
        }

        // ── Stop both timers entirely (logout, new character, etc.) ─────
        function stopAllRegen() {
            stopResting();
            if (gameState.restState.mpRegenTimer) {
                clearInterval(gameState.restState.mpRegenTimer);
                gameState.restState.mpRegenTimer = null;
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // END REGENERATION SYSTEM
        // ═══════════════════════════════════════════════════════════════

        // 🔑 Prevent UI reset after restore (mobile fix)
gameState.hasRestoredGame = false;

        // ═══════════════════════════════════════════════════════════════
        // SYSOP TERMINAL SYSTEM
        // ═══════════════════════════════════════════════════════════════
        // Credentials are NOT stored in plaintext.
        // Username is stored as a base64 label only.
        // Password is verified by comparing SHA-256 hashes — the actual
        // password never appears anywhere in this source file.
        // SHA-256 cannot be reversed without brute-force.
        const _SYS = {
            // atob('U3lzb3A=') → 'Sysop'
            u: 'U3lzb3A=',
            // SHA-256 of the real password (not the password itself)
            h: '708bdb7228d3bc89a59db53a36d686bac51fba5126229428f9ea532b821e77ea'
        };

        async function _hashPassword(pw) {
            const buf  = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(pw));
            return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2,'0')).join('');
        }

        async function _checkCredentials(u, p) {
            const expectedUser = atob(_SYS.u);
            if (u !== expectedUser) return false;
            const hashed = await _hashPassword(p);
            return hashed === _SYS.h;
        }

        // ══════════════════════════════════════════════════════════════
        // FULLSCREEN + iOS INSTALL BANNER
        // ══════════════════════════════════════════════════════════════

        // ══════════════════════════════════════════════════════════════
        // INSTALL APP MODAL  — detects platform, shows tailored steps
        // ══════════════════════════════════════════════════════════════

        // Detect platform
        function _getPlatform() {
            const ua = navigator.userAgent || '';
            const isStandalone = window.navigator.standalone === true ||
                                 window.matchMedia('(display-mode: standalone)').matches;
            if (isStandalone) return 'standalone';
            if (/iphone|ipad|ipod/i.test(ua)) return 'ios';
            if (/android/i.test(ua)) return 'android';
            if (/macintosh|windows|linux/i.test(ua)) return 'desktop';
            return 'unknown';
        }

        // Content for each platform
        const _installContent = {
            standalone: {
                title: '✅ Already Installed!',
                steps: [
                    { icon: '🎮', text: 'You\'re already running Dungeon Quest as an installed app.' },
                    { icon: '✨', text: 'Full-screen mode is active — enjoy your adventure!' }
                ]
            },
            ios: {
                title: '📱 Install on iPhone / iPad',
                steps: [
                    { icon: '1️⃣', text: 'Tap the <span class="install-highlight">⎙ Share</span> button at the bottom of Safari' },
                    { icon: '2️⃣', text: 'Scroll down and tap <span class="install-highlight">Add to Home Screen</span>' },
                    { icon: '3️⃣', text: 'Tap <span class="install-highlight">Add</span> in the top-right corner' },
                    { icon: '4️⃣', text: 'Open <span class="install-highlight">Dungeon Quest</span> from your home screen — full-screen, no browser chrome!' }
                ]
            },
            android: {
                title: '📱 Install on Android',
                steps: [
                    { icon: '1️⃣', text: 'Tap the <span class="install-highlight">⋮ menu</span> in the top-right of Chrome' },
                    { icon: '2️⃣', text: 'Tap <span class="install-highlight">Add to Home screen</span> (or look for an install banner at the bottom)' },
                    { icon: '3️⃣', text: 'Tap <span class="install-highlight">Install</span> when prompted' },
                    { icon: '4️⃣', text: 'Open <span class="install-highlight">Dungeon Quest</span> from your home screen for full-screen play!' }
                ]
            },
            desktop: {
                title: '🖥️ Install on Desktop',
                steps: [
                    { icon: '🌐', text: 'In <span class="install-highlight">Chrome or Edge</span>, look for the install icon (⊕) in the address bar' },
                    { icon: '2️⃣', text: 'Click <span class="install-highlight">Install</span> when prompted, or go to <span class="install-highlight">⋮ menu → Install Dungeon Quest</span>' },
                    { icon: '3️⃣', text: 'Once installed it opens in its own window without browser chrome' },
                    { icon: 'ℹ️', text: 'Firefox and Safari desktop do <span class="install-highlight">not</span> support PWA install' }
                ]
            },
            unknown: {
                title: '📱 Install Dungeon Quest',
                steps: [
                    { icon: '📖', text: 'Are you on <span class="install-highlight">iPhone/iPad</span>? Tap ⎙ Share → Add to Home Screen' },
                    { icon: '📖', text: 'Are you on <span class="install-highlight">Android</span>? Tap ⋮ menu → Add to Home Screen' },
                    { icon: '📖', text: 'Are you on <span class="install-highlight">Desktop</span>? Look for the ⊕ install icon in your address bar' }
                ]
            }
        };

        function openInstallModal() {
            const platform = _getPlatform();
            const content  = _installContent[platform] || _installContent.unknown;

            const stepsHtml = content.steps.map(s =>
                `<div class="install-step">
                    <span class="install-icon">${s.icon}</span>${s.text}
                </div>`
            ).join('');

            document.getElementById('installModalBody').innerHTML = `
                <div style="font-size:19px;color:var(--highlight-color);margin-bottom:10px;">
                    ${content.title}
                </div>
                ${stepsHtml}
                ${platform === 'unknown' ? `
                <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;">
                    <button onclick="_showInstallFor('ios')"    style="flex:1;font-size:14px;padding:6px;">🍎 iPhone</button>
                    <button onclick="_showInstallFor('android')" style="flex:1;font-size:14px;padding:6px;">🤖 Android</button>
                    <button onclick="_showInstallFor('desktop')" style="flex:1;font-size:14px;padding:6px;">🖥️ Desktop</button>
                </div>` : ''}
            `;

            document.getElementById('installModal').classList.add('open');
        }

        function _showInstallFor(platform) {
            const content = _installContent[platform] || _installContent.unknown;
            const stepsHtml = content.steps.map(s =>
                `<div class="install-step">
                    <span class="install-icon">${s.icon}</span>${s.text}
                </div>`
            ).join('');
            document.getElementById('installModalBody').innerHTML = `
                <div style="font-size:19px;color:var(--highlight-color);margin-bottom:10px;">
                    ${content.title}
                </div>
                ${stepsHtml}
                <button onclick="openInstallModal()" style="margin-top:10px;font-size:14px;padding:5px 10px;border-color:#555;">← Back</button>
            `;
        }

        function closeInstallModal() {
            document.getElementById('installModal').classList.remove('open');
        }

        // Close on backdrop click
        document.getElementById('installModal').addEventListener('click', function(e) {
            if (e.target === this) closeInstallModal();
        });



        // Toggle terminal with ~ key
        document.addEventListener('keydown', (e) => {
            if (e.key === '~' || e.key === '`') {
                e.preventDefault();
                toggleTerminal();
            }
            if (e.key === 'Escape' && gameState.sysop.terminalActive) {
                toggleTerminal();
            }
            // ── Dungeon keyboard navigation ───────────────────────────
            if (gameState.dungeon && !gameState.sysop.terminalActive) {
                const tag = document.activeElement?.tagName;
                const inInput = tag === 'INPUT' || tag === 'TEXTAREA';
                if (!inInput) {
                    const arrowMap = {
                        'ArrowUp':   'n',
                        'ArrowDown': 's',
                        'ArrowLeft': 'w',
                        'ArrowRight':'e'
                    };
                    if (arrowMap[e.key]) {
                        e.preventDefault();
                        dungeonNav(arrowMap[e.key]);
                    }
                }
            }
            // ── Combat / Explore keyboard shortcuts ──────────────────
            // Only on desktop (pointer:fine) and not in any input field
            // 1=Attack  2=Spell  3=Potion  4=Defend  5=Flee  6=Stats
            // Esc=Cancel/Back
            if (!gameState.sysop.terminalActive && gameState.combatState !== undefined) {
                const tag = document.activeElement?.tagName;
                if (tag === 'INPUT' || tag === 'TEXTAREA') return;
                const cs = gameState.combatState;
                const mode = cs ? (cs.actionMode || 'main') : null;
                // Number keys 1-9 — context-sensitive across all menu layers
                const numKey = parseInt(e.key, 10);   // 1-9, or NaN
                if (!isNaN(numKey) && numKey >= 1) {
                    // ── Target selection (attack or spell aimed at a monster) ──
                    if (cs && (mode === 'target_attack' || mode === 'target_spell' || mode === 'target_staff_melee')) {
                        const idx = numKey - 1;
                        if (idx < cs.monsters.length) { e.preventDefault(); executeTargetedAction(idx); }
                        return;
                    }
                    // ── Spell list ──
                    if (cs && mode === 'spell_list') {
                        const validSpells = (gameState.player.knownSpells || []).map(sk => ensureSpellExists(sk) || SPELLS[sk]).filter(Boolean);
                        const weapon   = WEAPONS[gameState.player.weapon];
                        const hasStaff = weapon && (weapon.name.toLowerCase().includes('staff') || weapon.baseMagicDamage > 0);
                        const idx = numKey - 1;
                        if (idx < validSpells.length) {
                            e.preventDefault();
                            selectSpell(gameState.player.knownSpells.filter(sk => (ensureSpellExists(sk)||SPELLS[sk]))[idx]);
                        } else if (hasStaff && idx === validSpells.length) {
                            e.preventDefault(); staffMeleeAttack();
                        }
                        return;
                    }
                    // ── Attack type sub-menu ──
                    if (cs && mode === 'attack_type') {
                        if (numKey === 1) { e.preventDefault(); selectAttackType('normal'); }
                        else if (numKey === 2) { e.preventDefault(); selectAttackType('heavy'); }
                        else if (numKey === 3) {
                            const hl = cs.pipAvailable ? cs.pipAvailable.filter(x=>x).length : 0;
                            if (hl >= 3) { e.preventDefault(); selectAttackType('special'); }
                        }
                        return;
                    }
                    // ── Main combat menu ──
                    if (cs && mode === 'main') {
                        e.preventDefault();
                        if (numKey === 1) showAttackMenu();
                        else if (numKey === 2) showSpellMenu();
                        else if (numKey === 3) showPotionMenu();
                        else if (numKey === 4) playerDefend();
                        else if (numKey === 5) attemptFlee();
                        else if (numKey === 6) printStatsToTerminal();
                        return;
                    }
                    // ── Explore (no combat) ──
                    if (!cs) {
                        e.preventDefault();
                        if (numKey === 1) exploreLocation(gameState.currentLocation);
                        else if (numKey === 3) showPotionMenuExplore();
                        else if (numKey === 4) printStatsToTerminal();
                        else if (numKey === 5) leaveExploreToTown();
                        return;
                    }
                }
                switch (e.key) {
                    case 'Escape':
                        if (cs && mode !== 'main')          { e.preventDefault(); cancelAction(); }
                        break;
                    // Trap shortcut for hunters
                    case 't': case 'T':
                        if (cs && mode === 'main' && (gameState.player.baseClass || gameState.player.class) === 'hunter') {
                            e.preventDefault();
                            castTrap();
                        }
                        break;
                    // Attack sub-menu letter shortcuts (legacy, still work)
                    case 'n': case 'N':
                        if (cs && mode === 'attack_type')   { e.preventDefault(); selectAttackType('normal'); }
                        return;
                    case 'h': case 'H':
                        if (cs && mode === 'attack_type')   { e.preventDefault(); selectAttackType('heavy'); }
                        break;
                    case 's': case 'S':
                        if (cs && mode === 'attack_type') {
                            const hl = cs.pipAvailable ? cs.pipAvailable.filter(x=>x).length : 0;
                            if (hl >= 3) { e.preventDefault(); selectAttackType('special'); }
                        }
                        return;
                }
            }
        });

function showActionBar() {
    // No-op: body.terminal-mode CSS handles actionBar visibility
}

function hideActionBar() {
    // No-op: body.terminal-mode CSS handles actionBar visibility
}


function buildSaveSnapshot() {
    if (!gameState.player) {
        console.warn('No player state to save');
        return null;
    }

    const p = gameState.player;
    
    const snapshot = {
        version: 1,
        characterId: p.id || 'default',
        characterName: p.name,
        timestamp: Date.now(),
        lastSaved: new Date().toLocaleString(),

        player: {
            // Identity
            id: p.id || 'default',
            name: p.name,
            class: p.class,
            
            // Core stats
            level: p.level,
            xp: p.xp,
            xpToNext: p.xpToNext,
            
            // Resources
            hp: p.hp,
            maxHp: p.maxHp,
            mp: p.mp,
            maxMp: p.maxMp,
            gold: p.gold,
            bankGold: p.bankGold || 0,  // Bank storage
            
            // Legacy base stats
            strength: p.strength,
            defense: p.defense,
            magic: p.magic,
            speed: p.speed,
            
            // New stat block (if exists)
            str: p.str,
            dex: p.dex,
            con: p.con,
            wis: p.wis,
            cha: p.cha,
            lck: p.lck,
            
            // Equipment
            weapon: p.weapon,
            armor: p.armor,
            activePet: p.activePet || null,
            
            // Inventory & spells
            inventory: [...(p.inventory || [])],
            knownSpells: [...(p.knownSpells || [])],
            
            // Stat points
            statPoints: p.statPoints || 0,

            // Defeated Masters/unlocked areas
            defeatedMasters: [...(p.defeatedMasters || [])],  // Explicit copy
            unlockedAreas: [...(p.unlockedAreas || [])],
            
            // Base class (for evolution tracking)
            baseClass: p.baseClass,
            className: p.className,
            hasEvolved: p.hasEvolved,
            
            // Progression
            defeatedMasters: [...(p.defeatedMasters || [])],
            unlockedAreas: [...(p.unlockedAreas || [])],
            
            // Special flags
            godMode: p.godMode || false,

            // Portal unlock flag — set when player first uses town2→town1 portal
            portalUnlocked: p.portalUnlocked || false,

            // Achievements & runestones
            achievements: [...(p.achievements || [])],
            runestones: [...(p.runestones || [])],

            // ═══════════════════════════════════════════════════════════════
            // BESTIARY — kill counts per monster key
            // Structure: { monsterKey: count }  e.g. { skeleton: 14, slime: 3 }
            // ═══════════════════════════════════════════════════════════════
            kills: Object.assign({}, p.kills || {}),

            // ── Bestiary read-tracking ──────────────────────────────────
            // Keys the player has opened in the bestiary — used to compute
            // the unread badge count (new discoveries the player hasn't viewed yet)
            bestiaryRead: Object.assign({}, p.bestiaryRead || {}),

            // ═══════════════════════════════════════════════════════════════
            // CHRONICLE — lore book state
            // unlockedEntries: entry ids available to read (level-gated)
            // readEntries:     entry ids the player has actually opened
            // ═══════════════════════════════════════════════════════════════
            chronicle: {
                unlockedEntries: [...((p.chronicle && p.chronicle.unlockedEntries) || [])],
                readEntries:     [...((p.chronicle && p.chronicle.readEntries)     || [])],
            },

            // ── One-time welcome screen flags ──────────────────────────────
            hasSeenWelcome:              p.hasSeenWelcome              || false,
            hasSeenLegacyWelcome:        p.hasSeenLegacyWelcome        || false,
            hasSeenTownArrival_town2:    p.hasSeenTownArrival_town2    || false,
            hasSeenTownArrival_town3:    p.hasSeenTownArrival_town3    || false,
            
            // ═══════════════════════════════════════════════════════════════
            // PERSISTENT DUNGEON MAPS — discovered rooms for all dungeons/floors
            // Structure: { dungeonKey: { floorNum: [roomIds...] } }
            // ═══════════════════════════════════════════════════════════════
            dungeonMaps: (() => {
                const maps = {};
                for (const dungeonKey in (p.dungeonMaps || {})) {
                    maps[dungeonKey] = {};
                    for (const floorNum in p.dungeonMaps[dungeonKey]) {
                        maps[dungeonKey][floorNum] = [...p.dungeonMaps[dungeonKey][floorNum]];
                    }
                }
                return maps;
            })(),

            // Persistent enemy respawn timers (survive town visits)
            dungeonTimers: (() => {
                const timers = {};
                const now = Date.now();
                for (const dk in (p.dungeonTimers || {})) {
                    const valid = (p.dungeonTimers[dk] || []).filter(e => now < e.respawnTime);
                    if (valid.length > 0) timers[dk] = valid;
                }
                return timers;
            })()
        },
        
        // Town hub the player is in
        currentTown: gameState.currentTown || 'town1',
        
        // ═══════════════════════════════════════════════════════════════
        // GENERATED WEAPONS - Save all dynamically created weapon drops
        // ═══════════════════════════════════════════════════════════════
        generatedWeapons: (() => {
            const generated = {};
            // Find all weapons in inventory that have .isDropped flag
            (p.inventory || []).forEach(itemKey => {
                const weapon = WEAPONS[itemKey];
                if (weapon && weapon.isDropped) {
                    generated[itemKey] = weapon;
                }
            });
            // Also save equipped weapon if it's generated
            if (p.weapon && WEAPONS[p.weapon]?.isDropped) {
                generated[p.weapon] = WEAPONS[p.weapon];
            }
            return generated;
        })(),
        
        // ═══════════════════════════════════════════════════════════════
        // GENERATED ARMOR - Save all dynamically created armor drops
        // ═══════════════════════════════════════════════════════════════
        generatedArmor: (() => {
            const generated = {};
            // Find all armor in inventory that have .isDropped flag
            (p.inventory || []).forEach(itemKey => {
                const armor = ARMOR[itemKey];
                if (armor && armor.isDropped) {
                    generated[itemKey] = armor;
                }
            });
            // Also save equipped armor if it's generated
            if (p.armor && ARMOR[p.armor]?.isDropped) {
                generated[p.armor] = ARMOR[p.armor];
            }
            return generated;
        })(),

        // Current location/state
        currentLocation: gameState.currentLocation,

        // ═══════════════════════════════════════════════════════════════
        // ACTIVE COMBAT - Save mid-fight state so enemies persist on reload
        // ═══════════════════════════════════════════════════════════════
        activeCombat: (() => {
            const cs = gameState.combatState;
            if (!cs || gameState.dungeon) return null; // Only for world exploration combat
            return {
                location: gameState.currentLocation,
                monsters: cs.monsters.map(m => ({
                    // All fields needed to fully reconstruct the enemy
                    key:         m.key,
                    name:        m.name,
                    rarity:      m.rarity,
                    rarityColor: m.rarityColor,
                    hp:          m.hp,
                    maxHp:       m.maxHp,
                    damage:      m.damage,
                    defense:     m.defense,
                    xp:          m.xp,
                    gold:        m.gold,
                    level:       m.level,
                    possibleDrops: m.possibleDrops,
                    dropRates:   m.dropRates,
                    index:       m.index
                })),
                currentTarget:   cs.currentTarget,
                enemyDelay:      cs.enemyDelay,
                enemyHits:       cs.enemyHits,
                enemyHitsLeft:   cs.enemyHitsLeft,
                // Save pip state (how many pips are ready vs cooling down)
                pipCount:        cs.pipAvailable.length,
                pipsReady:       cs.pipAvailable.map(x => x),
            };
        })(),

        // Dungeon state (if in dungeon)
        dungeon: gameState.dungeon ? {
            dungeonKey: gameState.dungeon.dungeonKey,
            floor: gameState.dungeon.floor,
            currentRoom: gameState.dungeon.currentRoom,
            discoveredRooms: [...gameState.dungeon.discoveredRooms],
            spawnedRooms: [...(gameState.dungeon.spawnedRooms || [])],
            activeEnemies: gameState.dungeon.activeEnemies.map(e => ({
                id: e.id,
                monsterId: e.monsterId,
                name: e.name,
                hp: e.hp,
                maxHp: e.maxHp,
                currentRoom: e.currentRoom,
                leash: e.leash,
                drop: e.drop || null
            })),
            defeatedEnemies: (gameState.dungeon.defeatedEnemies || []).map(e => ({
                id: e.id,
                monsterId: e.monsterId,
                name: e.name,
                currentRoom: e.currentRoom,
                leash: e.leash,
                drop: e.drop || null,
                deathTime: e.deathTime,
                respawnTime: e.respawnTime
            }))
        } : null,

        meta: {
            inDungeon: !!gameState.dungeon
        }
    };

    return snapshot;
}


// ═══════════════════════════════════════════════════════════════════════
// ██████████████████████████████████████████████████████████████████████
// CHRONICLE & BESTIARY ENGINE
// Phase 2 foundation — data layer only. UI built in next phase.
// ██████████████████████████████████████████████████████████████████████
// ═══════════════════════════════════════════════════════════════════════

// ── Chronicle entry unlock schedule ────────────────────────────────────
// Each entry has: id, level (when it unlocks), and class (which class gets it).
// 'all' means every class gets this entry (world lore).
// Class-specific entries use the base class key.
const CHRONICLE_SCHEDULE = [
    // ── World lore entries (all classes) ────────────────────────────
    { id:'world_1',  level:1,  cls:'all' },   // The seal. What it holds.
    { id:'world_2',  level:5,  cls:'all' },   // The 25 pillars. Why they're crumbling.
    { id:'world_3',  level:8,  cls:'all' },   // The Hollow King named for the first time.
    { id:'world_4',  level:13, cls:'all' },   // The cost of failure. What unmaking means.
    { id:'world_5',  level:18, cls:'all' },   // Others who tried. Why they fell short.
    { id:'world_6',  level:23, cls:'all' },   // The final pillar. The window closing.
    { id:'world_7',  level:25, cls:'all' },   // The Hollow King's bestiary entry unlocks.

    // ── Warrior personal arc ─────────────────────────────────────────
    { id:'warrior_1',  level:1,  cls:'warrior' },
    { id:'warrior_2',  level:3,  cls:'warrior' },
    { id:'warrior_3',  level:8,  cls:'warrior' },
    { id:'warrior_4',  level:13, cls:'warrior' },  // Epithet unlocked
    { id:'warrior_5',  level:15, cls:'warrior' },
    { id:'warrior_6',  level:18, cls:'warrior' },
    { id:'warrior_7',  level:20, cls:'warrior' },
    { id:'warrior_8',  level:23, cls:'warrior' },
    { id:'warrior_9',  level:25, cls:'warrior' },

    // ── Mage personal arc ────────────────────────────────────────────
    { id:'mage_1',  level:1,  cls:'mage' },
    { id:'mage_2',  level:3,  cls:'mage' },
    { id:'mage_3',  level:8,  cls:'mage' },
    { id:'mage_4',  level:13, cls:'mage' },
    { id:'mage_5',  level:15, cls:'mage' },
    { id:'mage_6',  level:18, cls:'mage' },
    { id:'mage_7',  level:20, cls:'mage' },
    { id:'mage_8',  level:23, cls:'mage' },
    { id:'mage_9',  level:25, cls:'mage' },

    // ── Rogue personal arc ───────────────────────────────────────────
    { id:'rogue_1',  level:1,  cls:'rogue' },
    { id:'rogue_2',  level:3,  cls:'rogue' },
    { id:'rogue_3',  level:8,  cls:'rogue' },
    { id:'rogue_4',  level:13, cls:'rogue' },
    { id:'rogue_5',  level:15, cls:'rogue' },
    { id:'rogue_6',  level:18, cls:'rogue' },
    { id:'rogue_7',  level:20, cls:'rogue' },
    { id:'rogue_8',  level:23, cls:'rogue' },
    { id:'rogue_9',  level:25, cls:'rogue' },

    // ── Ranger personal arc ──────────────────────────────────────────
    { id:'ranger_1',  level:1,  cls:'ranger' },
    { id:'ranger_2',  level:3,  cls:'ranger' },
    { id:'ranger_3',  level:8,  cls:'ranger' },
    { id:'ranger_4',  level:13, cls:'ranger' },
    { id:'ranger_5',  level:15, cls:'ranger' },
    { id:'ranger_6',  level:18, cls:'ranger' },
    { id:'ranger_7',  level:20, cls:'ranger' },
    { id:'ranger_8',  level:23, cls:'ranger' },
    { id:'ranger_9',  level:25, cls:'ranger' },

    // ── Runesmith personal arc ───────────────────────────────────────
    { id:'runesmith_1',  level:1,  cls:'runesmith' },
    { id:'runesmith_2',  level:3,  cls:'runesmith' },
    { id:'runesmith_3',  level:8,  cls:'runesmith' },
    { id:'runesmith_4',  level:13, cls:'runesmith' },
    { id:'runesmith_5',  level:15, cls:'runesmith' },
    { id:'runesmith_6',  level:18, cls:'runesmith' },
    { id:'runesmith_7',  level:20, cls:'runesmith' },
    { id:'runesmith_8',  level:23, cls:'runesmith' },
    { id:'runesmith_9',  level:25, cls:'runesmith' },

    // ── Cleric personal arc ──────────────────────────────────────────
    { id:'cleric_1',  level:1,  cls:'cleric' },
    { id:'cleric_2',  level:3,  cls:'cleric' },
    { id:'cleric_3',  level:8,  cls:'cleric' },
    { id:'cleric_4',  level:13, cls:'cleric' },
    { id:'cleric_5',  level:15, cls:'cleric' },
    { id:'cleric_6',  level:18, cls:'cleric' },
    { id:'cleric_7',  level:20, cls:'cleric' },
    { id:'cleric_8',  level:23, cls:'cleric' },
    { id:'cleric_9',  level:25, cls:'cleric' },

    // ── Necromancer personal arc ─────────────────────────────────────
    { id:'necromancer_1',  level:1,  cls:'necromancer' },
    { id:'necromancer_2',  level:3,  cls:'necromancer' },
    { id:'necromancer_3',  level:8,  cls:'necromancer' },
    { id:'necromancer_4',  level:13, cls:'necromancer' },
    { id:'necromancer_5',  level:15, cls:'necromancer' },
    { id:'necromancer_6',  level:18, cls:'necromancer' },
    { id:'necromancer_7',  level:20, cls:'necromancer' },
    { id:'necromancer_8',  level:23, cls:'necromancer' },
    { id:'necromancer_9',  level:25, cls:'necromancer' },

    // ── Berserker personal arc ───────────────────────────────────────
    { id:'berserker_1',  level:1,  cls:'berserker' },
    { id:'berserker_2',  level:3,  cls:'berserker' },
    { id:'berserker_3',  level:8,  cls:'berserker' },
    { id:'berserker_4',  level:13, cls:'berserker' },
    { id:'berserker_5',  level:15, cls:'berserker' },
    { id:'berserker_6',  level:18, cls:'berserker' },
    { id:'berserker_7',  level:20, cls:'berserker' },
    { id:'berserker_8',  level:23, cls:'berserker' },
    { id:'berserker_9',  level:25, cls:'berserker' },
];

// ── Unlock entries for a player at their current level ─────────────────
function unlockChronicleEntries(p) {
    if (!p.chronicle) p.chronicle = { unlockedEntries: [], readEntries: [] };
    const baseClass = p.baseClass || p.class;
    const level = p.level;
    let newUnlocks = [];

    CHRONICLE_SCHEDULE.forEach(entry => {
        if (entry.level !== level) return;                          // not this level
        if (entry.cls !== 'all' && entry.cls !== baseClass) return; // wrong class
        if (p.chronicle.unlockedEntries.includes(entry.id)) return; // already have it
        p.chronicle.unlockedEntries.push(entry.id);
        newUnlocks.push(entry.id);
    });

    // Notify UI if anything unlocked
    if (newUnlocks.length > 0) {
        onChronicleUnlock(newUnlocks);
    }
}

// ── Retroactively unlock all entries up to player's current level ───────
// Used on load for existing players — no notification, just fills state.
function retroactivelyUnlockChronicle(p) {
    // ── Legacy letter: rebuild CHRONICLE_CONTENT entry on every load ───
    // The letter content lives in CHRONICLE_CONTENT which is rebuilt fresh
    // each page load. If the player has seen the letter, re-inject it so
    // the content object is always populated — otherwise clicks find
    // CHRONICLE_CONTENT['legacy_letter'] === undefined and do nothing.
    if (p.hasSeenLegacyWelcome) {
        injectLegacyLetterIntoChronicle(p);  // always re-adds content + schedule entry
    }
    if (!p.chronicle) p.chronicle = { unlockedEntries: [], readEntries: [] };
    const baseClass = p.baseClass || p.class;

    CHRONICLE_SCHEDULE.forEach(entry => {
        if (entry.level > p.level) return;                          // not yet earned
        if (entry.cls !== 'all' && entry.cls !== baseClass) return; // wrong class
        if (p.chronicle.unlockedEntries.includes(entry.id)) return; // already have it
        p.chronicle.unlockedEntries.push(entry.id);
    });
    // Sort by schedule order so entries always appear in the right sequence
    const order = CHRONICLE_SCHEDULE.map(e => e.id);
    p.chronicle.unlockedEntries.sort((a, b) => order.indexOf(a) - order.indexOf(b));
}

// ── Mark a Chronicle entry as read ─────────────────────────────────────
function markChronicleRead(entryId) {
    const p = gameState.player;
    if (!p || !p.chronicle) return;
    if (!p.chronicle.readEntries.includes(entryId)) {
        p.chronicle.readEntries.push(entryId);
        updateChronicleNotificationBadge();
        saveGame();
    }
}

// ── Count unread Chronicle entries ─────────────────────────────────────
function getUnreadChronicleCount() {
    const p = gameState.player;
    if (!p || !p.chronicle) return 0;
    return p.chronicle.unlockedEntries.filter(
        id => !p.chronicle.readEntries.includes(id)
    ).length;
}

// ── Chronicle UI event hooks (stubs — wired up in Phase 3 UI build) ────
function onChronicleUnlock(newEntryIds) {
    // Show a brief in-world notification in the terminal
    const count = newEntryIds.length;
    if (typeof termAppend === 'function') {
        termAppend(
            `<span style="color:#c8a020;">📖 The Chronicle stirs — ${count === 1 ? 'a new page has' : count + ' new pages have'} been written.</span>`,
            'term-loot'
        );
    }
    updateChronicleNotificationBadge();
}

function updateChronicleNotificationBadge() {
    // Updates the red unread-count badge on the Chronicle button.
    // The button itself is built in Phase 3 — this just sets it if present.
    const badge = document.getElementById('chronicle-badge');
    if (!badge) return;
    const count = getUnreadChronicleCount();
    badge.textContent = count;
    badge.style.display = count > 0 ? 'flex' : 'none';
}

// ═══════════════════════════════════════════════════════════════════════
// BESTIARY ENGINE
// ═══════════════════════════════════════════════════════════════════════

// Discovery tier thresholds
const BESTIARY_TIERS = {
    NONE:      0,   // Never seen — silhouette + "???"
    SEEN:      1,   // Killed once — name + basic flavour
    STUDYING:  5,   // Killed 5 — stats revealed
    KNOWN:     10,  // Killed 10 — full entry + lore note
    HUNTER:    25,  // Killed 25 — hunter's note unlocked
};

// ── Get discovery tier for a monster key ───────────────────────────────
function getBestiaryTier(monsterKey) {
    const p = gameState.player;
    if (!p || !p.kills) return BESTIARY_TIERS.NONE;
    const kills = p.kills[monsterKey] || 0;
    if (kills === 0)  return BESTIARY_TIERS.NONE;
    if (kills < 5)    return BESTIARY_TIERS.SEEN;
    if (kills < 10)   return BESTIARY_TIERS.STUDYING;
    if (kills < 25)   return BESTIARY_TIERS.KNOWN;
    return BESTIARY_TIERS.HUNTER;
}

// ── Get total unique monsters discovered (killed at least once) ─────────
function getBestiaryTotalDiscovered() {
    const p = gameState.player;
    if (!p || !p.kills) return 0;
    return Object.keys(p.kills).filter(k => !k.startsWith('_') && p.kills[k] > 0).length;
}

// ── Get count of monsters discovered but NOT yet viewed in the bestiary ──
function getBestiaryDiscoveredCount() {
    const p = gameState.player;
    if (!p || !p.kills) return 0;
    const read = p.bestiaryRead || {};
    // Count monsters killed but not yet opened in the bestiary panel
    return Object.keys(p.kills).filter(k => !k.startsWith('_') && p.kills[k] > 0 && !read[k]).length;
}

// ── Also count tier upgrades not yet seen ─────────────────────────────
// Stored as bestiaryRead[key] = tier at time of reading.
// If current tier > stored tier, it's an upgrade the player hasn't seen.
function getBestiaryUnseenUpgrades() {
    const p = gameState.player;
    if (!p || !p.kills) return 0;
    const read = p.bestiaryRead || {};
    let count = 0;
    Object.keys(p.kills).forEach(k => {
        if (k.startsWith('_')) return;
        if (p.kills[k] <= 0) return;
        const currentTier = getBestiaryTier(k);
        const seenTier    = read[k] !== undefined ? read[k] : -1;
        if (currentTier > seenTier) count++;
    });
    return count;
}

// ── Called every time a monster is killed (from checkCombatEnd) ─────────
function onMonsterKill(killKey, newTotal, monsterData) {
    const prevTier = getBestiaryTier(killKey);  // tier BEFORE this kill
    // Recalculate with new total already applied
    const newTier  = (() => {
        if (newTotal === 0)  return BESTIARY_TIERS.NONE;
        if (newTotal < 5)    return BESTIARY_TIERS.SEEN;
        if (newTotal < 10)   return BESTIARY_TIERS.STUDYING;
        if (newTotal < 25)   return BESTIARY_TIERS.KNOWN;
        return BESTIARY_TIERS.HUNTER;
    })();

    // Fire notification only when crossing a tier threshold
    if (newTier > prevTier) {
        onBestiaryTierUp(killKey, newTier, monsterData);
    }

    // Update badge if bestiary is already built
    updateBestiaryNotificationBadge();
}

// ── Called when a monster crosses a new discovery tier ─────────────────
function onBestiaryTierUp(killKey, tier, monsterData) {
    if (typeof termAppend !== 'function') return;
    const name = (monsterData && monsterData.name) || killKey;
    // Creative, varied terminal messages per tier
    const SEEN_LINES = [
        `Your hand moves to your field notes before you have finished the fight. <em>${name}</em> — first encounter. You will remember this one.`,
        `The <em>${name}</em> falls. You have not faced this creature before. Your notes are already open.`,
        `A new entry scratches itself into the back of your mind: <em>${name}</em>. You will know more after the next one.`,
        `<em>${name}</em> — first kill. Something in your memory files it away with the focus of a hunter who intends to understand their prey.`,
    ];
    const STUDYING_LINES = [
        `Five kills. The patterns are starting to emerge — <em>${name}</em> has habits you can begin to map. The bestiary entry fills in further.`,
        `You have killed five <em>${name}</em>. You understand it better now. HP, damage, the tells before it strikes. The entry has more to show you.`,
        `<em>${name}</em> — five encounters logged. A hunter knows their quarry at five kills. The bestiary has updated. Check it when you can.`,
        `The fifth <em>${name}</em> dies like the first four, but you already knew it would. You understand this creature now. New data in the bestiary.`,
    ];
    const KNOWN_LINES = [
        `Ten kills. The <em>${name}</em> holds no surprises for you anymore. A full entry has been written — lore included. This creature is known.`,
        `You have now killed ten <em>${name}</em>. The bestiary entry is complete. You could describe its behavior in your sleep — and might have to.`,
        `<em>${name}</em> — tenth kill. The entry is finished. Lore note unlocked. You know this creature well enough to teach it to someone else.`,
        `The tenth <em>${name}</em> falls. Your field notes are thorough. The bestiary reflects it — full entry, full lore. Nothing left to learn here.`,
    ];
    const HUNTER_LINES = [
        `Twenty-five <em>${name}</em> have died by your hand. The Hunter's Note has been added — your personal field assessment. Few can claim this expertise.`,
        `<em>${name}</em> — twenty-five kills. The bestiary registers it with a Hunter's Note. You are not just familiar with this creature. You are its natural predator.`,
        `You have killed more <em>${name}</em> than most people have ever seen. A Hunter's Note, written in your experience, has been added to the entry.`,
        `Twenty-five. The <em>${name}</em> category in your bestiary is as complete as it can be. The Hunter's Note is yours. You earned it one kill at a time.`,
    ];
    const pools = {
        [BESTIARY_TIERS.SEEN]:     { lines: SEEN_LINES,     color: '#7a9a6a' },
        [BESTIARY_TIERS.STUDYING]: { lines: STUDYING_LINES, color: '#c8a020' },
        [BESTIARY_TIERS.KNOWN]:    { lines: KNOWN_LINES,    color: '#d4802a' },
        [BESTIARY_TIERS.HUNTER]:   { lines: HUNTER_LINES,   color: '#00ff88' },
    };
    const pool = pools[tier];
    if (pool) {
        const line = pool.lines[Math.floor(Math.random() * pool.lines.length)];
        termAppend(`<span style="color:${pool.color};">📖 ${line}</span>`, 'term-dim');
    }
}

function updateBestiaryNotificationBadge() {
    // Wired to UI badge in Phase 4
    const badge = document.getElementById('bestiary-badge');
    if (!badge) return;
    // For now just show total discovered count
    const count = getBestiaryDiscoveredCount();
    badge.textContent = count;
    badge.style.display = count > 0 ? 'flex' : 'none';
}

// ═══════════════════════════════════════════════════════════════════════
// END CHRONICLE & BESTIARY ENGINE
// ═══════════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════════
// ██████████████████████████████████████████████████████████████████████
// CHRONICLE & BESTIARY UI
// Phase 2 — full parchment overlay, entry list, reader, bestiary panels
// ██████████████████████████████████████████████████████████████████████
// ═══════════════════════════════════════════════════════════════════════

// ── State ──────────────────────────────────────────────────────────────
const CUI = {
    activeTab:        'chronicle',  // 'chronicle' | 'bestiary'
    activeEntryId:    null,         // currently open Chronicle entry id
    activeMonsterId:  null,         // currently open Bestiary monster key
    entryList:        [],           // ordered array of unlocked entry ids
    currentEntryIdx:  0,            // index within entryList for prev/next nav
};

// ── Open / close ────────────────────────────────────────────────────────
function openChronicle(tab) {
    const overlay = document.getElementById('chronicle-overlay');
    if (!overlay) return;
    overlay.classList.add('open');
    document.body.style.overflow = 'hidden';
    // Always start at list view when opening — reset any previous reader state
    closeChronicleReader();
    switchChronicleTab(tab || CUI.activeTab);
    refreshChroniclelaunchBadge();
}

function closeChronicle() {
    const overlay = document.getElementById('chronicle-overlay');
    if (!overlay) return;
    overlay.classList.remove('open');
    document.body.style.overflow = '';
    saveGame(); // Persist any newly-read entries
}

// Close on backdrop click
document.addEventListener('DOMContentLoaded', () => {
    const overlay = document.getElementById('chronicle-overlay');
    if (overlay) {
        overlay.addEventListener('click', e => {
            if (e.target === overlay) closeChronicle();
        });
    }
});
// Also close on Escape
document.addEventListener('keydown', e => {
    if (e.key === 'Escape') {
        const overlay = document.getElementById('chronicle-overlay');
        if (overlay && overlay.classList.contains('open')) closeChronicle();
    }
});

// ── Tab switching ────────────────────────────────────────────────────────
function switchChronicleTab(tab) {
    CUI.activeTab = tab;
    // Tab buttons
    document.getElementById('tab-chronicle').classList.toggle('active', tab === 'chronicle');
    document.getElementById('tab-bestiary').classList.toggle('active', tab === 'bestiary');
    // Panels
    document.getElementById('panel-chronicle').style.display = tab === 'chronicle' ? 'block' : 'none';
    document.getElementById('panel-bestiary').style.display  = tab === 'bestiary'  ? 'block' : 'none';
    // Subtitle
    const sub = document.getElementById('chronicle-header-sub');
    if (sub) sub.textContent = tab === 'chronicle'
        ? 'The world remembers everything.'
        : 'Know thine enemy.';

    if (tab === 'chronicle') renderChronicleList();
    if (tab === 'bestiary')  renderBestiaryList();
}

// ═══════════════════════════════════════════════════════════════════════
// CHRONICLE TAB
// ═══════════════════════════════════════════════════════════════════════

function renderChronicleList() {
    const p = gameState.player;
    if (!p || !p.chronicle) return;
    // NOTE: do NOT call closeChronicleReader() here — this function is also
    // called from openChronicleEntry to refresh the list highlight, and closing
    // the reader would immediately undo the open.

    const list  = document.getElementById('chronicle-entry-list');
    if (!list) return;

    const baseClass = p.baseClass || p.class;
    const playerName = p.name || 'the wanderer';

    // Build ordered list of unlocked entries
    CUI.entryList = CHRONICLE_SCHEDULE
        .filter(e => p.chronicle.unlockedEntries.includes(e.id))
        .map(e => e.id);

    if (CUI.entryList.length === 0) {
        list.innerHTML = `
            <div style="padding:40px 24px;text-align:center;color:#5a4020;font-style:italic;font-size:15px;">
                <div style="font-size:32px;margin-bottom:12px;opacity:0.4;">📖</div>
                The Chronicle stirs, but its pages are still blank.<br>
                <span style="font-size:13px;color:#3a2810;">Continue your journey — new entries unlock as you level up.</span>
            </div>`;
        return;
    }

    list.innerHTML = CUI.entryList.map((id, idx) => {
        const def  = CHRONICLE_CONTENT[id];
        if (!def) return '';
        const unread = !p.chronicle.readEntries.includes(id);
        const tierLabel = def.cls === 'all' ? 'World Lore' : (p.className || p.class);
        return `
            <div class="chronicle-entry-row ${unread ? 'unread' : ''} ${CUI.activeEntryId === id ? 'active' : ''}"
                 onclick="openChronicleEntry('${id}', ${idx})">
                <div class="chronicle-entry-icon">${def.icon || '📜'}</div>
                <div class="chronicle-entry-meta">
                    <div class="chronicle-entry-title">${def.title(playerName)}</div>
                    <div class="chronicle-entry-hint">${def.hint || ''}</div>
                </div>
                <div class="chronicle-entry-level">${def.level === 0 ? '✉' : 'Lv ' + def.level}</div>
            </div>`;
    }).join('');

    // Refresh badges
    refreshAllBadges();
}

function openChronicleEntry(id, idx) {
    const p = gameState.player;
    if (!p) return;
    const def = CHRONICLE_CONTENT[id];
    if (!def) { console.warn('Chronicle: no content for', id); return; }

    CUI.activeEntryId = id;
    CUI.currentEntryIdx = idx !== undefined ? idx : CUI.entryList.indexOf(id);

    // Cancel any in-progress animation from a previous entry
    if (window._chronAnimTimer) {
        window._chronAnimTimer.forEach(t => clearTimeout(t));
        window._chronAnimTimer = [];
    }

    markChronicleRead(id);

    // Show reader, hide list
    document.getElementById('chronicle-entry-list').style.display = 'none';
    const reader = document.getElementById('chronicle-reader');
    reader.classList.add('open');

    // Prev / next buttons
    const prevBtn = document.getElementById('chron-prev');
    const nextBtn = document.getElementById('chron-next');
    const pageNum = document.getElementById('chron-page-num');
    if (prevBtn) prevBtn.disabled = CUI.currentEntryIdx <= 0;
    if (nextBtn) nextBtn.disabled = CUI.currentEntryIdx >= CUI.entryList.length - 1;
    if (pageNum) pageNum.textContent = `${CUI.currentEntryIdx + 1} / ${CUI.entryList.length}`;

    // Build raw HTML from body function
    const playerName = p.name || 'the wanderer';
    const baseClass  = p.baseClass || p.class;
    const bodyHtml   = typeof def.body === 'function'
        ? def.body(playerName, baseClass, p.className || p.class)
        : (def.body || '');

    // ── Parse body HTML into individual segments ──────────────────────
    // We render into a temp container, then walk the child nodes so each
    // p, .chronicle-callout, .chronicle-epithet, div etc becomes its own
    // animated segment — exactly like the welcome screen letter.
    const tmp = document.createElement('div');
    tmp.innerHTML = bodyHtml;

    // Collect top-level child elements as segments
    const rawSegs = Array.from(tmp.children);

    // Build the page container
    const page = document.getElementById('chronicle-page-content');
    page.innerHTML = '';

    // Header: ornament + title + label + divider — shown immediately (no anim)
    const header = document.createElement('div');
    header.innerHTML = `
        <div class="chronicle-page-ornament">✦ · · · ✦</div>
        <div class="chronicle-page-title">${def.title(playerName)}</div>
        <div class="chronicle-page-label">${def.label || (def.cls === 'all' ? 'World Lore' : 'Personal Chronicle')}</div>
        <div class="chronicle-page-divider">⁂</div>
    `;
    page.appendChild(header);

    // Body wrapper
    const bodyWrap = document.createElement('div');
    bodyWrap.className = 'chronicle-page-body';
    page.appendChild(bodyWrap);

    // Skip button (hidden until animation starts)
    const skipBtn = document.createElement('button');
    skipBtn.className = 'chron-skip-btn';
    skipBtn.textContent = '[ skip animation ]';
    skipBtn.style.display = 'none';
    skipBtn.onclick = () => skipChronicleAnimation();
    page.appendChild(skipBtn);

    // Footer ornament (added after last segment animates in)
    const footer = document.createElement('div');
    footer.className = 'chronicle-page-ornament';
    footer.style.cssText = 'margin-top:28px;opacity:0;transition:opacity 0.8s ease;';
    footer.textContent = '✦ · · · ✦';
    page.appendChild(footer);

    // Wrap each segment in .chron-seg and append hidden
    const segEls = rawSegs.map(child => {
        const wrap = document.createElement('div');
        wrap.className = 'chron-seg';
        // Preserve original tag type for drop-cap and indent CSS to work
        // by cloning the element itself rather than wrapping
        const clone = child.cloneNode(true);
        wrap.appendChild(clone);
        bodyWrap.appendChild(wrap);
        return wrap;
    });

    // Scroll reader to top
    const chronicleBody = document.getElementById('chronicle-body');
    if (chronicleBody) chronicleBody.scrollTop = 0;

    // Show skip button
    skipBtn.style.display = 'block';

    // ── Animate segments in ───────────────────────────────────────────
    window._chronAnimTimer = [];
    window._chronAnimSkipped = false;
    let delay = 400;

    segEls.forEach((el, i) => {
        const t = setTimeout(() => {
            if (window._chronAnimSkipped) return;
            el.classList.add('visible');
            // Gentle scroll — bring new segment into view
            el.scrollIntoView({ behavior: 'smooth', block: 'end' });
            // After last segment: show footer, hide skip
            if (i === segEls.length - 1) {
                setTimeout(() => {
                    footer.style.opacity = '1';
                    skipBtn.style.display = 'none';
                }, 800);
            }
        }, delay);
        window._chronAnimTimer.push(t);

        // Reading-pace timing — match welcome screen
        const text = el.textContent || '';
        const isShort = text.trim().length < 60;
        const isCallout = el.querySelector('.chronicle-callout') !== null
                       || (el.firstElementChild && el.firstElementChild.classList.contains('chronicle-callout'));
        const isEpithet = el.querySelector('.chronicle-epithet') !== null;
        const dur = isCallout  ? 17500
                  : isEpithet  ? 5000
                  : isShort    ? 6000
                  : 12500;
        delay += dur;
    });

    // Update list highlight without closing reader
    renderChronicleList();
}

function skipChronicleAnimation() {
    window._chronAnimSkipped = true;
    if (window._chronAnimTimer) {
        window._chronAnimTimer.forEach(t => clearTimeout(t));
        window._chronAnimTimer = [];
    }
    // Make all segments visible instantly
    const page = document.getElementById('chronicle-page-content');
    if (!page) return;
    page.querySelectorAll('.chron-seg').forEach(el => el.classList.add('visible'));
    // Show footer, hide skip button
    const footer = page.querySelector('.chronicle-page-ornament:last-of-type');
    if (footer) footer.style.opacity = '1';
    const skipBtn = page.querySelector('.chron-skip-btn');
    if (skipBtn) skipBtn.style.display = 'none';
    // Smooth scroll to bottom
    const chronicleBody = document.getElementById('chronicle-body');
    if (chronicleBody) chronicleBody.scrollTo({ top: chronicleBody.scrollHeight, behavior: 'smooth' });
}

function closeChronicleReader() {
    CUI.activeEntryId = null;
    const reader = document.getElementById('chronicle-reader');
    if (reader) reader.classList.remove('open');
    const list = document.getElementById('chronicle-entry-list');
    if (list) list.style.display = 'flex';
}

function navigateChronicle(dir) {
    const newIdx = CUI.currentEntryIdx + dir;
    if (newIdx < 0 || newIdx >= CUI.entryList.length) return;
    openChronicleEntry(CUI.entryList[newIdx], newIdx);
}

// ═══════════════════════════════════════════════════════════════════════
// BESTIARY TAB
// ═══════════════════════════════════════════════════════════════════════

function renderBestiaryList() {
    const p = gameState.player;
    if (!p) return;
    // Do NOT call closeBestiaryReader() here — openBestiaryEntry calls this
    // after opening, which would immediately close the reader.

    const list = document.getElementById('bestiary-list');
    if (!list) return;

    const TIER_LABELS = {
        0: { cls: 'bestiary-tier-none',     label: '???' },
        1: { cls: 'bestiary-tier-seen',     label: 'Seen' },
        5: { cls: 'bestiary-tier-studying', label: 'Studying' },
        10:{ cls: 'bestiary-tier-known',    label: 'Known' },
        25:{ cls: 'bestiary-tier-hunter',   label: 'Hunter' },
    };

    const totalDiscovered = getBestiaryTotalDiscovered();  // use total, not unread count
    const azrathRelated = Object.keys(BESTIARY_DATA).filter(k => {
        const cat = BESTIARY_DATA[k] && BESTIARY_DATA[k].category;
        return (cat === 'Draconic' || cat === 'Void Entity' || cat === 'Demonic') &&
               (p.kills && (p.kills[k] || 0) > 0);
    }).length;

    let html = '';

    if (totalDiscovered > 0) {
        html += `
            <div style="padding:10px 18px 6px;border-bottom:1px solid rgba(90,58,24,0.3);">
                <span style="font-size:12px;color:#5a4020;letter-spacing:1px;">
                    ${totalDiscovered} creature${totalDiscovered !== 1 ? 's' : ''} recorded
                    ${azrathRelated > 0 ? `&nbsp;&middot;&nbsp;<span style="color:#8a3020;">${azrathRelated} Calamity-linked</span>` : ''}
                </span>
            </div>`;
    }

    const catOrder = (typeof BESTIARY_CAT_ORDER !== 'undefined') ? BESTIARY_CAT_ORDER
        : ['Common Beast','Humanoid','Undead','Corrupted','Elemental / Construct',
           'Draconic','Demonic','Void Entity','Ancient / Boss'];

    catOrder.forEach(cat => {
        const monsters = Object.keys(BESTIARY_DATA).filter(k => BESTIARY_DATA[k] && BESTIARY_DATA[k].category === cat);
        if (monsters.length === 0) return;

        // Discovered entries first, then alphabetical
        monsters.sort((a, b) => {
            const ka = (p.kills && p.kills[a]) || 0;
            const kb = (p.kills && p.kills[b]) || 0;
            if (!!ka !== !!kb) return kb - ka;
            return (BESTIARY_DATA[a].name || a).localeCompare(BESTIARY_DATA[b].name || b);
        });

        html += `<div style="padding:8px 18px 4px;background:rgba(0,0,0,0.2);border-bottom:1px solid rgba(90,58,24,0.2);">
            <span style="font-size:11px;color:#5a4020;letter-spacing:2px;text-transform:uppercase;">${cat}</span>
        </div>`;

        monsters.forEach(key => {
            const def = BESTIARY_DATA[key];
            if (!def) return;
            const kills = (p.kills && p.kills[key]) || 0;
            const tier  = getBestiaryTier(key);
            const tDef  = TIER_LABELS[tier] || TIER_LABELS[0];
            const discovered = kills > 0;

            html += `
                <div class="bestiary-entry-row ${CUI.activeMonsterId === key ? 'active' : ''}"
                     data-key="${key}"
                     onclick="openBestiaryEntry('${key}')">
                    <div class="bestiary-monster-icon ${discovered ? '' : 'undiscovered'}">
                        ${discovered ? (def.icon || '?') : '?'}
                    </div>
                    <div class="bestiary-monster-name ${discovered ? '' : 'undiscovered'}">
                        ${discovered ? def.name : '???'}
                    </div>
                    ${kills > 0 ? `<div class="bestiary-kill-count">${kills}&times;</div>` : ''}
                    <div class="bestiary-tier-badge ${tDef.cls}">${tDef.label}</div>
                </div>`;
        });
    });

    if (!html || getBestiaryTotalDiscovered() === 0) {
        html = `<div style="padding:40px 24px;text-align:center;color:#5a4020;font-style:italic;font-size:15px;">
            <div style="font-size:32px;margin-bottom:12px;opacity:0.4;">&#x1F4CB;</div>
            The Bestiary is empty.<br>
            <span style="font-size:13px;color:#3a2810;">Defeat enemies in combat to record them here.</span>
        </div>`;
    }

    list.innerHTML = html;
    refreshAllBadges();
}

function buildBestiaryProgressBar(kills) {
    if (kills <= 0) return '';
    var tiers = [{t:1,label:'Seen'},{t:5,label:'Studying'},{t:10,label:'Known'},{t:25,label:'Hunter'}];
    var next  = tiers.filter(function(t){ return kills < t.t; })[0];
    if (!next) return '<div style="color:#00ff88;font-size:12px;padding:4px 0;">&#9733; Hunter &mdash; fully mastered</div>';
    var prev  = tiers[tiers.indexOf(next) - 1] || { t: 0 };
    var pct   = Math.min(100, Math.round(((kills - prev.t) / (next.t - prev.t)) * 100));
    var filled = Math.floor(pct / 10);
    var bar   = '\u2588'.repeat(filled) + '\u2591'.repeat(10 - filled);
    return '<div style="font-size:12px;color:#7a6040;margin:4px 0 6px;">'
        + '<span style="color:#a07840;">[' + bar + ']</span>'
        + ' ' + pct + '% &rarr; <b style="color:#c8a050;">' + next.label + '</b>'
        + ' <span style="color:#5a4020;">(' + (next.t - kills) + ' more kill' + (next.t - kills !== 1 ? 's' : '') + ')</span>'
        + '</div>';
}

function openBestiaryEntry(key) {
    const p = gameState.player;
    if (!p) return;
    const def = BESTIARY_DATA[key];
    if (!def) return;

    // Mark as read at current tier so badge clears
    if (!p.bestiaryRead) p.bestiaryRead = {};
    p.bestiaryRead[key] = getBestiaryTier(key);
    refreshAllBadges();

    CUI.activeMonsterId = key;
    const kills = (p.kills && p.kills[key]) || 0;
    const tier  = getBestiaryTier(key);

    // Hide list, show reader
    document.getElementById('bestiary-list').style.display = 'none';
    const reader = document.getElementById('bestiary-reader');
    reader.classList.add('open');

    const statReveal   = tier >= BESTIARY_TIERS.STUDYING;
    const fullReveal   = tier >= BESTIARY_TIERS.KNOWN;
    const hunterReveal = tier >= BESTIARY_TIERS.HUNTER;
    const lockMsg      = statReveal
        ? '<span class="bestiary-locked-stat">&mdash; Requires 10 kills &mdash;</span>'
        : '<span class="bestiary-locked-stat">&mdash; Requires 5 kills &mdash;</span>';

    // Stat grid
    const stats = def.stats || {};
    function statVal(v) { return statReveal ? (v || '?') : lockMsg; }
    const statGrid = '<div class="bestiary-stat-grid">'
        + '<div class="bestiary-stat-row"><span class="bestiary-stat-label">HP</span><span class="bestiary-stat-value">'     + statVal(stats.hp)     + '</span></div>'
        + '<div class="bestiary-stat-row"><span class="bestiary-stat-label">Level</span><span class="bestiary-stat-value">'  + statVal(stats.level)  + '</span></div>'
        + '<div class="bestiary-stat-row"><span class="bestiary-stat-label">Damage</span><span class="bestiary-stat-value">' + statVal(stats.damage) + '</span></div>'
        + '<div class="bestiary-stat-row"><span class="bestiary-stat-label">Defense</span><span class="bestiary-stat-value">'+ statVal(stats.defense)+ '</span></div>'
        + '<div class="bestiary-stat-row"><span class="bestiary-stat-label">XP</span><span class="bestiary-stat-value">'     + statVal(stats.xp)     + '</span></div>'
        + '<div class="bestiary-stat-row"><span class="bestiary-stat-label">Gold</span><span class="bestiary-stat-value">'   + statVal(stats.gold)   + '</span></div>'
        + '</div>';

    // Lore note
    let loreBlock = '';
    if (fullReveal && def.lore) {
        loreBlock = '<div class="bestiary-lore-note"><strong style="color:#c8a050;font-style:normal;">Lore Note</strong><br>' + def.lore + '</div>';
    } else if (!statReveal) {
        const remaining = 5 - kills;
        loreBlock = '<div style="color:#3a2810;font-size:13px;font-style:italic;padding:8px 0;">Defeat this creature ' + remaining + ' more time' + (remaining !== 1 ? 's' : '') + ' to reveal its stats.</div>';
    }

    // Hunter note
    let hunterBlock = '';
    if (hunterReveal && def.hunterNote) {
        hunterBlock = '<div class="bestiary-hunters-note"><strong style="color:#7a9a60;font-style:normal;">Hunter\'s Note</strong><br>' + def.hunterNote(p.name || 'hunter') + '</div>';
    } else if (fullReveal && !hunterReveal) {
        const remaining = 25 - kills;
        hunterBlock = '<div style="color:#3a2810;font-size:13px;font-style:italic;padding:8px 0;">Defeat this creature ' + remaining + ' more time' + (remaining !== 1 ? 's' : '') + ' to unlock the Hunter\'s Note.</div>';
    }

    // Body content
    let body = '';
    if (kills === 0) {
        body = '<div class="bestiary-flavor" style="text-align:center;opacity:0.5;">Something moved through the dark.<br>You haven\'t faced it yet.</div>';
    } else {
        body = '<div class="bestiary-flavor">' + def.flavor + '</div>' + statGrid + loreBlock + hunterBlock;
    }

    const legacyTag = (p.kills && p.kills._legacy) ? '<span class="bestiary-legacy-tag">Legacy</span>' : '';

    document.getElementById('bestiary-detail-content').innerHTML =
        '<div class="bestiary-detail-name">' + (def.icon || '') + ' ' + def.name + ' ' + legacyTag + '</div>'
        + '<div class="bestiary-detail-class">' + def.category + ' &middot; ' + kills + ' kill' + (kills !== 1 ? 's' : '') + '</div>'
        + buildBestiaryProgressBar(kills)
        + body;

    document.getElementById('chronicle-body').scrollTop = 0;
    refreshAllBadges();

    // Highlight active row in list without re-rendering
    document.querySelectorAll('.bestiary-entry-row').forEach(function(row) {
        row.classList.toggle('active', row.dataset.key === key);
    });
}

function closeBestiaryReader() {
    CUI.activeMonsterId = null;
    const reader = document.getElementById('bestiary-reader');
    if (reader) reader.classList.remove('open');
    const list = document.getElementById('bestiary-list');
    if (list) list.style.display = 'block';
}

// ── Badge refresh ───────────────────────────────────────────────────────
function refreshAllBadges() {
    const unread = getUnreadChronicleCount();
    const discovered = getBestiaryDiscoveredCount();

    // Tab badges
    const cb = document.getElementById('chronicle-badge');
    if (cb) { cb.textContent = unread; cb.classList.toggle('visible', unread > 0); }
    const unseen = getBestiaryUnseenUpgrades();
    const bb = document.getElementById('bestiary-badge');
    if (bb) { bb.textContent = unseen; bb.classList.toggle('visible', unseen > 0); }

    // Launch button badge (in character stats)
    refreshChroniclelaunchBadge();
}

function refreshChroniclelaunchBadge() {
    const unread = getUnreadChronicleCount();
    const badge  = document.getElementById('chronicle-launch-badge');
    if (badge) {
        badge.textContent = unread || '';
        badge.classList.toggle('visible', unread > 0);
    }
}

// Wire updateChronicleNotificationBadge (called by engine) to our refresh
function updateChronicleNotificationBadge() { refreshAllBadges(); }
function updateBestiaryNotificationBadge()  { refreshAllBadges(); }

// ═══════════════════════════════════════════════════════════════════════
// BESTIARY DATA
// Auto-built from ENEMIES at runtime, with hand-crafted entries layered
// on top for notable monsters. Categories and flavor reflect the Azrath
// world — everything disturbed, displaced, or corrupted by the Waking.
// ═══════════════════════════════════════════════════════════════════════

// ── Category assignment by monster key ─────────────────────────────────
const BESTIARY_CATEGORIES = {
    // Common Beasts — existed before the Waking
    common_beast: [
        'angry_squirrel','giant_rat','wolf','wild_boar','wild_lynx',
        'plains_hawk','plains_lion','giant_spider','giant_frog','giant_beetle',
        'giant_wasp','giant_leech','giant_scorpion','mud_crab','mudskipper',
        'water_snake','snapping_turtle','war_boar','cave_worm','dungeon_bat',
        'venomfang_bat','moss_creeper','thornling','slime','poop_slime',
    ],
    // Humanoid — bandits, raiders, cultists, organized enemies
    humanoid: [
        'goblin','goblin_shaman','kobold','forest_imp','bandit','bandit_scout',
        'orc','orc_berserker','hobgoblin','gnoll','gnoll_chief','centaur',
        'plains_raider','lizardfolk','river_pirate','cave_orc','cave_gnoll',
        'minotaur_scout','harpy','dark_stalker','grave_robber','death_cultist',
        'doom_cultist','dark_priest','dark_ranger','dark_mage','dark_oracle',
        'necromancer','plague_bearer',
    ],
    // Undead — proliferating as the seal weakens
    undead: [
        'zombie','plague_zombie','ghoul','skeleton','skeleton_warrior',
        'wraith','dust_wraith','elder_wraith','wailing_banshee','banshee_queen',
        'spirit','specter','will_o_wisp','revenant','frozen_revenant',
        'lich_thrall','lich','ancient_lich','ancient_lich_lord',
        'grave_knight','rotting_knight','bone_archer','crypt_bat','crypt_guard',
        'tomb_rat','phantom_mage','spectral_warrior','vampire_thrall','vampire',
        'elder_vampire','vampire_lord','death_knight','undead_general',
        'bone_colossus','bone_dragon',
    ],
    // Corrupted — creatures twisted by the Waking's energy
    corrupted: [
        'corrupted_paladin','corrupted_titan','corrupted_treant',
        'troll','river_troll','swamp_lurker','swamp_hag','swamp_witch',
        'bog_beast','bog_shambler','bog_witch','cave_basilisk','cave_drake',
        'yeti','werewolf','medusa','gargoyle','flesh_golem','animated_armor',
        'ruin_guardian','runic_guardian','plague_lord','plague_rat',
        'fungal_horror','imp_swarm','lesser_demon','chaos_imp',
        'shadow_hound','nightmare_steed','abyssal_hound',
    ],
    // Elementals and Constructs
    elemental: [
        'fire_elemental','magma_elemental','inferno_elemental','blood_elemental',
        'chaos_elemental','stone_golem','iron_golem','ancient_golem','thorn_golem',
        'lava_golem','lava_titan','flame_titan','frost_giant','blizzard_titan',
        'star_titan','infernal_titan','fallen_titan','void_titan','corrupt_titan',
        'kelp_strangler',
    ],
    // Draconic — dragons and dragon-kin drawn by Azrath's Waking
    draconic: [
        'wyvern','poison_drake','ice_drake','cave_drake','frost_wyrm',
        'glacial_wyrm','magma_dragon','storm_dragon','shadow_dragon',
        'plague_dragon','nightmare_dragon','eclipse_dragon','eternal_dragon',
        'chaos_dragon','void_dragon','red_dragon','bone_dragon',
    ],
    // Demonic — forces of chaos surging through the weakening seal
    demonic: [
        'demon','demon_hound','demon_warrior','demon_sorceress','demon_lord',
        'hellhound','hellfire_knight','pit_fiend','elder_demon',
        'infernal_mage','abyssal_knight','fallen_angel',
        'chaos_knight','chaos_bringer',
    ],
    // Void — entities from beyond reality, drawn by the approaching Calamity
    void: [
        'void_sprite','void_walker','void_assassin','void_priest',
        'void_lord','void_overlord','void_colossus',
        'nihil_spawn','oblivion_herald','oblivion_incarnate',
        'reality_tear','reality_shredder','entropy_beast',
        'soul_devourer','soul_reaper','cosmic_horror',
        'shadow_stalker','shadow_archon',
    ],
    // Ancient and Boss-tier — the most dangerous beings in the world
    ancient: [
        'dark_champion','black_knight','cursed_knight','cursed_archon',
        'fallen_warlord','doom_knight','abyssal_knight',
        'ogre','stone_crawler','dungeon_spider',
        'phoenix','seraphim','arch_angel','divine_champion','divine_executioner',
        'celestial_guardian','eternal_warden','god_avatar',
        'herald_of_doom','venomous_hydra',
    ],
};

// ── Reverse lookup: key → category label ──────────────────────────────
const KEY_TO_CATEGORY = {};
const CAT_LABELS = {
    common_beast: 'Common Beast',
    humanoid:     'Humanoid',
    undead:       'Undead',
    corrupted:    'Corrupted',
    elemental:    'Elemental / Construct',
    draconic:     'Draconic',
    demonic:      'Demonic',
    void:         'Void Entity',
    ancient:      'Ancient / Boss',
};
Object.entries(BESTIARY_CATEGORIES).forEach(([cat, keys]) => {
    keys.forEach(k => { KEY_TO_CATEGORY[k] = CAT_LABELS[cat]; });
});

// ── Icon assignment by category ─────────────────────────────────────────
const CAT_ICONS = {
    'Common Beast':          '🐾',
    'Humanoid':              '⚔️',
    'Undead':                '💀',
    'Corrupted':             '🌑',
    'Elemental / Construct': '🔥',
    'Draconic':              '🐉',
    'Demonic':               '😈',
    'Void Entity':           '🌀',
    'Ancient / Boss':        '👑',
};

// ── Hand-crafted flavor entries (layered over auto-generated base) ──────
const BESTIARY_FLAVOR = {
    slime: {
        icon: '🟢',
        flavor: 'A quivering mass of translucent gel found in caves and dungeons throughout the land. They have always existed here — but they have never been this numerous. Whatever is waking beneath the world, the slimes feel it.',
        hunterNote: (n) => `${n}, aim for the darker nucleus near the top. Hit it and the whole body destabilises. Miss it and you are just splashing gel around.`,
    },
    poop_slime: {
        icon: '💩',
        flavor: 'Nobody is quite sure where these came from. The scholars refuse to study them. The dungeon delvers have strong opinions about the smell.',
        hunterNote: (n) => `${n} — just... aim for the middle and back away quickly.`,
    },
    wolf: {
        icon: '🐺',
        flavor: 'Once creatures of open forest and clean air. They have been driven from their territories by something they fear more than you. That something is still out there.',
        hunterNote: (n) => `Watch the shoulders not the head, ${n}. They drop just before a lunge — half a second to sidestep. Use it.`,
    },
    dire_wolf: {
        icon: '🐺',
        flavor: 'Twice the size of a normal wolf, with intelligence enough to coordinate with its pack. The tremors from the Waking have scattered their packs and driven them into areas where humans were previously safe.',
        hunterNote: (n) => `Never fight a dire wolf alone if there are others nearby, ${n}. They signal each other. Kill the one howling first.`,
    },
    skeleton: {
        icon: '💀',
        flavor: 'Bone animated by the overflow of energy from the weakening seal. The empty eye sockets carry no memory, no purpose — only the instruction to oppose the living. As the seal cracks further, the dead rise faster.',
        hunterNote: (n) => `Blunt weapons, ${n}. Always blunt. Blades slide between ribs and stick. A hammer strike to the pelvis drops them — they cannot walk without it.`,
    },
    zombie: {
        icon: '🧟',
        flavor: 'The freshly dead, animated within hours of passing. The seal\'s decay has thinned the barrier between life and death to the point where corpses near ley lines rise without any intention at all. They simply get back up.',
        hunterNote: (n) => `Slow, ${n}, but they do not tire. Do not let them corner you. Head or spine — anything else just makes them slower.`,
    },
    ghost: {
        icon: '👻',
        flavor: 'A spirit that refuses to accept its death, repeating patterns from its former life with the terrible patience of something that no longer ages. The Waking has not created them — it has prevented them from moving on.',
        hunterNote: (n) => `Magic or silver, ${n}. Anything physical passes through. No magic and no silver? Find another route.`,
    },
    goblin: {
        icon: '👺',
        flavor: 'Small, fast, and smarter than they look. The tremors have collapsed many of their underground warrens, forcing them into areas previously claimed by larger creatures — and by people.',
        hunterNote: (n) => `They go for ankles and eyes, ${n}. Keep your guard high and watch for the ones hiding behind the ones you can see.`,
    },
    orc: {
        icon: '💪',
        flavor: 'Driven from their traditional territories by the chaos of the Waking, orc warbands have become unpredictable and desperate. A desperate orc is significantly more dangerous than a comfortable one.',
        hunterNote: (n) => `They favor their weapon arm, ${n}. Attack from the off side. They are strong enough that blocking straight on is a mistake.`,
    },
    bandit: {
        icon: '🗡️',
        flavor: 'Someone who made a choice when the world started shaking — to take rather than fight. You can almost understand it. The understanding does not make them less dangerous.',
        hunterNote: (n) => `Unlike monsters, ${n}, bandits calculate risk. Look confident. Hesitate and they read it.`,
    },
    troll: {
        icon: '👹',
        flavor: 'The Waking has been particularly unkind to trolls — the tremors have destabilised their lairs, the displaced creature migrations have invaded their feeding grounds, and the ambient energy from the cracking seal makes them aggressive in ways they normally are not.',
        hunterNote: (n) => `Regeneration, ${n}. Fire or acid stops it. If you have neither, you need to end it faster than it can heal — which is faster than you think.`,
    },
    dragon: {
        icon: '🐉',
        flavor: 'Old enough to remember the last cycle. It fought against the original sealing. It is still fighting. The patience of something truly ancient is difficult to comprehend until you are standing in front of it.',
        hunterNote: (n) => `The scales are impenetrable from the front, ${n}. The underside near the hindquarters is thinner. Getting there without dying is the entire challenge.`,
    },
    demon: {
        icon: '😈',
        flavor: 'The Calamity Dragon\'s approach tears holes in the fabric of reality. Demons are what comes through the holes — not summoned, not invited. Simply opportunistic. The seal has been keeping them out for a thousand years.',
        hunterNote: (n) => `Stay out of the wing arc, ${n}. The physical strike hurts, but the disorientation is the real damage. Hit from behind when the wings extend.`,
    },
    vampire: {
        icon: '🧛',
        flavor: 'Ancient predators who have maintained careful balances with human settlements for centuries. The Waking has disrupted those balances. When the dead rise without intention, the distinction between a vampire\'s careful cultivation and crude undeath becomes academic.',
        hunterNote: (n) => `Sunlight or a stake to the heart, ${n}. Classic for a reason. They are fast and they know you are coming before you arrive — do not give them time to prepare.`,
    },
    lich: {
        icon: '💀',
        flavor: 'A mage who refused death by binding their soul to an external object. The Waking has been a gift to liches — the overflow of death energy from the cracking seal makes their power easier to maintain, and the chaos gives them cover to operate openly for the first time in centuries.',
        hunterNote: (n) => `Find the phylactery first, ${n}. Killing the body means nothing if the soul-object survives. They always keep it close. Think about what they value most.`,
    },
    void_walker: {
        icon: '🌀',
        flavor: 'Something that should not exist in a world where the seal holds. The seal has been keeping out more than one thing for a thousand years. As it cracks, the void finds gaps.',
        hunterNote: (n) => `They phase in and out, ${n}. Watch for the shimmer just before they solidify — that is your window. Strike then or wait for the next cycle.`,
    },
    chaos_dragon: {
        icon: '🐉',
        flavor: 'Not a natural dragon. Something that the chaos energies of the Waking shaped from raw unstable power. It has a dragon\'s form and a dragon\'s ferocity and none of a dragon\'s intelligence — which makes it, in some ways, more dangerous.',
        hunterNote: (n) => `No patterns, ${n}. Chaos dragons do not telegraph. Stay mobile and reactive. Do not try to read them — just survive their attacks and counter.`,
    },
    red_dragon: {
        icon: '🔴',
        flavor: 'The oldest living dragon in the known world, and the one most agitated by the Waking. It remembers the last cycle. It has been waiting, in its fashion, for a thousand years.',
        hunterNote: (n) => `${n}, if you are fighting this — you already know what you need to know. The talismans. That is the answer.`,
    },
};

// ── Build BESTIARY_DATA at runtime from ENEMIES + crafted flavor ────────
// Called once after ENEMIES is defined. Populates the global BESTIARY_DATA.
function buildBestiaryData() {
    const data = {};

    if (typeof ENEMIES === 'undefined') return data;

    Object.keys(ENEMIES).forEach(key => {
        const e = ENEMIES[key];
        const category = KEY_TO_CATEGORY[key] || 'Common Beast';
        const craft    = BESTIARY_FLAVOR[key] || {};
        const icon     = craft.icon || CAT_ICONS[category] || '❓';

        // Auto-generate hunter note if not hand-crafted
        const hunterNote = craft.hunterNote || ((n) =>
            `${n} — after ${25} encounters, you know this enemy well. Trust your instincts.`
        );

        data[key] = {
            name:       e.name || key,
            icon,
            category,
            flavor:     craft.flavor || (e.description || 'A creature disturbed by the Waking of Azrath the Calamity Dragon.'),
            stats: {
                hp:      `${e.baseHp}`,
                level:   `${e.level}`,
                damage:  e.minDamage !== undefined ? `${e.minDamage}–${e.maxDamage}` : `${e.baseDamage}`,
                defense: `${e.baseDefense}`,
                xp:      `${e.baseXp}`,
                gold:    `${e.baseGold}`,
            },
            lore:       craft.lore || null,
            hunterNote,
        };
    });

    // Add Azrath as the ultimate boss entry (not in ENEMIES — narrative only)
    data['azrath'] = {
        name: 'Azrath the Calamity Dragon',
        icon: '🔴',
        category: CAT_LABELS.ancient,
        flavor: 'Sealed a thousand years ago by Brennan the Unbroken. The tremors began when the seal started failing. Every creature you have fought, every dungeon you have survived, every level you have earned — it has all been in preparation for this.',
        stats: { hp: '???', level: '25', damage: '???', defense: '???', xp: '???', gold: '???' },
        lore: 'The seal Brennan built was never meant to be permanent — only to buy the world time. Time enough for someone of his bloodline to reach their full potential and finish what he started. The four talismans were his insurance. You are his inheritance.',
        hunterNote: (n) => `${n}. If you are reading this, you are ready. You have always been ready. You just needed to become who you are now. The talismans know what to do. Trust them. Trust yourself. Brennan trusted you a thousand years before you were born.`,
    };

    return data;
}

// ── BESTIARY_DATA is populated after page load when ENEMIES is available ─
let BESTIARY_DATA = {};
window.addEventListener('DOMContentLoaded', () => {
    // Small delay to ensure ENEMIES is fully defined
    setTimeout(() => {
        BESTIARY_DATA = buildBestiaryData();
        console.log(`✅ Bestiary built: ${Object.keys(BESTIARY_DATA).length} entries`);
        updateBestiaryNotificationBadge();
    }, 100);
});

// ── Display order for Bestiary tab (category sort order) ─────────────────
const BESTIARY_CAT_ORDER = [
    'Common Beast',
    'Humanoid',
    'Undead',
    'Corrupted',
    'Elemental / Construct',
    'Draconic',
    'Demonic',
    'Void Entity',
    'Ancient / Boss',
];

// ── CHRONICLE_CONTENT is built by the lore-*.js files loaded above ──────
// Nothing to patch — each lore file sets level and cls directly.

// ── Refresh badges on page load once player is available ────────────────
window.addEventListener('load', () => {
    setTimeout(refreshAllBadges, 800);
});

// ═══════════════════════════════════════════════════════════════════════
// END CHRONICLE & BESTIARY UI
// ═══════════════════════════════════════════════════════════════════════


// ═══════════════════════════════════════════════════════════════════════
// WELCOME / INTRO SCREEN ENGINE
// Shown once after brand-new character creation.
// Reads from CHRONICLE_CONTENT entry 1 for the player's class.
// ═══════════════════════════════════════════════════════════════════════

// Class-specific opening lore blocks shown on the welcome screen.
// Each returns an array of { type:'para'|'callout'|'divider', text } segments.
function getWelcomeLore(classKey, playerName) {
    const cls = classKey ? classKey.toLowerCase() : 'warrior';
    const base = cls.replace(/^(dark|chaos|shadow)_/,'');

    // Map evolved/advanced class keys back to base
    const baseMap = {
        paladin:'warrior', berserker_lord:'berserker', archmage:'mage',
        assassin:'rogue',  druid:'ranger',  high_cleric:'cleric',
        death_knight:'necromancer', master_smith:'runesmith',
    };
    const loreClass = baseMap[cls] || base;

    const CLASS_LORE = {
        warrior: [
            { type:'para',    text:`The ground has been shaking for three weeks. Not the trembling of a mine collapse or a mountain pass — this is something deeper. A rhythmic rumble that rises up through the earth itself, steady as breathing, like something enormous stirring in a sleep it has kept for a thousand years.` },
            { type:'callout', text:`Your grandmother called it the Waking. The name passed down through Brennan's bloodline for ten generations — a warning dressed as legend. <em>When the earth shakes like this, when the tremors come in threes, the blood of Brennan will be called.</em><br><br>You always thought it was a story families told to feel important.` },
            { type:'para',    text:`Then the tremors came, and your grandmother opened the chest at the foot of her bed — the one you were never allowed to touch — and set its contents on the table without a word. A journal. A fragment of ancient chain. A map with a location marked in faded red ink.` },
            { type:'para',    text:`Azrath the Calamity Dragon was sealed beneath the earth a thousand years ago by your ancestor Brennan the Unbroken. Not killed — nothing has ever killed it. Sealed. Bound in a prison of ancient making that was never meant to hold forever.` },
            { type:'callout', text:`The seal is breaking. The dungeons of the land grow more dangerous by the month as creatures are driven upward by the tremors. Somewhere ahead, at a place called the Crossroads, others like you are gathering — called by their own reasons, their own roads, all converging on the same endpoint.<br><br>The world has until Azrath wakes fully. You have until level twenty-five.` },
            { type:'para',    text:`The journal is in your pack. The training begins now. Every fight, every level earned, every skill sharpened in the dungeons ahead — it is not adventure. It is preparation for the one moment your bloodline was born for.` },
        ],
        mage: [
            { type:'para',    text:`You have been monitoring the seal's degradation for six months, longer than most institutions have been willing to admit the problem exists. The numbers do not lie. The rate of decay has accelerated three times since you first plotted it, and every new data point compresses the timeline further.` },
            { type:'callout', text:`The Academy calls it theoretical concern. You call it an imminent catastrophe. Azrath the Calamity Dragon — sealed beneath the earth by the warrior Brennan a thousand years ago — is nearly free. The tremors are not geological. They are the sound of a prison failing.` },
            { type:'para',    text:`You have heard of the Crossroads. The old texts describe it as a gathering place built for exactly this cycle — a place where the called ones find each other, where the four elemental dungeons begin, where a thousand years of Brennan's preparation waits for people strong enough to use it.` },
            { type:'para',    text:`The dungeons ahead will sharpen you. Every spell refined, every level of mastery earned — it is preparation. The world needs what you will become, not what you are now.` },
        ],
        rogue: [
            { type:'para',    text:`You have survived by knowing things other people do not. Information is your currency, your weapon, your escape route. And what you know right now — what every shadow network from the ports to the mountain passes is whispering about — is that the earth is wrong.` },
            { type:'callout', text:`The tremors. The dead rising near the old pillar routes. The creature migrations pushing everything out of the deep places and toward the surface. Every fence, every information broker, every person who makes their living knowing things before other people do — they all say the same thing. Something is coming. Something that makes kings irrelevant and armies useless.` },
            { type:'para',    text:`You have heard of Azrath the Calamity Dragon. Everyone has, in the same way everyone has heard of the dark at the end of the world — as metaphor, as warning tale, as something that was someone else's problem a thousand years ago.` },
            { type:'para',    text:`The Crossroads calls people like you. Not because you are the most powerful, but because the fight ahead requires every kind of strength. Your skills, honed in the dungeons ahead, will matter more than you expect.` },
        ],
        ranger: [
            { type:'para',    text:`The forest has been wrong for months. You noticed it before the tremors started — the way the migration routes shifted, the silence in places that should have been full of sound, the look of an animal that has been frightened badly enough to abandon ten thousand years of instinct.` },
            { type:'callout', text:`The tremors confirmed what you already knew from the land itself. Azrath the Calamity Dragon — sealed a thousand years ago by a warrior named Brennan the Unbroken — is nearly free. The creatures fleeing the deep places are not random. They are running from what is waking beneath them.` },
            { type:'para',    text:`The Crossroads exists for this. Brennan built it after the last sealing, a gathering place for the next cycle. People are already moving there — warriors, mages, clerics, all called by their own reasons. The four elemental dungeons beyond the Crossroads hold the talismans Brennan left behind.` },
            { type:'para',    text:`You know how to survive. You know how to read what the land tells you. Train in the dungeons ahead, and what you know will become what the world needs.` },
        ],
        runesmith: [
            { type:'para',    text:`The hand reached for the tool before you knew you needed it. Not the first time — that has been happening for months. The muscle memory of techniques you were never taught, for instruments you have never made, for a purpose you are only beginning to understand.` },
            { type:'callout', text:`The tremors started three weeks ago. The scholars say geological instability. You say something else. The runes you have been waking with in your hands — the same configurations, again and again — are binding runes. Ancient ones. The kind used in major workings a thousand years ago.<br><br>Someone named Brennan used them to seal a dragon called Azrath. You are beginning to believe you were there.` },
            { type:'para',    text:`The Crossroads holds Brennan's second journal — and a room full of tools that no one else can use. The four elemental dungeons beyond it contain talismans that need a runesmith's understanding to be properly wielded. Train in the dungeons ahead. The craft you are inheriting from a past life is the craft the world needs now.` },
        ],
        cleric: [
            { type:'para',    text:`The prayers stopped being answered six months ago. Not all at once — a gradual fading, like a voice growing distant. You kept the log, kept the practice, kept looking for the pattern. And you found it: the silence correlates exactly with the worsening of the tremors.` },
            { type:'callout', text:`Something is interfering. The order calls it a trial of faith. You call it a signal. Azrath the Calamity Dragon — sealed a thousand years ago, breaking free now — is not just a physical threat. It is the kind of force that distorts everything around it, including the connections between the faithful and their gods.<br><br>The silence is not absence. It is obstruction.` },
            { type:'para',    text:`The Crossroads calls you. Brennan's preparations extend to every class, every calling, every form of strength the world can produce. The four elemental dungeons ahead test not power but purpose. What you believe, why you fight, who you serve — those will matter as much as the levels you earn.` },
            { type:'para',    text:`Train. Level. Become what your faith has been building you toward. The silence will end when Azrath does.` },
        ],
        necromancer: [
            { type:'para',    text:`The dead have been afraid for three months. Not restless — afraid. You have conducted thousands of séances in your practice. You have spoken to spirits from every era. In all that time, you have never encountered a spirit that was frightened.` },
            { type:'callout', text:`They all say the same thing, unprompted: <em>It is coming and the dead cannot stop it.</em> Every spirit, across every session, across every century they died in. Azrath the Calamity Dragon does not discriminate between the living and the dead. What it touches is simply gone — not killed, not transformed. Erased.<br><br>The dead are afraid of ceasing to have ever existed.` },
            { type:'para',    text:`The Crossroads holds records from every past cycle. People are gathering there from every corner of the land, called by their own paths to the same destination. The four elemental dungeons Brennan left behind require someone who understands the boundary between life and death to properly interpret what they contain.` },
            { type:'para',    text:`That someone is you. Train in the dungeons ahead. The dead are counting on the living to finish this.` },
        ],
        berserker: [
            { type:'para',    text:`You came back from three days in the high passes to find your village empty. Not attacked, not fled — empty. The people were still there, still breathing, still standing in the places they had been when whatever happened happened. But the lights were out behind their eyes. Your grandmother at her loom. Old Davin at the gate. The children in the yard. Present and gone at the same time.` },
            { type:'callout', text:`You have been told this is what Azrath does. The Calamity Dragon — sealed a thousand years ago by a warrior named Brennan, nearly free now, the tremors the proof of it — does not kill. It empties. It strips the meaning from things until the things themselves no longer matter enough to remain.<br><br>Your people are still alive. They are just no longer there.` },
            { type:'para',    text:`Someone at the Crossroads told you it might be reversible. That if Azrath is stopped before it fully wakes, the emptying stops with it. That the people taken first might come back when the source of the taking is gone.` },
            { type:'para',    text:`You do not know if that is true. You are going to find out. Train hard. Get to level twenty-five. If there is any chance they can come back, you are going to earn it.` },
        ],
    };

    return CLASS_LORE[loreClass] || CLASS_LORE['warrior'];
}

// Build the town closing line
function getStartingTownName() {
    const tid = gameState.currentTown || 'town1';
    if (typeof TOWNS !== 'undefined' && TOWNS[tid]) return TOWNS[tid].name;
    return 'Silverdale';
}

// Show the welcome screen
function showWelcomeScreen() {
    const p = gameState.player;
    if (!p) { showTown(); return; }

    const overlay = document.getElementById('welcome-overlay');
    if (!overlay) { showTown(); return; }

    // Populate header
    document.getElementById('welcome-char-name').textContent = p.name || 'Adventurer';
    document.getElementById('welcome-char-class').textContent = p.className || p.class || '';

    // Build content segments
    const baseClass = p.baseClass || p.class || 'warrior';
    const segments  = getWelcomeLore(baseClass, p.name);

    // Town closing segment (always last)
    const townName = getStartingTownName();
    segments.push({ type:'town', townName });

    // Render all segments as hidden elements
    const body = document.getElementById('welcome-body');
    body.innerHTML = '';

    segments.forEach((seg, i) => {
        let el;
        if (seg.type === 'para') {
            el = document.createElement('p');
            el.className = 'welcome-para';
            el.innerHTML = seg.text;
        } else if (seg.type === 'callout') {
            el = document.createElement('div');
            el.className = 'welcome-callout';
            el.innerHTML = seg.text;
        } else if (seg.type === 'divider') {
            el = document.createElement('div');
            el.className = 'welcome-divider';
            el.textContent = '✦  ·  ·  ·  ✦';
        } else if (seg.type === 'town') {
            el = document.createElement('div');
            el.className = 'welcome-town-line';
            el.innerHTML = `
                <div class="welcome-divider" style="opacity:0.4;margin-bottom:16px;">✦  ·  ·  ·  ✦</div>
                <div class="welcome-town-top">And so your journey begins in the town of</div>
                <div class="welcome-town-name">${seg.townName}</div>`;
        }
        if (el) {
            el.dataset.segIndex = i;
            body.appendChild(el);
        }
    });

    // Open overlay
    overlay.classList.add('open');
    document.body.style.overflow = 'hidden';

    // Animate segments in one by one
    let delay = 300;
    const allSegs = body.querySelectorAll('[data-seg-index]');
    const lastIdx = allSegs.length - 1;

    allSegs.forEach((el, i) => {
        setTimeout(() => {
            el.classList.add('visible');
            // Gently scroll new element into view — slow and deliberate
            el.scrollIntoView({ behavior:'smooth', block:'end' });
            // Enable begin button after last segment
            if (i === lastIdx) {
                setTimeout(() => {
                    const btn = document.getElementById('welcome-begin-btn');
                    if (btn) btn.classList.add('ready');
                }, 800);
            }
        }, delay);
        // Reading pace — 2.5x longer per paragraph so players finish before next arrives.
        // Short single-line paras (under ~60 chars) get 6s, full paras 12.5s,
        // callouts 17.5s (they're dense), town closing line 8s.
        const text = el.textContent || '';
        const isShortLine = text.trim().length < 60;
        const dur = el.classList.contains('welcome-callout')   ? 17500
                  : el.classList.contains('welcome-town-line') ? 8000
                  : isShortLine                                 ? 6000
                  : 12500;
        delay += dur;
    });
}

function beginAdventure() {
    const overlay = document.getElementById('welcome-overlay');
    if (overlay) overlay.classList.remove('open');
    document.body.style.overflow = '';
    const p = gameState.player;
    if (p) {
        p.hasSeenWelcome = true;          // mark so legacy check skips this player
        unlockChronicleEntries(p);
        retroactivelyUnlockChronicle(p);
        saveGame();
    }
    showTown();
}

function skipWelcome() {
    const overlay = document.getElementById('welcome-overlay');
    if (overlay) {
        // Instantly show all segments, then allow begin
        overlay.querySelectorAll('[data-seg-index]').forEach(el => el.classList.add('visible'));
        const btn = document.getElementById('welcome-begin-btn');
        if (btn) btn.classList.add('ready');
        // Smooth scroll to bottom on skip
        const body = document.getElementById('welcome-body');
        if (body) body.scrollTo({ top: body.scrollHeight, behavior: 'smooth' });
    }
}

// ═══════════════════════════════════════════════════════════════════════
// END WELCOME SCREEN ENGINE
// ═══════════════════════════════════════════════════════════════════════


// ═══════════════════════════════════════════════════════════════════════
// LEGACY WELCOME SYSTEM
// Shows once on next login for players who existed before the Chronicle/
// lore system was added. Detected by absence of p.hasSeenLegacyWelcome.
// The letter is also permanently readable in the Chronicle as a special
// entry labeled "A Letter Found".
// ═══════════════════════════════════════════════════════════════════════

function isLegacyPlayer(p) {
    // A legacy player is one who has no hasSeenLegacyWelcome flag AND
    // no hasSeenWelcome flag (new players get hasSeenWelcome set).
    // We also check they actually exist (level >= 1).
    if (!p) return false;
    if (p.hasSeenWelcome) return false;       // new-flow player
    if (p.hasSeenLegacyWelcome) return false; // already shown
    return true;
}

function maybeShowLegacyWelcome() {
    const p = gameState.player;
    if (p && isLegacyPlayer(p)) {
        showLegacyWelcome();
    } else {
        showTown();
    }
}

// ── Level-tier helper ─────────────────────────────────────────────────
function getLegacyTier(level) {
    if (level >= 25) return 'complete';
    if (level >= 17) return 'late';
    if (level >= 9)  return 'mid';
    return 'early';
}

// ── Build the letter body based on level and class ────────────────────
function buildLegacyLetter(p) {
    const name     = p.name || 'Adventurer';
    const level    = p.level || 1;
    const cls      = (p.baseClass || p.class || 'warrior').toLowerCase();
    const tier     = getLegacyTier(level);
    const levelsLeft = Math.max(0, 25 - level);

    // Class-specific opener — who is writing to them, and why they matter
    const CLASS_OPENERS = {
        warrior:     `You are the last of Brennan's bloodline. We have known this since before you were born. The four talismans hidden in the elemental dungeons beyond the Crossroads will only answer to you — keyed by your ancestor to the blood he trusted would hold for a thousand years.`,
        mage:        `Your calculations are correct. We have been watching the Academy dismiss your findings for months. The seal's degradation follows exactly the curve you plotted. Your understanding of what is happening makes you irreplaceable in what comes next.`,
        rogue:       `Every shadow network on the continent has the same whisper running through it right now. You have heard it. You know what it means. The skills you have spent your life sharpening were not, it turns out, merely for survival. They are exactly what the fight ahead requires.`,
        ranger:      `The forest told you before the scholars admitted it. You read the migration routes, the silence in the wrong places, the fear in animals that do not normally fear anything. Your instincts have been correct from the beginning. Trust them in what comes next.`,
        runesmith:   `The muscle memory is not random. The runes you keep waking with in your hands are Brennan's binding configurations — the same ones used to seal Azrath a thousand years ago. You are not learning them. You are remembering them. There is a difference, and it matters.`,
        cleric:      `The silence in your prayers is not divine absence. Something is interfering with the connection — the same force that is cracking the seal, leaking energy into the world in ways that distort everything around it. Your faith has not been misplaced. It has been obstructed. That obstruction has a name.`,
        necromancer: `Every spirit you have spoken to for the past three months has said the same thing unprompted: <em>It is coming and the dead cannot stop it.</em> You have noted this. You have not yet understood the full implication. The dead are afraid of ceasing to have ever existed. That is what Azrath does.`,
        berserker:   `We know about your village. We know what happened to the people there. We also know that what happened to them may not be permanent — that the emptying Azrath performs can be reversed if the source of it is stopped before it fully wakes. That is not a promise. But it is a reason.`,
    };

    // Tier-specific urgency block — what the seal looks like right now
    const TIER_STATUS = {
        early: `The seal still holds — barely. The tremors you have felt are its fracture lines widening. Each one is worse than the last. The scholars have calculated a timeline and stopped publishing it because the timeline is soon. You have ${levelsLeft} levels between where you stand now and where you need to be.`,
        mid:   `The seal is failing in ways that are no longer theoretical. Creatures from the deep places are surfacing with increasing frequency. The tremors are regular now. The sky near the sealing site changes on bad days. You have reached level ${level}. You have ${levelsLeft} levels left. The window is narrowing.`,
        late:  `The seal has partially fractured. What is coming through the cracks is only a hint of what comes when it breaks entirely. You are level ${level} — close enough to see the end, far enough away that the next ${levelsLeft} levels are not optional. Move.`,
        complete: `You are level 25. If you are reading this, you already know what you need to know. The seal is gone. Azrath is nearly free. Everything that has happened to you has been preparation for what happens next. We have nothing left to tell you that you have not already learned.`,
    };

    // The Crossroads paragraph — adjusted by tier
    const CROSSROADS = {
        early:    `There is a place called the Crossroads. You will find it when you are strong enough — around level ten to twelve, when the road becomes clear. Others like you are already moving toward it from every direction. Warriors, mages, rogues, rangers — each called by their own reason. The Crossroads is where those reasons converge.`,
        mid:      `If you have not yet reached the Crossroads, it sits in a valley roughly ten to twelve days from most starting points. The four elemental dungeons begin there — Wind, Fire, Earth, Water — each holding a talisman that Brennan placed there a thousand years ago as insurance. They are waiting for someone strong enough to claim them.`,
        late:     `The elemental dungeons beyond the Crossroads hold four talismans that Brennan placed there a thousand years ago. Wind, Fire, Earth, Water — each one earned through a dungeon that tests not just strength but character. If you have not collected them, do so before level twenty-five. They are what makes the final confrontation survivable.`,
        complete: ``,
    };

    // Closer — always personal
    const CLOSER = tier === 'complete'
        ? `The old man at the Crossroads gate is still at his post. The others who trained here are watching. The world is waiting to find out who you are.<br><br>We have been watching since before you knew there was anything to watch for. We have never doubted you.<br><br><em>— The Keepers of the Crossroads</em>`
        : `We have been watching you since before you knew there was anything to watch for. You have reached level ${level}. The seal has that much less time. Every level you earn from here is a level closer to the moment this has all been building toward.<br><br>Do not stop.<br><br><em>— The Keepers of the Crossroads</em>`;

    const opener  = CLASS_OPENERS[cls] || CLASS_OPENERS['warrior'];
    const status  = TIER_STATUS[tier];
    const cross   = CROSSROADS[tier];

    return { name, level, cls, tier, levelsLeft, opener, status, cross, closer: CLOSER };
}

// ── Render and show ───────────────────────────────────────────────────
function showLegacyWelcome() {
    const p = gameState.player;
    if (!p) { showTown(); return; }

    const overlay = document.getElementById('welcome-overlay');
    if (!overlay) { showTown(); return; }

    const lore = buildLegacyLetter(p);

    // Header
    document.getElementById('welcome-char-name').textContent = lore.name;
    document.getElementById('welcome-char-class').textContent =
        (p.className || p.class || '') + '  ·  Level ' + lore.level;

    // Override dragon icon with envelope/scroll feel for the letter
    const icon = overlay.querySelector('.welcome-dragon-icon');
    if (icon) { icon.textContent = '📜'; icon.style.animation = 'none'; }

    const title = overlay.querySelector('.welcome-title');
    if (title) title.textContent = 'A Letter Found at Your Door';

    // Build segments
    const segments = [
        { type:'para',    text:`<em>${lore.name},</em>` },
        { type:'para',    text:`We have been watching you.` },
        { type:'callout', text:lore.opener },
        { type:'para',    text:lore.status },
    ];

    if (lore.cross) {
        segments.push({ type:'para', text:lore.cross });
    }

    segments.push({ type:'divider' });
    segments.push({ type:'para',   text:lore.closer });
    segments.push({ type:'town',   isTownLine:false, isLetter:true });

    // Render
    const body = document.getElementById('welcome-body');
    body.innerHTML = '';

    segments.forEach((seg, i) => {
        let el;
        if (seg.type === 'para') {
            el = document.createElement('p');
            el.className = 'welcome-para';
            el.innerHTML = seg.text;
            // No drop-cap on this one — it's a letter, not a chronicle entry
            el.style.cssText += 'font-size:15px;';
        } else if (seg.type === 'callout') {
            el = document.createElement('div');
            el.className = 'welcome-callout';
            el.innerHTML = seg.text;
        } else if (seg.type === 'divider') {
            el = document.createElement('div');
            el.className = 'welcome-divider';
            el.textContent = '✦  ·  ·  ·  ✦';
        } else if (seg.type === 'town') {
            el = document.createElement('div');
            el.className = 'welcome-town-line';
            el.innerHTML = `
                <div class="welcome-divider" style="opacity:0.4;margin-bottom:16px;">✦  ·  ·  ·  ✦</div>
                <div class="welcome-town-top">The letter can be re-read in your Chronicle</div>
                <div class="welcome-town-name" style="font-size:16px;letter-spacing:1px;">under "A Letter Found"</div>`;
        }
        if (el) {
            el.dataset.segIndex = i;
            body.appendChild(el);
        }
    });

    // Swap begin button text
    const btn = document.getElementById('welcome-begin-btn');
    if (btn) btn.textContent = 'Return to Town →';

    overlay.classList.add('open');
    document.body.style.overflow = 'hidden';

    // Animate in
    let delay = 200;
    const allSegs = body.querySelectorAll('[data-seg-index]');
    allSegs.forEach((el, i) => {
        setTimeout(() => {
            el.classList.add('visible');
            // Gently scroll new element into view — slow and deliberate
            el.scrollIntoView({ behavior:'smooth', block:'end' });
            if (i === allSegs.length - 1) {
                setTimeout(() => {
                    if (btn) btn.classList.add('ready');
                }, 800);
            }
        }, delay);
        // Reading pace — 2.5x longer so players finish before next arrives.
        // Short single-line paras get 6s, full paras 12.5s, callouts 17.5s.
        const text = el.textContent || '';
        const isShortLine = text.trim().length < 60;
        delay += el.classList.contains('welcome-callout') ? 17500
               : isShortLine                              ? 6000
               : 12500;
    });

    // Wire begin button for legacy flow
    if (btn) {
        btn.onclick = function() { dismissLegacyWelcome(); };
    }
}

function dismissLegacyWelcome() {
    const p = gameState.player;
    if (p) {
        p.hasSeenLegacyWelcome = true;
        // Add the letter as a permanent Chronicle entry
        injectLegacyLetterIntoChronicle(p);
        saveGame();
    }
    const overlay = document.getElementById('welcome-overlay');
    if (overlay) overlay.classList.remove('open');
    document.body.style.overflow = '';
    showTown();
}

// ── Inject a permanent Chronicle entry for the letter ─────────────────
function injectLegacyLetterIntoChronicle(p) {
    if (!p || !CHRONICLE_CONTENT) return;

    const lore   = buildLegacyLetter(p);
    const opener = lore.opener;
    const status = lore.status;
    const cross  = lore.cross;
    const closer = lore.closer;

    CHRONICLE_CONTENT['legacy_letter'] = {
        cls:   p.baseClass || p.class || 'all',
        level: 0,  // level 0 = always visible, never locked
        icon:  '📜',
        title: (n) => `A Letter Found`,
        label: 'The Keepers of the Crossroads',
        hint:  'A letter that was waiting for you.',
        body:  (n) => `
            <p style="font-size:15px;font-style:italic;">${n},</p>
            <p style="font-size:15px;">We have been watching you.</p>
            <div class="chronicle-callout">${opener}</div>
            <p style="font-size:15px;">${status}</p>
            ${cross ? `<p style="font-size:15px;">${cross}</p>` : ''}
            <div style="text-align:center;color:#5a3a18;letter-spacing:6px;margin:20px 0;font-size:14px;">✦  ·  ·  ·  ✦</div>
            <p style="font-size:15px;">${closer}</p>`,
    };

    // Add to schedule so it shows up in the Chronicle list
    if (typeof CHRONICLE_SCHEDULE !== 'undefined') {
        // Remove any existing legacy entry first
        const existingIdx = CHRONICLE_SCHEDULE.findIndex(s => s.id === 'legacy_letter');
        if (existingIdx >= 0) CHRONICLE_SCHEDULE.splice(existingIdx, 1);

        // Add at the top of the schedule
        CHRONICLE_SCHEDULE.unshift({ id:'legacy_letter', level:0, cls:'all' });
    }

    // Ensure chronicle object exists (may be absent on very old saves)
    if (!p.chronicle) p.chronicle = { unlockedEntries:[], readEntries:[] };
    if (!p.chronicle.unlockedEntries) p.chronicle.unlockedEntries = [];
    if (!p.chronicle.readEntries)     p.chronicle.readEntries     = [];

    // Mark as unlocked so it appears in the list
    if (!p.chronicle.unlockedEntries.includes('legacy_letter')) {
        p.chronicle.unlockedEntries.push('legacy_letter');
    }
    // Leave out of readEntries so the unread badge appears
}

// ── Also wire skipWelcome for legacy flow ────────────────────────────
const _origSkipWelcome = typeof skipWelcome === 'function' ? skipWelcome : null;
function skipWelcome() {
    const overlay = document.getElementById('welcome-overlay');
    if (!overlay) return;
    overlay.querySelectorAll('[data-seg-index]').forEach(el => el.classList.add('visible'));
    const btn = document.getElementById('welcome-begin-btn');
    if (btn) btn.classList.add('ready');
    const body = document.getElementById('welcome-body');
    if (body) body.scrollTo({ top: body.scrollHeight, behavior: 'smooth' });
}

// ═══════════════════════════════════════════════════════════════════════
// END LEGACY WELCOME SYSTEM
// ═══════════════════════════════════════════════════════════════════════


// ═══════════════════════════════════════════════════════════════════════
// LEVEL-UP CEREMONY + POST-COMBAT CHRONICLE CINEMATIC
// ═══════════════════════════════════════════════════════════════════════

// ── Level-up flash + announcement ─────────────────────────────────────
function showLevelUpCeremony(newLevel) {
    const p = gameState.player;

    // 1. White screen flash
    const flash = document.getElementById('levelup-flash');
    if (flash) {
        flash.style.display = 'block';
        setTimeout(() => { flash.style.display = 'none'; }, 600);
    }

    // 2. Big announcement overlay
    const announce  = document.getElementById('levelup-announce');
    const burst     = document.getElementById('levelup-burst');
    const numEl     = document.getElementById('levelup-num');
    const subEl     = document.getElementById('levelup-sub');
    if (!announce || !burst) return;

    // Subtitle varies by milestone
    let subtitle = 'The journey continues';
    if (newLevel === 5)  subtitle = 'Azrath stirs. The tremors worsen.';
    if (newLevel === 10) subtitle = 'The Crossroads draws near.';
    if (newLevel === 13) subtitle = 'New Chronicle entries await.';
    if (newLevel === 15) subtitle = 'The talismans are within reach.';
    if (newLevel === 20) subtitle = 'Class evolution unlocked.';
    if (newLevel === 23) subtitle = 'The seal is failing.';
    if (newLevel === 25) subtitle = 'You are ready. The world is waiting.';

    if (numEl) numEl.textContent = newLevel;
    if (subEl) subEl.textContent = subtitle;

    // Reset burst animation by removing and re-adding it
    burst.classList.remove('levelup-fade-out');
    burst.style.animation = 'none';
    burst.offsetHeight; // force reflow
    burst.style.animation = '';

    announce.classList.add('show');

    // Hold for 2.2s then fade out
    setTimeout(() => {
        burst.classList.add('levelup-fade-out');
        setTimeout(() => {
            announce.classList.remove('show');
        }, 650);
    }, 2200);
}

// ── Chronicle queue — entries unlocked during combat ──────────────────
// Stored here, played after the fight is fully over.
window._pendingChronicleEntries = [];

function queueChronicleEntry(id) {
    if (!window._pendingChronicleEntries.includes(id)) {
        window._pendingChronicleEntries.push(id);
    }
}

// Called by unlockChronicleEntries when new entries come in
const _origOnChronicleUnlock = typeof onChronicleUnlock === 'function' ? onChronicleUnlock : null;
function onChronicleUnlock(newIds) {
    // Queue all new entries for post-combat playback
    newIds.forEach(id => queueChronicleEntry(id));
    // Refresh badge immediately so button glows during combat
    refreshAllBadges();
}

// ── Play pending Chronicle entries after combat ends ──────────────────
function playPendingChronicleEntries() {
    if (!window._pendingChronicleEntries || window._pendingChronicleEntries.length === 0) return;

    const ids = [...window._pendingChronicleEntries];
    window._pendingChronicleEntries = [];

    // Play them one at a time, chaining through the queue
    playChronicleEntrySequence(ids, 0);
}

function playChronicleEntrySequence(ids, index) {
    if (index >= ids.length) return;

    const id  = ids[index];
    const def = CHRONICLE_CONTENT[id];
    if (!def) {
        // Skip unknown entries
        playChronicleEntrySequence(ids, index + 1);
        return;
    }

    showChronicleCinematic(id, def, () => {
        // After this entry closes, play the next one
        playChronicleEntrySequence(ids, index + 1);
    });
}

// ── Chronicle cinematic — reuses welcome-overlay parchment ────────────
function showChronicleCinematic(id, def, onClose) {
    const p = gameState.player;
    if (!p) { if (onClose) onClose(); return; }

    const overlay = document.getElementById('welcome-overlay');
    if (!overlay) { if (onClose) onClose(); return; }

    const playerName = p.name || 'Adventurer';
    const baseClass  = p.baseClass || p.class;

    // Mark as read
    markChronicleRead(id);

    // Header
    const icon = overlay.querySelector('.welcome-dragon-icon');
    if (icon) {
        icon.textContent = def.icon || '📖';
        icon.style.animation = 'none';
        icon.style.filter = 'drop-shadow(0 0 12px rgba(200,160,40,0.6))';
    }
    const titleEl = overlay.querySelector('.welcome-title');
    if (titleEl) titleEl.textContent = 'New Chronicle Entry';

    const nameEl = document.getElementById('welcome-char-name');
    if (nameEl) nameEl.textContent = def.label || 'Chronicle';

    const clsEl = document.getElementById('welcome-char-class');
    if (clsEl) clsEl.textContent = def.title ? def.title(playerName) : '';

    // Render body content as a single animated block
    const body = document.getElementById('welcome-body');
    if (!body) { if (onClose) onClose(); return; }
    body.innerHTML = '';

    // Parse the entry body HTML into paragraph segments
    const rawHtml = typeof def.body === 'function'
        ? def.body(playerName, baseClass, p.className || p.class)
        : (def.body || '');

    // Create a temp container to extract paragraphs and callouts
    const tmp = document.createElement('div');
    tmp.innerHTML = rawHtml;
    const nodes = Array.from(tmp.children);

    if (nodes.length === 0) {
        // Fallback: render as single block
        const el = document.createElement('div');
        el.className = 'welcome-para';
        el.innerHTML = rawHtml;
        el.dataset.segIndex = 0;
        body.appendChild(el);
    } else {
        nodes.forEach((node, i) => {
            const el = document.createElement(node.tagName.toLowerCase() === 'div' ? 'div' : 'p');
            el.className = node.className.includes('chronicle-callout') ? 'welcome-callout' : 'welcome-para';
            el.innerHTML = node.innerHTML;
            el.dataset.segIndex = i;
            body.appendChild(el);
        });
    }

    // Wire begin button
    const btn = document.getElementById('welcome-begin-btn');
    if (btn) {
        btn.textContent = 'Continue →';
        btn.classList.remove('ready');
        btn.onclick = function() {
            overlay.classList.remove('open');
            document.body.style.overflow = '';
            if (onClose) setTimeout(onClose, 200);
        };
    }

    // Open overlay
    overlay.classList.add('open');
    document.body.style.overflow = 'hidden';

    // Animate segments
    let delay = 400;
    const allSegs = body.querySelectorAll('[data-seg-index]');
    allSegs.forEach((el, i) => {
        setTimeout(() => {
            el.classList.add('visible');
            el.scrollIntoView({ behavior: 'smooth', block: 'end' });
            if (i === allSegs.length - 1) {
                setTimeout(() => {
                    if (btn) btn.classList.add('ready');
                }, 800);
            }
        }, delay);
        const text = el.textContent || '';
        const isShortLine = text.trim().length < 60;
        delay += el.classList.contains('welcome-callout') ? 17500
               : isShortLine                              ? 6000
               : 12500;
    });
}

// ═══════════════════════════════════════════════════════════════════════
// END LEVEL-UP CEREMONY + CHRONICLE CINEMATIC
// ═══════════════════════════════════════════════════════════════════════


// ═══════════════════════════════════════════════════════════════════════
// TOWN ARRIVAL CINEMATICS
// Fires once per character per town on their very first visit.
// Uses the same welcome-overlay parchment as the welcome screen.
// Flags saved to player object: p.hasSeenTownArrival_town2, _town3
// ═══════════════════════════════════════════════════════════════════════

const TOWN_ARRIVAL_LORE = {

    town2: {
        townName: 'Ashen Harbor',
        icon: '⚓',
        subtitle: 'The Second Town',
        segments: (p) => {
            const name  = p.name || 'Adventurer';
            const cls   = (p.baseClass || p.class || 'warrior').toLowerCase();
            const level = p.level || 1;

            // Class-specific line about what brought them here
            const CLASS_LINES = {
                warrior:     `The map your grandmother showed you — the faded one with the red ink — had a mark somewhere near this coast. You understood it when you saw the harbor's black sand.`,
                mage:        `The Academy's charts showed a ley line convergence at this latitude. Standing here, you feel it — a hum in the air that your instruments would have measured, but your bones already know.`,
                rogue:       `Three different contacts, none of whom knew about the others, all pointed here when asked where the real information was moving. They were right. The docks are loud with people who know things.`,
                ranger:      `The migration routes you tracked all bent toward this coast. The creatures weren't fleeing randomly — they were avoiding something that originates here, or passes through here, on its way somewhere worse.`,
                runesmith:   `You woke up three nights running with the same set of binding configurations in your hands. Each one a variation on a harbor seal — not a nautical seal. A containment seal. Something passed through this port.`,
                cleric:      `The silence in your prayers has a direction now. It points inland, past this harbor, toward whatever is at the center of the distortion. Ashen Harbor is not the source. It is the last place before the source.`,
                necromancer: `The dead here are not afraid. They are angry. That is unusual — fear is the dominant affect near Azrath's influence. Whatever happened in this harbor a long time ago made its ghosts defiant rather than terrified.`,
                berserker:   `Nobody in Silverdale knew what happened to villages like yours. Someone in Ashen Harbor does. You could see it in the dockmaster's eyes when you described the emptiness — recognition, and the careful look of someone deciding how much to say.`,
            };

            const classLine = CLASS_LINES[cls] || CLASS_LINES['warrior'];

            return [
                { type:'para', text:`The harbor smells of salt and ash. That is where it gets its name — not from any fire, but from the color of the sand along the waterline, grey-black and fine as powder, unlike anything in the lands around Silverdale.` },
                { type:'para', text:`You are level ${level}. You walked — or fought, or navigated — every step between there and here. That is not nothing. The road between Silverdale and Ashen Harbor is not kind to people who are not ready for it.` },
                { type:'callout', text:`${classLine}<br><br>Ashen Harbor is a harder town than Silverdale. The merchants here have seen things come through their port that Silverdale's traders would not believe. The dungeons in this region are more dangerous. The creatures are larger, angrier, displaced further from the deep places by the worsening tremors.<br><br>You are ready for them. That is why you are here.` },
                { type:'para', text:`The tremors reach this far now. You felt one on the road — a long slow roll that lasted nearly a minute, the kind that makes buildings creak and horses uneasy. The locals barely reacted. They have been living with it for months.` },
                { type:'para', text:`The Crossroads is still ahead. Ashen Harbor is a waypoint — a place to resupply, train, and grow stronger before the road leads you to where the called ones gather. The people here know what is coming. Some of them are also moving toward it.` },
                { type:'para', text:`Rest here. Learn what this town knows. The dungeons of this region will prepare you for what the Crossroads requires.<br><br>You earned every step of the road that brought you here, <span class="chronicle-name">${name}</span>. The next road begins at dawn.` },
            ];
        },
    },

    town3: {
        townName: 'The Crossroads',
        icon: '✦',
        subtitle: 'Where All Roads Converge',
        segments: (p) => {
            const name  = p.name || 'Adventurer';
            const cls   = (p.baseClass || p.class || 'warrior').toLowerCase();
            const level = p.level || 1;

            // Class-specific moment of arrival
            const CLASS_ARRIVALS = {
                warrior:     `The old man at the gate looked at you for a long moment before you said a word. Then he nodded — one single nod — like he had been waiting for exactly you, and the waiting was finally over.`,
                mage:        `The ley line convergence you charted is real and it is here. You felt it a mile out — the air pressure changed, the light shifted slightly, and your calculations were confirmed by something older and more reliable than mathematics.`,
                rogue:       `Every information network you have ever worked with had the Crossroads as a blank spot — a place people mentioned but never described. Now you understand why. Some places are not kept secret by silence. They are kept secret by the fact that you cannot explain them until you have been here.`,
                ranger:      `The wildlife is completely absent for a half-mile radius around the valley. Not hiding — absent. The Crossroads sits in a pocket of stillness that the natural world has chosen, collectively and without apparent coordination, to respect.`,
                runesmith:   `The binding configurations you have been waking up with make sense here. The valley itself is constructed — not by architecture but by ancient working. Someone rune-crafted this place into stability a thousand years ago. You can feel every seam of it.`,
                cleric:      `Your prayers are louder here. Not answered — you have learned to distinguish between proximity and response — but louder. Whatever is interfering with the connection between faith and its source has less purchase in this valley than anywhere else you have been.`,
                necromancer: `The dead here are quiet in a way that has nothing to do with emptiness. They are at peace. Every spirit in this valley has made its choice about what it is staying for, and the choice was deliberate. This is a place where purpose holds.`,
                berserker:   `Someone here knows about the emptying. You saw it in the faces when you described your village — not the careful look of someone deciding how much to say, but the open look of people who have been waiting for you to arrive so they could tell you everything.`,
            };

            const classArrival = CLASS_ARRIVALS[cls] || CLASS_ARRIVALS['warrior'];

            return [
                { type:'para', text:`You heard it before you saw it.` },
                { type:'para', text:`Voices — dozens of them, in accents you recognize and accents you do not — all arriving from different roads at the same point in the valley below. You crested the ridge and stopped. Warriors sharpening blades beside mages with open-air research stations. Rogues comparing notes with rangers. A necromancer and a cleric sitting across a fire from each other with the careful courtesy of people who disagree about everything except the one thing that brought them here.` },
                { type:'callout', text:`${classArrival}<br><br>The Crossroads is older than any nation currently on the map. Built at the end of the last cycle, it has been added to by every generation that passed through it — new buildings over old foundations, new records layered over old ones. It is a waystation, a library, a training ground, and a monument to everyone who faced the Calamity and kept the world going.` },
                { type:'para', text:`You are level ${level}. The journey from Silverdale to here is not supposed to be easy, and for you it was not. Every dungeon you survived, every fight that should have ended differently and did not — all of it is why you are standing here now instead of someone who was not ready.` },
                { type:'para', text:`The four elemental dungeons begin here. Wind, Fire, Earth, Water — each one holding a talisman that Brennan placed there a thousand years ago as insurance against the day the seal failed. They are waiting for people strong enough and purposeful enough to claim them.` },
                { type:'callout', text:`The old records in the Crossroads library describe the talismans as tests — not of combat, but of character. What you believe, why you are fighting, who you have become across every level of the road that led you here. The dungeons read all of that and decide whether you are ready.<br><br>You are nearly ready. The Crossroads exists to make you the rest of the way.` },
                { type:'para', text:`Train here. Use the library. Talk to the people around these fires — every one of them arrived by a different road and knows things that you do not.<br><br>Welcome to the Crossroads, <span class="chronicle-name">${name}</span>.<br>Brennan built this place for you.` },
            ];
        },
    },
};

// ── Check and show town arrival cinematic ─────────────────────────────
function maybeShowTownArrivalCinematic(townId) {
    const p = gameState.player;
    if (!p) return;

    const flagKey = `hasSeenTownArrival_${townId}`;
    if (p[flagKey]) return;  // already seen it

    const lore = TOWN_ARRIVAL_LORE[townId];
    if (!lore) return;  // no lore for this town

    // Mark as seen and save immediately
    p[flagKey] = true;
    saveGame();

    // Small delay so the town screen renders first
    setTimeout(() => showTownArrivalCinematic(lore, p), 600);
}

function showTownArrivalCinematic(lore, p) {
    const overlay = document.getElementById('welcome-overlay');
    if (!overlay) return;

    // Header
    const icon = overlay.querySelector('.welcome-dragon-icon');
    if (icon) {
        icon.textContent = lore.icon;
        icon.style.animation = 'none';
        icon.style.filter = 'drop-shadow(0 0 12px rgba(200,160,40,0.5))';
    }
    const titleEl = overlay.querySelector('.welcome-title');
    if (titleEl) titleEl.textContent = lore.subtitle;

    const nameEl = document.getElementById('welcome-char-name');
    if (nameEl) nameEl.textContent = lore.townName;

    const clsEl = document.getElementById('welcome-char-class');
    if (clsEl) clsEl.textContent = `Level ${p.level} · ${p.className || p.class || ''}`;

    // Build segments
    const segments = lore.segments(p);

    const body = document.getElementById('welcome-body');
    if (!body) return;
    body.innerHTML = '';

    segments.forEach((seg, i) => {
        let el;
        if (seg.type === 'callout') {
            el = document.createElement('div');
            el.className = 'welcome-callout';
        } else {
            el = document.createElement('p');
            el.className = 'welcome-para';
        }
        el.innerHTML = seg.text;
        el.dataset.segIndex = i;
        body.appendChild(el);
    });

    // Wire the button
    const btn = document.getElementById('welcome-begin-btn');
    if (btn) {
        btn.textContent = `Enter ${lore.townName} →`;
        btn.classList.remove('ready');
        btn.onclick = function() {
            overlay.classList.remove('open');
            document.body.style.overflow = '';
        };
    }

    overlay.classList.add('open');
    document.body.style.overflow = 'hidden';

    // Animate in — same reading pace as welcome screen
    let delay = 400;
    const allSegs = body.querySelectorAll('[data-seg-index]');
    allSegs.forEach((el, i) => {
        setTimeout(() => {
            el.classList.add('visible');
            el.scrollIntoView({ behavior: 'smooth', block: 'end' });
            if (i === allSegs.length - 1) {
                setTimeout(() => { if (btn) btn.classList.add('ready'); }, 800);
            }
        }, delay);
        const text = el.textContent || '';
        const isShort = text.trim().length < 60;
        delay += el.classList.contains('welcome-callout') ? 17500
               : isShort                                  ? 6000
               : 12500;
    });
}

// ═══════════════════════════════════════════════════════════════════════
// END TOWN ARRIVAL CINEMATICS
// ═══════════════════════════════════════════════════════════════════════

function saveGame() {
    try {
        const snapshot = buildSaveSnapshot();
        if (!snapshot) return;

        const key = `dq_save_${snapshot.characterId}`;
        localStorage.setItem(key, JSON.stringify(snapshot));
        
        // Also update character list
        updateCharacterList(snapshot);

        console.log(`✅ Game saved: ${snapshot.characterName} (${snapshot.lastSaved})`);
        
        // Show brief save confirmation
        const hud = document.getElementById('hud');
        if (hud && hud.style.display !== 'none') {
            const saveMsg = document.createElement('div');
            saveMsg.style.cssText = 'position:fixed;top:10px;right:10px;background:#0a0a0a;border:2px solid var(--text-color);padding:8px 12px;color:var(--text-color);font-size:14px;z-index:9999;';
            saveMsg.textContent = '💾 Game Saved';
            document.body.appendChild(saveMsg);
            setTimeout(() => saveMsg.remove(), 2000);
        }
    } catch (e) {
        console.error('Error saving game:', e);
    }
}

function updateCharacterList(snapshot) {
    try {
        let charList = JSON.parse(localStorage.getItem('dq_character_list') || '[]');
        
        // Remove old entry for this character if exists
        charList = charList.filter(c => c.id !== snapshot.characterId);
        
        // Add new entry
        charList.push({
            id: snapshot.characterId,
            name: snapshot.characterName,
            level: snapshot.player.level,
            class: snapshot.player.class,
            timestamp: snapshot.timestamp,
            lastSaved: snapshot.lastSaved
        });
        
        // Sort by most recent
        charList.sort((a, b) => b.timestamp - a.timestamp);
        
        localStorage.setItem('dq_character_list', JSON.stringify(charList));
    } catch (e) {
        console.error('Error updating character list:', e);
    }
}

function getAllCharacters() {
    try {
        return JSON.parse(localStorage.getItem('dq_character_list') || '[]');
    } catch (e) {
        console.error('Error getting character list:', e);
        return [];
    }
}

function deleteCharacter(characterId) {
    try {
        // Remove save data
        localStorage.removeItem(`dq_save_${characterId}`);
        
        // Remove from character list
        let charList = getAllCharacters();
        charList = charList.filter(c => c.id !== characterId);
        localStorage.setItem('dq_character_list', JSON.stringify(charList));
        
        console.log(`🗑️ Deleted character: ${characterId}`);
        return true;
    } catch (e) {
        console.error('Error deleting character:', e);
        return false;
    }
}

// Auto-save on page unload
window.addEventListener('beforeunload', () => {
    saveGame();
});



        function toggleTerminal() {
            const terminal = document.getElementById('terminalContainer');
            const input = document.getElementById('terminalInput');
            
            gameState.sysop.terminalActive = !gameState.sysop.terminalActive;
            
            if (gameState.sysop.terminalActive) {
                terminal.classList.add('active');
                input.focus();
                if (!gameState.sysop.authenticated) {
                    terminalPrint('Terminal activated. Type /login <username> <password> to authenticate.', 'warning');
                }
            } else {
                terminal.classList.remove('active');
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // 🎒 INVENTORY BUTTON LONG-PRESS → SYSOP (3 seconds)
        // Works in both dungeon action bar and town menu
        // ═══════════════════════════════════════════════════════════════
        let _invMenuHoldTimer = null, _invMenuFired = false;
        function _invMenuDown(e) {
            if (e.cancelable) e.preventDefault();
            _invMenuFired = false;
            _invMenuHoldTimer = setTimeout(() => {
                _invMenuHoldTimer = null;
                _invMenuFired = true;
                openSysopOverlay();
            }, POT_HOLD_MS);
        }
        function _invMenuUp() {
            if (_invMenuHoldTimer) { clearTimeout(_invMenuHoldTimer); _invMenuHoldTimer = null; }
            if (!_invMenuFired) showInventory();
            _invMenuFired = false;
        }
        function _invMenuCancel() {
            if (_invMenuHoldTimer) { clearTimeout(_invMenuHoldTimer); _invMenuHoldTimer = null; }
            _invMenuFired = false;
        }
        let _potHoldTimer  = null;
        let _potFired      = false;
        const POT_HOLD_MS  = 3000;

        function potBtnDown(e, normalFn) {
            e.preventDefault();
            _potFired = false;
            _potHoldTimer = setTimeout(() => {
                _potHoldTimer = null;
                _potFired     = true;
                openSysopOverlay();
            }, POT_HOLD_MS);
        }
        function potBtnUp(e, normalFn) {
            if (_potHoldTimer) {
                clearTimeout(_potHoldTimer);
                _potHoldTimer = null;
            }
            if (!_potFired) {
                // Normal short tap — call the potion menu
                if (typeof window[normalFn] === 'function') window[normalFn]();
            }
            _potFired = false;
        }
        function potBtnCancel() {
            if (_potHoldTimer) { clearTimeout(_potHoldTimer); _potHoldTimer = null; }
            _potFired = false;
        }

        // ═══════════════════════════════════════════════════════════════
        // 📊 PRINT STATS TO TERMINAL
        // ═══════════════════════════════════════════════════════════════
        function printStatsToTerminal() {
            const p = gameState.player;
            if (!p) { termAppend('No character loaded.', 'term-error'); return; }
            termAppend('', 'term-separator');
            termAppend(`📊 <span style="color:var(--highlight-color);">${p.name}${getRunestonePip(p)}</span> · Lv ${p.level} ${p.className}`, 'term-highlight');
            termAppend(`❤️ HP: <span style="color:#ff6666;">${p.hp}/${p.maxHp}</span>  ✨ MP: <span style="color:#4488ff;">${p.mp}/${p.maxMp}</span>`);
            termAppend(`⭐ XP: ${p.xp}/${p.xpToNext}  💰 Gold: ${p.gold}g`);
            termAppend(`STR:${p.str} DEX:${p.dex} CON:${p.con} WIS:${p.wis} CHA:${p.cha} LCK:${p.lck}`, 'term-dim');
            termAppend('', 'term-separator');
        }

        // ═══════════════════════════════════════════════════════════════
        // ── Quit to menu ─────────────────────────────────────────────
        function confirmQuitToMenu() {
            if (confirm('Quit to main menu?\nUnsaved progress will be lost.')) {
                stopAllRegen();
                if (gameState.combatTimer) {
                    clearInterval(gameState.combatTimer);
                    gameState.combatTimer = null;
                }
                gameState.combatState = null;
                gameState.dungeon     = null;
                document.body.classList.remove('terminal-mode');
                showMainMenu();
            }
        }

        // ── SYSOP overlay open / close ────────────────────────────────
        function openSysopOverlay() {
            document.getElementById('sysopOverlay').classList.add('open');
            renderSysopOverlay();
        }
        function closeSysopOverlay() {
            document.getElementById('sysopOverlay').classList.remove('open');
        }

        // ── Output log (shared with desktop terminal) ─────────────────
        window._sysoLog = [];
        function sysoLog(msg, type = 'normal') {
            const colors = { normal:'#00FF41', error:'#ff4444', success:'#88ff88', warning:'#ff8c00' };
            window._sysoLog.push({ msg, color: colors[type] || '#00FF41' });
            if (window._sysoLog.length > 50) window._sysoLog.shift();
            terminalPrint(msg, type);   // mirror to desktop terminal
            _refreshSysoLog();
        }
        function _refreshSysoLog() {
            const el = document.getElementById('sysoLog');
            if (!el) return;
            el.innerHTML = window._sysoLog.slice(-25).map(e =>
                `<div style="color:${e.color};">${e.msg.replace(/</g,'&lt;')}</div>`
            ).join('');
            el.scrollTop = el.scrollHeight;
        }
        // Wrap executeCommand to capture output into sysoLog
        function sysoExec(cmd) {
            sysoLog(`> ${cmd}`);
            executeCommand(cmd);
            setTimeout(_refreshSysoLog, 100);
        }

        // ── Main overlay renderer ─────────────────────────────────────
        function renderSysopOverlay() {
            const content = document.getElementById('sysopOverlayContent');
            const auth = gameState.sysop.authenticated;
            let html = `<div class="syo-log" id="sysoLog"></div>`;

            if (!auth) {
                // LOGIN SCREEN
                html += `
                <div class="syo-login-art">
╔══════════════════════╗<br>
║   SYSOP  TERMINAL    ║<br>
║   AUTHENTICATION     ║<br>
╚══════════════════════╝
                </div>
                <div class="syo-section">
                    <div class="syo-label">USERNAME</div>
                    <input class="syo-input" id="sysoUser" placeholder="sysop" autocomplete="off" autocorrect="off" spellcheck="false">
                    <div class="syo-label">PASSWORD</div>
                    <input class="syo-input" id="sysoPass" type="password" placeholder="••••••••" autocomplete="off">
                    <div id="sysoLoginErr" style="display:none;color:#ff4444;font-family:'VT323',monospace;font-size:18px;margin:4px 0 8px;"></div>
                    <div class="syo-grid" style="margin-top:8px;">
                        <button class="syo-btn full" style="border-color:#00FF41;color:#00FF41;font-size:22px;padding:14px;"
                            onclick="sysoLogin()">⚡ LOGIN</button>
                    </div>
                </div>`;
            } else {
                // COMMAND GRID
                const isGod = gameState.player?._godMode;
                html += `
                <div class="syo-section">
                    <div class="syo-section-title">⌨️ COMMAND</div>
                    <div style="display:flex;gap:6px;">
                        <input class="syo-input" id="sysocmdInput" placeholder="/help — type a command..." 
                            autocomplete="off" autocorrect="off" spellcheck="false" style="margin-bottom:0;font-size:18px;"
                            oninput="_sysoLiveHelp(this.value)"
                            onkeydown="if(event.key==='Enter'){const v=this.value.trim();if(v){sysoExec(v);this.value='';_sysoLiveHelp('');}}">
                        <button class="syo-btn" style="white-space:nowrap;padding:6px 10px;"
                            onclick="(function(){const v=document.getElementById('sysocmdInput')?.value?.trim();if(v){sysoExec(v);document.getElementById('sysocmdInput').value='';_sysoLiveHelp('');}})()">▶ RUN</button>
                    </div>
                    <div id="sysoCmdHints" style="font-family:'VT323',monospace;font-size:14px;color:#3a6a3a;padding:3px 4px 0;min-height:16px;"></div>
                </div>
                <div class="syo-section">
                    <div class="syo-section-title">👤 PLAYER</div>
                    <div class="syo-grid">
                        <button class="syo-btn" onclick="sysoExec('/heal');_refreshSysoLog();">❤️ FULL HEAL</button>
                        <button class="syo-btn ${isGod?'orange':''}" onclick="sysoShowGodmode()">⚡ GOD MODE ${isGod?'[ON]':'[OFF]'}</button>
                        <button class="syo-btn" onclick="sysoShowSub('level')">📈 SET LEVEL</button>
                        <button class="syo-btn" onclick="sysoShowSub('gold')">💰 SET GOLD</button>
                    </div>
                </div>

                <div class="syo-section">
                    <div class="syo-section-title">🎁 GIVE</div>
                    <div class="syo-grid cols3">
                        <button class="syo-btn" onclick="sysoShowGive('weapon')">⚔️<br>Weapon</button>
                        <button class="syo-btn" onclick="sysoShowGive('armor')">🛡️<br>Armor</button>
                        <button class="syo-btn" onclick="sysoShowGive('item')">🧪<br>Item</button>
                        <button class="syo-btn" onclick="sysoShowGive('spell')">🔮<br>Spell</button>
                    </div>
                </div>

                <div class="syo-section">
                    <div class="syo-section-title">📋 LISTS</div>
                    <div class="syo-grid">
                        <button class="syo-btn" onclick="_sysoShowListPanel('weapons')">⚔️ Weapons</button>
                        <button class="syo-btn" onclick="_sysoShowListPanel('armor')">🛡️ Armor</button>
                        <button class="syo-btn" onclick="_sysoShowListPanel('monsters')">👹 Monsters</button>
                        <button class="syo-btn" onclick="_sysoShowListPanel('items')">🎒 Items</button>
                    </div>
                </div>

                <div class="syo-section">
                    <div class="syo-section-title">🏰 DUNGEON</div>
                    <div class="syo-grid">
                        <button class="syo-btn orange" onclick="sysoExec('/killmonster')">💀 Kill Enemy</button>
                        <button class="syo-btn" onclick="sysoShowSub('teleport')">🚀 Teleport</button>
                    </div>
                </div>

                <div class="syo-section">
                    <div class="syo-section-title">🛠️ SYSTEM</div>
                    <div class="syo-grid">
                        <button class="syo-btn" onclick="window._sysoLog=[];clearTerminal();_refreshSysoLog();">🧹 Clear Log</button>
                        <button class="syo-btn" onclick="sysoShowSub('export')">📤 Export</button>
                        <button class="syo-btn" onclick="sysoExec('/help')">❓ Help</button>
                        <button class="syo-btn red" onclick="sysoLogout()">🔒 Logout</button>
                    </div>
                </div>

                <div id="sysoSub"></div>`;
            }

            content.innerHTML = html;
            _refreshSysoLog();
        }

        // ── Login / Logout ────────────────────────────────────────────
        function sysoLogin() {
            const u = (document.getElementById('sysoUser')?.value || '').trim();
            const p = (document.getElementById('sysoPass')?.value || '').trim();
            _checkCredentials(u, p).then(valid => {
                if (valid) {
                    gameState.sysop.authenticated = true;
                    gameState.sysop.username = atob(_SYS.u);
                    document.getElementById('sysopBadge')?.classList.add('active');
                    sysoLog('Authentication successful. Welcome, ' + atob(_SYS.u));
                    renderSysopOverlay();
                } else {
                    const errEl = document.getElementById('sysoLoginErr');
                    if (errEl) {
                        errEl.textContent = '✗ Invalid credentials';
                        errEl.style.display = 'block';
                    }
                    sysoLog('Authentication failed.', 'error');
                }
            });
        }
        function sysoLogout() {
            handleLogout();
            renderSysopOverlay();
        }

        // ── Godmode sub-panel ─────────────────────────────────────────
        function sysoShowGodmode() {
            document.getElementById('sysoSub').innerHTML = `
            <div class="syo-sub">
                <div class="syo-sub-title">⚡ GOD MODE</div>
                <div class="syo-grid">
                    <button class="syo-btn" style="border-color:#00FF41;color:#00FF41;"
                        onclick="sysoExec('/godmode on');renderSysopOverlay();">⚡ ON</button>
                    <button class="syo-btn red"
                        onclick="sysoExec('/godmode off');renderSysopOverlay();">⛔ OFF</button>
                </div>
            </div>`;
        }

        // ── Generic sub-panel dispatcher ─────────────────────────────
        function sysoShowSub(type) {
            const sub = document.getElementById('sysoSub');
            if (!sub) return;

            if (type === 'level') {
                sub.innerHTML = `
                <div class="syo-sub">
                    <div class="syo-sub-title">📈 SET LEVEL (1–25)</div>
                    <input class="syo-input" id="sysoLvl" type="number" min="1" max="25"
                        inputmode="numeric" placeholder="e.g. 10">
                    <button class="syo-btn full" style="margin-top:4px;"
                        onclick="sysoExec('/setlevel '+document.getElementById('sysoLvl').value.trim());">✔ CONFIRM</button>
                </div>`;
                setTimeout(() => document.getElementById('sysoLvl')?.focus(), 50);
            }

            else if (type === 'gold') {
                sub.innerHTML = `
                <div class="syo-sub">
                    <div class="syo-sub-title">💰 SET GOLD</div>
                    <input class="syo-input" id="sysoGold" type="number" min="0"
                        inputmode="numeric" placeholder="e.g. 9999">
                    <button class="syo-btn full" style="margin-top:4px;"
                        onclick="sysoExec('/setgold '+document.getElementById('sysoGold').value.trim());">✔ CONFIRM</button>
                </div>`;
                setTimeout(() => document.getElementById('sysoGold')?.focus(), 50);
            }

            else if (type === 'teleport') {
                // List available dungeons for the dropdown
                const dungeonOptions = (typeof DUNGEONS !== 'undefined')
                    ? Object.keys(DUNGEONS).map(k => `<option value="${k}">${k}</option>`).join('')
                    : '<option value="Dungeon1">Dungeon1</option>';

                sub.innerHTML = `
                <div class="syo-sub">
                    <div class="syo-sub-title">🚀 TELEPORT</div>
                    <div class="syo-grid" style="margin-bottom:8px;">
                        <button class="syo-btn" onclick="sysoExec('/teleport town1')">🏘 Silverdale</button>
                        <button class="syo-btn" onclick="sysoExec('/teleport town2')">🌋 Ashen Harbor</button>
                        <button class="syo-btn" onclick="sysoExec('/teleport town3')">🏙 Town 3</button>
                    </div>
                    <div class="syo-label">Dungeon</div>
                    <select class="syo-input" id="sysoTpDungeon" style="font-size:18px;padding:6px;">
                        ${dungeonOptions}
                    </select>
                    <div class="syo-label">Floor (e.g. 1, 2, 3)</div>
                    <input class="syo-input" id="sysoTpF" type="number" min="1" inputmode="numeric" value="1">
                    <div class="syo-label">Room ID (e.g. R1, R57) — leave blank for floor start</div>
                    <input class="syo-input" id="sysoTpR" placeholder="R1" autocorrect="off" spellcheck="false"
                           style="text-transform:uppercase;">
                    <button class="syo-btn full" style="margin-top:8px;"
                        onclick="(function(){
                            const d=document.getElementById('sysoTpDungeon').value.trim();
                            const f=document.getElementById('sysoTpF').value.trim();
                            const r=document.getElementById('sysoTpR').value.trim();
                            const cmd='/teleport '+d+' f'+f+(r?' '+r.toUpperCase():'');
                            sysoExec(cmd);
                        })();">🚀 GO</button>
                </div>`;
            }

            else if (type === 'export') {
                sub.innerHTML = `
                <div class="syo-sub">
                    <div class="syo-sub-title">📤 EXPORT</div>
                    <div class="syo-grid">
                        <button class="syo-btn" onclick="sysoExec('/export save');">💾 Save File</button>
                        <button class="syo-btn" onclick="sysoExec('/export stats');">📊 Stats</button>
                    </div>
                </div>`;
            }

            sub.scrollIntoView({ behavior:'smooth', block:'nearest' });
        }

        // ── Give item sub-panel ───────────────────────────────────────
        function sysoShowGive(type) {
            if (!document.getElementById('sysopOverlay')?.classList.contains('open')) {
                openSysopOverlay();
            }
            let sub = document.getElementById('sysoSub');
            if (!sub) {
                setTimeout(() => sysoShowGive(type), 80);
                return;
            }

            let allKeys = [];
            if (type === 'weapon') allKeys = Object.keys(WEAPONS).filter(k => !WEAPONS[k].unarmed && !WEAPONS[k].isDropped);
            else if (type === 'armor')  allKeys = Object.keys(ARMOR).filter(k => !ARMOR[k].unarmored && !ARMOR[k].isDropped);
            else if (type === 'item')   allKeys = typeof ITEMS  !== 'undefined' ? Object.keys(ITEMS)  : [];
            else if (type === 'spell')  allKeys = typeof SPELLS !== 'undefined' ? Object.keys(SPELLS) : [];

            const needsQuality = type === 'weapon' || type === 'armor';
            const qualities = ['poor','normal','rare','epic','legendary','godly'];
            const db = type==='weapon' ? WEAPONS : type==='armor' ? ARMOR : type==='item' ? ITEMS : SPELLS;

            // Store for autocomplete handler
            window._sysoGiveKeys = allKeys;
            window._sysoGiveDb = db;

            const qualityHtml = needsQuality ? `
                <div class="syo-label">Quality</div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:4px;margin-bottom:6px;">
                    ${qualities.map(q => `<button class="syo-btn" id="sysoGiveQ_${q}"
                        onclick="window._sysoGiveQuality='${q}';document.querySelectorAll('[id^=sysoGiveQ_]').forEach(b=>b.style.borderColor='');this.style.borderColor='#00FF41';"
                        style="${q==='normal'?'border-color:#00FF41;':''}">${q}</button>`).join('')}
                </div>` : '';

            sub.innerHTML = `
            <div class="syo-sub">
                <div class="syo-sub-title">🎁 GIVE ${type.toUpperCase()}</div>
                <div class="syo-label">Search (type to filter)</div>
                <input class="syo-input" id="sysoGiveSearch" placeholder="Type name or key..."
                    autocorrect="off" spellcheck="false"
                    oninput="(function(v){
                        const q=v.toLowerCase();
                        const keys=window._sysoGiveKeys||[];
                        const db=window._sysoGiveDb||{};
                        const matches=keys.filter(k=>!q||k.toLowerCase().includes(q)||(db[k]?.name||'').toLowerCase().includes(q));
                        const sel=document.getElementById('sysoGiveId');
                        if(!sel) return;
                        sel.innerHTML=matches.length===0
                            ? '<option value=\"\">No matches</option>'
                            : matches.map(k=>'<option value=\"'+k+'\">'+(db[k]?.name||k)+' ['+k+']</option>').join('');
                        document.getElementById('sysoGiveCount').textContent=matches.length+' / '+keys.length;
                    })(this.value)">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                    <div class="syo-label">Select</div>
                    <span id="sysoGiveCount" style="color:#5a8a5a;font-family:'VT323',monospace;font-size:13px;">${allKeys.length} / ${allKeys.length}</span>
                </div>
                <select class="syo-input" id="sysoGiveId" size="6" style="height:auto;">
                    ${allKeys.map(k => `<option value="${k}">${db[k]?.name||k} [${k}]</option>`).join('')}
                </select>
                ${qualityHtml}
                <button class="syo-btn full" style="margin-top:6px;" onclick="sysoExecGive('${type}');">✔ GIVE</button>
            </div>`;

            // Default quality
            window._sysoGiveQuality = 'normal';

            sub.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            setTimeout(() => document.getElementById('sysoGiveSearch')?.focus(), 100);
        }

        function sysoExecGive(type) {
            const id  = document.getElementById('sysoGiveId')?.value;
            if (!id) { sysoLog('No item selected', 'error'); return; }
            const needsQuality = type === 'weapon' || type === 'armor';
            const q = needsQuality ? (window._sysoGiveQuality || 'normal') : '';
            const cmd = q ? `/give ${type} ${id} ${q}` : `/give ${type} ${id}`;
            sysoExec(cmd);
        }

        // ── Live command help / autocomplete ─────────────────────────
        function _sysoLiveHelp(raw) {
            const hintsEl = document.getElementById('sysoCmdHints');
            if (!hintsEl) return;

            const input = raw.trim().toLowerCase();
            if (!input) { hintsEl.innerHTML = ''; return; }

            // ── All available commands with signatures ────────────────
            const COMMANDS = [
                { cmd: '/help',           sig: '',                            desc: 'Show all commands' },
                { cmd: '/heal',           sig: '',                            desc: 'Full heal player' },
                { cmd: '/godmode',        sig: 'on|off',                      desc: 'Toggle god mode' },
                { cmd: '/setlevel',       sig: '<1-25>',                      desc: 'Set player level' },
                { cmd: '/setgold',        sig: '<amount>',                    desc: 'Set gold amount' },
                { cmd: '/give',           sig: 'weapon|armor|item|spell <id> [quality]', desc: 'Give item to player' },
                { cmd: '/giveweapon',     sig: '<id> [quality]',              desc: 'Give weapon — type name to search' },
                { cmd: '/givearmor',      sig: '<id> [quality]',              desc: 'Give armor — type name to search' },
                { cmd: '/giveitem',       sig: '<id>',                        desc: 'Give item — type name to search' },
                { cmd: '/givespell',      sig: '<id>',                        desc: 'Give spell — type name to search' },
                { cmd: '/listweapons',    sig: '',                            desc: 'Browse all weapons' },
                { cmd: '/listarmor',      sig: '',                            desc: 'Browse all armor' },
                { cmd: '/listitems',      sig: '',                            desc: 'Browse all items' },
                { cmd: '/listmonsters',   sig: '',                            desc: 'Browse all monsters' },
                { cmd: '/teleport',       sig: 'town1|town2|town3|<dungeon> [fN] [roomId]', desc: 'Teleport anywhere' },
                { cmd: '/killmonster',    sig: '',                            desc: 'Kill current enemy' },
                { cmd: '/revealmap',      sig: '[dungeonKey]',                desc: 'Reveal dungeon map' },
                { cmd: '/unlockmaster',   sig: '<masterId>',                  desc: 'Unlock class master' },
                { cmd: '/export',         sig: 'save|stats',                  desc: 'Export data' },
            ];

            const parts = input.split(/\s+/);
            const cmdPart = parts[0];
            const argPart = parts.slice(1).join(' ');

            // ── If first token matches a full command, show arg hints ──
            const exact = COMMANDS.find(c => c.cmd === cmdPart);
            if (exact) {
                let extraHints = '';

                // Context-aware arg autocomplete
                if ((cmdPart === '/giveweapon' || cmdPart === '/give weapon') && argPart) {
                    const q = argPart.split(' ')[0].toLowerCase();
                    const matches = Object.keys(WEAPONS).filter(k => !WEAPONS[k].unarmed && !WEAPONS[k].isDropped &&
                        (k.includes(q) || (WEAPONS[k].name||'').toLowerCase().includes(q))).slice(0,5);
                    if (matches.length) extraHints = ' → ' + matches.map(k=>`<span style="color:#00FF41;cursor:pointer;" onclick="document.getElementById('sysocmdInput').value='/give weapon ${k} normal';_sysoLiveHelp('/give weapon ${k} normal');">${k}</span>`).join('  ');
                } else if ((cmdPart === '/givearmor' || cmdPart === '/give armor') && argPart) {
                    const q = argPart.split(' ')[0].toLowerCase();
                    const matches = Object.keys(ARMOR).filter(k => !ARMOR[k].unarmored && !ARMOR[k].isDropped &&
                        (k.includes(q) || (ARMOR[k].name||'').toLowerCase().includes(q))).slice(0,5);
                    if (matches.length) extraHints = ' → ' + matches.map(k=>`<span style="color:#00FF41;cursor:pointer;" onclick="document.getElementById('sysocmdInput').value='/give armor ${k} normal';_sysoLiveHelp('/give armor ${k} normal');">${k}</span>`).join('  ');
                } else if ((cmdPart === '/giveitem' || cmdPart === '/give item') && argPart) {
                    const q = argPart.split(' ')[0].toLowerCase();
                    const matches = Object.keys(ITEMS||{}).filter(k => k.includes(q) || (ITEMS[k].name||'').toLowerCase().includes(q)).slice(0,5);
                    if (matches.length) extraHints = ' → ' + matches.map(k=>`<span style="color:#00FF41;cursor:pointer;" onclick="document.getElementById('sysocmdInput').value='/give item ${k}';_sysoLiveHelp('/give item ${k}');">${k}</span>`).join('  ');
                } else if (cmdPart === '/teleport' && argPart) {
                    const q = argPart.toLowerCase();
                    const towns = ['town1','town2','town3'].filter(t => t.includes(q));
                    const dungeons = typeof DUNGEONS !== 'undefined' ? Object.keys(DUNGEONS).filter(k => k.toLowerCase().includes(q)) : [];
                    const all = [...towns, ...dungeons].slice(0, 6);
                    if (all.length) extraHints = ' → ' + all.map(d=>`<span style="color:#00FF41;cursor:pointer;" onclick="document.getElementById('sysocmdInput').value='/teleport ${d}';_sysoLiveHelp('/teleport ${d}');">${d}</span>`).join('  ');
                } else if (cmdPart === '/setlevel' && argPart) {
                    const lvl = parseInt(argPart);
                    if (!isNaN(lvl)) extraHints = lvl < 1 || lvl > 25 ? ' <span style="color:#ff4444;">⚠ Level must be 1–25</span>' : ` <span style="color:#00FF41;">→ Set level to ${lvl}</span>`;
                }

                hintsEl.innerHTML = `<span style="color:#ff8c00;">${exact.cmd}</span> <span style="color:#5a8a5a;">${exact.sig}</span>  <span style="color:#3a6a3a;">${exact.desc}</span>${extraHints}`;
                return;
            }

            // ── Partial match — show suggestions ──────────────────────
            const suggestions = COMMANDS.filter(c => c.cmd.startsWith(cmdPart) || c.cmd.includes(cmdPart)).slice(0, 6);
            if (suggestions.length === 0) {
                hintsEl.innerHTML = `<span style="color:#ff4444;">Unknown command. Try /help</span>`;
                return;
            }
            hintsEl.innerHTML = suggestions.map(c =>
                `<span style="color:#ff8c00;cursor:pointer;" onclick="document.getElementById('sysocmdInput').value='${c.cmd} ';document.getElementById('sysocmdInput').focus();_sysoLiveHelp('${c.cmd} ');">${c.cmd}</span> <span style="color:#3a6a3a;">${c.desc}</span>`
            ).join('  <span style="color:#1a3a1a;">|</span>  ');
        }
        function toggleMobileSysop()   { openSysopOverlay(); }
        function renderMobileSysop()   { renderSysopOverlay(); }
        function msysopLog(msg, type)  { sysoLog(msg, type); }
        function refreshMsysopOutput() { _refreshSysoLog(); }

        function terminalPrint(message, type = 'normal') {
            const output = document.getElementById('terminalOutput');
            const line = document.createElement('div');
            line.className = `terminal-line ${type === 'error' ? 'terminal-error' : ''} ${type === 'success' ? 'terminal-success' : ''} ${type === 'warning' ? 'terminal-warning' : ''}`;
            line.textContent = message;
            output.appendChild(line);
            
            // Auto-scroll to bottom
            output.scrollTop = output.scrollHeight;
        }

        function clearTerminal() {
            document.getElementById('terminalOutput').innerHTML = '';
        }

        // Terminal input handler
        // ── Detect touch/mobile device ────────────────────────────────
        const _isMobile = () => navigator.maxTouchPoints > 0 || /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);

        // ── Terminal command history ──────────────────────────────────
        let _termHistIdx = -1;

        // ── Inline hint engine (PC only) ──────────────────────────────
        function _termHint(raw) {
            const hintsEl = document.getElementById('termHints');
            if (!hintsEl || _isMobile()) { if (hintsEl) hintsEl.style.display = 'none'; return; }

            const input = raw.trim();
            if (!input || !input.startsWith('/')) { hintsEl.style.display = 'none'; return; }

            const parts  = input.split(/\s+/);
            const cmd    = parts[0].toLowerCase();
            const args   = parts.slice(1);
            const argStr = args.join(' ').toLowerCase();

            const CMDS = [
                { c:'/help',          s:'',                                   d:'List all commands' },
                { c:'/heal',          s:'',                                   d:'Full heal player' },
                { c:'/godmode',       s:'on | off',                           d:'Toggle god mode' },
                { c:'/setlevel',      s:'<1–25>',                             d:'Set player level' },
                { c:'/setgold',       s:'<amount>',                           d:'Set gold' },
                { c:'/give',          s:'weapon|armor|item|spell <id> [quality]', d:'Give item' },
                { c:'/listweapons',   s:'',                                   d:'List all weapons' },
                { c:'/listarmor',     s:'',                                   d:'List all armor' },
                { c:'/listitems',     s:'',                                   d:'List all items' },
                { c:'/listmonsters',  s:'',                                   d:'List all monsters' },
                { c:'/teleport',      s:'town1|town2|town3|<dungeon> [fN] [roomId]', d:'Teleport anywhere' },
                { c:'/killmonster',   s:'',                                   d:'Kill current enemy' },
                { c:'/revealmap',     s:'[dungeonKey]',                       d:'Reveal dungeon map' },
                { c:'/unlockmaster',  s:'<masterId>',                         d:'Unlock class master' },
                { c:'/export',        s:'save | stats',                       d:'Export data' },
                { c:'/clear',         s:'',                                   d:'Clear terminal' },
                { c:'/logout',        s:'',                                   d:'Logout of sysop' },
            ];

            let html = '';

            // ── Exact command match — show arg hints + live suggestions ──
            const exact = CMDS.find(x => x.c === cmd);
            if (exact) {
                html += `<span style="color:#ff8c00;">${exact.c}</span> <span style="color:#5a8a5a;">${exact.s}</span>  <span style="color:#3a6a3a;">${exact.d}</span>`;

                // Arg-level autocomplete
                const q = (args[0] || '').toLowerCase();
                let suggestions = [];

                if (cmd === '/give') {
                    const sub = (args[0]||'').toLowerCase();
                    const id  = (args[1]||'').toLowerCase();
                    const qual= (args[2]||'').toLowerCase();
                    if (!sub || ['weapon','armor','item','spell'].some(x=>x.startsWith(sub) && x!==sub)) {
                        suggestions = ['weapon','armor','item','spell'].filter(x=>x.startsWith(sub));
                        html += _hintRow('Subtype:', suggestions, s => `/give ${s} `);
                    } else if (sub === 'weapon' && id !== undefined) {
                        const db = Object.keys(WEAPONS).filter(k=>!WEAPONS[k].unarmed && !WEAPONS[k].isDropped);
                        suggestions = db.filter(k=>k.includes(id)||(WEAPONS[k].name||'').toLowerCase().includes(id)).slice(0,5);
                        if (suggestions.length) html += _hintRow('Weapons:', suggestions, s=>`/give weapon ${s} `, k=>WEAPONS[k]?.name);
                        if (qual !== undefined && args.length >= 3) {
                            const qs = ['poor','normal','rare','epic','legendary','godly'].filter(x=>x.startsWith(qual));
                            if (qs.length) html += _hintRow('Quality:', qs, q=>`/give weapon ${args[1]} ${q}`);
                        }
                    } else if (sub === 'armor' && id !== undefined) {
                        const db = Object.keys(ARMOR).filter(k=>!ARMOR[k].unarmored && !ARMOR[k].isDropped);
                        suggestions = db.filter(k=>k.includes(id)||(ARMOR[k].name||'').toLowerCase().includes(id)).slice(0,5);
                        if (suggestions.length) html += _hintRow('Armor:', suggestions, s=>`/give armor ${s} `, k=>ARMOR[k]?.name);
                        if (qual !== undefined && args.length >= 3) {
                            const qs = ['poor','normal','rare','epic','legendary','godly'].filter(x=>x.startsWith(qual));
                            if (qs.length) html += _hintRow('Quality:', qs, q=>`/give armor ${args[1]} ${q}`);
                        }
                    } else if (sub === 'item' && id !== undefined) {
                        const db = typeof ITEMS!=='undefined' ? Object.keys(ITEMS) : [];
                        suggestions = db.filter(k=>k.includes(id)||(ITEMS[k]?.name||'').toLowerCase().includes(id)).slice(0,5);
                        if (suggestions.length) html += _hintRow('Items:', suggestions, s=>`/give item ${s}`, k=>ITEMS[k]?.name);
                    } else if (sub === 'spell' && id !== undefined) {
                        const db = typeof SPELLS!=='undefined' ? Object.keys(SPELLS) : [];
                        suggestions = db.filter(k=>k.includes(id)||(SPELLS[k]?.name||'').toLowerCase().includes(id)).slice(0,5);
                        if (suggestions.length) html += _hintRow('Spells:', suggestions, s=>`/give spell ${s}`, k=>SPELLS[k]?.name);
                    }
                } else if (cmd === '/teleport') {
                    const towns = ['town1','town2','town3'].filter(t=>t.startsWith(q)||!q);
                    const dungeons = typeof DUNGEONS!=='undefined' ? Object.keys(DUNGEONS).filter(k=>k.toLowerCase().startsWith(q)||!q) : [];
                    const dest = [...towns, ...dungeons].slice(0,8);
                    if (dest.length && args.length <= 1) html += _hintRow('Destinations:', dest, d=>`/teleport ${d}`);
                } else if (cmd === '/setlevel' && q) {
                    const n = parseInt(q);
                    if (!isNaN(n)) html += (n<1||n>25) ? `  <span style="color:#ff4444;">⚠ must be 1–25</span>` : `  <span style="color:#88ff88;">→ set to level ${n}</span>`;
                } else if (cmd === '/godmode' && q) {
                    ['on','off'].filter(x=>x.startsWith(q)).forEach(x=>{ html += `  <span class="_termFill" data-fill="/godmode ${x}" style="color:#00FF41;cursor:pointer;text-decoration:underline;">${x}</span>`; });
                } else if (cmd === '/export' && q) {
                    ['save','stats'].filter(x=>x.startsWith(q)).forEach(x=>{ html += `  <span class="_termFill" data-fill="/export ${x}" style="color:#00FF41;cursor:pointer;text-decoration:underline;">${x}</span>`; });
                }

                hintsEl.innerHTML = html;
                hintsEl.style.display = 'block';
                _bindTermFill();
                return;
            }

            // ── Partial command — show matching commands ──────────────
            const matches = CMDS.filter(x => x.c.startsWith(cmd) || (cmd.length > 1 && x.c.includes(cmd)));
            if (!matches.length) {
                hintsEl.innerHTML = `<span style="color:#ff4444;">Unknown command — try /help</span>`;
                hintsEl.style.display = 'block';
                return;
            }
            html = matches.map(x =>
                `<span class="_termFill" data-fill="${x.c} " style="color:#ff8c00;cursor:pointer;text-decoration:underline;">${x.c}</span><span style="color:#3a6a3a;"> ${x.d}</span>`
            ).join('  <span style="color:#1a2a1a;">·</span>  ');
            hintsEl.innerHTML = html;
            hintsEl.style.display = 'block';
            _bindTermFill();
        }

        function _hintRow(label, keys, fillFn, nameFn) {
            if (!keys.length) return '';
            const items = keys.map(k => {
                const name = nameFn ? nameFn(k) : null;
                const display = name ? `${k}<span style="color:#3a6a3a;"> ${name}</span>` : k;
                const fill = fillFn(k);
                return `<span class="_termFill" data-fill="${fill}" style="color:#00FF41;cursor:pointer;text-decoration:underline;white-space:nowrap;margin-right:12px;">${display}</span>`;
            }).join('');
            return `<br><span style="color:#5a8a5a;">${label}</span> ${items}`;
        }

        function _bindTermFill() {
            document.querySelectorAll('._termFill').forEach(el => {
                el.onclick = () => {
                    const inp = document.getElementById('terminalInput');
                    inp.value = el.dataset.fill;
                    inp.focus();
                    _termHint(inp.value);
                };
            });
        }

        // ── List/Give routing: overlay on mobile, terminal print on PC ─
        function _routeList(type) {
            if (_isMobile()) {
                _sysoShowListPanel(type);
            } else {
                // Print to terminal in a compact readable format
                const configs = {
                    weapons:  { db: WEAPONS,  filter: k=>!WEAPONS[k].unarmed&&!WEAPONS[k].isDropped, meta: (k,v)=>`Lv${v.level||'?'} DMG:${v.baseDamage||'?'}` },
                    armor:    { db: ARMOR,    filter: k=>!ARMOR[k].unarmored&&!ARMOR[k].isDropped,   meta: (k,v)=>`Lv${v.level||'?'} DEF:${v.baseDefense||'?'}` },
                    items:    { db: typeof ITEMS!=='undefined'?ITEMS:{}, filter:()=>true, meta:(k,v)=>v.type||'' },
                    monsters: { db: ENEMIES,  filter: ()=>true, meta: (k,v)=>`Lv${v.level||'?'} HP:${v.baseHp||'?'}` },
                };
                const cfg = configs[type];
                if (!cfg) return;
                const keys = Object.keys(cfg.db).filter(cfg.filter);
                terminalPrint(`═══ ${type.toUpperCase()} (${keys.length}) ═══`, 'warning');
                keys.forEach(k => {
                    const v = cfg.db[k];
                    terminalPrint(`  ${k.padEnd(28)} ${(v.name||k).padEnd(28)} ${cfg.meta(k,v)}`);
                });
                terminalPrint(`═══ END ${type.toUpperCase()} ═══`, 'warning');
            }
        }

        document.getElementById('terminalInput').addEventListener('keydown', (e) => {
            const inp = e.target;
            const hist = gameState.sysop.commandHistory || [];

            // ── Up/Down arrow: command history ────────────────────────
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (_termHistIdx < hist.length - 1) _termHistIdx++;
                inp.value = hist[hist.length - 1 - _termHistIdx] || '';
                _termHint(inp.value);
                return;
            }
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (_termHistIdx > 0) { _termHistIdx--; inp.value = hist[hist.length - 1 - _termHistIdx] || ''; }
                else { _termHistIdx = -1; inp.value = ''; }
                _termHint(inp.value);
                return;
            }

            // ── Tab: autocomplete first suggestion ────────────────────
            if (e.key === 'Tab') {
                e.preventDefault();
                const first = document.querySelector('._termFill');
                if (first) { inp.value = first.dataset.fill; _termHint(inp.value); }
                return;
            }

            // ── Enter: execute ────────────────────────────────────────
            if (e.key === 'Enter') {
                const val = inp.value.trim();
                inp.value = '';
                _termHistIdx = -1;
                document.getElementById('termHints').style.display = 'none';
                if (val) {
                    terminalPrint(`root@dungeon:~# ${val}`, 'normal');
                    gameState.sysop.commandHistory.push(val);
                    executeCommand(val);
                }
            }
        });

        document.getElementById('terminalInput').addEventListener('input', (e) => {
            _termHistIdx = -1;
            _termHint(e.target.value);
        });

        function executeCommand(input) {
            const parts = input.split(' ');
            const command = parts[0].toLowerCase();
            const args = parts.slice(1);

            // Login command (always available)
            if (command === '/login') {
                handleLogin(args);
                return;
            }

            // Check authentication for all other commands
            if (!gameState.sysop.authenticated) {
                terminalPrint('ERROR: Authentication required. Use /login <username> <password>', 'error');
                return;
            }

            // Execute authenticated commands
            switch(command) {
                case '/help':
                    showHelp();
                    break;
                case '/logout':
                    handleLogout();
                    break;
                case '/clear':
                    clearTerminal();
                    break;
                case '/give':
                    handleGive(args);
                    break;
                case '/addmonster':
                    openAddMonsterForm();
                    break;
                case '/addweapon':
                    openAddWeaponForm();
                    break;
                case '/addarmor':
                    openAddArmorForm();
                    break;
                case '/additem':
                    openAddItemForm();
                    break;
                case '/listmonsters':
                    listMonsters();
                    break;
                case '/listweapons':
                    listWeapons();
                    break;
                case '/listarmor':
                    listArmor();
                    break;
                case '/listitems':
                    listItems();
                    break;
                case '/setlevel':
                    handleSetLevel(args);
                    break;
                case '/setgold':
                    handleSetGold(args);
                    break;
                case '/heal':
                    handleHeal();
                    break;
                case '/godmode':
                    handleGodMode(args);
                    break;
                case '/teleport':
                    handleTeleport(args);
                    break;
                case '/killmonster':
                    handleKillMonster();
                    break;
                case '/export':
                    handleExport(args);
                    break;
                case '/revealmap':
                    handleRevealMap(args);
                    break;
                case '/unlockmaster':
                    handleUnlockMaster(args);
                    break;
                default:
                    terminalPrint(`ERROR: Unknown command '${command}'. Type /help for available commands.`, 'error');
            }
        }

        function handleLogin(args) {
            if (args.length < 2) {
                terminalPrint('ERROR: Usage: /login <username> <password>', 'error');
                return;
            }
            const username = args[0];
            const password = args[1];
            const displayName = atob(_SYS.u);
            _checkCredentials(username, password).then(valid => {
                if (valid) {
                    gameState.sysop.authenticated = true;
                    gameState.sysop.username = displayName;
                    document.getElementById('sysopBadge').classList.add('active');
                    terminalPrint('═══════════════════════════════════════', 'success');
                    terminalPrint('  AUTHENTICATION SUCCESSFUL', 'success');
                    terminalPrint('  Welcome, ' + displayName, 'success');
                    terminalPrint('  Type /help for available commands', 'success');
                    terminalPrint('═══════════════════════════════════════', 'success');
                } else {
                    terminalPrint('ERROR: Authentication failed. Invalid credentials.', 'error');
                }
            });
        }

        function handleLogout() {
            gameState.sysop.authenticated = false;
            gameState.sysop.username = null;
            document.getElementById('sysopBadge').classList.remove('active');
            terminalPrint('Logged out. Terminal locked.', 'warning');
        }

        function showHelp() {
            terminalPrint('═══════════════════════════════════════', 'warning');
            terminalPrint('SYSOP COMMANDS:', 'warning');
            terminalPrint('═══════════════════════════════════════', 'warning');
            terminalPrint('');
            terminalPrint('AUTHENTICATION:');
            terminalPrint('  /login <user> <pass>  - Authenticate as sysop');
            terminalPrint('  /logout               - End sysop session');
            terminalPrint('');
            terminalPrint('PLAYER COMMANDS:');
            terminalPrint('  /give <type> <id> [quality]  - Give item to player');
            terminalPrint('                                 Types: weapon, armor, item, spell, runestone');
            terminalPrint('                                 Quality (optional): poor, normal, rare,');
            terminalPrint('                                           epic, legendary, godly');
            terminalPrint('                                 Examples:');
            terminalPrint('                                   /give weapon iron_sword legendary');
            terminalPrint('                                   /give armor leather_armor godly');
            terminalPrint('                                   /give runestone white');
            terminalPrint('                                   /give runestone yellow');
            terminalPrint('                                   /give runestone none  (removes all)');
            terminalPrint('                                 Runestone colors:');
            terminalPrint('                                   white, yellow, green, blue,');
            terminalPrint('                                   purple, brown, black, red');
            terminalPrint('  /setlevel <level>     - Set player level (1-25)');
            terminalPrint('                          ⚡ Level 20 triggers class evolution!');
            terminalPrint('  /setgold <amount>     - Set gold amount');
            terminalPrint('  /heal                 - Fully heal player');
            terminalPrint('  /godmode <on/off>     - Toggle invincibility');
            terminalPrint('');
            terminalPrint('GAME CONTENT:');
            terminalPrint('  /addmonster           - Add new monster (opens form)');
            terminalPrint('  /addweapon            - Add new weapon (opens form)');
            terminalPrint('  /addarmor             - Add new armor (opens form)');
            terminalPrint('  /additem              - Add new item (opens form)');
            terminalPrint('');
            terminalPrint('LISTING:');
            terminalPrint('  /listmonsters         - Show all monsters');
            terminalPrint('  /listweapons          - Show all weapons');
            terminalPrint('  /listarmor            - Show all armor');
            terminalPrint('  /listitems            - Show all items');
            terminalPrint('');
            terminalPrint('UTILITIES:');
            terminalPrint('  /teleport <dest>               - Teleport anywhere');
            terminalPrint('    /teleport town1              - Go to Silverdale');
            terminalPrint('    /teleport town2              - Go to Ashen Harbor');
            terminalPrint('    /teleport town3              - Go to Town 3');
            terminalPrint('    /teleport dungeon1           - Dungeon1 Floor 1 start');
            terminalPrint('    /teleport dungeon1 f2        - Dungeon1 Floor 2 start');
            terminalPrint('    /teleport dungeon1 f1 R57    - Dungeon1 Floor 1 Room R57');
            terminalPrint('    /teleport forest             - Any explore zone key');
            terminalPrint('  /revealmap [dungeon]     - Reveal entire dungeon map');
            terminalPrint('                             No arg = all dungeons');
            terminalPrint('                             /revealmap dungeon1');
            terminalPrint('  /unlockmaster [area|all] - Mark class master(s) as defeated');
            terminalPrint('                             and unlock the zone they guard');
            terminalPrint('                             /unlockmaster all');
            terminalPrint('                             /unlockmaster plains');
            terminalPrint('  /killmonster             - Instantly kill current enemy');
            terminalPrint('  /export <type>           - Export data (monsters/weapons/armor/items)');
            terminalPrint('  /clear                   - Clear terminal output');
            terminalPrint('═══════════════════════════════════════', 'warning');
        }

        function handleGive(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            if (args.length < 2) {
                terminalPrint('ERROR: Usage: /give <type> <id> [quality]', 'error');
                terminalPrint('Types: weapon, armor, item, spell', 'error');
                terminalPrint('Quality (optional, for weapons): poor, normal, rare, epic, legendary, godly', 'error');
                return;
            }

            const type = args[0].toLowerCase();
            const id = args[1].toLowerCase();
            const quality = args[2] ? args[2].toLowerCase() : null;

            switch(type) {
                case 'weapon':
                    if (WEAPONS[id]) {
                        // Check if quality was specified and is valid
                        if (quality && QUALITY_CONFIG[quality]) {
                            // Generate a weapon drop with specified quality
                            const baseWeapon = WEAPONS[id];
                            const weaponLevel = baseWeapon.level || gameState.player.level;
                            
                            // Create unique weapon ID with quality
                            const weaponId = `${id}_${quality}_sysop_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
                            
                            // Apply quality bonus (percentage-based)
                            const bonusPct = QUALITY_CONFIG[quality].bonusPct || 0;
                            const bonusDmg = Math.floor(baseWeapon.baseDamage * bonusPct);
                            const bonusMax = Math.floor((baseWeapon.maxDamage || baseWeapon.baseDamage) * bonusPct);
                            
                            // Create the quality weapon
                            const qualityWeapon = {
                                id: weaponId,
                                name: `${QUALITY_CONFIG[quality].name} ${baseWeapon.name}`,
                                baseDamage: baseWeapon.baseDamage + bonusDmg,
                                maxDamage: (baseWeapon.maxDamage || baseWeapon.baseDamage) + bonusMax,
                                baseMagicDamage: baseWeapon.baseMagicDamage || 0,
                                level: weaponLevel,
                                quality: quality,
                                modifiers: [],
                                cost: baseWeapon.cost * (QUALITY_CONFIG[quality].bonusPct + 1),
                                description: `A ${quality} quality ${baseWeapon.name}`,
                                slot: 'weapon',
                                isDropped: true, // Mark as generated
                                classRestriction: baseWeapon.classRestriction
                            };
                            
                            // Register in WEAPONS
                            WEAPONS[weaponId] = qualityWeapon;
                            
                            // Add to inventory
                            gameState.player.inventory.push(weaponId);
                            
                            terminalPrint(`SUCCESS: Gave ${quality} ${baseWeapon.name} (${qualityWeapon.baseDamage}-${qualityWeapon.maxDamage} dmg)`, 'success');
                        } else {
                            // Give base weapon without quality
                            if (!gameState.player.inventory.includes(id)) {
                                gameState.player.inventory.push(id);
                            }
                            terminalPrint(`SUCCESS: Gave weapon '${WEAPONS[id].name}' to player`, 'success');
                        }
                    } else {
                        terminalPrint(`ERROR: Weapon '${id}' not found`, 'error');
                        terminalPrint('Use /listweapons to see available weapons', 'error');
                    }
                    break;
                case 'armor':
                    if (ARMOR[id]) {
                        // Check if quality was specified and is valid
                        if (quality && QUALITY_CONFIG[quality]) {
                            // Generate armor with specified quality
                            const baseArmor = ARMOR[id];
                            const armorLevel = baseArmor.level || gameState.player.level;
                            
                            // Create unique armor ID with quality
                            const armorId = `${id}_${quality}_sysop_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
                            
                            // Apply quality bonus (percentage-based)
                            const bonusPct = QUALITY_CONFIG[quality].bonusPct || 0;
                            const bonusDef = Math.floor(baseArmor.baseDefense * bonusPct);
                            const bonusMag = Math.floor((baseArmor.baseMagicBonus || 0) * bonusPct);
                            
                            // Create the quality armor
                            const qualityArmor = {
                                id: armorId,
                                name: `${QUALITY_CONFIG[quality].name} ${baseArmor.name}`,
                                baseDefense: baseArmor.baseDefense + bonusDef,
                                baseMagicBonus: (baseArmor.baseMagicBonus || 0) + bonusMag,
                                level: armorLevel,
                                quality: quality,
                                cost: baseArmor.cost * (QUALITY_CONFIG[quality].bonusPct + 1),
                                description: `A ${quality} quality ${baseArmor.name}`,
                                slot: 'armor',
                                isDropped: true, // Mark as generated
                                classRestriction: baseArmor.classRestriction
                            };
                            
                            // Register in ARMOR
                            ARMOR[armorId] = qualityArmor;
                            
                            // Add to inventory
                            gameState.player.inventory.push(armorId);
                            
                            terminalPrint(`SUCCESS: Gave ${quality} ${baseArmor.name} (${qualityArmor.baseDefense} DEF${qualityArmor.baseMagicBonus > 0 ? `, +${qualityArmor.baseMagicBonus} MAG` : ''})`, 'success');
                        } else {
                            // Give base armor without quality
                            if (!gameState.player.inventory.includes(id)) {
                                gameState.player.inventory.push(id);
                            }
                            terminalPrint(`SUCCESS: Gave armor '${ARMOR[id].name}' to player`, 'success');
                        }
                    } else {
                        terminalPrint(`ERROR: Armor '${id}' not found`, 'error');
                        terminalPrint('Use /listarmor to see available armor', 'error');
                    }
                    break;
                case 'item':
                    if (ITEMS[id]) {
                        gameState.player.inventory.push(id); // Items can stack, so always push
                        terminalPrint(`SUCCESS: Gave item '${ITEMS[id].name}' to player`, 'success');
                    } else {
                        terminalPrint(`ERROR: Item '${id}' not found`, 'error');
                    }
                    break;
                case 'spell':
                    if (SPELLS[id]) {
                        if (!gameState.player.knownSpells.includes(id)) {
                            gameState.player.knownSpells.push(id);
                        }
                        terminalPrint(`SUCCESS: Taught spell '${SPELLS[id].name}' to player`, 'success');
                    } else {
                        terminalPrint(`ERROR: Spell '${id}' not found`, 'error');
                    }
                    break;
                case 'runestone': {
                    // Special: /give runestone none — clears all runestones
                    if (id === 'none' || id === 'clear' || id === 'reset') {
                        if (!gameState.player.runestones || gameState.player.runestones.length === 0) {
                            terminalPrint('Player has no runestones to remove.', 'warning');
                        } else {
                            const removed = [...gameState.player.runestones];
                            gameState.player.runestones = [];
                            // Also clear portalUnlocked since it ties to runestone travel
                            gameState.player.portalUnlocked = false;
                            saveGame();
                            terminalPrint(`SUCCESS: Removed ${removed.length} runestone(s): ${removed.join(', ')}`, 'success');
                            terminalPrint('  → Portal access reset.', 'info');
                        }
                        break;
                    }
                    // Accept 'white' or 'white_runestone' — normalize to full key
                    const rsId = id.includes('_runestone') ? id : `${id}_runestone`;
                    if (RUNESTONES[rsId]) {
                        const rs = RUNESTONES[rsId];
                        if (!gameState.player.runestones) gameState.player.runestones = [];
                        if (!gameState.player.runestones.includes(rsId)) {
                            gameState.player.runestones.push(rsId);
                            if (!gameState.player.achievements) gameState.player.achievements = [];
                            gameState.player.achievements.push({ id: rsId, name: rs.name, earned: Date.now() });
                            terminalPrint(`SUCCESS: Gave <span style="color:${rs.color};">${rs.name}</span> to player`, 'success');
                            terminalPrint(`  → "${rs.description}"`, 'info');
                            if (rs.unlocksPortal) {
                                terminalPrint(`  → Portal unlocked: ${rs.unlocksPortal.from} ↔ ${rs.unlocksPortal.to}`, 'success');
                            }
                            saveGame();
                        } else {
                            terminalPrint(`Player already has the ${rs.name}`, 'warning');
                        }
                    } else {
                        terminalPrint(`ERROR: Unknown runestone color '${id}'`, 'error');
                        terminalPrint('Valid colors: white, yellow, green, blue, purple, brown, black, red', 'error');
                        terminalPrint('Usage: /give runestone white   OR   /give runestone white_runestone', 'error');
                        terminalPrint('       /give runestone none    — removes all runestones', 'error');
                    }
                    break;
                }
                default:
                    terminalPrint(`ERROR: Invalid type '${type}'`, 'error');
            }
        }

        function handleSetLevel(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const targetLevel = parseInt(args[0]);
            if (isNaN(targetLevel) || targetLevel < 1 || targetLevel > 25) {
                terminalPrint('ERROR: Invalid level. Use 1-25', 'error');
                return;
            }

            const p = gameState.player;
            const currentLevel = p.level;
            
            // Calculate how many levels to add
            const levelsToAdd = targetLevel - currentLevel;
            
            if (levelsToAdd === 0) {
                terminalPrint(`Player is already level ${targetLevel}`, 'info');
                return;
            }
            
            // Apply level-ups manually
            for (let i = 0; i < Math.abs(levelsToAdd); i++) {
                if (levelsToAdd > 0) {
                    // Level up
                    p.level++;
                    p.maxHp += 15 + (p.con || 0);
                    p.hp = p.maxHp;
                    p.maxMp += 10;
                    p.mp = p.maxMp;
                    p.strength += 2;
                    p.defense += 2;
                    p.magic += 2;
                    p.speed += 1;

                    // ── Stat points: 3 per level, same as normal level-up ──
                    if (p.statPoints === undefined) p.statPoints = 0;
                    p.statPoints += 3;
                    
                    if (p.str !== undefined) {
                        p.str++; p.dex++; p.wis++; p.cha++; p.con++; p.lck++;
                        if (p.class === 'paladin' || p.baseClass === 'paladin') { 
                            p.str++; p.wis++; 
                        }
                    }
                    
                    // Check for class evolution at 20
                    if (p.level === 20 && evolveClass(p)) {
                        const evolution = ADVANCED_CLASSES[p.baseClass];
                        terminalPrint(`⚡ CLASS EVOLUTION! ${evolution.announcement}`, 'success');
                    }
                } else {
                    // Level down
                    p.level--;
                    p.maxHp = Math.max(20, p.maxHp - 15 - (p.con || 0));
                    p.hp = Math.min(p.hp, p.maxHp);
                    p.maxMp = Math.max(10, p.maxMp - 10);
                    p.mp = Math.min(p.mp, p.maxMp);
                    p.strength = Math.max(1, p.strength - 2);
                    p.defense = Math.max(1, p.defense - 2);
                    p.magic = Math.max(1, p.magic - 2);
                    p.speed = Math.max(1, p.speed - 1);

                    // ── Remove 3 stat points per level removed ──
                    if (p.statPoints === undefined) p.statPoints = 0;
                    p.statPoints = Math.max(0, p.statPoints - 3);
                    
                    if (p.str !== undefined) {
                        p.str = Math.max(1, p.str - 1);
                        p.dex = Math.max(1, p.dex - 1);
                        p.wis = Math.max(1, p.wis - 1);
                        p.cha = Math.max(1, p.cha - 1);
                        p.con = Math.max(1, p.con - 1);
                        p.lck = Math.max(1, p.lck - 1);
                    }
                }
            }
            
            // Update XP to next
            p.xpToNext = getXpToNextLevel(p.baseClass || p.class, p.level);
            p.xp = getXpForLevel(p.baseClass || p.class, p.level); // Set to start of this level
            
            // ═══════════════════════════════════════════════════════════════
            // AUTO-UNLOCK EXPLORE ZONES (same logic as showTown)
            // ═══════════════════════════════════════════════════════════════
            if (typeof LOCATIONS !== 'undefined') {
                Object.keys(LOCATIONS).forEach(key => {
                    const loc = LOCATIONS[key];
                    if (key === 'town') return;
                    if (!loc.locked && loc.requiredLevel && p.level >= loc.requiredLevel) {
                        if (!p.unlockedAreas.includes(key)) {
                            p.unlockedAreas.push(key);
                            terminalPrint(`✓ Unlocked zone: ${loc.name}`, 'success');
                        }
                    }
                });
            }

            // ═══════════════════════════════════════════════════════════════
            // AUTO-DEFEAT CLASS MASTERS for skipped levels
            // Locked zones require a master fight — when /setlevel skips past
            // a master's requiredLevel, mark that master as defeated and unlock
            // the zone it guards so the player isn't permanently soft-locked.
            // ═══════════════════════════════════════════════════════════════
            if (typeof CLASS_MASTERS !== 'undefined') {
                const areaOrder = ['forest', 'riverside', 'plains', 'cave', 'crypt', 'volcano'];
                Object.keys(CLASS_MASTERS).forEach(masterKey => {
                    const master = CLASS_MASTERS[masterKey];
                    // Only process masters for this player's class
                    const playerClass = p.baseClass || p.class;
                    if (!masterKey.startsWith(playerClass + '_master_')) return;
                    // If player meets or exceeds the master's required level, auto-defeat
                    if (p.level >= master.requiredLevel && !p.defeatedMasters.includes(masterKey)) {
                        p.defeatedMasters.push(masterKey);
                        terminalPrint(`✓ Auto-defeated master: ${master.name}`, 'success');
                        // Unlock the zone this master guards
                        if (master.unlocks && typeof LOCATIONS !== 'undefined' && LOCATIONS[master.unlocks]) {
                            if (!p.unlockedAreas.includes(master.unlocks)) {
                                p.unlockedAreas.push(master.unlocks);
                                terminalPrint(`✓ Unlocked zone: ${LOCATIONS[master.unlocks].name}`, 'success');
                            }
                        }
                    }
                });
            }
            
            updateHud();
            saveGame();
            const spAwarded = levelsToAdd > 0 ? levelsToAdd * 3 : 0;
            const spMsg = spAwarded > 0 ? ` (+${spAwarded} stat points)` : levelsToAdd < 0 ? ` (${levelsToAdd * 3} stat points)` : '';
            terminalPrint(`SUCCESS: Set player level to ${targetLevel}${spMsg}`, 'success');
            
            if (p.hasEvolved) {
                terminalPrint(`Player is now a ${getAdvancedClassName(p)} with ${getClassDamageMultiplier(p)}x damage!`, 'info');
            }
        }

        function handleSetGold(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const gold = parseInt(args[0]);
            if (isNaN(gold) || gold < 0) {
                terminalPrint('ERROR: Invalid gold amount', 'error');
                return;
            }

            gameState.player.gold = gold;
            terminalPrint(`SUCCESS: Set gold to ${gold}`, 'success');
        }

        function handleHeal() {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            gameState.player.hp = gameState.player.maxHp;
            gameState.player.mp = gameState.player.maxMp;
            terminalPrint('SUCCESS: Player fully healed', 'success');
        }

        function handleGodMode(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const mode = args[0]?.toLowerCase();
            if (mode === 'on') {
                gameState.player.godMode = true;
                terminalPrint('SUCCESS: God Mode ENABLED - Player is invincible', 'success');
            } else if (mode === 'off') {
                gameState.player.godMode = false;
                terminalPrint('SUCCESS: God Mode DISABLED', 'success');
            } else {
                terminalPrint('ERROR: Usage: /godmode <on/off>', 'error');
            }
        }

        function handleTeleport(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }
            if (!args || args.length === 0) {
                terminalPrint('ERROR: Usage: /teleport <destination>', 'error');
                terminalPrint('  /teleport town1               — Silverdale', 'warning');
                terminalPrint('  /teleport town2               — Ashen Harbor', 'warning');
                terminalPrint('  /teleport town3               — Town 3', 'warning');
                terminalPrint('  /teleport dungeon1            — Dungeon1 Floor 1 start', 'warning');
                terminalPrint('  /teleport dungeon1 f2         — Dungeon1 Floor 2 start', 'warning');
                terminalPrint('  /teleport dungeon1 f3         — Dungeon1 Floor 3 start', 'warning');
                terminalPrint('  /teleport dungeon1 f1 R57     — Dungeon1 Floor 1 Room R57', 'warning');
                terminalPrint('  /teleport <zone>              — Any explore zone key', 'warning');
                return;
            }

            const dest = args[0].toLowerCase();

            // ── Town teleport ──────────────────────────────────────────────
            if (dest === 'town1' || dest === 'town2' || dest === 'town3') {
                // Clear any dungeon/combat state
                gameState.dungeon = null;
                gameState.combatState = null;
                if (gameState.combatTimer) { clearInterval(gameState.combatTimer); gameState.combatTimer = null; }
                document.body.classList.remove("terminal-mode");
                document.getElementById('actionBar').innerHTML = '';
                gameState._terminalOpen = false;
                gameState._currentExploreArea = null;
                gameState.currentTown = dest;
                saveGame();
                showTown(dest);
                const tname = (typeof TOWNS !== 'undefined' && TOWNS[dest]) ? TOWNS[dest].name : dest;
                terminalPrint(`SUCCESS: Teleported to ${tname}`, 'success');
                return;
            }

            // ── Dungeon teleport: /teleport dungeon1 [fN] [RoomId] ────────
            // Match dungeon key case-insensitively
            const dungeonKey = (() => {
                if (typeof DUNGEONS === 'undefined') return null;
                for (const k in DUNGEONS) {
                    if (k.toLowerCase() === dest) return k;
                }
                return null;
            })();

            if (dungeonKey) {
                if (typeof DUNGEONS === 'undefined' || !DUNGEONS[dungeonKey]) {
                    terminalPrint(`ERROR: Dungeon "${dungeonKey}" not loaded`, 'error');
                    return;
                }
                const dungeonData = DUNGEONS[dungeonKey];

                // Parse floor: second arg like "f2" or "2"
                let targetFloor = 1;
                if (args[1]) {
                    const floorStr = args[1].replace(/^f/i, '');
                    const parsed = parseInt(floorStr);
                    if (!isNaN(parsed) && dungeonData.floors[parsed]) {
                        targetFloor = parsed;
                    } else {
                        terminalPrint(`ERROR: Floor "${args[1]}" not found in ${dungeonKey}`, 'error');
                        terminalPrint(`Available floors: ${Object.keys(dungeonData.floors).map(f=>'F'+f).join(', ')}`, 'warning');
                        return;
                    }
                }

                const floorData = dungeonData.floors[targetFloor];

                // Parse room: third arg like "R57"
                let targetRoom = floorData.startRoom;
                if (args[2]) {
                    const roomId = args[2].toUpperCase();
                    if (floorData.rooms[roomId]) {
                        targetRoom = roomId;
                    } else {
                        // Try lowercase
                        const found = Object.keys(floorData.rooms).find(k => k.toUpperCase() === roomId);
                        if (found) {
                            targetRoom = found;
                        } else {
                            terminalPrint(`ERROR: Room "${args[2]}" not found on Floor ${targetFloor}`, 'error');
                            const roomList = Object.keys(floorData.rooms).join(', ');
                            terminalPrint(`Floor ${targetFloor} rooms: ${roomList}`, 'warning');
                            return;
                        }
                    }
                }

                // ── Actually teleport into dungeon ────────────────────────
                // Clear any current dungeon/combat/explore state
                gameState.combatState = null;
                if (gameState.combatTimer) { clearInterval(gameState.combatTimer); gameState.combatTimer = null; }
                gameState._terminalOpen = false;
                gameState._currentExploreArea = null;

                // Mark room as discovered
                const destRoom = floorData.rooms[targetRoom];
                destRoom.flags = destRoom.flags || {};
                destRoom.flags.discovered = true;

                // Load persistent map and add target room
                const persistentMap = loadDungeonMap(gameState.player, dungeonKey, targetFloor);
                const scopedTargetRoom = `${targetFloor}:${targetRoom}`;
                persistentMap.add(scopedTargetRoom);
                saveRoomDiscovery(gameState.player, dungeonKey, targetFloor, targetRoom);

                gameState.dungeon = {
                    dungeonKey,
                    floor:          targetFloor,
                    currentRoom:    targetRoom,
                    discoveredRooms: persistentMap, // Load from persistent map
                    activeEnemies: []
                };

                // Show terminal
                /* mainScreen hidden by terminal-mode CSS class */
                openTerminalView(dungeonKey);
                startMpRegen(false);
                startResting(false);

                termAppend('', 'term-separator');
                termAppend(`🔮 <span style="color:#AA88FF;">[SYSOP TELEPORT]</span> Floor ${targetFloor} — ${targetRoom}`, 'term-highlight');
                termAppend(`<strong>${destRoom.name || targetRoom}</strong>`);
                termAppend(destRoom.description || '', 'term-dim');
                const exitList = buildExitList(destRoom);
                termAppend(`You see exits: ${exitList}.`, 'term-dim');
                checkTownExit(destRoom);

                saveGame();
                renderDungeonActionBar();

                terminalPrint(`SUCCESS: Teleported to ${dungeonKey} Floor ${targetFloor} Room ${targetRoom}`, 'success');
                return;
            }

            // ── Exploration zone teleport ─────────────────────────────────
            if (typeof LOCATIONS !== 'undefined' && LOCATIONS[dest]) {
                gameState.dungeon = null;
                gameState.combatState = null;
                if (gameState.combatTimer) { clearInterval(gameState.combatTimer); gameState.combatTimer = null; }
                gameState.currentLocation = dest;
                gameState._terminalOpen = false;
                exploreLocation(dest);
                terminalPrint(`SUCCESS: Teleported to ${LOCATIONS[dest].name}`, 'success');
                return;
            }

            // ── Nothing matched ───────────────────────────────────────────
            terminalPrint(`ERROR: Unknown destination "${dest}"`, 'error');
            terminalPrint('Valid towns: town1, town2', 'warning');
            if (typeof DUNGEONS !== 'undefined') {
                terminalPrint('Valid dungeons: ' + Object.keys(DUNGEONS).map(k=>k.toLowerCase()).join(', '), 'warning');
            }
            if (typeof LOCATIONS !== 'undefined') {
                terminalPrint('Valid zones: ' + Object.keys(LOCATIONS).filter(k=>k!=='town').join(', '), 'warning');
            }
        }

        function handleKillMonster() {
            if (!gameState.combatState) {
                terminalPrint('ERROR: Not in combat', 'error');
                return;
            }

            gameState.combatState.enemy.hp = 0;
            terminalPrint('SUCCESS: Enemy eliminated', 'success');
            checkCombatEnd();
        }

        function handleRevealMap(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }
            
            if (typeof DUNGEONS === 'undefined') {
                terminalPrint('ERROR: DUNGEONS not loaded', 'error');
                return;
            }
            
            const p = gameState.player;
            let targetDungeons = [];
            
            // If dungeon specified, reveal only that one
            if (args && args.length > 0) {
                const dungeonKey = args[0];
                // Match case-insensitively
                const matched = Object.keys(DUNGEONS).find(k => k.toLowerCase() === dungeonKey.toLowerCase());
                if (!matched) {
                    terminalPrint(`ERROR: Dungeon "${dungeonKey}" not found`, 'error');
                    terminalPrint(`Available dungeons: ${Object.keys(DUNGEONS).join(', ')}`, 'warning');
                    return;
                }
                targetDungeons = [matched];
            } else {
                // No arg = reveal ALL dungeons
                targetDungeons = Object.keys(DUNGEONS);
            }
            
            let totalRooms = 0;
            let totalFloors = 0;
            
            targetDungeons.forEach(dungeonKey => {
                const dungeon = DUNGEONS[dungeonKey];
                
                Object.keys(dungeon.floors).forEach(floorNum => {
                    const floor = dungeon.floors[floorNum];
                    totalFloors++;
                    
                    // Reveal all rooms on this floor
                    Object.keys(floor.rooms).forEach(roomId => {
                        const room = floor.rooms[roomId];
                        if (room.map) { // Only rooms with map coordinates
                            saveRoomDiscovery(p, dungeonKey, parseInt(floorNum), roomId);
                            totalRooms++;
                        }
                    });
                });
            });
            
            // If currently in a dungeon, reload the persistent map for active floor
            if (gameState.dungeon) {
                const ds = gameState.dungeon;
                ds.discoveredRooms = loadDungeonMap(p, ds.dungeonKey, ds.floor);
            }
            
            saveGame();
            
            terminalPrint('═══════════════════════════════════════', 'success');
            terminalPrint('  MAP REVEAL COMPLETE', 'success');
            terminalPrint(`  Dungeons: ${targetDungeons.join(', ')}`, 'success');
            terminalPrint(`  Floors revealed: ${totalFloors}`, 'success');
            terminalPrint(`  Rooms revealed: ${totalRooms}`, 'success');
            terminalPrint('  Open dungeon map to see all rooms', 'success');
            terminalPrint('═══════════════════════════════════════', 'success');
        }

        // ─────────────────────────────────────────────────────────────────
        // /unlockmaster [area|all]
        // Marks class masters as defeated and unlocks the zones they guard.
        // Usage:
        //   /unlockmaster all        — unlock every master for this class
        //   /unlockmaster forest     — unlock the master tied to "forest"
        //   /unlockmaster plains     — unlock the master tied to "plains"
        //   (etc. for cave, crypt, volcano, riverside)
        // ─────────────────────────────────────────────────────────────────
        function handleUnlockMaster(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }
            if (typeof CLASS_MASTERS === 'undefined') {
                terminalPrint('ERROR: CLASS_MASTERS not loaded', 'error');
                return;
            }

            const p = gameState.player;
            const playerClass = p.baseClass || p.class;
            const target = args[0] ? args[0].toLowerCase() : 'all';

            let unlocked = 0;

            Object.keys(CLASS_MASTERS).forEach(masterKey => {
                // Only this class's masters
                if (!masterKey.startsWith(playerClass + '_master_')) return;

                // Filter by specific area if requested
                if (target !== 'all') {
                    if (!masterKey.endsWith('_' + target)) return;
                }

                const master = CLASS_MASTERS[masterKey];

                if (p.defeatedMasters.includes(masterKey)) {
                    terminalPrint(`  (already defeated: ${master.name})`, 'info');
                    return;
                }

                p.defeatedMasters.push(masterKey);
                terminalPrint(`✓ Defeated master: ${master.name}`, 'success');
                unlocked++;

                // Unlock the zone this master guards
                if (master.unlocks && typeof LOCATIONS !== 'undefined' && LOCATIONS[master.unlocks]) {
                    if (!p.unlockedAreas.includes(master.unlocks)) {
                        p.unlockedAreas.push(master.unlocks);
                        terminalPrint(`✓ Unlocked zone: ${LOCATIONS[master.unlocks].name}`, 'success');
                    } else {
                        terminalPrint(`  (zone already unlocked: ${LOCATIONS[master.unlocks].name})`, 'info');
                    }
                }
            });

            if (unlocked === 0 && target !== 'all') {
                terminalPrint(`ERROR: No undefeated master found for area "${target}" and class "${playerClass}"`, 'error');
                terminalPrint(`Valid areas: forest, riverside, plains, cave, crypt, volcano`, 'warning');
                return;
            }

            saveGame();
            terminalPrint('═══════════════════════════════════════', 'success');
            terminalPrint(`  ${unlocked} master(s) unlocked. Re-open Explore to see zones.`, 'success');
            terminalPrint('═══════════════════════════════════════', 'success');
        }

        function listMonsters() { _routeList('monsters'); }
        function listWeapons()  { _routeList('weapons');  }
        function listArmor()    { _routeList('armor');    }
        function listItems()    { _routeList('items');    }

        function _sysoShowListPanel(type) {
            // Ensure the sysop overlay is open and rendered
            if (!document.getElementById('sysopOverlay')?.classList.contains('open')) {
                openSysopOverlay();
            }
            // sysoSub may not exist yet if overlay just opened — give it a tick
            let sub = document.getElementById('sysoSub');
            if (!sub) {
                setTimeout(() => _sysoShowListPanel(type), 80);
                return;
            }

            const configs = {
                weapons:  { title: '⚔️ WEAPONS',  icon: '⚔️', db: () => WEAPONS, filter: k => !WEAPONS[k].unarmed && !WEAPONS[k].isDropped,
                            meta: (k,v) => `Lv${v.level||'?'} | DMG:${v.baseDamage||v.damage||'?'}`, desc: (k,v) => v.description||'' },
                armor:    { title: '🛡️ ARMOR',    icon: '🛡️', db: () => ARMOR,   filter: k => !ARMOR[k].unarmored && !ARMOR[k].isDropped,
                            meta: (k,v) => `Lv${v.level||'?'} | DEF:${v.baseDefense||v.defense||'?'}`, desc: (k,v) => v.description||'' },
                items:    { title: '🎒 ITEMS',    icon: '🎒', db: () => (typeof ITEMS!=='undefined'?ITEMS:{}), filter: ()=>true,
                            meta: (k,v) => v.type||'', desc: (k,v) => v.description||'' },
                monsters: { title: '👹 MONSTERS', icon: '👹', db: () => ENEMIES,  filter: ()=>true,
                            meta: (k,v) => `Lv${v.level||'?'} | HP:${v.baseHp||v.hp||'?'}`, desc: (k,v) => v.description||'' },
            };
            const cfg = configs[type];
            if (!cfg) return;

            const db = cfg.db();
            const allKeys = Object.keys(db).filter(cfg.filter);

            const renderRows = (filter) => {
                const q = filter.toLowerCase();
                const matches = allKeys.filter(k => {
                    if (!q) return true;
                    const v = db[k];
                    return k.toLowerCase().includes(q) || (v.name||'').toLowerCase().includes(q) || (v.description||'').toLowerCase().includes(q);
                });
                const countEl = document.getElementById('sysoListCount');
                if (countEl) countEl.textContent = `${matches.length} / ${allKeys.length} entries`;
                const body = document.getElementById('sysoListBody');
                if (!body) return;
                if (matches.length === 0) {
                    body.innerHTML = `<div style="color:#5a8a5a;font-family:'VT323',monospace;padding:10px;">No matches for "${filter}"</div>`;
                    return;
                }
                body.innerHTML = matches.map(k => {
                    const v = db[k];
                    const name = v.name || k;
                    const meta = cfg.meta(k, v);
                    const desc = cfg.desc(k, v);
                    // Clicking a list row copies the key into the give panel or fills the search
                    const clickable = (type !== 'monsters')
                        ? `onclick="document.getElementById('sysoListSearch').value='${k}';document.getElementById('sysoListSearch').dispatchEvent(new Event('input'));"`
                        : '';
                    return `<div class="syo-list-row" ${clickable}>
                        <div class="syo-list-key">${k}</div>
                        <div class="syo-list-name">${name}${desc ? `<br><span style="color:#3a6a3a;font-size:13px;">${desc}</span>` : ''}</div>
                        <div class="syo-list-meta">${meta}</div>
                    </div>`;
                }).join('');
            };

            sub.innerHTML = `
            <div class="syo-list-panel">
                <div style="padding:8px 8px 0;display:flex;justify-content:space-between;align-items:center;">
                    <span style="color:#ff8c00;font-family:'VT323',monospace;font-size:18px;">${cfg.title}</span>
                    <span class="syo-list-count" id="sysoListCount">${allKeys.length} entries</span>
                </div>
                <div class="syo-list-search">
                    <input id="sysoListSearch" placeholder="🔍 Filter by name, key, or description..." autocorrect="off" spellcheck="false"
                        oninput="(function(v){
                            const db=window._sysoListDb; const cfg=window._sysoListCfg;
                            if(!db||!cfg) return;
                            const q=v.toLowerCase();
                            const allKeys=Object.keys(db).filter(cfg.filter);
                            const matches=allKeys.filter(k=>!q||k.toLowerCase().includes(q)||(db[k].name||'').toLowerCase().includes(q)||(db[k].description||'').toLowerCase().includes(q));
                            document.getElementById('sysoListCount').textContent=matches.length+' / '+allKeys.length+' entries';
                            document.getElementById('sysoListBody').innerHTML=matches.length===0
                                ? '<div style=\"color:#5a8a5a;font-family:VT323,monospace;padding:10px;\">No matches</div>'
                                : matches.map(k=>{
                                    const v=db[k];
                                    return '<div class=\"syo-list-row\"><div class=\"syo-list-key\">'+k+'</div><div class=\"syo-list-name\">'+(v.name||k)+(v.description?'<br><span style=\"color:#3a6a3a;font-size:13px;\">'+v.description+'</span>':'')+'</div><div class=\"syo-list-meta\">'+cfg.meta(k,v)+'</div></div>';
                                }).join('');
                        })(this.value)">
                </div>
                <div class="syo-list-body" id="sysoListBody"></div>
            </div>`;

            // Store db and cfg on window for the inline oninput handler
            window._sysoListDb = db;
            window._sysoListCfg = cfg;

            renderRows('');
            sub.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            setTimeout(() => document.getElementById('sysoListSearch')?.focus(), 100);
        }

        function openAddMonsterForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW MONSTER</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Monster ID (lowercase, underscores):</label>
                    <input type="text" id="monsterId" placeholder="fire_dragon">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="monsterName" placeholder="Fire Dragon">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">HP:</label>
                    <input type="number" id="monsterHp" value="100">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Damage:</label>
                    <input type="number" id="monsterDamage" value="20">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Defense:</label>
                    <input type="number" id="monsterDefense" value="10">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">XP Reward:</label>
                    <input type="number" id="monsterXp" value="100">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Gold Reward:</label>
                    <input type="number" id="monsterGold" value="80">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level:</label>
                    <input type="number" id="monsterLevel" value="5">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="monsterDesc" placeholder="A fearsome creature">
                </div>
                <button onclick="submitAddMonster()">ADD MONSTER</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddMonster() {
            const id = document.getElementById('monsterId').value.trim().toLowerCase();
            const name = document.getElementById('monsterName').value.trim();
            const hp = parseInt(document.getElementById('monsterHp').value);
            const damage = parseInt(document.getElementById('monsterDamage').value);
            const defense = parseInt(document.getElementById('monsterDefense').value);
            const xp = parseInt(document.getElementById('monsterXp').value);
            const gold = parseInt(document.getElementById('monsterGold').value);
            const level = parseInt(document.getElementById('monsterLevel').value);
            const description = document.getElementById('monsterDesc').value.trim();

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            ENEMIES[id] = {
                name: name,
                hp: hp,
                damage: damage,
                defense: defense,
                xp: xp,
                gold: gold,
                level: level,
                description: description
            };

            closeModal();
            terminalPrint(`SUCCESS: Added monster '${name}' with ID '${id}'`, 'success');
            terminalPrint('Remember to add it to a location\'s encounter list!', 'warning');
        }

        function openAddWeaponForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW WEAPON</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Weapon ID:</label>
                    <input type="text" id="weaponId" placeholder="flame_sword">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="weaponName" placeholder="Flame Sword">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Damage:</label>
                    <input type="number" id="weaponDamage" value="30">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Magic Damage:</label>
                    <input type="number" id="weaponMagic" value="10">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Cost:</label>
                    <input type="number" id="weaponCost" value="200">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level Requirement:</label>
                    <input type="number" id="weaponLevel" value="5">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="weaponDesc" placeholder="A blazing weapon">
                </div>
                <button onclick="submitAddWeapon()">ADD WEAPON</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddWeapon() {
            const id = document.getElementById('weaponId').value.trim().toLowerCase();
            const name = document.getElementById('weaponName').value.trim();
            const damage = parseInt(document.getElementById('weaponDamage').value);
            const magicDamage = parseInt(document.getElementById('weaponMagic').value);
            const cost = parseInt(document.getElementById('weaponCost').value);
            const level = parseInt(document.getElementById('weaponLevel').value);
            const description = document.getElementById('weaponDesc').value.trim();

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            WEAPONS[id] = {
                name: name,
                damage: damage,
                magicDamage: magicDamage,
                cost: cost,
                level: level,
                description: description
            };

            closeModal();
            terminalPrint(`SUCCESS: Added weapon '${name}' with ID '${id}'`, 'success');
        }

        function openAddArmorForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW ARMOR</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Armor ID:</label>
                    <input type="text" id="armorId" placeholder="dragon_mail">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="armorName" placeholder="Dragon Mail">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Defense:</label>
                    <input type="number" id="armorDefense" value="25">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Magic Bonus:</label>
                    <input type="number" id="armorMagic" value="0">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Cost:</label>
                    <input type="number" id="armorCost" value="300">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level Requirement:</label>
                    <input type="number" id="armorLevel" value="6">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="armorDesc" placeholder="Strong protective armor">
                </div>
                <button onclick="submitAddArmor()">ADD ARMOR</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddArmor() {
            const id = document.getElementById('armorId').value.trim().toLowerCase();
            const name = document.getElementById('armorName').value.trim();
            const defense = parseInt(document.getElementById('armorDefense').value);
            const magicBonus = parseInt(document.getElementById('armorMagic').value);
            const cost = parseInt(document.getElementById('armorCost').value);
            const level = parseInt(document.getElementById('armorLevel').value);
            const description = document.getElementById('armorDesc').value.trim();

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            ARMOR[id] = {
                name: name,
                defense: defense,
                magicBonus: magicBonus,
                cost: cost,
                level: level,
                description: description
            };

            closeModal();
            terminalPrint(`SUCCESS: Added armor '${name}' with ID '${id}'`, 'success');
        }

        function openAddItemForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW ITEM</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Item ID:</label>
                    <input type="text" id="itemId" placeholder="super_potion">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="itemName" placeholder="Super Potion">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Type:</label>
                    <select id="itemType" style="width: 100%; background: var(--secondary-bg); color: var(--text-color); border: 2px solid var(--border-color); padding: 10px; font-family: 'VT323', monospace; font-size: 18px;">
                        <option value="consumable">Consumable</option>
                        <option value="quest">Quest</option>
                        <option value="permanent">Permanent</option>
                        <option value="utility">Utility</option>
                        <option value="passive">Passive</option>
                    </select>
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Subtype:</label>
                    <input type="text" id="itemSubtype" placeholder="heal_hp">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Power:</label>
                    <input type="number" id="itemPower" value="50">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Cost:</label>
                    <input type="number" id="itemCost" value="30">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level:</label>
                    <input type="number" id="itemLevel" value="1">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="itemDesc" placeholder="Restores HP">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">
                        <input type="checkbox" id="itemStackable" checked> Stackable
                    </label>
                </div>
                <button onclick="submitAddItem()">ADD ITEM</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddItem() {
            const id = document.getElementById('itemId').value.trim().toLowerCase();
            const name = document.getElementById('itemName').value.trim();
            const type = document.getElementById('itemType').value;
            const subtype = document.getElementById('itemSubtype').value.trim();
            const power = parseInt(document.getElementById('itemPower').value);
            const cost = parseInt(document.getElementById('itemCost').value);
            const level = parseInt(document.getElementById('itemLevel').value);
            const description = document.getElementById('itemDesc').value.trim();
            const stackable = document.getElementById('itemStackable').checked;

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            ITEMS[id] = {
                name: name,
                type: type,
                subtype: subtype,
                power: power,
                cost: cost,
                level: level,
                description: description,
                stackable: stackable
            };

            closeModal();
            terminalPrint(`SUCCESS: Added item '${name}' with ID '${id}'`, 'success');
        }

        function closeModal() {
            document.getElementById('modalOverlay').classList.remove('active');
        }

        function handleExport(args) {
            const type = args[0]?.toLowerCase();
            let data;
            let filename;

            switch(type) {
                case 'monsters':
                    data = JSON.stringify(ENEMIES, null, 2);
                    filename = 'monsters.json';
                    break;
                case 'weapons':
                    data = JSON.stringify(WEAPONS, null, 2);
                    filename = 'weapons.json';
                    break;
                case 'armor':
                    data = JSON.stringify(ARMOR, null, 2);
                    filename = 'armor.json';
                    break;
                case 'items':
                    data = JSON.stringify(ITEMS, null, 2);
                    filename = 'items.json';
                    break;
                default:
                    terminalPrint('ERROR: Usage: /export <monsters/weapons/armor/items>', 'error');
                    return;
            }

            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);

            terminalPrint(`SUCCESS: Exported ${type} to ${filename}`, 'success');
        }

        // ═══════════════════════════════════════════════════════════════
        // CLASS-SPECIFIC XP TABLES (Levels 1-25)
        // ═══════════════════════════════════════════════════════════════
        // ── XP TABLES (levels 1-25) ────────────────────────────────────────
        // Calibrated against actual monster XP output per zone:
        //   Zone1 (Lv1-2 mobs, ~22 xp avg) → Lv1-3: ~50-80 kills each
        //   Zone2 unlocks Lv4 (~62 xp avg) → Lv4-5: ~80 kills each
        //   Zone3 unlocks Lv6 (~105 xp avg) → Lv6-9: ~80-85 kills each
        //   Zone4 unlocks Lv10 (~211 xp avg) → Lv10-15: ~85 kills each
        //   Zone5 unlocks Lv13, Zone6 Lv16, Zone7 Lv19, Zone8 Lv22
        // Lv1→2 and Lv2→3 kept at original values (already fair).
        // Lv3 onward: cut to match real kill counts (old table was 8-10x too high).

        // Base table (warrior/paladin/archer/hunter — standard speed)
        const _BASE_XP = [
              0,    1125,    3240,    5000,    9960,
          15720,   24120,   33400,   45320,   57985,
          75920,   98275,  123350,  153100,  187100,
         226520,  290150,  355940,  466190,  561950,
         699700,  817500,  975200, 1160100, 1370300
        ];

        // Class XP multipliers (higher = needs more XP per level = slower)
        // Applied to every threshold from Lv3 onward (Lv1-2 stay identical)
        const _XP_MULT = {
            warrior:  1.00,
            paladin:  1.00,
            archer:   1.00,
            hunter:   1.00,
            ranger:   1.00,
            rogue:    0.93,   // rogues level slightly faster
            acolyte:  1.08,   // casters slightly slower (AOE advantage)
            necrolyte:1.08,
            druid:    1.08,
            sorceror: 1.08,
            mage:     1.05,
            cleric:   1.00,
            warlock:  1.05,
            runesmith:1.02,
        };

        function _buildXpTable(cls) {
            const mult = _XP_MULT[cls] || 1.00;
            return _BASE_XP.map((v, i) => {
                if (i <= 2) return v;          // Lv1-3 thresholds unchanged
                return Math.round(v * mult);
            });
        }

        const XP_TABLES = {
            warrior:   _buildXpTable('warrior'),
            paladin:   _buildXpTable('paladin'),
            archer:    _buildXpTable('archer'),
            hunter:    _buildXpTable('hunter'),
            ranger:    _buildXpTable('ranger'),
            rogue:     _buildXpTable('rogue'),
            acolyte:   _buildXpTable('acolyte'),
            necrolyte: _buildXpTable('necrolyte'),
            druid:     _buildXpTable('druid'),
            sorceror:  _buildXpTable('sorceror'),
            mage:      _buildXpTable('mage'),
            cleric:    _buildXpTable('cleric'),
            warlock:   _buildXpTable('warlock'),
            runesmith: _buildXpTable('runesmith'),
        };
        
        function getXpForLevel(playerClass, level) {
            const table = XP_TABLES[playerClass] || XP_TABLES.warrior;
            if (level < 1) return 0;
            if (level > 25) return table[24]; // Max at level 25
            return table[level - 1];
        }
        
        function getXpToNextLevel(playerClass, currentLevel) {
            if (currentLevel >= 25) return 999999999; // Max level
            return getXpForLevel(playerClass, currentLevel + 1);
        }

        // ═══════════════════════════════════════════════════════════════
        // END XP TABLES
        // ═══════════════════════════════════════════════════════════════
        window.submitAddMonster = submitAddMonster;
        window.submitAddWeapon = submitAddWeapon;
        window.submitAddArmor = submitAddArmor;
        window.submitAddItem = submitAddItem;
        window.closeModal = closeModal;

        // ═══════════════════════════════════════════════════════════════
        // END SYSOP TERMINAL SYSTEM
        // ═══════════════════════════════════════════════════════════════





        // Initialize Game
        function initGame() {
            try {
                // Try to auto-restore character (especially important for dungeons!)
                const characters = getAllCharacters();
                
                if (characters.length > 0) {
                    // Check if any character is currently in a dungeon
                    let dungeonChar = null;
                    try {
                        dungeonChar = characters.find(char => {
                            try {
                                const saveData = localStorage.getItem(`dq_save_${char.id}`);
                                if (saveData) {
                                    const data = JSON.parse(saveData);
                                    return data.meta?.inDungeon === true;
                                }
                            } catch (e) {
                                console.error(`Corrupted save for ${char.id}:`, e);
                                // Delete corrupted save
                                localStorage.removeItem(`dq_save_${char.id}`);
                            }
                            return false;
                        });
                    } catch (e) {
                        console.error('Error checking for dungeon characters:', e);
                    }
                    
                    if (dungeonChar) {
                        // Auto-load character that was in a dungeon (prevent cheating!)
                        console.log('🏰 Auto-restoring dungeon session:', dungeonChar.name);
                        try {
                            loadCharacter(dungeonChar.id);
                            return;
                        } catch (e) {
                            console.error('Failed to load dungeon character:', e);
                            alert('⚠️ Your dungeon save was corrupted. Returning to main menu.');
                            // Delete corrupted save and continue to main menu
                            deleteCharacter(dungeonChar.id);
                        }
                    }
                    
                    // If single character and not in dungeon, auto-load for convenience
                    if (characters.length === 1) {
                        console.log('Auto-loading single character:', characters[0].name);
                        try {
                            loadCharacter(characters[0].id);
                            return;
                        } catch (e) {
                            console.error('Failed to load character:', e);
                            alert('⚠️ Your save was corrupted. Returning to main menu.');
                            // Delete corrupted save and continue to main menu
                            deleteCharacter(characters[0].id);
                        }
                    }
                }
            } catch (e) {
                console.error('Critical error in initGame:', e);
                // Clear potentially corrupted data
                try {
                    localStorage.removeItem('dq_character_list');
                } catch (clearError) {
                    console.error('Could not clear character list:', clearError);
                }
            }
            
            // Always fall back to main menu if anything goes wrong
            showMainMenu();
            
            // Warn before leaving page without saving
            window.addEventListener('beforeunload', function(e) {
                // Only warn if player exists and has made progress
                if (gameState.player && gameState.player.level >= 1) {
                    const message = 'You have unsaved progress! Are you sure you want to leave?';
                    e.preventDefault();
                    e.returnValue = message;  // Chrome requires returnValue
                    return message;           // Some browsers use return value
                }
            });
        }

        function showMainMenu() {
            checkGameVersion();
            const screen = document.getElementById('mainScreen');
            const characters = getAllCharacters();
            const hasCharacters = characters.length > 0;

            // Only show install option if not already a standalone PWA
            const isStandalone = window.navigator.standalone === true ||
                                 window.matchMedia('(display-mode: standalone)').matches;
            const installOption = isStandalone ? '' : `
                    <div class="menu-option" onclick="openInstallModal()"
                         style="border-color:#2a5a2a;color:#4a9a4a;margin-top:12px;">
                        📱 INSTALL APP
                        <span style="font-size:13px;color:#336633;"> — play fullscreen</span>
                    </div>`;

            screen.innerHTML = `
                <div class="location-header">MAIN MENU</div>
                <div style="text-align:center; margin: 30px 0;">
                    <div style="display:inline-block; border:2px solid var(--highlight-color); padding:10px 28px; color:var(--highlight-color); font-family:'VT323',monospace; font-size:22px; letter-spacing:2px; box-shadow:0 0 12px rgba(255,200,0,0.3);">
                        DUNGEON QUEST AWAITS!
                    </div>
                    <div style="color:var(--highlight-color); font-size:18px; margin-top:8px; letter-spacing:3px;">⚔️ ——————————————— ⚔️</div>
                </div>
                <div style="max-width: 400px; margin: 0 auto;">
                    <div class="menu-option" onclick="newGame()">► NEW GAME</div>
                    <div class="menu-option ${!hasCharacters?'disabled':''}" onclick="${hasCharacters?'showCharacterSelect()':''}">
                        ► CONTINUE ${hasCharacters?`(${characters.length} local save${characters.length>1?'s':''})`:' (No saves)'}
                    </div>
                    <div class="menu-option" onclick="loadFromFile()">📁 LOAD FROM FILE (.dqsave)</div>
                    <div class="menu-option" onclick="showInstructions()">► INSTRUCTIONS</div>
                    <div class="menu-option" onclick="showRevisionHistory()" style="border-color:#4a7a4a;color:#8aaa8a;">► 📋 REVISION HISTORY</div>
                    ${installOption}
                </div>
                <div style="position:fixed;bottom:6px;right:10px;font-family:'VT323',monospace;font-size:13px;color:#1a3a1a;pointer-events:none;user-select:none;">
                    v${GAME_VERSION}
                </div>
            `;
        }

        function showCharacterSelect() {
            checkGameVersion();
            const characters = getAllCharacters();
            if (characters.length === 0) {
                alert('No saved characters found!');
                return;
            }
            
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">SELECT CHARACTER</div>
                <div id="characterList" style="max-width: 600px; margin: 20px auto; padding: 0 10px;"></div>
                <div style="padding: 0 10px 20px;">
                    <button onclick="showMainMenu()" style="width:100%;max-width:600px;display:block;margin:0 auto;">← BACK TO MENU</button>
                </div>
            `;
            
            const charList = document.getElementById('characterList');
            
            characters.forEach(char => {
                const card = document.createElement('div');
                card.className = 'character-card';
                card.style.cssText = `
                    background: var(--secondary-bg);
                    border: 2px solid var(--border-color);
                    padding: 15px;
                    margin-bottom: 15px;
                    box-sizing: border-box;
                    width: 100%;
                `;
                
                card.innerHTML = `
                    <div style="margin-bottom: 12px;">
                        <div style="color: var(--highlight-color); font-size: 22px; margin-bottom: 4px; word-break: break-word;">
                            ${char.name}
                        </div>
                        <div style="color: var(--text-color); font-size: 16px;">
                            Level ${char.level} ${char.class || 'Adventurer'}
                        </div>
                        <div style="color: #8aaa8a; font-size: 14px; margin-top: 4px;">
                            Last played: ${char.lastSaved}
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; width: 100%;">
                        <button onclick="event.stopPropagation(); loadCharacter('${char.id}')"
                                style="flex: 1; padding: 12px 8px; background: #0a3a0a; border: 2px solid var(--text-color); font-size: 18px; min-width: 0;">
                            ▶ PLAY
                        </button>
                        <button onclick="event.stopPropagation(); confirmDeleteCharacter('${char.id}', '${char.name}')"
                                style="flex: 1; padding: 12px 8px; background: #3a0a0a; border: 2px solid var(--error-color); color: var(--error-color); font-size: 18px; min-width: 0;">
                            🗑️ DELETE
                        </button>
                    </div>
                `;
                
                card.addEventListener('mouseenter', () => {
                    card.style.background = 'var(--primary-bg)';
                    card.style.borderColor = 'var(--highlight-color)';
                });
                
                card.addEventListener('mouseleave', () => {
                    card.style.background = 'var(--secondary-bg)';
                    card.style.borderColor = 'var(--border-color)';
                });
                
                charList.appendChild(card);
            });
        }

        function confirmDeleteCharacter(charId, charName) {
            if (confirm(`Are you sure you want to DELETE ${charName}? This cannot be undone!`)) {
                if (deleteCharacter(charId)) {
                    showCharacterSelect(); // Refresh the list
                } else {
                    alert('Error deleting character!');
                }
            }
        }

        function loadCharacter(characterId) {
            try {
                const saveData = localStorage.getItem(`dq_save_${characterId}`);
                if (!saveData) {
                    console.error('Save file not found:', characterId);
                    alert('⚠️ Save file not found!');
                    showMainMenu();
                    return;
                }

                const data = JSON.parse(saveData);
                
                // Validate save data structure
                if (!data.player) {
                    throw new Error('Invalid save data: missing player data');
                }
                
                // Restore complete player state
                gameState.player = {
                    ...data.player,
                    // Ensure all arrays are properly restored
                    inventory: data.player.inventory || [],
                    knownSpells: data.player.knownSpells || [],
                    defeatedMasters: data.player.defeatedMasters || [],
                    unlockedAreas: data.player.unlockedAreas || [],
                    // Ensure bankGold exists (for old saves)
                    bankGold: data.player.bankGold || 0,
                    achievements: data.player.achievements || [],
                    runestones: data.player.runestones || [],
                    // Portal unlock — false for old saves that predate this flag
                    portalUnlocked: data.player.portalUnlocked || false,
                    // ═══════════════════════════════════════════════════════════════
                    // PERSISTENT DUNGEON MAPS - Restore and convert arrays back to Sets
                    // ═══════════════════════════════════════════════════════════════
                    dungeonMaps: (() => {
                        const maps = {};
                        if (data.player.dungeonMaps) {
                            for (const dungeonKey in data.player.dungeonMaps) {
                                maps[dungeonKey] = {};
                                for (const floorNum in data.player.dungeonMaps[dungeonKey]) {
                                    // Convert arrays back to Sets
                                    maps[dungeonKey][floorNum] = new Set(data.player.dungeonMaps[dungeonKey][floorNum]);
                                }
                            }
                        }
                        return maps;
                    })(),

                    // Restore enemy respawn timers (prune any that expired while offline)
                    dungeonTimers: (() => {
                        const timers = {};
                        const now = Date.now();
                        if (data.player.dungeonTimers) {
                            for (const dk in data.player.dungeonTimers) {
                                const valid = (data.player.dungeonTimers[dk] || []).filter(e => now < e.respawnTime);
                                if (valid.length > 0) timers[dk] = valid;
                            }
                        }
                        return timers;
                    })(),

                    // ═══════════════════════════════════════════════════════════════
                    // BESTIARY — restore kill counts (empty obj for old saves)
                    // ═══════════════════════════════════════════════════════════════
                    kills: Object.assign({}, data.player.kills || {}),
                    bestiaryRead: Object.assign({}, data.player.bestiaryRead || {}),

                    // ═══════════════════════════════════════════════════════════════
                    // CHRONICLE — restore lore state, initialise for old saves
                    // ═══════════════════════════════════════════════════════════════
                    chronicle: {
                        unlockedEntries: [...((data.player.chronicle && data.player.chronicle.unlockedEntries) || [])],
                        readEntries:     [...((data.player.chronicle && data.player.chronicle.readEntries)     || [])],
                    },
                };
                
                // Restore current town
                gameState.currentTown = data.currentTown || 'town1';

                // ═══════════════════════════════════════════════════════════════
                // MIGRATIONS — patch existing saves when base values change
                // ═══════════════════════════════════════════════════════════════
                const _p = gameState.player;
                const _class = _p.baseClass || _p.class;

                // Cleric MP raised from 70 → 100 starting (same as mage).
                // Each level gains +10 MP, so expected maxMp = 100 + (level-1)*10.
                // If their maxMp is below that, they were created before the change.
                if (_class === 'cleric') {
                    const expectedMaxMp = 100 + (_p.level - 1) * 10;
                    if (_p.maxMp < expectedMaxMp) {
                        const diff = expectedMaxMp - _p.maxMp;
                        _p.maxMp += diff;
                        _p.mp = Math.min(_p.mp + diff, _p.maxMp);
                        console.log(`🔧 Cleric MP migration: +${diff} MP (now ${_p.mp}/${_p.maxMp})`);
                    }
                }
                
                // ═══════════════════════════════════════════════════════════════
                // RESTORE GENERATED WEAPONS - Must happen BEFORE equipment check!
                // ═══════════════════════════════════════════════════════════════
                if (data.generatedWeapons) {
                    Object.keys(data.generatedWeapons).forEach(weaponId => {
                        WEAPONS[weaponId] = data.generatedWeapons[weaponId];
                    });
                    console.log(`✅ Restored ${Object.keys(data.generatedWeapons).length} generated weapons`);
                }
                
                // ═══════════════════════════════════════════════════════════════
                // RESTORE GENERATED ARMOR - Must happen BEFORE equipment check!
                // ═══════════════════════════════════════════════════════════════
                if (data.generatedArmor) {
                    Object.keys(data.generatedArmor).forEach(armorId => {
                        ARMOR[armorId] = data.generatedArmor[armorId];
                    });
                    console.log(`✅ Restored ${Object.keys(data.generatedArmor).length} generated armor pieces`);
                }
                
                // ═══════════════════════════════════════════════════════════════
                // EQUIPMENT MIGRATION (fix old save data with missing weapons/armor)
                // ═══════════════════════════════════════════════════════════════
                const p = gameState.player;
                
                // Check if weapon exists (null/undefined = intentionally unarmed)
                if (p.weapon && !WEAPONS[p.weapon]) {
                    console.warn(`⚠️ Weapon '${p.weapon}' not found. Migrating to bare_fists...`);
                    p.weapon = 'bare_fists';
                    console.log(`✅ Migrated weapon to: bare_fists`);
                }
                if (!p.weapon) p.weapon = 'bare_fists';
                
                // Check if armor exists (null/undefined = intentionally unarmored)
                if (p.armor && !ARMOR[p.armor]) {
                    console.warn(`⚠️ Armor '${p.armor}' not found. Migrating to no_armor...`);
                    p.armor = 'no_armor';
                    console.log(`✅ Migrated armor to: no_armor`);
                }
                if (!p.armor) p.armor = 'no_armor';
                
                // Ensure className exists (for old saves)
                if (!p.className && p.class && CLASSES[p.class]) {
                    p.className = CLASSES[p.class].name;
                    console.log(`✅ Added className: ${p.className}`);
                }

                // ═══════════════════════════════════════════════════════════════
                // ROGUE WEAPON MIGRATION — daggers only (force old rogues to comply)
                // ═══════════════════════════════════════════════════════════════
                const baseClassCheck = p.baseClass || p.class;
                if (baseClassCheck === 'rogue' && p.weapon && WEAPONS[p.weapon]) {
                    const wpn = WEAPONS[p.weapon];
                    const isDagger = wpn.classRestriction === 'rogue'
                        || (wpn.name && (wpn.name.toLowerCase().includes('dagger') || wpn.name.toLowerCase().includes('shiv')))
                        || (p.weapon && (p.weapon.toLowerCase().includes('dagger') || p.weapon.toLowerCase().includes('shiv')));
                    if (!isDagger) {
                        console.warn(`⚠️ Rogue has non-dagger weapon '${p.weapon}'. Migrating to rusty_shiv...`);
                        // Strip the non-dagger from inventory if present
                        const idx = p.inventory.indexOf(p.weapon);
                        if (idx !== -1) p.inventory.splice(idx, 1);
                        // Equip rusty_shiv
                        p.weapon = 'rusty_shiv';
                        if (!p.inventory.includes('rusty_shiv')) p.inventory.push('rusty_shiv');
                        console.log(`✅ Rogue weapon migrated to rusty_shiv`);
                    }
                }

                // ═══════════════════════════════════════════════════════════════
                // XP SYSTEM MIGRATION — running total (v2) vs per-level (v1)
                // Old saves store p.xp as XP earned within the current level
                // (always < xpToNext). New system stores p.xp as a cumulative
                // running total (always >= getXpForLevel(cls, level)).
                // We detect old saves and convert them automatically.
                // ═══════════════════════════════════════════════════════════════
                (function migrateXp(p) {
                    if (p.level <= 1) return; // Level 1 needs no migration
                    const cls = p.baseClass || p.class;
                    const levelFloor = getXpForLevel(cls, p.level);
                    if (p.xp < levelFloor) {
                        // Old-style save: p.xp is within-level XP.
                        // Convert to running total by adding the level's base threshold.
                        const oldXp = p.xp;
                        p.xp = levelFloor + oldXp;
                        console.log(`✅ XP migration: level ${p.level} ${cls} | ${oldXp} within-level → ${p.xp} running total`);
                    }
                    // Also ensure xpToNext matches the cumulative table value
                    p.xpToNext = getXpToNextLevel(cls, p.level);
                })(p);
                
                gameState.currentLocation = data.currentLocation || 'silverdale';

                // ═══════════════════════════════════════════════════════════════
                // CHRONICLE MIGRATION — retroactively unlock all entries the player
                // has earned based on their current level. This runs for both new
                // and existing players. For existing players it silently fills in
                // every entry they would have earned so far. No prompt, no friction.
                // ═══════════════════════════════════════════════════════════════
                retroactivelyUnlockChronicle(p);
                
                // Restore dungeon state if applicable
                if (data.meta?.inDungeon && data.dungeon) {
                    // Check if DUNGEONS is loaded
                    if (typeof DUNGEONS === 'undefined') {
                        console.error('⚠️ DUNGEONS not loaded! Check dungeon-data.js for syntax errors.');
                        alert('⚠️ Dungeon data failed to load. Returning to town.');
                        gameState.dungeon = null;
                        showTown();
                        return;
                    }
                    
                    console.log('🔍 Loading dungeon:', data.dungeon.dungeonKey);
                    console.log('📦 Available dungeons:', Object.keys(DUNGEONS));
                    
                    let dungeonKey = data.dungeon.dungeonKey;
                    
                    // Migrate old dungeon keys if needed
                    if (!DUNGEONS[dungeonKey]) {
                        console.warn(`⚠️ Dungeon "${dungeonKey}" not found. Attempting migration...`);
                        const availableDungeons = Object.keys(DUNGEONS);
                        if (availableDungeons.length > 0) {
                            dungeonKey = availableDungeons[0];
                            console.log(`✅ Migrated to dungeon: ${dungeonKey}`);
                        } else {
                            console.error('❌ No dungeons available!');
                            alert('⚠️ Dungeon not found. Returning to town.');
                            gameState.dungeon = null;
                            showTown();
                            return;
                        }
                    }
                    
                    const dungeon = DUNGEONS[dungeonKey];
                    
                    // ═══════════════════════════════════════════════════════════════
                    // MERGE: Load persistent map + current session discovered rooms
                    // Only merge rooms that belong to the current floor to prevent
                    // cross-floor contamination when room IDs are shared across floors.
                    // ═══════════════════════════════════════════════════════════════
                    const floorNum = data.dungeon.floor;
                    const persistentMap = loadDungeonMap(p, dungeonKey, floorNum);
                    const sessionRooms = new Set(data.dungeon.discoveredRooms || []);
                    
                    // Merge session rooms into persistent map — current floor only
                    sessionRooms.forEach(roomKey => {
                        if (roomKey.includes(':')) {
                            const [floor, roomId] = roomKey.split(':');
                            const roomFloor = parseInt(floor);
                            // Only merge rooms belonging to the current floor
                            if (roomFloor === floorNum) {
                                persistentMap.add(roomKey);
                                saveRoomDiscovery(p, dungeonKey, roomFloor, roomId);
                            } else {
                                // Save other floors to their own persistent maps but don't pollute current
                                saveRoomDiscovery(p, dungeonKey, roomFloor, roomId);
                            }
                        } else {
                            // Old unscoped format — scope to current floor
                            persistentMap.add(`${floorNum}:${roomKey}`);
                            saveRoomDiscovery(p, dungeonKey, floorNum, roomKey);
                        }
                    });
                    
                    gameState.dungeon = {
                        dungeonKey: dungeonKey,
                        floor: floorNum,
                        currentRoom: data.dungeon.currentRoom,
                        discoveredRooms: persistentMap, // Use merged map
                        spawnedRooms: new Set(data.dungeon.spawnedRooms || []),
                        activeEnemies: (data.dungeon.activeEnemies || []).map(e => ({
                            ...e,
                            isChasing: false,
                            roomsFollowed: 0
                        })),
                        defeatedEnemies: (data.dungeon.defeatedEnemies || []).map(e => ({
                            ...e
                        }))
                    };
                    
                    // ═══════════════════════════════════════════════════════════════
                    // MIGRATION: Ensure discoveredRooms only contains current-floor keys
                    // ═══════════════════════════════════════════════════════════════
                    const ds = gameState.dungeon;
                    const migratedSet = new Set();
                    ds.discoveredRooms.forEach(entry => {
                        if (entry.includes(':')) {
                            const [floor] = entry.split(':');
                            // Only keep entries for the current floor
                            if (parseInt(floor) === ds.floor) {
                                migratedSet.add(entry);
                            }
                        } else {
                            // Old format (just roomId) — scope to current floor
                            migratedSet.add(`${ds.floor}:${entry}`);
                        }
                    });
                    ds.discoveredRooms = migratedSet;
                    
                    // Open dungeon UI
                    openTerminalView(dungeonKey);
                    
                    const floor = dungeon.floors[data.dungeon.floor];
                    if (!floor) {
                        console.error(`⚠️ Floor ${data.dungeon.floor} not found!`);
                        alert('⚠️ Invalid dungeon floor. Returning to town.');
                        gameState.dungeon = null;
                        showTown();
                        return;
                    }
                    
                    const room = floor.rooms[data.dungeon.currentRoom];
                    if (!room) {
                        console.error(`⚠️ Room ${data.dungeon.currentRoom} not found!`);
                        alert('⚠️ Invalid dungeon room. Returning to town.');
                        gameState.dungeon = null;
                        showTown();
                        return;
                    }
                    
                    termAppend('', 'term-separator');
                    termAppend(`<strong>${room.name}</strong>`);
                    termAppend(room.description, 'term-dim');
                    
                    const exits = Object.keys(room.exits).map(d => d.toUpperCase()).join(', ');
                    termAppend(`You see exits: ${exits}.`, 'term-dim');
                    
                    checkEnemiesInRoom(data.dungeon.currentRoom);
                    renderDungeonActionBar();
                    
                    // Start regeneration in dungeon (normal speed)
                    startMpRegen(false);
                    startResting(false);
                } else if (data.activeCombat && data.activeCombat.monsters && data.activeCombat.monsters.length > 0) {
                    // ═══════════════════════════════════════════════════════════════
                    // RESTORE MID-COMBAT STATE - enemies still waiting from last session
                    // ═══════════════════════════════════════════════════════════════
                    const ac = data.activeCombat;
                    const p  = gameState.player;
                    
                    // Restore pip array
                    const pipCount  = ac.pipCount || calcPlayerHits(p);
                    const pipTimers = Array(pipCount).fill(10);
                    const pipReady  = ac.pipsReady || Array(pipCount).fill(true);
                    
                    gameState.combatState = {
    monsters:           ac.monsters,
    currentTarget:      ac.currentTarget || 0,
    messages:           [],
    defeatedMonsters:   [],
    pipTimers:          pipTimers,
    pipAvailable:       pipReady,
    enemyTimer:         ac.enemyDelay || 15,
    enemyDelay:         ac.enemyDelay || 15,
    enemyHits:          ac.enemyHits  || 1,
    enemyHitsLeft:      ac.enemyHitsLeft || 1,
    playerStatusEffects:  [],
    monsterStatusEffects: {},
    dotTimers:            {},
    actionMode:           'main',
    shieldActive:         false  // Warrior shield starts inactive
};
                    
                    // Open the terminal view for the saved location
                    const loc = ac.location || gameState.currentLocation;
                    gameState.currentLocation = loc;
                    gameState._terminalOpen = false;
                    openTerminalView(loc);
                    
                    // Print restoration message
                    termAppend('', 'term-separator');
                    termAppend(`<span style="color:#FF8800;">⚠️ You were mid-combat when you left!</span>`, 'term-enemy');
                    
                    const names = ac.monsters.map(m =>
                        `<span style="color:${m.rarityColor};">${m.name}</span> (${m.hp}/${m.maxHp} HP)`
                    ).join(', ');
                    termAppend(`Still fighting: ${names}`, 'term-enemy');
                    
                    // Start regen, render UI
                    startMpRegen(false);
                    startResting(false);
                    renderEnemyCards();
                    renderActionBar();
                    startCombatTimer();
                    
                    console.log(`⚔️ Restored combat: ${ac.monsters.length} enemies waiting`);
                } else {
                    maybeShowLegacyWelcome();
                }
                
                // Apply gem HP/MP/defense bonuses from equipped items
                recalcGemStats(gameState.player);
                
                console.log(`✅ Character loaded: ${data.characterName}`);
                console.log(`   Weapon: ${gameState.player.weapon} | Armor: ${gameState.player.armor}`);
            } catch (e) {
                console.error('Error loading character:', e);
                alert('⚠️ Failed to load save file. The data may be corrupted. Returning to main menu.');
                
                // Clean up corrupted state
                gameState.player = null;
                gameState.dungeon = null;
                gameState.combatState = null;
                
                // Try to delete corrupted save
                try {
                    deleteCharacter(characterId);
                } catch (deleteError) {
                    console.error('Could not delete corrupted save:', deleteError);
                }
                
                // Always return to main menu on error
                showMainMenu();
            }
        }

        function showInstructions() {
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">INSTRUCTIONS</div>
                <button onclick="showMainMenu()" style="margin-bottom:10px;">BACK TO MENU</button>

                <div class="message">
                    <p><span class="stat-label">OBJECTIVE:</span> Explore dungeons, defeat monsters, collect loot, level up, and become legendary!</p>
                </div>

                <div class="message">
                    <p><span class="stat-label">COMBAT:</span> Turn-based with a pip timer. Each pip takes ~10 seconds to recharge. Use Attack, Spell, or Potion each turn. The enemy attacks on its own timer — watch for telegraphed moves! You must have full pips restored to move to a new room.</p>
                </div>

                <div class="message">
                    <p><span class="stat-label">EXPLORATION:</span> Travel to different locations from the world map. Stronger zones have tougher enemies but better loot. You must defeat zone bosses to unlock further areas.</p>
                </div>

                <div class="message">
                    <p><span class="stat-label">PROGRESSION:</span> Gain XP and Gold from combat. Level up to increase stats, unlock new spells, and equip higher-tier gear. Visit the Temple to learn spells. Check the Shop for weapons and armor.</p>
                </div>

                <div class="message">
                    <p><span class="stat-label">SAVING:</span> The game auto-saves after most actions. Use Quick Save or Download Save File from the town menu to keep a backup.</p>
                </div>

                <div class="message" style="border-color:#FF4444;">
                    <p><span class="stat-label" style="color:#FF4444;">⚠ DUNGEON WARNING:</span></p>
                    <p>Dungeons are persistent — enemies remember where you are. If you run from a fight, <strong>enemies will follow you</strong> into the next room and immediately join any existing combat. Pulling multiple enemies is intentional — use AOE spells to handle groups!</p>
                    <p style="margin-top:6px;">You cannot move while your pips are recharging. Plan your retreat carefully — a cornered adventurer with empty pips is a dead one.</p>
                    <p style="margin-top:6px;">Dungeon keys are <strong>permanent collectibles</strong> — they never leave your inventory and are not consumed when unlocking doors. Collect them all to access deeper areas.</p>
                </div>

                <div class="message" style="border-color:#9933FF;">
                    <p><span class="stat-label" style="color:#9933FF;">🎨 ENEMY RARITY COLORS:</span></p>
                    <p>Enemy names are colored by rarity tier. Higher rarity = more HP, damage, and better drop chance:</p>
                    <p style="margin-top:6px;">
                        <span style="color:#FFFFFF;">■ Common</span> — Standard encounter, normal drops<br>
                        <span style="color:#00FF00;">■ Uncommon</span> — 30% stronger, improved drops<br>
                        <span style="color:#0099FF;">■ Rare</span> — 60% stronger, can double-attack<br>
                        <span style="color:#9933FF;">■ Epic</span> — 2× stats, multi-attacks, good loot<br>
                        <span style="color:#FF9900;">■ Legendary</span> — 2.5× stats, dangerous, rare drops<br>
                        <span style="color:#FF0000;">■ Mythic</span> — 3.5× stats, extremely deadly, best loot
                    </p>
                </div>

                <div class="message" style="border-color:#FF9900;">
                    <p><span class="stat-label" style="color:#FF9900;">🗡️ WEAPON &amp; ARMOR QUALITY:</span></p>
                    <p>Equipment has a quality tier that boosts its base stats by a percentage. Quality is shown by the item's name color:</p>
                    <p style="margin-top:6px;">
                        <span style="color:#808080;">■ Poor</span> — No bonus (base stats only)<br>
                        <span style="color:#00FF00;">■ Normal</span> — +10% stats<br>
                        <span style="color:#0099FF;">■ Rare</span> — +25% stats<br>
                        <span style="color:#9933FF;">■ Epic</span> — +40% stats<br>
                        <span style="color:#FF9900;">■ Legendary</span> — +60% stats<br>
                        <span style="color:#FF0000;">■ Godly</span> — +85% stats (extremely rare)
                    </p>
                </div>

                <div class="message" style="border-color:#00FF88;">
                    <p><span class="stat-label" style="color:#00FF88;">📦 WEAPON &amp; ARMOR DROPS:</span></p>
                    <p>Every enemy you defeat has a chance to drop a weapon or armor piece. Drop quality scales with the enemy's rarity and your current level — so a Legendary enemy killed at level 10 will drop much better gear than the same enemy at level 1.</p>
                    <p style="margin-top:6px;">Dungeon enemies with a <span style="color:#e8b84a;">🔑 key</span> always drop their key on death. Other special drops (like rare crafting materials) show up as loot in the combat results screen.</p>
                    <p style="margin-top:6px;">New drops go directly into your inventory. Use the <strong>🎒 Inventory</strong> button in the dungeon or visit Inventory from town to equip them.</p>
                </div>

                <button onclick="showMainMenu()">BACK TO MENU</button>
            `;
        }

        function showRevisionHistory() {
            const screen = document.getElementById('mainScreen');
            let html = `<div class="location-header">📋 REVISION HISTORY</div>`;
            html += `<button onclick="showMainMenu()" style="margin-bottom:10px;">BACK TO MENU</button>`;

            if (typeof REVISION_HISTORY === 'undefined' || REVISION_HISTORY.length === 0) {
                html += `<div class="message"><p style="color:#888;">No revision history available.</p></div>`;
            } else {
                REVISION_HISTORY.forEach((rev, idx) => {
                    const isLatest = idx === 0;
                    const borderCol = isLatest ? '#00FF88' : '#2a4a2a';
                    const labelHtml = isLatest
                        ? `<span style="color:#00FF88;font-size:13px;margin-left:8px;">← CURRENT</span>`
                        : '';
                    html += `
                    <div class="message" style="border-color:${borderCol};margin-bottom:10px;">
                        <div style="display:flex;align-items:baseline;flex-wrap:wrap;gap:4px;margin-bottom:6px;">
                            <span style="color:${isLatest?'#00FF88':'var(--highlight-color)'};font-size:16px;font-weight:bold;">v${rev.version}</span>
                            ${labelHtml}
                            <span style="color:#666;font-size:13px;margin-left:6px;">${rev.date}</span>
                        </div>
                        <div style="color:#aaa;font-size:14px;margin-bottom:6px;font-style:italic;">${rev.summary}</div>
                        <ul style="margin:0;padding-left:18px;font-size:13px;color:#8aaa8a;line-height:1.7;">
                            ${rev.changes.map(c => `<li>${c}</li>`).join('')}
                        </ul>
                    </div>`;
                });
            }

            html += `<button onclick="showMainMenu()">BACK TO MENU</button>`;
            screen.innerHTML = html;
        }

        function newGame() {
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">CHARACTER CREATION</div>
                <div class="message">
                    <p>Enter your character name:</p>
                    <input type="text" id="playerName" maxlength="20" placeholder="Hero Name">
                </div>
                <div class="message">
                    <p><span class="stat-label">Choose your class:</span></p>
                </div>
                <div class="character-select" id="classSelect"></div>
                <button onclick="goToStatAlloc()" id="createBtn" disabled>ALLOCATE STATS →</button>
                <button onclick="showMainMenu()">CANCEL</button>
            `;

            const classSelect = document.getElementById('classSelect');
            window._selectedClass = null;

            Object.keys(CLASSES).forEach(classKey => {
                const cd   = CLASSES[classKey];
                const card = document.createElement('div');
                card.className = 'class-card';
                card.innerHTML = `
                    <div style="color:var(--highlight-color);font-size:22px;margin-bottom:8px;">${cd.name}</div>
                    <div style="font-size:16px;margin-bottom:8px;">${cd.description}</div>
                    <div class="stat">HP: ${cd.hp} | MP: ${cd.mp}</div>
                    <div class="stat" style="color:#8aaa8a;">STR/DEF/MAG/SPD set at creation</div>
                `;
                card.onclick = () => {
                    document.querySelectorAll('.class-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    window._selectedClass = classKey;
                    document.getElementById('createBtn').disabled = false;
                };
                classSelect.appendChild(card);
            });
        }

        // ── stat allocation screen ─────────────────────────────────
        window._pendingStats = null;
        window._pendingName  = '';

        function goToStatAlloc() {
            const name = document.getElementById('playerName').value.trim();
            if (!name)                { alert('Please enter a character name!'); return; }
            if (!window._selectedClass) { alert('Please select a class!');       return; }
            window._pendingName  = name;
            window._pendingStats = Object.assign({}, CLASS_STAT_PRESETS[window._selectedClass]);
            renderStatAllocScreen();
        }

        function renderStatAllocScreen() {
            const classKey   = window._selectedClass;
            const classData  = CLASSES[classKey];
            const stats      = window._pendingStats;
            const spent      = STAT_NAMES.reduce((a,k) => a + stats[k], 0);
            const remaining  = STAT_BUDGET - spent;
            const affinities = CLASS_AFFINITIES[classKey];
            const screen     = document.getElementById('mainScreen');

            // preview derived values
            const previewHp   = classData.hp + stats.con * 5;
            const previewHits = (function(){
                let h=1;
                if(classKey==='rogue') h++;
                h += Math.floor(Math.max(0, stats.str-8)/6);
                return h;
            })();

            let rows = '';
            STAT_NAMES.forEach(s => {
                const isAff   = affinities.includes(s);
                const canUp   = remaining > 0 && stats[s] < 15;
                const canDown = stats[s] > 0;
                rows += `
                <div style="display:flex;align-items:center;gap:6px;padding:5px 0;border-bottom:1px solid #1a4a1a;flex-wrap:wrap;">
                    <span style="min-width:36px;color:${isAff?'var(--highlight-color)':'var(--text-color)'};font-weight:bold;">${STAT_LABELS[s]}</span>
                    <span style="flex:1;min-width:120px;font-size:16px;color:#8aaa8a;">${STAT_DESCS[s]}${isAff?' ★':''}</span>
                    <button onclick="statAdj('${s}',-1)" ${canDown?'':'disabled'} style="width:32px;padding:4px 0;margin:0;font-size:20px;">−</button>
                    <span style="min-width:28px;text-align:center;color:var(--highlight-color);font-size:22px;">${stats[s]}</span>
                    <button onclick="statAdj('${s}',+1)" ${canUp ?'':'disabled'} style="width:32px;padding:4px 0;margin:0;font-size:20px;">+</button>
                </div>`;
            });

            screen.innerHTML = `
                <div class="location-header">ALLOCATE STATS – ${classData.name}</div>
                <div class="message" style="border-color:var(--highlight-color);">
                    <span style="color:var(--highlight-color);">Points remaining: </span>
                    <span style="color:${remaining>0?'var(--text-color)':'var(--error-color)'};font-size:22px;">${remaining}</span>
                    <span style="color:#8aaa8a;font-size:15px;"> (★ = class affinity)</span>
                </div>
                <div style="max-width:520px;margin:0 auto;">${rows}</div>
                <div class="message" style="border-color:#005500;margin-top:12px;font-size:15px;">
                    <span style="color:#8aaa8a;">PREVIEW:</span><br>
                    <span style="color:var(--highlight-color);">HP ${previewHp}</span>
                    <span style="color:var(--border-color);"> | ATK/rd: ${previewHits}</span><br>
                    <span style="color:#8aaa8a;">Crit ${calcCritChance(stats.lck)}% | Dodge ${calcDodgeChance(stats.dex)}%</span>
                </div>
                <div style="margin-top:14px;display:flex;flex-wrap:wrap;gap:8px;">
                    <button onclick="window._pendingStats=Object.assign({},CLASS_STAT_PRESETS['${classKey}']);renderStatAllocScreen();">📋 CLASS PRESET</button>
                    <button onclick="window._pendingStats=rerollStats('${classKey}');renderStatAllocScreen();">🎲 REROLL</button>
                    <button onclick="STAT_NAMES.forEach(s=>window._pendingStats[s]=0);renderStatAllocScreen();" style="border-color:#ff4444;color:#ff4444;">🗑 RESET ALL</button>
                </div>
                <div style="margin-top:14px;">
                    <button onclick="finaliseCharacter()" ${remaining===0?'':'disabled'} style="font-size:20px;">⚔️ BEGIN ADVENTURE ⚔️</button>
                    <button onclick="newGame()">← BACK</button>
                </div>
            `;
        }

        window.statAdj = function(stat, dir) {
            const stats = window._pendingStats;
            const spent = STAT_NAMES.reduce((a,k) => a + stats[k], 0);
            if (dir > 0 && spent >= STAT_BUDGET) return;
            if (dir < 0 && stats[stat] <= 0)     return;  // can go to 0
            stats[stat] += dir;
            renderStatAllocScreen();
        };

        function finaliseCharacter() {
            const classKey  = window._selectedClass;
            const classData = CLASSES[classKey];
            const stats     = window._pendingStats;

            // Generate unique character ID
            const charId = 'char_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

            gameState.player = {
                id: charId,  // Unique character ID
                name: window._pendingName,
                class: classKey,  className: classData.name,
                level: 1,  xp: 0,  xpToNext: getXpToNextLevel(classKey, 1),
                hp: classData.hp + stats.con * 5,
                maxHp: classData.hp + stats.con * 5,
                mp: classData.mp,  maxMp: classData.mp,
                strength: classData.strength,   // legacy weapon-calc field
                defense:  classData.defense,
                magic:    classData.magic,
                speed:    classData.speed,
                gold: 100,
                bankGold: 0,  // Bank storage starts empty
                weapon: classData.startWeapon,
                armor:  classData.startArmor,
                inventory:  [classData.startWeapon, classData.startArmor],
                knownSpells: getStartingSpells(classKey),
                defeatedMasters: [],
                unlockedAreas:  ['forest'],
                // ── new stat block ──
                str: stats.str,  dex: stats.dex,  wis: stats.wis,
                cha: stats.cha,  con: stats.con,  lck: stats.lck,
                // ── stat point allocation ──
                statPoints: 0,   // earned 3 per level-up, spent in Character Stats
                // ── store base class so evolution doesn't lose class identity ──
                baseClass: classKey,
                // ── hunter pet system ──
                activePet: classKey === 'hunter' ? null : undefined,  // hunters start with no pet, others don't use this
                runeOverloadPips: classKey === 'runesmith' ? 0 : undefined  // runesmith overload charge tracker
                
            };
            gameState.currentLocation = 'town';
            
            // Auto-save new character
            saveGame();

            // Show cinematic welcome screen for new characters
            showWelcomeScreen();
        }

        function getStartingSpells(classKey) {
            // Use CLASS_SPELL_TREES to get starting spell
            if (typeof CLASS_SPELL_TREES !== 'undefined' && CLASS_SPELL_TREES[classKey]) {
                const startingSpell = CLASS_SPELL_TREES[classKey].startingSpell;
                return startingSpell ? [startingSpell] : [];
            }
            
            // Fallback for classes without spell trees (warriors, rogues, etc.)
            return [];
        }

        function showTown(townId) {
            checkGameVersion();
            document.body.classList.remove("terminal-mode");
            
            // Update current town if specified
            if (townId) gameState.currentTown = townId;
            const tid = gameState.currentTown || 'town1';

            // First-visit arrival cinematic for town2 and town3
            if ((tid === 'town2' || tid === 'town3') && gameState.player) {
                maybeShowTownArrivalCinematic(tid);
            }
            
            // Get town definition (fall back to inline data if TOWNS not loaded yet)
            const townDef = (typeof TOWNS !== 'undefined' && TOWNS[tid]) ? TOWNS[tid] : null;
            const townName = townDef ? townDef.name : 'Silverdale';
            const townDesc = townDef ? townDef.description : 'A peaceful starting town.';

            // Apply town color theme
            if (townDef && townDef.theme) {
                document.documentElement.style.setProperty('--text-color', townDef.theme);
            } else {
                document.documentElement.style.setProperty('--text-color', '#00FF41');
            }

            // Start MP/HP regen (slower in town)
            startMpRegen(true);
            startResting(true);

            const p = gameState.player;
            const screen = document.getElementById('mainScreen');

            // ── Portal option logic ───────────────────────────────────────
            // Town1: shows only if player has white_runestone OR portalUnlocked flag
            // Town2: ALWAYS shows a portal back to town1 (you got here somehow).
            //        First use of town2 portal permanently unlocks bidirectional travel
            //        (sets p.portalUnlocked = true, which also enables town1 → town2).
            const hasRunestone    = p.runestones && p.runestones.includes('white_runestone');
            const portalUnlocked  = !!p.portalUnlocked;
            let portalOption = '';

            if (tid === 'town2') {
                // Town2 always has the return portal visible
                portalOption = `
                    <div class="menu-option" onclick="usePortal('town1')"
                         style="border-color:#AA88FF;background:rgba(170,136,255,0.07);">
                        ► 🌀 PORTAL → Silverdale
                        ${!portalUnlocked ? '<span style="color:#AA88FF;font-size:12px;"> [First use unlocks permanent travel]</span>' : ''}
                    </div>`;
            } else if (tid === 'town1' && (hasRunestone || portalUnlocked)) {
                // Town1: portal visible once player has runestone OR used town2 portal
                const destDef  = (typeof TOWNS !== 'undefined' && TOWNS['town2']) ? TOWNS['town2'] : null;
                const destName = destDef ? destDef.name : 'Ashen Harbor';
                portalOption = `
                    <div class="menu-option" onclick="usePortal('town2')"
                         style="border-color:#AA88FF;background:rgba(170,136,255,0.07);">
                        ► 🌀 PORTAL → ${destName}
                        ${hasRunestone ? '<span style="color:#AA88FF;font-size:12px;"> [White Runestone ✦]</span>' : ''}
                    </div>`;
            }

            // ── Dungeon option (level-gated) ──────────────────────────────
            let dungeonOption = '';
            if (townDef && townDef.dungeonKey) {
                const dungeonReady = p.level >= (townDef.dungeonRequiredLevel || 3);
                if (dungeonReady) {
                    dungeonOption = `
                        <div class="menu-option" onclick="enterTownDungeon('${tid}')"
                             style="border-color:var(--highlight-color);">
                            ► 🏰 ${townDef.dungeonName || 'DUNGEON'}
                        </div>`;
                } else {
                    dungeonOption = `
                        <div class="menu-option" style="opacity:0.45;cursor:default;"
                             onclick="alert('${townDef.dungeonUnlockMessage || 'Not yet ready.'}')">
                            🏰 ${townDef.dungeonName || 'DUNGEON'}
                            <span style="color:var(--error-color);font-size:12px;"> [Requires Lv ${townDef.dungeonRequiredLevel || 3}]</span>
                        </div>`;
                }
            } else if (!townDef) {
                dungeonOption = `<div class="menu-option" onclick="enterDungeons()">► 🏰 DUNGEONS</div>`;
            }

            // ── Runestone badges next to town name ────────────────────────
            let runestoneBadge = '';
            if (p.runestones && p.runestones.length > 0) {
                runestoneBadge = p.runestones.map(rsId => {
                    const rs = (typeof RUNESTONES !== 'undefined') ? RUNESTONES[rsId] : null;
                    if (!rs) return '';
                    return `<span title="${rs.name}: ${rs.description}" style="color:${rs.color};margin-left:5px;font-size:14px;cursor:default;">${rs.badgeSymbol}</span>`;
                }).join('');
            }

            // ── Custom town renderer hook ─────────────────────────────────
            // If townDef defines a render() function, it owns the entire screen.
            // Used by town3 for its full elemental UI.
            if (townDef && typeof townDef.render === 'function') {
                townDef.render(screen, p, dungeonOption, portalOption);
                return;
            }

            screen.innerHTML = `
                <div class="location-header">${townName}</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>${townDesc}</p>
                    <p style="color: var(--border-color); font-size: 14px;">Modem Speed: ${currentModemSpeed}</p>
                </div>
                <div style="margin: 20px 0;">
                    <div class="menu-option" onclick="showShop()">► VISIT SHOP</div>
                    <div class="menu-option" onclick="showBank()">► 🏦 BANK (${p.bankGold || 0}g stored)</div>
                    <div class="menu-option" onclick="showCharacterStats()">► 📊 CHARACTER STATS</div>
                    <div class="menu-option" onclick="showTemple()">► ⛪ TEMPLE</div>
                    <div class="menu-option" onclick="showBlacksmith()">► ⚒️ BLACKSMITH</div>
                    ${dungeonOption}
                    <div class="menu-option" onclick="restAtInn()">► REST AT INN (${calcInnCost(p.cha)} Gold)</div>
                    <div class="menu-option" id="townInvBtn"
                        onmousedown="_invMenuDown(event)" onmouseup="_invMenuUp()" onmouseleave="_invMenuCancel()"
                        ontouchstart="_invMenuDown(event)" ontouchend="_invMenuUp()" ontouchcancel="_invMenuCancel()">► INVENTORY</div>
                    <div class="menu-option" onclick="showExplore()">► EXPLORE WORLD</div>
                    ${portalOption}
                    <div class="menu-option" onclick="showModemSettings()">► MODEM SETTINGS</div>
                    <div class="menu-option" onclick="saveGame()" style="border-color:var(--text-color);">► 💾 QUICK SAVE</div>
                    <div class="menu-option" onclick="downloadSaveFile()" style="border-color:var(--highlight-color);background:rgba(255,255,0,0.05);">► 📥 DOWNLOAD SAVE FILE</div>
                    <div class="menu-option" onclick="confirmQuitToMenu()">► ⏏ QUIT TO MENU</div>
                </div>
            `;
        }

        // ── Travel to another town via portal ──────────────────────────
        function usePortal(destTownId) {
            const p = gameState.player;
            const fromTown = gameState.currentTown || 'town1';

            // Town2 → Town1: always allowed (you're already there).
            // First time using this direction unlocks permanent bidirectional travel.
            if (fromTown === 'town2' && destTownId === 'town1') {
                if (!p.portalUnlocked) {
                    p.portalUnlocked = true;
                    saveGame();
                    // Show unlock announcement
                    const screen = document.getElementById('mainScreen');
                    const flash = document.createElement('div');
                    flash.style.cssText = 'position:fixed;top:15px;left:50%;transform:translateX(-50%);background:#0a0a0a;border:2px solid #AA88FF;padding:12px 24px;color:#AA88FF;font-size:16px;z-index:9999;text-align:center;';
                    flash.innerHTML = '🌀 <strong>Portal Unlocked!</strong><br><span style="font-size:13px;color:#ccc;">You can now travel freely between Silverdale and Ashen Harbor.</span>';
                    document.body.appendChild(flash);
                    setTimeout(() => flash.remove(), 3500);
                }
            } else if (fromTown === 'town1' && destTownId === 'town2') {
                // Town1 → Town2: requires runestone OR already unlocked
                if (!p.portalUnlocked && !(p.runestones && p.runestones.includes('white_runestone'))) {
                    alert('You need to have visited Ashen Harbor first to use this portal!');
                    return;
                }
            }

            const destDef = (typeof TOWNS !== 'undefined' && TOWNS[destTownId]) ? TOWNS[destTownId] : null;
            const destName = destDef ? destDef.name : destTownId;
            gameState.currentTown = destTownId;
            saveGame();
            showTown(destTownId);
            // Flash arrival message
            setTimeout(() => {
                const flash = document.createElement('div');
                flash.style.cssText = 'position:fixed;top:15px;left:50%;transform:translateX(-50%);background:#0a0a0a;border:2px solid #AA88FF;padding:10px 20px;color:#AA88FF;font-size:16px;z-index:9999;';
                flash.textContent = `🌀 Arrived in ${destName}`;
                document.body.appendChild(flash);
                setTimeout(() => flash.remove(), 2500);
            }, 50);
        }

        // ── Enter the dungeon attached to the current town ─────────────
        function enterTownDungeon(townId) {
            const tid = townId || gameState.currentTown || 'town1';
            const townDef = (typeof TOWNS !== 'undefined' && TOWNS[tid]) ? TOWNS[tid] : null;
            if (!townDef || !townDef.dungeonKey) {
                alert('No dungeon available here yet!');
                return;
            }
            const p = gameState.player;
            if (p.level < (townDef.dungeonRequiredLevel || 5)) {
                alert(townDef.dungeonUnlockMessage || `You must be level ${townDef.dungeonRequiredLevel} to enter!`);
                return;
            }
            if (typeof DUNGEONS === 'undefined' || !DUNGEONS[townDef.dungeonKey]) {
                alert(`⚠️ Dungeon data not loaded! Make sure ${townDef.dungeonKey}.js is in the game folder.`);
                return;
            }

            // ── Show dungeon warning modal ──────────────────────────────────
            const hasRecall  = p.inventory.includes('recall_potion');
            const dungeonName = DUNGEONS[townDef.dungeonKey].name || townDef.dungeonKey;
            const recallNote  = hasRecall
                ? `<div style="color:#00ff88;margin-top:8px;">✅ You carry a <strong>Recall Potion</strong> — you can use it to escape at any time.</div>`
                : `<div style="color:#ff4444;margin-top:8px;">❌ You do NOT have a Recall Potion!<br>
                   Visit the <strong>Shop → Potions</strong> to buy one for <span style="color:#FFD700;">5,000 gold</span> before you go.</div>`;

            // Build modal entirely with createElement — no innerHTML template literals
            // so nested quotes / special chars in dungeonName can't break the HTML
            const modal = document.createElement('div');
            modal.id = 'dungeonWarningModal';
            Object.assign(modal.style, {
                position: 'fixed', inset: '0', zIndex: '9999',
                display: 'flex', alignItems: 'center', justifyContent: 'center',
                background: 'rgba(0,0,0,0.88)', fontFamily: "'VT323',monospace",
                padding: '16px'
            });

            // Outer card — centered, full border, max-width for readability
            const card = document.createElement('div');
            Object.assign(card.style, {
                width: '100%', maxWidth: '480px',
                background: '#000',
                border: '3px double #ff4444',
                boxShadow: '0 0 40px rgba(255,0,0,0.4)',
                color: '#00ff00',
                boxSizing: 'border-box'
            });

            // Header
            const hdr = document.createElement('div');
            Object.assign(hdr.style, { padding: '14px 20px 10px', textAlign: 'center', borderBottom: '1px solid #330000' });
            hdr.innerHTML = `<div style="font-size:24px;color:#ff4444;letter-spacing:2px;">⚠️ DUNGEON WARNING ⚠️</div>
                             <div style="font-size:18px;color:#ffff00;margin-top:4px;"></div>`;
            hdr.querySelector('div + div').textContent = dungeonName; // safe text assignment
            card.appendChild(hdr);

            // Body
            const body = document.createElement('div');
            Object.assign(body.style, { padding: '12px 20px', fontSize: '15px', lineHeight: '1.6', borderBottom: '1px solid #330000' });
            body.innerHTML = `
                <div style="color:#ff8800;margin-bottom:8px;font-size:16px;">
                    ⚠️ You <strong>cannot shop or bank</strong> once inside. Prepare first!
                </div>
                <div style="color:#aaa;font-size:14px;margin-bottom:8px;">
                    Leave via: &nbsp;🌀 Recall Potion &nbsp;|&nbsp; 🚪 Walk back out &nbsp;|&nbsp; 🏙️ Portal room
                </div>`;
            // Recall note added separately so its HTML is injected cleanly
            const rn = document.createElement('div');
            rn.innerHTML = recallNote;
            body.appendChild(rn);
            card.appendChild(body);

            // Button row
            const btnRow = document.createElement('div');
            Object.assign(btnRow.style, { display: 'flex', gap: '10px', padding: '12px 20px' });

            const btnEnter = document.createElement('button');
            Object.assign(btnEnter.style, {
                flex: '1', fontFamily: "'VT323',monospace", fontSize: '22px',
                padding: '12px 8px', cursor: 'pointer',
                background: 'linear-gradient(180deg,#1a0000,#0a0000)',
                color: '#ff4444', border: '2px solid #ff4444'
            });
            btnEnter.textContent = '⚔️ ENTER';
            btnEnter.onclick = () => { modal.remove(); startDungeon(townDef.dungeonKey); };

            const btnBack = document.createElement('button');
            Object.assign(btnBack.style, {
                flex: '1', fontFamily: "'VT323',monospace", fontSize: '22px',
                padding: '12px 8px', cursor: 'pointer',
                background: 'linear-gradient(180deg,#001a00,#000a00)',
                color: '#00ff88', border: '2px solid #00ff88'
            });
            btnBack.textContent = '← BACK';
            btnBack.onclick = () => modal.remove();

            btnRow.appendChild(btnEnter);
            btnRow.appendChild(btnBack);
            card.appendChild(btnRow);
            modal.appendChild(card);
            document.body.appendChild(modal);
        }

        // ── Generic dungeon start (replaces testDungeon) ──────────────
        function startDungeon(dungeonKey) {
            document.body.classList.add("terminal-mode");
            startMpRegen(false);
            startResting(false);

            const dungeon = DUNGEONS[dungeonKey];
            const floor = dungeon.floors[1];

            // Reset only discovered state for fresh run — preserve design flags (townExit, etc.)
            Object.values(floor.rooms).forEach(r => {
                r.flags = r.flags || {};
                r.flags.discovered = false;
                // Re-arm firstDiscovery only if player doesn't have runestone yet
                if (r.flags.townExit === 'town2') {
                    const p = gameState.player;
                    const hasRunestone = p && p.runestones && p.runestones.includes('white_runestone');
                    r.flags.firstDiscovery = !hasRunestone;
                }
            });

            // ═══════════════════════════════════════════════════════════════
            // Initialize dungeon state with persistent discovered rooms
            // ═══════════════════════════════════════════════════════════════
            const persistentMap = loadDungeonMap(gameState.player, dungeonKey, 1);
            const scopedStartRoom = `1:${floor.startRoom}`;
            persistentMap.add(scopedStartRoom); // Ensure start room is always discovered
            saveRoomDiscovery(gameState.player, dungeonKey, 1, floor.startRoom);
            
            gameState.dungeon = {
                dungeonKey,
                floor: 1,
                currentRoom: floor.startRoom,
                discoveredRooms: persistentMap, // Load from persistent map
                activeEnemies: []
            };

            // ── Restore persisted enemy respawn timers ──────────────────────
            // Enemies killed in a previous visit keep their 30-min timer.
            // Expired ones (timer has elapsed) are removed so they spawn normally.
            const savedTimers = (gameState.player.dungeonTimers && gameState.player.dungeonTimers[dungeonKey]) || [];
            if (savedTimers.length > 0) {
                const now = Date.now();
                const stillPending = savedTimers.filter(e => now < e.respawnTime);
                const justRespawned = savedTimers.filter(e => now >= e.respawnTime);
                gameState.dungeon.defeatedEnemies = stillPending;
                if (!gameState.player.dungeonTimers) gameState.player.dungeonTimers = {};
                gameState.player.dungeonTimers[dungeonKey] = stillPending; // prune expired
                if (justRespawned.length > 0)
                    console.log(`♻️ ${justRespawned.length} enemy timer(s) expired — enemies will spawn normally`);
                if (stillPending.length > 0)
                    console.log(`⏱️ ${stillPending.length} enemy timer(s) still active for ${dungeonKey}`);
            }

            openTerminalView(dungeonKey);

            const room = floor.rooms[floor.startRoom];
            room.flags.discovered = true;

            termAppend('', 'term-separator');
            termAppend(`<strong>${room.name || 'Entrance'}</strong>`);
            termAppend(room.description || 'You step into the darkness.', 'term-dim');

            const exits = Object.keys(room.exits).map(d => d.toUpperCase()).join(', ');
            termAppend(`You see exits: ${exits}.`, 'term-dim');

            // Check for townExit flag at start room
            checkTownExit(room);

            saveGame();
            renderDungeonActionBar();
        }

        function showBank() {
            checkGameVersion();
            const screen = document.getElementById('mainScreen');
            const p = gameState.player;
            screen.innerHTML = `
                <div class="location-header">🏦 TOWN BANK</div>
                <button onclick="showTown()" style="margin-bottom:10px;">← BACK TO TOWN</button>
                ${renderPlayerStats()}
                <div class="message" style="border-color:var(--highlight-color);">
                    <p><strong style="color:var(--highlight-color);">💰 YOUR VAULT IS SAFE</strong></p>
                    <p style="color:#8aaa8a;">Gold stored in the bank is protected from death penalties in dungeons!</p>
                </div>
                <div class="message">
                    <p><span class="stat-label">Carried Gold:</span> <span style="color:#FFD700;">${p.gold}g</span></p>
                    <p><span class="stat-label">Bank Vault:</span> <span style="color:#00FF00;">${p.bankGold || 0}g</span></p>
                </div>
                <div style="margin: 20px 0;">
                    <div class="message">
                        <p><span class="stat-label">Deposit Gold:</span></p>
                        <input type="number" id="depositAmount" min="1" max="${p.gold}" value="${Math.min(100, p.gold)}" 
                               style="width:150px;padding:8px;background:var(--secondary-bg);color:var(--text-color);border:2px solid var(--border-color);font-family:'Courier New',monospace;font-size:16px;">
                        <button onclick="depositGold()" style="margin-left:10px;">💰 DEPOSIT</button>
                    </div>
                    <div class="message">
                        <p><span class="stat-label">Withdraw Gold:</span></p>
                        <input type="number" id="withdrawAmount" min="1" max="${p.bankGold || 0}" value="${Math.min(100, p.bankGold || 0)}" 
                               style="width:150px;padding:8px;background:var(--secondary-bg);color:var(--text-color);border:2px solid var(--border-color);font-family:'Courier New',monospace;font-size:16px;">
                        <button onclick="withdrawGold()" style="margin-left:10px;">💵 WITHDRAW</button>
                    </div>
                </div>
                <button onclick="showTown()">← BACK TO TOWN</button>
            `;
        }

        function depositGold() {
            const amount = parseInt(document.getElementById('depositAmount').value);
            const p = gameState.player;
            
            if (isNaN(amount) || amount <= 0) {
                alert('Invalid amount!');
                return;
            }
            
            if (amount > p.gold) {
                alert('You don\'t have that much gold!');
                return;
            }
            
            p.gold -= amount;
            p.bankGold = (p.bankGold || 0) + amount;
            
            saveGame();
            showBank();
        }

        function withdrawGold() {
            const amount = parseInt(document.getElementById('withdrawAmount').value);
            const p = gameState.player;
            
            if (isNaN(amount) || amount <= 0) {
                alert('Invalid amount!');
                return;
            }
            
            if (amount > (p.bankGold || 0)) {
                alert('You don\'t have that much gold in the bank!');
                return;
            }
            
            p.bankGold -= amount;
            p.gold += amount;
            
            saveGame();
            showBank();
        }

        function showModemSettings() {
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">📞 MODEM SETTINGS 📞</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>Select your connection speed:</p>
                    <p style="font-size: 14px; color: var(--border-color);">Current: ${currentModemSpeed}</p>
                </div>
                <div style="margin: 20px 0;">
                    <div class="menu-option ${currentModemSpeed === '4800' ? 'equipped' : ''}" onclick="setModemSpeed('4800')">
                        ► 4800 BAUD (Ultra Slow - Maximum Nostalgia)
                    </div>
                    <div class="menu-option ${currentModemSpeed === '9600' ? 'equipped' : ''}" onclick="setModemSpeed('9600')">
                        ► 9600 BAUD (Very Slow - Early 90s)
                    </div>
                    <div class="menu-option ${currentModemSpeed === '14.4k' ? 'equipped' : ''}" onclick="setModemSpeed('14.4k')">
                        ► 14.4k MODEM (Slow - Classic BBS Feel)
                    </div>
                    <div class="menu-option ${currentModemSpeed === '28.8k' ? 'equipped' : ''}" onclick="setModemSpeed('28.8k')">
                        ► 28.8k MODEM (Medium - Mid 90s Standard)
                    </div>
                    <div class="menu-option ${currentModemSpeed === '56k' ? 'equipped' : ''}" onclick="setModemSpeed('56k')">
                        ► 56k MODEM (Fast - Late 90s)
                    </div>
                    <div class="menu-option ${currentModemSpeed === 'instant' ? 'equipped' : ''}" onclick="setModemSpeed('instant')">
                        ► INSTANT (No Delay - Modern Broadband)
                    </div>
                </div>
                <div class="message" style="border-color: var(--highlight-color);">
                    <p style="color: var(--highlight-color);">ℹ️ INFO</p>
                    <p style="font-size: 14px;">Modem speed affects how quickly text appears on screen.</p>
                    <p style="font-size: 14px;">Lower speeds = more authentic 1990s BBS experience!</p>
                    <p style="font-size: 14px;">Combat timer won't start until screen finishes loading.</p>
                </div>
                <button onclick="showTown()">BACK TO TOWN</button>
            `;
        }

        function setModemSpeed(speed) {
            currentModemSpeed = speed;
            showModemSettings();
        }

        function renderPlayerStats() {
            const p = gameState.player;
            const hpPercent = (p.hp / p.maxHp) * 100;
            const mpPercent = (p.mp / p.maxMp) * 100;
            const xpPercent = p.xpToNext > 0 ? Math.min(100, (p.xp / p.xpToNext) * 100) : 100;
            
            // Get display class name
            let displayClass;
            if (p.hasEvolved) {
                // Show advanced class name if evolved
                displayClass = `<span style="color:#FF00FF;font-weight:bold;">${getAdvancedClassName(p)}</span>`;
            } else if (p.className) {
                // Use stored className
                displayClass = p.className;
            } else if (p.class && CLASSES[p.class]) {
                // Fallback: get from CLASSES object
                displayClass = CLASSES[p.class].name;
            } else {
                // Last resort: capitalize the class key
                displayClass = p.class ? p.class.charAt(0).toUpperCase() + p.class.slice(1) : 'Adventurer';
            }

            return `
                <div class="stats-bar">
                    <div>
                        <span class="stat-label">${p.name}${getRunestonePip(p)}</span> - Level ${p.level} ${displayClass}
                    </div>
                    <div>
                        <span class="stat-label">Gold:</span> ${p.gold}
                    </div>
                </div>
                <div class="stats-bar">
                    <div>
                        <span class="stat-label">HP:</span> <span id="townHp">${p.hp}/${p.maxHp}</span>
                    </div>
                    <div>
                        <span class="stat-label">MP:</span> <span id="townMp">${p.mp}/${p.maxMp}</span>
                    </div>
                    <div>
                        <span class="stat-label">XP:</span> ${p.xp}/${p.xpToNext}
                        <span style="color:#888;font-size:0.85em;"> (${Math.floor(((p.xp - getXpForLevel(p.baseClass||p.class, p.level)) / Math.max(1, p.xpToNext - getXpForLevel(p.baseClass||p.class, p.level))) * 100)}% to next)</span>
                    </div>
                </div>
            `;
        }

        function showShop() {
            checkGameVersion();
            const screen = document.getElementById('mainScreen');
            
            let shopHtml = `
                <div class="location-header">MERCHANT SHOP</div>
                <button onclick="showTown()" style="margin-bottom:10px;">LEAVE SHOP</button>
                ${renderPlayerStats()}
                <div class="message">
                    <p>Welcome to my shop! What can I do for you?</p>
                </div>
                <div style="margin: 20px 0;">
                    <button onclick="showShopBuy()" style="margin-right: 10px;">💰 BUY ITEMS</button>
                    <button onclick="showShopSell()">💎 SELL ITEMS</button>
                </div>
                <div id="shopContent"></div>
                <button onclick="showTown()">LEAVE SHOP</button>
            `;
            
            screen.innerHTML = shopHtml;
            showShopBuy(); // Default to buy tab
        }

        function enterDungeons() {
    checkGameVersion();
    termClear();
    testDungeon();
}


        function showShopBuy() {
            const p = gameState.player;
            const playerClass = p.baseClass || p.class;
            
            let shopHtml = `
                <div style="margin: 20px 0;">
                    <h3 style="color: var(--highlight-color);">WEAPONS</h3>
                    <div class="inventory-grid">
            `;

            Object.keys(WEAPONS).forEach(key => {
                const weapon = WEAPONS[key];
                
                // Filter by level, class, and quality — shop only sells common (normal) gear.
                // Higher quality items come from drops only. Also enforce class restrictions.
                if (!weapon.unarmed && weapon.quality === 'normal' && weapon.level <= p.level + 2 && canUseWeapon(playerClass, weapon)) {
                    const owned = p.inventory.includes(key);
                    const equipped = p.weapon === key;
                    const qualityColor = QUALITY_CONFIG[weapon.quality].color;
                    const qualityBonus = getQualityBonus(weapon.quality, weapon.baseDamage);
                    const totalDmg = weapon.baseDamage + qualityBonus;
                    const totalMag = weapon.baseMagicDamage + getQualityBonus(weapon.quality, weapon.baseMagicDamage);
                    
                    // Build modifier display
                    let modifierHtml = '';
                    if (weapon.modifiers && weapon.modifiers.length > 0) {
                        modifierHtml = '<div style="margin-top:3px;font-size:11px;">';
                        weapon.modifiers.forEach(modKey => {
                            const mod = WEAPON_MODIFIERS[modKey];
                            if (mod) {
                                modifierHtml += `<div style="color:${mod.color};">• ${mod.name}</div>`;
                            }
                        });
                        modifierHtml += '</div>';
                    }
                    
                    shopHtml += `
                        <div class="item-card ${equipped ? 'equipped' : ''}">
                            <div style="color: ${qualityColor};">${weapon.name}</div>
                            <div style="font-size:12px;">${buildWeaponDmgLine(weapon)}</div>
                            ${modifierHtml}
                            ${buildGemSlotHtml(weapon)}
                            <div>Level: ${weapon.level}</div>
                            ${owned ? '<div style="color: var(--border-color);">OWNED</div>' : 
                              `<button onclick="buyItem('weapon', '${key}', ${weapon.cost})">Buy ${weapon.cost}G</button>`}
                            ${p.cha ? '<div style="color:#8aaa8a;font-size:15px;">CHA disc: ' + calcChaDiscount(p.cha) + '%</div>' : ''}
                        </div>
                    `;
                }
            });

            shopHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">ARMOR</h3>
                    <div class="inventory-grid">
            `;

            Object.keys(ARMOR).forEach(key => {
                const armor = ARMOR[key];
                
                // Filter: shop only sells normal quality, class-appropriate armor.
                // Better armor drops from enemies. Skip virtual slots and drop-only pieces.
                if (!armor.unarmored && !armor.isDropped && armor.quality === 'normal' && armor.level <= p.level + 2 && canUseArmor(playerClass, armor)) {
                    const owned = p.inventory.includes(key);
                    const equipped = p.armor === key;
                    const qualityColor = QUALITY_CONFIG[armor.quality].color;
                    const qualityBonus = getQualityBonus(armor.quality, armor.baseDefense);
                    const totalDef = armor.baseDefense + qualityBonus;
                    const totalMag = (armor.baseMagicBonus || 0) + getQualityBonus(armor.quality, armor.baseMagicBonus || 0);
                    
                    shopHtml += `
                        <div class="item-card ${equipped ? 'equipped' : ''}">
                            <div style="color: ${qualityColor};">${armor.name}</div>
                            <div>DEF: ${totalDef}</div>
                            ${totalMag > 0 ? `<div>MAG+: ${totalMag}</div>` : ''}
                            <div>Level: ${armor.level}</div>
                            ${owned ? '<div style="color: var(--border-color);">OWNED</div>' : 
                              `<button onclick="buyItem('armor', '${key}', ${armor.cost})">Buy ${armor.cost}G</button>`}
                            ${p.cha ? '<div style="color:#8aaa8a;font-size:15px;">CHA disc: ' + calcChaDiscount(p.cha) + '%</div>' : ''}
                        </div>
                    `;
                }
            });

            shopHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">POTIONS</h3>
                    <div class="inventory-grid">
            `;

            // Add potions to shop
            const potionsForSale = ['health_potion', 'greater_health_potion', 'superior_health_potion',
                                   'mana_potion', 'greater_mana_potion', 'superior_mana_potion', 'elixir',
                                   'recall_potion'];
            
            potionsForSale.forEach(key => {
                if (ITEMS[key]) {
                    const item = ITEMS[key];
                    const p = gameState.player;

                    if (key === 'recall_potion') {
                        // Special recall potion card — one per character, dungeon use only
                        const alreadyOwned = p.inventory.includes('recall_potion');
                        shopHtml += `
                            <div class="item-card" style="border-color:#AA88FF;">
                                <div style="color:#AA88FF;font-size:17px;">🌀 ${item.name}</div>
                                <div style="color:#888;font-size:13px;font-style:italic;">${item.lore}</div>
                                <div style="color:#ffcc00;margin-top:4px;">${item.description}</div>
                                <div style="color:#ff8800;font-size:13px;">⚠ Dungeon use only · 1 per adventure</div>
                                ${alreadyOwned
                                    ? '<div style="color:#AA88FF;font-size:14px;margin-top:4px;">ALREADY OWNED</div>'
                                    : `<button onclick="buyItem('item', 'recall_potion', 1000)"
                                        style="border-color:#AA88FF;color:#AA88FF;margin-top:6px;">Buy 1000G</button>`
                                }
                            </div>
                        `;
                    } else {
                        const _held = item.maxStack ? p.inventory.filter(k => k === key).length : 0;
                        const _capped = item.maxStack && _held >= item.maxStack;
                        const _stackLabel = item.maxStack
                            ? `<span style="color:${_capped ? '#ff6666' : '#888'};font-size:12px;"> ${_held}/${item.maxStack}</span>`
                            : '';
                        shopHtml += `
                            <div class="item-card">
                                <div style="color: var(--highlight-color);">${item.name}${_stackLabel}</div>
                                <div>${item.description}</div>
                                <div>Power: ${item.power || 'Full'}</div>
                                ${_capped
                                    ? `<div style="color:#ff6666;font-size:13px;margin-top:4px;">BAG FULL (${item.maxStack}/${item.maxStack})</div>`
                                    : `<button onclick="buyItem('item', '${key}', ${item.cost})">Buy ${item.cost}G</button>`
                                }
                                ${p.cha && !_capped ? '<div style="color:#8aaa8a;font-size:15px;">CHA disc: ' + calcChaDiscount(p.cha) + '%</div>' : ''}
                            </div>
                        `;
                    }
                }
            });

            shopHtml += `
                    </div>
                </div>
            `;
            
            document.getElementById('shopContent').innerHTML = shopHtml;
        }

        function showShopSell() {
            const p = gameState.player;
            const QUALITY_ORDER = ['poor','normal','rare','epic','legendary','godly'];

            // Current sell threshold from UI (default: poor = only poor)
            const thresholdEl = document.getElementById('sellQualityThreshold');
            const threshold   = thresholdEl ? thresholdEl.value : 'poor';
            const thresholdIdx = QUALITY_ORDER.indexOf(threshold);

            // Build sellable item list
            const itemCounts = {};
            p.inventory.forEach(itemKey => {
                if (ITEMS[itemKey] && (ITEMS[itemKey].sellValue > 0)) {
                    if (!itemCounts[itemKey]) itemCounts[itemKey] = { type:'item', count:0 };
                    itemCounts[itemKey].count++;
                } else if (WEAPONS[itemKey] && itemKey !== p.weapon && !WEAPONS[itemKey].unarmed) {
                    // Group by itemKey + quality to avoid stacking different qualities
                    const wpn = WEAPONS[itemKey];
                    const groupKey = `${itemKey}__${wpn.quality || 'normal'}`;
                    if (!itemCounts[groupKey]) itemCounts[groupKey] = { type:'weapon', count:0, baseKey:itemKey, quality:wpn.quality };
                    itemCounts[groupKey].count++;
                } else if (ARMOR[itemKey] && itemKey !== p.armor && !ARMOR[itemKey].unarmored) {
                    // Group by itemKey + quality to avoid stacking different qualities
                    const arm = ARMOR[itemKey];
                    const groupKey = `${itemKey}__${arm.quality || 'normal'}`;
                    if (!itemCounts[groupKey]) itemCounts[groupKey] = { type:'armor', count:0, baseKey:itemKey, quality:arm.quality };
                    itemCounts[groupKey].count++;
                }
            });

            // Determine which items are within the sell threshold
            function getItemQualityIdx(itemKey, type) {
                if (type === 'item') return -1; // items always sellable
                if (type === 'weapon') return QUALITY_ORDER.indexOf(WEAPONS[itemKey]?.quality || 'poor');
                if (type === 'armor')  return QUALITY_ORDER.indexOf(ARMOR[itemKey]?.quality || 'poor');
                return -1;
            }

            // Count gold total for "sell all" preview
            let sellAllGold = 0;
            let sellAllCount = 0;
            Object.entries(itemCounts).forEach(([groupKey, data]) => {
                const actualKey = data.baseKey || groupKey;  // weapons/armor use baseKey
                const qIdx = getItemQualityIdx(actualKey, data.type);
                if (data.type === 'item' || qIdx <= thresholdIdx) {
                    const sv = getSellValue(actualKey, data.type);
                    sellAllGold  += sv * data.count;
                    sellAllCount += data.count;
                }
            });

            const qualityOptions = QUALITY_ORDER.map(q => {
                const cfg = QUALITY_CONFIG[q];
                return `<option value="${q}" ${q === threshold ? 'selected' : ''}>
                    ${cfg.name} and below
                </option>`;
            }).join('');

            let sellHtml = `
                <div style="margin-bottom:12px;">
                    <div style="color:var(--highlight-color);font-size:18px;margin-bottom:8px;">SELL ITEMS</div>
                    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:10px;">
                        <label style="font-size:14px;color:#aaa;">Sell threshold:</label>
                        <select id="sellQualityThreshold"
                            style="background:#111;border:1px solid var(--border-color);color:#fff;padding:4px 8px;font-size:14px;"
                            onchange="showShopSell()">
                            ${qualityOptions}
                        </select>
                        <button onclick="sellAllBelowThreshold()"
                            style="background:#222;border:1px solid #ff8c00;color:#ff8c00;padding:5px 14px;font-size:14px;cursor:pointer;">
                            💰 SELL ALL (${sellAllCount} items · ${sellAllGold}g)
                        </button>
                    </div>
                    <div style="font-size:12px;color:#666;">Items at or below the chosen quality tier will be sold. Equipped gear is never sold.</div>
                </div>
                <div class="inventory-grid">`;

            const itemKeys = Object.keys(itemCounts);
            if (itemKeys.length === 0) {
                sellHtml += '<div class="message">You have nothing to sell.</div>';
            } else {
                itemKeys.forEach(groupKey => {
                    const data = itemCounts[groupKey];
                    // For weapons/armor, use baseKey to lookup the actual item; for items, groupKey = itemKey
                    const actualItemKey = data.baseKey || groupKey;
                    const qIdx = getItemQualityIdx(actualItemKey, data.type);
                    const withinThreshold = data.type === 'item' || qIdx <= thresholdIdx;

                    let itemName, itemColor, sellValue, itemDesc, qualityLabel = '';

                    if (data.type === 'item') {
                        const item = ITEMS[actualItemKey];
                        itemName  = item.name;
                        itemColor = '#00FF00';
                        sellValue = item.sellValue;
                        itemDesc  = item.description;
                    } else if (data.type === 'weapon') {
                        const weapon = WEAPONS[actualItemKey];
                        itemName     = weapon.name;
                        itemColor    = QUALITY_CONFIG[weapon.quality]?.color || '#fff';
                        sellValue    = getSellValue(actualItemKey, 'weapon');
                        qualityLabel = QUALITY_CONFIG[weapon.quality]?.name || '';
                        const qb     = getQualityBonus(weapon.quality, weapon.baseDamage);
                        itemDesc     = `DMG: ${weapon.baseDamage+qb}`;
                    } else if (data.type === 'armor') {
                        const armor = ARMOR[actualItemKey];
                        itemName     = armor.name;
                        itemColor    = QUALITY_CONFIG[armor.quality]?.color || '#fff';
                        sellValue    = getSellValue(actualItemKey, 'armor');
                        qualityLabel = QUALITY_CONFIG[armor.quality]?.name || '';
                        const qb     = getQualityBonus(armor.quality, armor.baseDefense);
                        itemDesc     = `DEF: ${armor.baseDefense+qb}`;
                    }

                    const dimmed = !withinThreshold ? 'opacity:0.4;' : '';

                    sellHtml += `
                        <div class="item-card" style="${dimmed}">
                            <div style="color:${itemColor};">${itemName}${qualityLabel ? ` <span style="font-size:11px;">[${qualityLabel}]</span>` : ''}${data.count > 1 ? ` <span style="color:#FFD700;">x${data.count}</span>` : ''}</div>
                            <div style="font-size:14px;color:#aaa;">${itemDesc}</div>
                            <div style="color:var(--border-color);margin-top:6px;">${sellValue}g each</div>
                            ${withinThreshold
                                ? `<button onclick="sellItemGroup('${groupKey}', ${sellValue}, ${data.count})" style="margin-top:6px;">SELL${data.count > 1 ? ` ALL (${sellValue*data.count}g)` : ` (${sellValue}g)`}</button>`
                                : `<div style="font-size:11px;color:#555;margin-top:6px;">Above threshold</div>`
                            }
                        </div>`;
                });
            }
            sellHtml += '</div>';
            document.getElementById('shopContent').innerHTML = sellHtml;
        }

        // Returns sell value for a weapon or armor (10% of cost)
        function getSellValue(itemKey, type) {
            if (type === 'item') return ITEMS[itemKey]?.sellValue || 0;
            if (type === 'weapon') return Math.max(1, Math.floor((WEAPONS[itemKey]?.cost || 0) * 0.10));
            if (type === 'armor')  return Math.max(1, Math.floor((ARMOR[itemKey]?.cost  || 0) * 0.10));
            return 0;
        }

        function sellAllBelowThreshold() {
            const p = gameState.player;
            const QUALITY_ORDER = ['poor','normal','rare','epic','legendary','godly'];
            const thresholdEl = document.getElementById('sellQualityThreshold');
            const threshold   = thresholdEl ? thresholdEl.value : 'poor';
            const thresholdIdx = QUALITY_ORDER.indexOf(threshold);
            const bonus = calcChaSellBonus(p.cha);

            let totalGold = 0, totalItems = 0;
            const toRemove = [];

            // Collect items to sell (don't remove during iteration)
            p.inventory.forEach(itemKey => {
                if (ITEMS[itemKey] && ITEMS[itemKey].sellValue > 0 && !ITEMS[itemKey].maxStack) {
                    // maxStack items are potions — excluded from Sell All
                    toRemove.push({ key: itemKey, value: ITEMS[itemKey].sellValue });
                } else if (WEAPONS[itemKey] && itemKey !== p.weapon && !WEAPONS[itemKey].unarmed) {
                    const qIdx = QUALITY_ORDER.indexOf(WEAPONS[itemKey]?.quality || 'poor');
                    if (qIdx <= thresholdIdx) toRemove.push({ key: itemKey, value: getSellValue(itemKey, 'weapon') });
                } else if (ARMOR[itemKey] && itemKey !== p.armor && !ARMOR[itemKey].unarmored) {
                    const qIdx = QUALITY_ORDER.indexOf(ARMOR[itemKey]?.quality || 'poor');
                    if (qIdx <= thresholdIdx) toRemove.push({ key: itemKey, value: getSellValue(itemKey, 'armor') });
                }
            });

            if (toRemove.length === 0) {
                showShopSell(); return;
            }

            // Remove all and tally gold
            toRemove.forEach(({ key, value }) => {
                const idx = p.inventory.indexOf(key);
                if (idx !== -1) {
                    p.inventory.splice(idx, 1);
                    const actualValue = Math.floor(value * (1 + bonus/100));
                    totalGold  += actualValue;
                    totalItems++;
                }
            });

            p.gold += totalGold;
            const bonusText = bonus > 0 ? ` (+${bonus}% CHA)` : '';
            // No popup — just refresh sell panel with a brief status line
            saveGame();
            showShopSell();
            // Insert a one-line feedback message above the panel
            const content = document.getElementById('shopContent');
            const msg = document.createElement('div');
            msg.style.cssText = 'background:#111;border:1px solid #ff8c00;color:#ff8c00;padding:6px 12px;font-size:15px;margin-bottom:10px;';
            msg.textContent = `Sold ${totalItems} item${totalItems!==1?'s':''} for ${totalGold}g${bonusText}.`;
            content.prepend(msg);
            setTimeout(() => msg.remove(), 3000);
        }

        function sellItemGroup(groupKey, baseValue, quantity = 1) {
            // groupKey might be "itemKey__quality" for weapons/armor, or just "itemKey" for items
            // We need to sell the actual items from inventory that match this group
            const p = gameState.player;
            const parts = groupKey.split('__');
            const actualItemKey = parts[0];
            const targetQuality = parts[1]; // undefined for items
            
            let removed = 0;
            for (let i = p.inventory.length - 1; i >= 0 && removed < quantity; i--) {
                const invKey = p.inventory[i];
                if (typeof invKey !== 'string') continue; // skip gem objects
                // For items: match key exactly
                // For weapons/armor: match key AND quality
                if (invKey === actualItemKey || invKey.startsWith(actualItemKey)) {
                    // Check quality match for weapons/armor
                    if (targetQuality) {
                        const item = WEAPONS[invKey] || ARMOR[invKey];
                        if (item && item.quality === targetQuality) {
                            p.inventory.splice(i, 1);
                            removed++;
                        }
                    } else {
                        // No quality check needed (it's an item)
                        p.inventory.splice(i, 1);
                        removed++;
                    }
                }
            }
            if (removed === 0) return;
            const bonus      = calcChaSellBonus(p.cha);
            const unitValue  = Math.floor(baseValue * (1 + bonus/100));
            const totalValue = unitValue * removed;
            p.gold += totalValue;
            saveGame();
            showShopSell();
            // Brief inline feedback, no alert()
            const content = document.getElementById('shopContent');
            if (content) {
                const msg = document.createElement('div');
                const name = getItemName(actualItemKey);
                msg.style.cssText = 'background:#111;border:1px solid #4a9a4a;color:#4a9a4a;padding:6px 12px;font-size:15px;margin-bottom:10px;';
                msg.textContent = `Sold ${removed > 1 ? removed+'× ' : ''}${name} for ${totalValue}g.`;
                content.prepend(msg);
                setTimeout(() => msg.remove(), 2500);
            }
        }

        function showSellQuantityPrompt(itemKey, unitPrice, totalCount) {
            // Legacy path — no longer used but kept for safety
            sellItem(itemKey, unitPrice, totalCount);
        }

        function sellItem(itemKey, baseValue, quantity = 1) {
            const p = gameState.player;
            let removed = 0;
            for (let i = p.inventory.length - 1; i >= 0 && removed < quantity; i--) {
                if (p.inventory[i] === itemKey) { p.inventory.splice(i, 1); removed++; }
            }
            if (removed === 0) return;
            const bonus      = calcChaSellBonus(p.cha);
            const unitValue  = Math.floor(baseValue * (1 + bonus/100));
            const totalValue = unitValue * removed;
            p.gold += totalValue;
            saveGame();
            showShopSell();
            // Brief inline feedback, no alert()
            const content = document.getElementById('shopContent');
            if (content) {
                const msg = document.createElement('div');
                const name = getItemName(itemKey);
                msg.style.cssText = 'background:#111;border:1px solid #4a9a4a;color:#4a9a4a;padding:6px 12px;font-size:15px;margin-bottom:10px;';
                msg.textContent = `Sold ${removed > 1 ? removed+'× ' : ''}${name} for ${totalValue}g.`;
                content.prepend(msg);
                setTimeout(() => msg.remove(), 2500);
            }
        }

        function buyItem(type, key, baseCost) {
            const p = gameState.player;
            const playerClass = p.baseClass || p.class;
            
            // Recall potion: only one allowed at a time
            if (key === 'recall_potion' && p.inventory.includes('recall_potion')) {
                alert('You already carry a Recall Potion.\nYou can only hold one at a time.');
                return;
            }

            // Enforce maxStack limit (potions: 10 each)
            const _itemDef = ITEMS[key];
            if (_itemDef && _itemDef.maxStack) {
                const _held = p.inventory.filter(k => k === key).length;
                if (_held >= _itemDef.maxStack) {
                    alert(`You are already carrying the maximum (${_itemDef.maxStack}) of ${_itemDef.name}.`);
                    return;
                }
            }

            // Validate class restrictions
            if (type === 'weapon') {
                const weapon = WEAPONS[key];
                if (!canUseWeapon(playerClass, weapon)) {
                    alert(`Your class (${playerClass}) cannot use ${weapon.name}!`);
                    return;
                }
                if (weapon.level > p.level) {
                    alert(`You must be level ${weapon.level} to buy ${weapon.name}!`);
                    return;
                }
            } else if (type === 'armor') {
                const armor = ARMOR[key];
                if (!canUseArmor(playerClass, armor)) {
                    alert(`Your class (${playerClass}) cannot use ${armor.name}!`);
                    return;
                }
                if (armor.level > p.level) {
                    alert(`You must be level ${armor.level} to buy ${armor.name}!`);
                    return;
                }
            }
            
            const disc   = calcChaDiscount(p.cha);
            const cost   = Math.max(1, Math.floor(baseCost * (1 - disc/100)));
            if (p.gold < cost) {
                alert('Not enough gold!');
                return;
            }
            p.gold -= cost;
            p.inventory.push(key);
            let itemName;
            if (type === 'weapon') itemName = WEAPONS[key].name;
            else if (type === 'armor') itemName = ARMOR[key].name;
            else if (type === 'item') itemName = ITEMS[key].name;
            alert(`Purchased ${itemName} for ${cost}g!` + (disc > 0 ? ` (${disc}% CHA discount)` : ''));
            
            // 💾 AUTO-SAVE after buying
            saveGame();
            
            showShopBuy();
        }

        function restAtInn() {
            const cost = calcInnCost(gameState.player.cha);
            if (gameState.player.gold < cost) {
                alert('Not enough gold!');
                return;
            }
            gameState.player.gold -= cost;
            gameState.player.hp = gameState.player.maxHp;
            gameState.player.mp = gameState.player.maxMp;
            alert('You rest at the inn and recover fully!');
            showTown();
        }

        function showInventory() {
            checkGameVersion();
            const p = gameState.player;
            const playerClass = p.baseClass || p.class;
            const screen = document.getElementById('mainScreen');
            
            let invHtml = `
                <div class="location-header">INVENTORY</div>
                <button onclick="showTown()" style="margin-bottom:10px;">BACK</button>
                ${renderPlayerStats()}
                <div style="margin: 20px 0;">
                    <h3 style="color: var(--highlight-color);">WEAPONS</h3>
                    <div class="inventory-grid">
            `;

            // ── Currently equipped weapon slot ────────────────────────────
            const eqWeapon    = WEAPONS[p.weapon];
            const eqWIsUnarmed = !eqWeapon || !!eqWeapon.unarmed;
            if (eqWIsUnarmed) {
                invHtml += `
                    <div class="item-card equipped" style="border-color:#555;">
                        <div style="color:#888;">✊ Bare Fists</div>
                        <div style="color:#555;font-size:13px;">DMG: 0 (stats only)</div>
                        <div style="color:#555;font-size:12px;">No weapon equipped</div>
                    </div>
                `;
            } else {
                const qc   = QUALITY_CONFIG[eqWeapon.quality];
                const qb   = getQualityBonus(eqWeapon.quality, eqWeapon.baseDamage);
                const tMin = eqWeapon.baseDamage + qb;
                const tMax = eqWeapon.maxDamage ? eqWeapon.maxDamage + getQualityBonus(eqWeapon.quality, eqWeapon.maxDamage - eqWeapon.baseDamage) : tMin;
                const tMag = (eqWeapon.baseMagicDamage || 0) + Math.floor((eqWeapon.baseMagicDamage || 0) * (qc?.bonusPct || 0));
                
                // Build modifier display for equipped weapon
                let eqModifierHtml = '';
                if (eqWeapon.modifiers && eqWeapon.modifiers.length > 0) {
                    eqModifierHtml = '<div style="margin-top:5px;font-size:12px;">';
                    eqWeapon.modifiers.forEach(modKey => {
                        if (typeof WEAPON_MODIFIERS === 'undefined') {
                            eqModifierHtml += `<div style="color:#FF8800;">• ${modKey}</div>`;
                            return;
                        }
                        const mod = WEAPON_MODIFIERS[modKey];
                        if (mod) {
                            eqModifierHtml += `<div style="color:${mod.color};">• ${mod.name}`;
                            if (mod.minDamage) eqModifierHtml += ` (${mod.minDamage}-${mod.maxDamage})`;
                            eqModifierHtml += `</div>`;
                        }
                    });
                    eqModifierHtml += '</div>';
                }
                
                invHtml += `
                    <div class="item-card equipped">
                        <div style="color:${qc?.color || '#0f0'};">⚔️ ${eqWeapon.name}</div>
                        <div style="font-size:12px;">${buildWeaponDmgLine(eqWeapon)}</div>
                        ${eqModifierHtml}
                        ${buildGemSlotHtml(eqWeapon)}
                        <div style="color:var(--border-color);">EQUIPPED</div>
                        <button onclick="unequipItem('weapon')" style="border-color:#ff4444;color:#ff4444;margin-top:4px;">UNEQUIP</button>
                    </div>
                `;
            }

            // ── Other weapons in inventory ────────────────────────────────
            p.inventory.filter(item => {
                const weapon = WEAPONS[item];
                // Skip bare_fists (virtual slot) and currently equipped
                return weapon && !weapon.unarmed;
            }).forEach(key => {
                const weapon = WEAPONS[key];
                const equipped = p.weapon === key;
                if (equipped) return; // already shown in the equipped slot above
                
                const canEquip = canUseWeapon(playerClass, weapon);
                const qualityColor = QUALITY_CONFIG[weapon.quality].color;
                const qualityBonus = getQualityBonus(weapon.quality, weapon.baseDamage);
                const totalDmg = weapon.baseDamage + qualityBonus;
                const totalMag = weapon.baseMagicDamage + Math.floor(weapon.baseMagicDamage * (QUALITY_CONFIG[weapon.quality]?.bonusPct || 0));
                const totalMax = weapon.maxDamage ? weapon.maxDamage + getQualityBonus(weapon.quality, weapon.maxDamage - weapon.baseDamage) : totalDmg;
                
                // Build modifier display
                let modifierHtml = '';
                if (weapon.modifiers && weapon.modifiers.length > 0) {
                    modifierHtml = '<div style="margin-top:5px;font-size:12px;">';
                    weapon.modifiers.forEach(modKey => {
                        if (typeof WEAPON_MODIFIERS === 'undefined') {
                            console.warn('WEAPON_MODIFIERS not loaded');
                            modifierHtml += `<div style="color:#FF8800;">• ${modKey}</div>`;
                            return;
                        }
                        const mod = WEAPON_MODIFIERS[modKey];
                        if (mod) {
                            modifierHtml += `<div style="color:${mod.color};">• ${mod.name}`;
                            if (mod.minDamage) modifierHtml += ` (${mod.minDamage}-${mod.maxDamage})`;
                            modifierHtml += `</div>`;
                        } else {
                            console.warn(`Modifier ${modKey} not found in WEAPON_MODIFIERS`);
                        }
                    });
                    modifierHtml += '</div>';
                }
                
                invHtml += `
                    <div class="item-card${canEquip ? '' : ' unusable'}" style="${canEquip ? '' : 'opacity:0.5;border-color:#555;'}">
                        <div style="color: ${qualityColor};">${weapon.name}</div>
                        <div style="font-size:12px;">${buildWeaponDmgLine(weapon)}</div>
                        ${modifierHtml}
                        ${buildGemSlotHtml(weapon)}
                        ${canEquip 
                            ? `<button onclick="equipItem('weapon', '${key}')">EQUIP</button>`
                            : `<button disabled style="opacity:0.4;">CANNOT EQUIP</button>`
                        }
                    </div>
                `;
            });

            invHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">ARMOR</h3>
                    <div class="inventory-grid">
            `;

            // ── Currently equipped armor slot ─────────────────────────────
            const eqArmor      = ARMOR[p.armor];
            const eqAIsUnarmored = !eqArmor || !!eqArmor.unarmored;
            if (eqAIsUnarmored) {
                invHtml += `
                    <div class="item-card equipped" style="border-color:#555;">
                        <div style="color:#888;">🫥 No Armor</div>
                        <div style="color:#555;font-size:13px;">DEF: 0</div>
                        <div style="color:#555;font-size:12px;">No armor equipped</div>
                    </div>
                `;
            } else {
                const aqc  = QUALITY_CONFIG[eqArmor.quality];
                const aqb  = getQualityBonus(eqArmor.quality, eqArmor.baseDefense);
                const tDef = eqArmor.baseDefense + aqb;
                const tMag = (eqArmor.baseMagicBonus || 0) + Math.floor((eqArmor.baseMagicBonus || 0) * (aqc?.bonusPct || 0));
                invHtml += `
                    <div class="item-card equipped">
                        <div style="color:${aqc?.color || '#0f0'};">🛡️ ${eqArmor.name}</div>
                        <div>DEF: ${tDef}${tMag > 0 ? ` | MAG+: ${tMag}` : ''}</div>
                        <div style="color:var(--border-color);">EQUIPPED</div>
                        <button onclick="unequipItem('armor')" style="border-color:#ff4444;color:#ff4444;margin-top:4px;">UNEQUIP</button>
                    </div>
                `;
            }

            // ── Other armors in inventory ─────────────────────────────────
            p.inventory.filter(item => {
                const armor = ARMOR[item];
                // Skip no_armor (virtual slot) and currently equipped
                return armor && !armor.unarmored;
            }).forEach(key => {
                const armor = ARMOR[key];
                const equipped = p.armor === key;
                if (equipped) return; // already shown in the equipped slot above
                
                const canEquip = canUseArmor(playerClass, armor);
                const qualityColor = QUALITY_CONFIG[armor.quality].color;
                const qualityBonus = getQualityBonus(armor.quality, armor.baseDefense);
                const totalDef = armor.baseDefense + qualityBonus;
                const totalMag = (armor.baseMagicBonus || 0) + Math.floor((armor.baseMagicBonus || 0) * (QUALITY_CONFIG[armor.quality]?.bonusPct || 0));
                
                invHtml += `
                    <div class="item-card${canEquip ? '' : ' unusable'}" style="${canEquip ? '' : 'opacity:0.5;border-color:#555;'}">
                        <div style="color: ${qualityColor};">${armor.name}</div>
                        <div>DEF: ${totalDef}${totalMag > 0 ? ` | MAG+: ${totalMag}` : ''}</div>
                        ${canEquip
                            ? `<button onclick="equipItem('armor', '${key}')">EQUIP</button>`
                            : `<button disabled style="opacity:0.4;">CANNOT EQUIP</button>`
                        }
                    </div>
                `;
            });

            invHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">SPELLS</h3>
                    <div class="inventory-grid">
            `;

            if (p.knownSpells.length === 0) {
                invHtml += '<div class="message">No spells learned yet.</div>';
            } else {
                p.knownSpells.forEach(spellKey => {
                    const spell = ensureSpellExists(spellKey) || SPELLS[spellKey];
                    if (!spell) {
                        console.warn(`⚠️ Spell '${spellKey}' not found in SPELLS object (inventory display)`);
                        return; // Skip this spell
                    }
                    invHtml += `
                        <div class="item-card">
                            <div style="color: var(--highlight-color);">${spell.name}</div>
                            <div>MP Cost: ${spell.mpCost}</div>
                            <div>${spell.minPower !== undefined ? `Power: ${spell.minPower}–${spell.maxPower}` : ''}</div>
                            <div>${spell.description}</div>
                        </div>
                    `;
                });
            }

            invHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">CONSUMABLES & ITEMS</h3>
                    <div class="inventory-grid">
            `;

            // Count and display items — EXCLUDE dungeon keys (shown in Key Ring below)
            const itemCounts = {};
            p.inventory.filter(item => ITEMS[item] && ITEMS[item].subtype !== 'dungeon_key').forEach(key => {
                itemCounts[key] = (itemCounts[key] || 0) + 1;
            });

            if (Object.keys(itemCounts).length === 0) {
                invHtml += '<div class="message">No items.</div>';
            } else {
                Object.keys(itemCounts).forEach(itemKey => {
                    const item = ITEMS[itemKey];
                    const count = itemCounts[itemKey];
                    const color = item.type === 'sellable' ? '#FFD700' : 
                                 item.subtype === 'heal_hp' ? '#FF0000' :
                                 item.subtype === 'heal_mp' ? '#0000FF' : '#00FF00';
                    
                    // Check if it's a usable potion
                    const isPotion = item.subtype === 'heal_hp' || 
                                    item.subtype === 'heal_mp' || 
                                    item.subtype === 'full_restore' ||
                                    item.subtype?.startsWith('buff_');
                    
                    // Check if at full HP/MP for healing potions
                    let canUse = true;
                    let disabledReason = '';
                    if (item.subtype === 'heal_hp' && p.hp >= p.maxHp) {
                        canUse = false;
                        disabledReason = '(Already at full HP)';
                    } else if (item.subtype === 'heal_mp' && p.mp >= p.maxMp) {
                        canUse = false;
                        disabledReason = '(Already at full MP)';
                    } else if (item.subtype === 'full_restore' && p.hp >= p.maxHp && p.mp >= p.maxMp) {
                        canUse = false;
                        disabledReason = '(Already fully restored)';
                    }
                    
                    // Show total value if sellable and multiple
                    let valueDisplay = '';
                    if (item.sellValue) {
                        if (count > 1) {
                            valueDisplay = `<div style="color: var(--border-color);">${item.sellValue}g each | <span style="color:#FFD700;">Total: ${item.sellValue * count}g</span></div>`;
                        } else {
                            valueDisplay = `<div style="color: var(--border-color);">Value: ${item.sellValue}g</div>`;
                        }
                    }
                    
                    // Add USE button for potions
                    let buttonHtml = '';
                    if (isPotion) {
                        buttonHtml = canUse ? 
                            `<button onclick="useInventoryPotion('${itemKey}')">USE</button>` :
                            `<div style="color:#666;font-size:12px;">${disabledReason}</div>`;
                    }
                    
                    invHtml += `
                        <div class="item-card">
                            <div style="color: ${color};">${item.name} ${count > 1 ? `<span style="color:#FFD700;">x${count}</span>` : ''}</div>
                            <div style="font-size: 16px;">${item.description}</div>
                            ${valueDisplay}
                            ${buttonHtml}
                        </div>
                    `;
                });
            }

            invHtml += `
                    </div>
                </div>
                ${renderKeyRing(p)}
                <button onclick="showTown()">BACK</button>
            `;

            screen.innerHTML = invHtml;
        }

        function renderKeyRing(p) {
            // ── Key metadata: ASCII art + color for each key type ──
            const KEY_META = {
                bronze_key:   { color: '#cd7f32', glow: '#7a3a00', label: 'BRONZE',   ascii: '&lt;=-[O' },
                copper_key:   { color: '#b87333', glow: '#5a2800', label: 'COPPER',   ascii: '&lt;=-{O' },
                iron_key:     { color: '#8a8a8a', glow: '#333333', label: 'IRON',     ascii: '&lt;==|O' },
                brass_key:    { color: '#d4a017', glow: '#6b4c00', label: 'BRASS',    ascii: '&lt;=-&lt;O' },
                silver_key:   { color: '#c0c0c0', glow: '#555577', label: 'SILVER',   ascii: '&lt;==*O' },
                electrum_key: { color: '#88d4c0', glow: '#005544', label: 'ELECTRUM', ascii: '&lt;=~(O' },
                ruby_key:     { color: '#e0115f', glow: '#800030', label: 'RUBY',     ascii: '&lt;=-@O' },
                topaz_key:    { color: '#ffa500', glow: '#804000', label: 'TOPAZ',    ascii: '&lt;=-&Diamond;O' },
                diamond_key:  { color: '#b9f2ff', glow: '#005080', label: 'DIAMOND',  ascii: '&lt;==&lt;&gt;' },
                obsidian_key: { color: '#4a0080', glow: '#200040', label: 'OBSIDIAN', ascii: '&lt;==%O' },
                bone_key:     { color: '#e8dcc8', glow: '#5a4a2a', label: 'BONE',     ascii: '&lt;=-#O' },
            };

            // Collect dungeon keys from inventory (they persist permanently)
            const heldKeys = {};
            (p.inventory || []).forEach(itemKey => {
                if (ITEMS[itemKey] && ITEMS[itemKey].subtype === 'dungeon_key') {
                    heldKeys[itemKey] = (heldKeys[itemKey] || 0) + 1;
                }
            });

            const hasAnyKey = Object.keys(heldKeys).length > 0;

            let html = `
                <div style="margin:20px 0;">
                    <h3 style="
                        color:var(--highlight-color);
                        border-bottom:1px solid var(--border-color);
                        padding-bottom:6px;
                        margin-bottom:12px;
                        letter-spacing:3px;
                    ">⚿ KEY RING</h3>`;

            if (!hasAnyKey) {
                html += `
                    <div style="
                        font-family:monospace;
                        color:#333;
                        font-size:14px;
                        padding:12px;
                        border:1px solid #1a1a1a;
                        text-align:center;
                        letter-spacing:2px;
                    ">[ NO KEYS COLLECTED ]</div>`;
            } else {
                html += `<div style="display:flex;flex-wrap:wrap;gap:10px;">`;

                Object.entries(heldKeys).forEach(([keyId, count]) => {
                    const meta  = KEY_META[keyId] || { color:'#aaa', glow:'#333', label: keyId.replace('_key','').toUpperCase(), ascii:'&lt;=-[O' };
                    const item  = ITEMS[keyId];
                    const desc  = item ? item.description : '';
                    const cnt   = count > 1 ? ` ×${count}` : '';

                    html += `
                        <div title="${desc}" style="
                            font-family:'VT323',monospace;
                            background:#050505;
                            border:1px solid ${meta.color};
                            box-shadow:0 0 8px ${meta.glow},inset 0 0 6px #000;
                            padding:8px 14px;
                            display:inline-flex;
                            flex-direction:column;
                            align-items:center;
                            gap:4px;
                            min-width:90px;
                            cursor:default;
                            position:relative;
                        ">
                            <div style="
                                font-size:22px;
                                letter-spacing:-2px;
                                color:${meta.color};
                                text-shadow:0 0 10px ${meta.color},0 0 4px ${meta.glow};
                                line-height:1;
                            ">${meta.ascii}</div>
                            <div style="
                                font-size:13px;
                                color:${meta.color};
                                letter-spacing:2px;
                                text-shadow:0 0 6px ${meta.color};
                                line-height:1;
                            ">${meta.label}${cnt}</div>
                        </div>`;
                });

                html += `</div>`;
            }

            html += `</div>`;
            return html;
}

// Equip weapon or armor
function equipItem(type, key) {
    const p = gameState.player;
    const playerClass = p.baseClass || p.class;
            
            if (type === 'weapon') {
                const weapon = WEAPONS[key];
                if (!weapon) { alert('Invalid weapon!'); return; }
                // bare_fists always equippable (unequip path)
                if (!weapon.unarmed) {
                    if (!canUseWeapon(playerClass, weapon)) {
                        alert(`Your class (${playerClass}) cannot use ${weapon.name}!`);
                        return;
                    }
                    if (weapon.level > p.level) {
                        alert(`You must be level ${weapon.level} to equip ${weapon.name}!`);
                        return;
                    }
                }
                p.weapon = key;
            } else {
                const armor = ARMOR[key];
                if (!armor) { alert('Invalid armor!'); return; }
                // no_armor always equippable (unequip path)
                if (!armor.unarmored) {
                    if (!canUseArmor(playerClass, armor)) {
                        alert(`Your class (${playerClass}) cannot use ${armor.name}!`);
                        return;
                    }
                    if (armor.level > p.level) {
                        alert(`You must be level ${armor.level} to equip ${armor.name}!`);
                        return;
                    }
                }
                p.armor = key;
            }
            
            // 💾 Recalc gem stat bonuses (hp/mp/defense) then auto-save
            recalcGemStats(p);
            saveGame();
            updateHud();
            showInventory();
        }

        // Unequip: revert to bare fists or no armor
        function unequipItem(type) {
            const p = gameState.player;
            if (type === 'weapon') {
                p.weapon = 'bare_fists';
            } else {
                p.armor = 'no_armor';
            }
            recalcGemStats(p);
            saveGame();
            updateHud();
            showInventory();
        }

        // ═══════════════════════════════════════════════════════════════
        // USE POTION FROM INVENTORY
        // ═══════════════════════════════════════════════════════════════
        function useInventoryPotion(potionKey) {
            const potion = ITEMS[potionKey];
            const p = gameState.player;
            
            if (!potion) {
                alert('Invalid potion!');
                return;
            }

            // ── Recall Potion ──────────────────────────────────────────────
            if (potion.subtype === 'recall') {
                alert('Recall Potions can only be used while inside a dungeon.');
                return;
            }
            
            let msg = '';
            let used = false;
            
            // Handle different potion types
            if (potion.subtype === 'heal_hp') {
                if (p.hp >= p.maxHp) {
                    alert("You're already at full HP!");
                    return;
                }
                const actual = Math.min(p.maxHp - p.hp, potion.power);
                p.hp = Math.min(p.maxHp, p.hp + potion.power);
                msg = `Used ${potion.name} – restored ${actual} HP!`;
                used = true;
            } 
            else if (potion.subtype === 'heal_mp') {
                if (p.mp >= p.maxMp) {
                    alert("You're already at full MP!");
                    return;
                }
                const actual = Math.min(p.maxMp - p.mp, potion.power);
                p.mp = Math.min(p.maxMp, p.mp + potion.power);
                msg = `Used ${potion.name} – restored ${actual} MP!`;
                used = true;
            } 
            else if (potion.subtype === 'full_restore') {
                if (p.hp >= p.maxHp && p.mp >= p.maxMp) {
                    alert("You're already fully restored!");
                    return;
                }
                const hpR = p.maxHp - p.hp;
                const mpR = p.maxMp - p.mp;
                p.hp = p.maxHp;
                p.mp = p.maxMp;
                msg = `Used ${potion.name} – fully restored ${hpR} HP & ${mpR} MP!`;
                used = true;
            }
            else if (potion.subtype?.startsWith('buff_')) {
                // Apply buff
                const buffType = potion.subtype;
                const duration = potion.duration || 300000; // 5 minutes default
                
                if (!p.activeBuffs) p.activeBuffs = {};
                
                // Check if buff is already active
                if (p.activeBuffs[buffType] && Date.now() < p.activeBuffs[buffType].endTime) {
                    // Check if we can stack
                    const currentStacks = p.activeBuffs[buffType].stacks || 1;
                    if (currentStacks >= 3) {
                        alert(`${potion.name} is already at maximum stacks (3x)!`);
                        return;
                    }
                    // Stack the buff
                    p.activeBuffs[buffType].stacks = currentStacks + 1;
                    p.activeBuffs[buffType].power = potion.power * (currentStacks + 1);
                    p.activeBuffs[buffType].endTime = Date.now() + duration;
                    msg = `Used ${potion.name} – buff stacked! (${currentStacks + 1}x)`;
                } else {
                    // New buff
                    p.activeBuffs[buffType] = {
                        power: potion.power,
                        endTime: Date.now() + duration,
                        stacks: 1
                    };
                    msg = `Used ${potion.name} – buff activated!`;
                }
                used = true;
            }
            
            if (used) {
                // Remove potion from inventory
                const idx = p.inventory.indexOf(potionKey);
                if (idx !== -1) {
                    p.inventory.splice(idx, 1);
                }
                
                // Update HUD
                updateHud();
                
                // Save game
                saveGame();
                
                // Show message and refresh inventory
                alert(msg);
                showInventory();
            }
        }

        function showExplore() {
            checkGameVersion();
            const screen = document.getElementById('mainScreen');
            const p = gameState.player;
            const tid = gameState.currentTown || 'town1';
            const townDef = (typeof TOWNS !== 'undefined' && TOWNS[tid]) ? TOWNS[tid] : null;

            // Determine which zone keys belong to this town
            // A zone belongs here if: it has no 'town' field (legacy), OR its town matches current
            const townZoneKeys = townDef ? (townDef.zones || []) : null;

            // Auto-unlock zones that are not locked (level-only requirement)
            Object.keys(LOCATIONS).forEach(key => {
                const loc = LOCATIONS[key];
                if (key === 'town') return;
                // Only auto-unlock zones that belong to this town
                if (townZoneKeys && !townZoneKeys.includes(key)) return;
                
                // ALWAYS unlock forest (starter zone) regardless of level
                if (key === 'forest' && !p.unlockedAreas.includes(key)) {
                    p.unlockedAreas.push(key);
                }
                
                if (!loc.locked && loc.requiredLevel && p.level >= loc.requiredLevel) {
                    if (!p.unlockedAreas.includes(key)) {
                        p.unlockedAreas.push(key);
                    }
                }
                // Safety: strip locks that shouldn't be held
                if (loc.locked && loc.requiredLevel && p.level < loc.requiredLevel) {
                    const idx = p.unlockedAreas.indexOf(key);
                    if (idx !== -1) p.unlockedAreas.splice(idx, 1);
                }
            });

            const townName = townDef ? townDef.name : 'World';
            let exploreHtml = `
                <div class="location-header">${townName} — EXPLORE</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>Where would you like to explore?</p>
                </div>
                <div style="margin: 20px 0;">
            `;

            // Only show zones that belong to this town (or all zones if no town system)
            Object.keys(LOCATIONS).forEach(key => {
                const loc = LOCATIONS[key];
                if (key === 'town') return;
                // Filter by town
                if (townZoneKeys && !townZoneKeys.includes(key)) return;

                const levelInfo = loc.enemyLevelRange ?
                    ` (Lv ${loc.enemyLevelRange[0]}-${loc.enemyLevelRange[1]})` : '';

                const isUnlocked = p.unlockedAreas.includes(key);
                const meetsLevelReq = p.level >= (loc.requiredLevel || 1);

                // Hide zones that don't meet level requirement and aren't unlocked
                if (!isUnlocked && !meetsLevelReq) return;

                if (isUnlocked) {
                    exploreHtml += `
                        <div class="menu-option" onclick="exploreLocation('${key}')">
                            ► ${loc.name}${levelInfo} <span style="color: var(--border-color);">✓</span>
                        </div>
                    `;
                    // Show master challenge if available
                    const masterKey = `${p.baseClass || p.class}_master_${key}`;
                    if (typeof CLASS_MASTERS !== 'undefined' && CLASS_MASTERS[masterKey] && !p.defeatedMasters.includes(masterKey)) {
                        const master = CLASS_MASTERS[masterKey];
                        if (p.level >= master.requiredLevel) {
                            exploreHtml += `
                                <div class="menu-option" onclick="challengeMaster('${masterKey}')"
                                     style="border-color:var(--highlight-color);background:rgba(255,255,0,0.1);">
                                    ⚔️ CHALLENGE MASTER: ${master.name} (Lv ${master.level})
                                </div>
                            `;
                        }
                    }
                } else {
                    // Locked but level met — show with unlock requirement
                    const masterKey = typeof getMasterKeyForArea !== 'undefined' ? getMasterKeyForArea(key) : null;
                    const master = masterKey && typeof CLASS_MASTERS !== 'undefined' ? CLASS_MASTERS[masterKey] : null;
                    if (master) {
                        exploreHtml += `
                            <div class="menu-option" style="opacity:0.6;cursor:default;"
                                 onclick="alert('${loc.unlockMessage || 'Locked'}')">
                                🔒 ${loc.name}${levelInfo} - LOCKED
                            </div>
                            <div class="menu-option" onclick="challengeMaster('${masterKey}')"
                                 style="border-color:var(--error-color);background:rgba(255,0,0,0.1);">
                                ⚔️ CHALLENGE MASTER: ${master.name} (Lv ${master.level}) TO UNLOCK
                            </div>
                        `;
                    } else {
                        exploreHtml += `
                            <div class="menu-option" style="opacity:0.6;cursor:default;"
                                 onclick="alert('${loc.unlockMessage || 'Complete previous areas to unlock!'}')">
                                🔒 ${loc.name}${levelInfo} - LOCKED
                            </div>
                        `;
                    }
                }
            });

            exploreHtml += `
                </div>
                <button onclick="showTown()">RETURN TO TOWN</button>
            `;

            screen.innerHTML = exploreHtml;
        }

        function getMasterKeyForArea(areaKey) {
            // Find which master unlocks this area.
            // 'riverside' is unlocked by the forest master (index 0 → forest master unlocks riverside).
            // All other areas are unlocked by the master of the previous area in order.
            const playerClass = gameState.player.baseClass || gameState.player.class;

            // Map: area → the zone whose master unlocks it
            const unlockedBy = {
                riverside: 'forest',
                plains:    'forest',
                cave:      'plains',
                crypt:     'cave',
                volcano:   'crypt'
            };

            const sourceArea = unlockedBy[areaKey];
            if (sourceArea) {
                return `${playerClass}_master_${sourceArea}`;
            }
            return null;
        }

        function challengeMaster(masterKey) {
            const master = CLASS_MASTERS[masterKey];
            if (!master) {
                alert('Master not found!');
                return;
            }
            
            const p = gameState.player;
            
            // Check if already defeated
            if (p.defeatedMasters.includes(masterKey)) {
                alert('You have already defeated this master!');
                return;
            }
            
            // Check level requirement
            if (p.level < master.requiredLevel) {
                alert(`You need to be level ${master.requiredLevel} to challenge this master!`);
                return;
            }
            
            // Show master challenge screen
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">⚔️ MASTER CHALLENGE ⚔️</div>
                ${renderPlayerStats()}
                <div class="message" style="border-color: var(--error-color); background: rgba(255, 0, 0, 0.1);">
                    <p style="color: var(--highlight-color); font-size: 24px;">${master.name}</p>
                    <p style="color: var(--text-color); margin: 10px 0;">${master.description}</p>
                    <p style="color: var(--border-color);">Level: ${master.level} | HP: ${master.baseHp} | Defense: ${master.baseDefense}</p>
                    <p style="color: var(--error-color); margin-top: 15px;">⚠️ THIS IS A BOSS FIGHT! ⚠️</p>
                    <p>Defeating this master will unlock: <span style="color: var(--highlight-color);">${LOCATIONS[master.unlocks].name}</span></p>
                </div>
                <div class="message" style="border-color: var(--highlight-color);">
                    <p style="color: var(--highlight-color);">GUARANTEED REWARDS:</p>
                    ${master.guaranteedDrops.map(item => `<p>• ${getItemName(item)}</p>`).join('')}
                    <p style="margin-top: 10px;">+ ${master.xp} XP and ${master.gold} Gold</p>
                </div>
                <div style="margin: 20px 0;">
                    <button onclick="startMasterBattle('${masterKey}')" style="background: var(--error-color); font-size: 22px;">⚔️ BEGIN BATTLE ⚔️</button>
                    <button onclick="showExplore()">RETREAT</button>
                </div>
            `;
        }

        function startMasterBattle(masterKey) {
            const master = CLASS_MASTERS[masterKey];
            const masterMonster = {
                key: masterKey, name: master.name, rarity: 'epic',
                rarityColor: RARITY_CONFIG.epic.color,
                hp: master.baseHp, maxHp: master.baseHp,
                damage: master.baseDamage, defense: master.baseDefense,
                xp: master.xp, gold: master.gold, level: master.level,
                possibleDrops: master.possibleDrops, dropRates: master.dropRates,
                isMaster: true, masterKey: masterKey,
                guaranteedDrops: master.guaranteedDrops
            };
            const maxHits   = calcPlayerHits(gameState.player);
            const pipTimers = [];
            for (let i = 0; i < maxHits; i++) {
                pipTimers.push(10);
            }
            gameState.combatState = {
                monsters: [masterMonster], currentTarget: 0,
                messages: [], defeatedMonsters: [],
                pipTimers:     pipTimers,
                pipAvailable:  pipTimers.map(() => true),
                enemyTimer:    18,
                enemyDelay:    18,
                enemyHits:     3,
                enemyHitsLeft: 3
            };
            // Open the terminal view (clear it fresh for a boss)
            openTerminalView(gameState.currentLocation);
            // Append intro text (streaming) — but render UI immediately so player can act
            termAppend(`<span style="color:${RARITY_CONFIG.epic.color}; font-size:22px;">⚔️ ${master.name} challenges you to an honorable duel! ⚔️</span>`, 'term-highlight');
            // Render combat UI immediately — don't block on streaming intro
            renderEnemyCards();
            renderActionBar();
            startCombatTimer();
        }

        // ═══════════════════════════════════════════════════════════════
        // HUD – write once, update in place
        // ═══════════════════════════════════════════════════════════════
        function initHud() {
            updateHud();
        }
        // ── Shared helper: returns HTML ✦ pip(s) for the player's runestones ──
        // font-size:'1em' inherits parent size so pip is always same size as name
        function getRunestonePip(player) {
            if (!player || !player.runestones || !player.runestones.length) return '';
            if (typeof RUNESTONES === 'undefined') return '';
            return player.runestones.map(rsId => {
                const rs = RUNESTONES[rsId];
                return rs
                    ? `<span title="${rs.name}" style="color:${rs.color};margin-left:8px;font-size:16px;vertical-align:middle;line-height:1;">✦</span>`
                    : '';
            }).join('');
        }

        function updateHud() {
    const p = gameState.player;

    // ── helper: set element text safely ──
    const set = (id, txt) => { const el = document.getElementById(id); if (el) el.textContent = txt; };
    // ── helper: set element width% safely ──
    const setBar = (id, pct) => {
        const el = document.getElementById(id);
        if (el) el.style.width = Math.max(0, Math.min(100, pct)) + '%';
    };

    if (!p) {
        set('hudName',   '— No Adventurer —');
        set('hudHpNums', '❤️ HP: —');
        set('hudMpNums', '✨ MP: —');
        set('hudXpNums', '⭐ XP: —');
        set('hudGold',   '💰 0 g');
        setBar('sbHpFill', 0);
        setBar('sbMpFill', 0);
        setBar('sbXpFill', 0);
        return;
    }

    // ── Desktop HUD strip (name + numbers, desktop only) ──
    const runestonePip = getRunestonePip(p);
    const hudNameEl = document.getElementById('hudName');
    if (hudNameEl) {
        hudNameEl.innerHTML = `${p.name} – Lv ${p.level} ${p.className}${runestonePip}`;
    }
    set('hudHpNums', `❤️ ${p.hp}/${p.maxHp}`);
    set('hudMpNums', `✨ ${p.mp}/${p.maxMp}`);
    set('hudXpNums', `⭐ ${p.xp}/${p.xpToNext}`);
    set('hudGold',   `💰 ${p.gold}g`);

    // ── Mobile HUD strip — single line: name/level | class | gold ──
    set('mhHp',   `${p.name}  Lv${p.level}`);
    set('mhMp',   `${p.className}`);
    set('mhGold', `💰 ${p.gold}g`);

    // ── Status bars (HP / MP / XP) ──
    const hpPct = p.maxHp  > 0 ? (p.hp  / p.maxHp)  * 100 : 0;
    const mpPct = p.maxMp  > 0 ? (p.mp  / p.maxMp)  * 100 : 0;
    // XP bar: progress within current level only (0% at level-up, 100% at next level)
    const hudCls = p.baseClass || p.class;
    const xpLevelStart = getXpForLevel(hudCls, p.level);
    const xpLevelEnd   = p.xpToNext;
    const xpInLevel    = Math.max(0, p.xp - xpLevelStart);
    const xpSpan       = Math.max(1, xpLevelEnd - xpLevelStart);
    const xpPct        = Math.min(100, (xpInLevel / xpSpan) * 100);
    setBar('sbHpFill', hpPct);
    setBar('sbMpFill', mpPct);
    setBar('sbXpFill', xpPct);

    // Update HP/MP labels
    const hpLabel = document.getElementById('sbHpLabel');
    if (hpLabel) hpLabel.textContent = `HP  ${p.hp} / ${p.maxHp}`;
    const mpLabel = document.getElementById('sbMpLabel');
    if (mpLabel) mpLabel.textContent = `MP  ${p.mp} / ${p.maxMp}`;
    const xpLabel = document.getElementById('sbXpLabel');
    if (xpLabel) {
        // Show accumulated XP / total needed — bar fills from level floor to xpToNext
        xpLabel.textContent = 'XP  ' + p.xp.toLocaleString() + ' / ' + p.xpToNext.toLocaleString();
    }

    // ── Low-HP: change HP bar colour and add heartbeat ──
    const hpFill = document.getElementById('sbHpFill');
    if (hpFill) {
        if (hpPct < 25) {
            hpFill.style.background = 'linear-gradient(90deg, #880000, #ff0000)';
            hpFill.style.animation  = 'hpLowPulse 0.8s ease-in-out infinite';
        } else {
            hpFill.style.background = 'linear-gradient(90deg, #cc0000, #ff3333)';
            hpFill.style.animation  = '';
        }
    }

    // ── Low-HP heartbeat border on terminal ──
    const tw = document.getElementById('terminalWindow');
    if (tw) tw.classList.toggle('danger-heartbeat', hpPct < 15);
}


        // ═══════════════════════════════════════════════════════════════
        // TERMINAL VIEW helpers
        // ═══════════════════════════════════════════════════════════════
        
function openTerminalView(locKey) {
    // CSS body.terminal-mode handles all show/hide — just add the class
    document.body.classList.add('terminal-mode');

    const term = document.getElementById('terminalWindow');

    updateHud();
    initHud();

    if (!gameState._terminalOpen) {
        term.innerHTML = '';
        term.scrollTop = 0;

        gameState._terminalOpen = true;
        gameState._currentExploreArea = locKey;

        if (LOCATIONS?.[locKey]) {
            termAppend(`── ${LOCATIONS[locKey].name} ──`, 'term-separator');
        }
    }

    updateTerminalSafeArea();
}


function stabilizeTerminalLayout() {
    const tw = document.getElementById('terminalWindow');
    if (!tw) return;

    // Force flexbox to resolve height again
    tw.style.display = 'block';
    tw.offsetHeight;   // read triggers reflow

    // Reassert scrolling
    tw.style.overflowY = 'auto';

    // Scroll to bottom — triple rAF on mobile to survive layout shifts
    requestAnimationFrame(() => requestAnimationFrame(() => requestAnimationFrame(() => {
        tw.scrollTop = tw.scrollHeight + 9999;
    })));
}



        function closeTerminalView() {
            // Remove terminal-mode class — CSS handles all element visibility
            document.body.classList.remove('terminal-mode');
            gameState._terminalOpen = false;
            gameState._currentExploreArea = null;
        }
        // ── modem-style line queue ────────────────────────────────
        const termQueue   = [];          // pending { html, extraClass, onDone }
        let   termBusy    = false;       // true while a line is mid-stream



        function termAppend(html, extraClass, onDone) {
            termQueue.push({ html, extraClass, onDone: onDone || null });
            if (!termBusy) termDrain();
        }

        function scrollTerminalToBottom() {
    const tw = document.getElementById('terminalWindow');
    if (!tw) return;
    // Double rAF: first frame paints, second measures correct scrollHeight
    requestAnimationFrame(() => requestAnimationFrame(() => {
        tw.scrollTop = tw.scrollHeight + 9999;
    }));
}


 function termDrain() {
    if (termQueue.length === 0) {
        termBusy = false;
        return;
    }

    termBusy = true;
    const { html, extraClass, onDone } = termQueue.shift();
    const tw = document.getElementById('terminalWindow');

    // Decide whether to auto-scroll BEFORE appending so we know
    // if the user has manually scrolled up.
    // During combat: ALWAYS follow (never let new text appear off-screen).
    // Outside combat: follow only if already near the bottom (user hasn't scrolled up).
    const distFromBottom = tw.scrollHeight - tw.scrollTop - tw.clientHeight;
    const shouldAutoScroll = !!gameState.combatState || distFromBottom < 80;

    const line = document.createElement('div');
    line.className = 'term-line' + (extraClass ? ' ' + extraClass : '');
    tw.appendChild(line);

    // Inline scroll helper — fires after paint so scrollHeight is correct
    const doScroll = () => {
        if (shouldAutoScroll) {
            requestAnimationFrame(() => { tw.scrollTop = tw.scrollHeight + 9999; });
        }
    };

    // separator or empty lines — no streaming
    if (extraClass === 'term-separator' || html === '') {
        line.innerHTML = html;
        doScroll();
        if (onDone) onDone();
        termDrain();
        return;
    }

    // instant mode
    if (currentModemSpeed === 'instant') {
        line.innerHTML = html;
        doScroll();
        if (onDone) onDone();
        termDrain();
        return;
    }

    // streaming mode — scroll on EVERY tick so the line scrolls into view
    // as characters arrive, not just when it completes
    const charsPerTick = MODEM_SPEEDS[currentModemSpeed];
    let visibleCount = 0;
    let totalVisible = 0;

    {
        let inTag = false;
        for (let i = 0; i < html.length; i++) {
            if (html[i] === '<') inTag = true;
            else if (html[i] === '>') inTag = false;
            else if (!inTag) totalVisible++;
        }
    }

    const ticker = setInterval(() => {
        visibleCount += charsPerTick;

        if (visibleCount >= totalVisible) {
            clearInterval(ticker);
            line.innerHTML = html;
            doScroll();
            if (onDone) onDone();
            termDrain();
        } else {
            line.innerHTML =
                sliceToVisible(html, visibleCount) +
                '<span style="animation:blink 1s infinite;">_</span>';
            // Scroll during streaming so text stays visible as it types
            if (shouldAutoScroll) tw.scrollTop = tw.scrollHeight + 9999;
        }
    }, 16);
}



            function sliceToVisible(html, n) {
    let vis = 0;
    let inTag = false;

    for (let i = 0; i < html.length; i++) {
        if (html[i] === '<') inTag = true;
        else if (html[i] === '>') inTag = false;
        else if (!inTag) {
            vis++;
            if (vis >= n) return html.slice(0, i + 1);
        }
    }
    return html;
}


     

       function termClear() {
    const tw = document.getElementById('terminalWindow');
    tw.innerHTML = '';
    tw.scrollTop = 0;  // 🔥 RESET SCROLL TO TOP
}


        // ═══════════════════════════════════════════════════════════════
        // EXPLORE
        // ═══════════════════════════════════════════════════════════════
        function exploreLocation(locKey) {
            document.body.classList.add("terminal-mode");

            const location = LOCATIONS[locKey];
            const p = gameState.player;
            
            // Hard level gate - even if somehow unlocked, enforce min level
            if (location.requiredLevel && p.level < location.requiredLevel) {
                document.body.classList.remove("terminal-mode");
                alert(`You must be level ${location.requiredLevel} to explore ${location.name}!`);
                showExplore();
                return;
            }
            
            if (!p.unlockedAreas.includes(locKey)) {
                document.body.classList.remove("terminal-mode");
                alert(location.unlockMessage || 'This area is locked!');
                showExplore();
                return;
            }

            gameState.currentLocation = locKey;
            
            // Start regeneration when exploring (normal speed)
            startMpRegen(false);
            startResting(false);

            // If we just arrived (from town / map), open the terminal fresh
            if (!gameState._terminalOpen || gameState._currentExploreArea !== locKey) {
                gameState._terminalOpen = false;   // force fresh open
                openTerminalView(locKey);
            } else {
                // Already in this area – just add a separator
                termAppend('', 'term-separator');
            }

            // ═══════════════════════════════════════════════════════════════
            // ROLL FOR RANDOM ADVENTURE (if adventure system is loaded)
            // ═══════════════════════════════════════════════════════════════
            if (typeof rollForAdventure !== 'undefined') {
                const adventureRoll = Math.random();
                const adventureThreshold = location.adventureChance || 0.01;  // 1% rare encounter
                
                if (adventureRoll < adventureThreshold) {
                    const adventure = rollForAdventure(p.level);
                    if (adventure) {
                        startAdventure(adventure);
                        return; // Adventure takes over, no normal combat
                    }
                }
            }

            // ═══════════════════════════════════════════════════════════════
            // NORMAL COMBAT ENCOUNTER
            // ═══════════════════════════════════════════════════════════════
            if (Math.random() < 0.7) {
                const numMonsters = rollMonsterCount();
                const enemyKeys = [];
                for (let i = 0; i < numMonsters; i++) {
                    enemyKeys.push(location.encounters[Math.floor(Math.random() * location.encounters.length)]);
                }
                startCombat(enemyKeys);
            } else {
                termAppend(`You explore the area… but find nothing.`, 'term-dim');
                renderActionBar();   // show "Continue / Town" buttons
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // COMBAT – start / spawn / rarity
        // ═══════════════════════════════════════════════════════════════
        function rollMonsterCount() {
            const r = Math.random() * 100;
            if (r < 70) return 1;
            if (r < 95) return 2;
            return 3;
        }
        // ═══════════════════════════════════════════════════════════════
        // STATUS EFFECTS SYSTEM
        // ═══════════════════════════════════════════════════════════════
        
        function cleanupCombatStatusEffects() {
            const cs = gameState.combatState;
            if (!cs) return;
            
            // Clear all DOT timers
            for (const timerKey in cs.dotTimers) {
                clearInterval(cs.dotTimers[timerKey]);
            }
            cs.dotTimers = {};
            cs.playerStatusEffects = [];
            cs.monsterStatusEffects = {};
        }
        
        function applyStatusEffect(target, statusKey, isPlayer = false) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            const statusDef = STATUS_EFFECTS[statusKey];
            if (!statusDef) return;
            
            // Get target's status effects array
            let effects;
            if (isPlayer) {
                effects = cs.playerStatusEffects;
            } else {
                if (!cs.monsterStatusEffects[target.index]) {
                    cs.monsterStatusEffects[target.index] = [];
                }
                effects = cs.monsterStatusEffects[target.index];
            }
            
            // ALLOW STACKING: Each status application gets a unique ID
            // Multiple instances of the same status can exist simultaneously
            const effect = {
                type: statusKey,
                id: `${statusKey}_${Date.now()}_${Math.random()}`, // Unique ID per instance
                startTime: Date.now(),
                duration: statusDef.duration
            };
            effects.push(effect);
            
            // Show message — use applyMessage for the "caught fire" moment, message for ticks
            const targetName = isPlayer ? 'You' : target.name;
            const applyMsg = statusDef.applyMessage
                ? statusDef.applyMessage(targetName)
                : statusDef.message(targetName, '');  // empty string avoids "undefined"
            
            // Count stacks for display
            const stackCount = effects.filter(e => e.type === statusKey).length;
            const stackTag = stackCount > 1 ? ` <span style="color:#FFD700;">[x${stackCount}]</span>` : '';
            termAppend(applyMsg + stackTag, 'term-warning');
            
            // Start DOT ticks if applicable (each instance ticks independently)
            if (statusDef.type === 'dot') {
                startDOTTicks(target, effect.id, statusKey, isPlayer);
            }
            
            // Auto-remove after duration (remove THIS specific instance)
            setTimeout(() => {
                removeStatusEffectById(target, effect.id, isPlayer);
            }, statusDef.duration);
        }
        
        function removeStatusEffectById(target, effectId, isPlayer = false) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            let effects;
            if (isPlayer) {
                effects = cs.playerStatusEffects;
            } else {
                effects = cs.monsterStatusEffects[target.index] || [];
            }
            
            const index = effects.findIndex(e => e.id === effectId);
            if (index > -1) {
                effects.splice(index, 1);
                
                // Stop DOT timer for this specific instance
                const timerKey = isPlayer ? `player_${effectId}` : `monster_${target.index}_${effectId}`;
                if (cs.dotTimers[timerKey]) {
                    clearInterval(cs.dotTimers[timerKey]);
                    delete cs.dotTimers[timerKey];
                }
            }
        }
        
        function removeStatusEffect(target, statusKey, isPlayer = false) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            let effects;
            if (isPlayer) {
                effects = cs.playerStatusEffects;
            } else {
                effects = cs.monsterStatusEffects[target.index] || [];
            }
            
            // Remove ALL instances of this status type (for cleanse/cure effects)
            const toRemove = effects.filter(e => e.type === statusKey);
            toRemove.forEach(effect => {
                const index = effects.findIndex(e => e.id === effect.id);
                if (index > -1) {
                    effects.splice(index, 1);
                    
                    // Stop DOT timer if exists
                    const timerKey = isPlayer ? `player_${effect.id}` : `monster_${target.index}_${effect.id}`;
                    if (cs.dotTimers[timerKey]) {
                        clearInterval(cs.dotTimers[timerKey]);
                        delete cs.dotTimers[timerKey];
                    }
                }
            });
        }
        
        function startDOTTicks(target, effectId, statusKey, isPlayer = false) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            const statusDef = STATUS_EFFECTS[statusKey];
            if (!statusDef || statusDef.type !== 'dot') return;
            
            const timerKey = isPlayer ? `player_${effectId}` : `monster_${target.index}_${effectId}`;
            
            // Don't start if already ticking (shouldn't happen with unique IDs but safety check)
            if (cs.dotTimers[timerKey]) return;
            
            cs.dotTimers[timerKey] = setInterval(() => {
                if (!cs || !gameState.combatState) {
                    clearInterval(cs.dotTimers[timerKey]);
                    return;
                }

                // ── Stop ticking if the enemy is already dead or gone ──
                if (!isPlayer) {
                    const stillAlive = cs.monsters && cs.monsters.some(m => m === target);
                    if (!stillAlive || target.hp <= 0) {
                        clearInterval(cs.dotTimers[timerKey]);
                        delete cs.dotTimers[timerKey];
                        return;
                    }
                }
                
                const damage = statusDef.damagePerTick;
                target.hp -= damage;
                
                const targetName = isPlayer ? 'You' : target.name;
                // Tick message always has damage value — no undefined
                termAppend(statusDef.tickMessage
                    ? statusDef.tickMessage(targetName, damage)
                    : statusDef.message(targetName, damage),
                    'term-warning');
                
                updateHud();
                updateEnemyCards();
                
                // Check if target died from DOT
                if (target.hp <= 0) {
                    // Stop ticking immediately — target is dead
                    clearInterval(cs.dotTimers[timerKey]);
                    delete cs.dotTimers[timerKey];

                    if (!isPlayer) {
                        termAppend(`${target.name} succumbs to ${statusDef.name}!`, 'term-victory');
                        checkCombatEnd();
                    } else {
                        gameState.player.hp = 0;
                        checkCombatEnd();
                    }
                }
            }, statusDef.tickInterval);
        }
        
        function hasStatusEffect(target, statusKey, isPlayer = false) {
            const cs = gameState.combatState;
            if (!cs) return false;
            
            const effects = isPlayer ? cs.playerStatusEffects : (cs.monsterStatusEffects[target.index] || []);
            return effects.some(e => e.type === statusKey);
        }
        
        function getStatusEffectIcons(target, isPlayer = false) {
            const cs = gameState.combatState;
            if (!cs) return '';
            
            const effects = isPlayer ? cs.playerStatusEffects : (cs.monsterStatusEffects[target.index] || []);
            if (effects.length === 0) return '';
            
            return effects.map(effect => {
                const def = STATUS_EFFECTS[effect.type];
                return `<span title="${def.description}" style="color:${def.color};">${def.icon}</span>`;
            }).join(' ');
        }
        
        function applyWeaponModifiers(attacker, target, baseDamage, weapon) {
            if (!weapon.modifiers || weapon.modifiers.length === 0) {
                return { totalDamage: baseDamage, messages: [] };
            }
            
            let totalDamage = baseDamage;
            const messages = [];
            
            weapon.modifiers.forEach(modKey => {
                const mod = WEAPON_MODIFIERS[modKey];
                if (!mod) return;
                
                // Add elemental/bonus damage
                if (mod.minDamage !== undefined) {
                    const bonusDmg = Math.floor(Math.random() * (mod.maxDamage - mod.minDamage + 1)) + mod.minDamage;
                    totalDamage += bonusDmg;
                    messages.push(`<span style="color:${mod.color};">+${bonusDmg} ${mod.name} damage</span>`);
                }
                
                // Apply status effect chance
                if (mod.statusEffect && Math.random() < mod.statusChance) {
                    applyStatusEffect(target, mod.statusEffect, false);
                }
                
                // Apply lifesteal
                if (mod.lifestealPercent) {
                    const heal = Math.floor(totalDamage * (mod.lifestealPercent / 100));
                    attacker.hp = Math.min(attacker.maxHp, attacker.hp + heal);
                    messages.push(`<span style="color:#00FF00;">+${heal} HP (Lifesteal)</span>`);
                }
                
                // Apply crit bonus
                if (mod.critBonus) {
                    // This will be used in the attack calculation
                    // Store for now (handled in executeAttack)
                }
            });
            
            return { totalDamage, messages };
        }
        
        // ═══════════════════════════════════════════════════════════════
        // COMBAT FUNCTIONS
        // ═══════════════════════════════════════════════════════════════
        
        function startCombat(enemyKeys, useZoneLevel = true, forcedRarities = null) {
            // Stop resting when combat starts
            stopResting();
            
            if (!Array.isArray(enemyKeys)) enemyKeys = [enemyKeys];
            const monsters = enemyKeys.map((k, index) => {
                const fr = forcedRarities ? (forcedRarities[index] || null) : null;
                const monster = spawnMonsterWithRarity(k, useZoneLevel, fr);
                monster.index = index; // Add index for status effect tracking
                return monster;
            });

            let msg;
            if (monsters.length === 1) {
                const m0 = monsters[0];
                const lvlDiff = (m0.level || 1) - (gameState.player.level || 1);
                const lvlColor = lvlDiff > 2 ? '#ff4444' : lvlDiff > 0 ? '#ff8c00' : lvlDiff < 0 ? '#88ff88' : '#aaa';
                const lvlTag = `<span style="color:${lvlColor};font-size:14px;"> [Lv.${m0.level || '?'}]</span>`;
                msg = `A wild <span style="color:${m0.rarityColor};">${m0.name}</span>${lvlTag} appears!`;
            } else {
                const names = monsters.map(m => {
                    const lvlDiff = (m.level||1) - (gameState.player.level||1);
                    const lvlColor = lvlDiff > 2 ? '#ff4444' : lvlDiff > 0 ? '#ff8c00' : lvlDiff < 0 ? '#88ff88' : '#aaa';
                    return `<span style="color:${m.rarityColor};">${m.name}</span><span style="color:${lvlColor};"> Lv.${m.level||'?'}</span>`;
                }).join(', ');
                msg = `${monsters.length} enemies appear: ${names}!`;
            }

            // All enemies attack once per cycle regardless of rarity
            const eHits = 1;

            const enemyDelay = 12 + Math.floor(Math.random()*4);  // 12-15s, fixed for this combat
            const maxHits    = calcPlayerHits(gameState.player);
            const pipTimers  = [];
            for (let i = 0; i < maxHits; i++) {
                pipTimers.push(10);  // each pip starts at 10s
            }
            gameState.combatState = {
                monsters, currentTarget: 0,
                messages: [], defeatedMonsters: [],
                pipTimers:     pipTimers,    // array of timers, one per pip
                pipAvailable:  pipTimers.map(() => true),  // which pips are ready
                enemyTimer:    enemyDelay,
                enemyDelay:    enemyDelay,
                enemyHits:     eHits,
                enemyHitsLeft: eHits,
                // ═══════════════════════════════════════════════════════════
                // STATUS EFFECTS SYSTEM
                // ═══════════════════════════════════════════════════════════
                playerStatusEffects: [], // Active status effects on player
                monsterStatusEffects: {}, // Active status effects per monster (by index)
                dotTimers: {} // DOT tick interval IDs
            };
            // Stream the encounter line immediately; render combat UI without waiting
            termAppend(msg, 'term-enemy');
            renderEnemyCards();
            renderActionBar();
            setTimeout(updatePipButtons, 0);
            startCombatTimer();
        }

        function spawnMonsterWithRarity(enemyKey, zoneLevel = null, forcedRarity = null) {
            const template = ENEMIES[enemyKey];
            // Dungeon enemies pass a forcedRarity (default 'common' = no random roll).
            // Exploration enemies always roll randomly (forcedRarity = null).
            const rarity   = (forcedRarity && RARITY_CONFIG[forcedRarity]) ? forcedRarity : rollRarity();
            const mult     = RARITY_CONFIG[rarity].multiplier;
            
            // Determine monster level (use template level for dungeons, zone level for exploration)
            let monsterLevel = template.level;
            if (zoneLevel !== null && zoneLevel !== false) {
                // Random level within zone range (exploration zones only)
                const location = LOCATIONS[gameState.currentLocation];
                if (location && location.enemyLevelRange) {
                    const [minLvl, maxLvl] = location.enemyLevelRange;
                    monsterLevel = minLvl + Math.floor(Math.random() * (maxLvl - minLvl + 1));
                }
            }
            
            // Scale stats based on monster level
            const levelMult = 1 + (monsterLevel - 1) * 0.10; // 10% increase per level
            
            // ── Damage variance: use template min/max if available, otherwise calculate from baseDamage ──
            let scaledMin, scaledMax, scaledAvg;
            
            if (template.minDamage !== undefined && template.maxDamage !== undefined) {
                // Use template's predefined min/max damage
                scaledMin = Math.max(1, Math.floor(template.minDamage * mult * levelMult));
                scaledMax = Math.max(scaledMin + 1, Math.floor(template.maxDamage * mult * levelMult));
                scaledAvg = Math.floor((scaledMin + scaledMax) / 2);
            } else {
                // Fallback: calculate from baseDamage (±33% variance)
                scaledAvg = Math.floor(template.baseDamage * mult * levelMult);
                scaledMin = Math.max(1, Math.round(scaledAvg * 0.67));
                scaledMax = Math.max(scaledMin + 1, Math.round(scaledAvg * 1.33));
            }

            const monster = {
                key: enemyKey, 
                name: template.name, 
                rarity, 
                rarityColor: RARITY_CONFIG[rarity].color,
                hp: Math.floor(template.baseHp * mult * levelMult), 
                maxHp: Math.floor(template.baseHp * mult * levelMult),
                // damage is the average (kept for backwards-compat); min/max used in combat
                damage:    scaledAvg,
                minDamage: scaledMin,
                maxDamage: scaledMax,
                defense: Math.floor(template.baseDefense * mult * levelMult),
                xp: Math.floor(template.baseXp * mult * levelMult),
                gold: Math.floor(template.baseGold * mult * levelMult),
                level: monsterLevel, 
                possibleDrops: template.possibleDrops, 
                dropRates: template.dropRates,
                // Copy abilities array from template (these are read-only behavior data,
                // not scaled — they reference the original objects directly)
                abilities: template.abilities || [],
                isBoss: template.isBoss || false,
                magicAttack: template.magicAttack || false,
            };

            // ── Phase II: enemy MP ───────────────────────────────────
            // Each ability that costs MP gets exactly 2 casts worth of MP.
            // If multiple abilities have mpCost, use the highest (one pool).
            // Enemies with no mpCost abilities get 0 MP (irrelevant).
            const _abils = monster.abilities || [];
            const _maxMpCost = _abils.reduce((max, a) => Math.max(max, a.mpCost || 0), 0);
            monster.baseMp = _maxMpCost * 2;   // enough for exactly 2 ability uses
            monster.mp     = monster.baseMp;
            monster.mpDepleted = false;         // flag: fires "exhausted" debug once
            
            return monster;
        }
        
        function calculateXpReward(monster, playerLevel) {
            // Dynamic XP based on level difference and rarity
            const levelDiff = monster.level - playerLevel;
            
            // Base XP from monster
            let xp = monster.xp;
            
            // Level difference multiplier
            // Same level: 100%
            // 1 level higher: 120%
            // 2 levels higher: 140%
            // 1 level lower: 80%
            // 5+ levels lower: 10%
            let levelMult = 1.0;
            
            if (levelDiff >= 5) {
                levelMult = 2.0; // Huge bonus for fighting much stronger enemies
            } else if (levelDiff >= 3) {
                levelMult = 1.6;
            } else if (levelDiff >= 1) {
                levelMult = 1.0 + (levelDiff * 0.2);
            } else if (levelDiff === 0) {
                levelMult = 1.0;
            } else if (levelDiff >= -2) {
                levelMult = 1.0 + (levelDiff * 0.1); // 90%, 80%
            } else if (levelDiff >= -5) {
                levelMult = 0.5;
            } else {
                levelMult = 0.1; // Killing gray mobs gives almost nothing
            }
            
            // Rarity bonus (already in base XP, but add a small extra)
            const rarityBonus = RARITY_CONFIG[monster.rarity].multiplier * 0.1;
            
            xp = Math.floor(xp * levelMult * (1 + rarityBonus));
            
            // Minimum 1 XP
            return Math.max(1, xp);
        }
        
        function rollRarity() {
            const roll = Math.random() * 100;
            let cum = 0;
            for (const [rarity, config] of Object.entries(RARITY_CONFIG)) {
                cum += config.spawnWeight;
                if (roll < cum) return rarity;
            }
            return 'common';
        }
        function getRarityText(rarity) {
            return `<span style="color:${RARITY_CONFIG[rarity].color}; font-weight:bold;">${RARITY_CONFIG[rarity].name}</span>`;
        }

        // ═══════════════════════════════════════════════════════════════
        // ENEMY CARDS – rendered into terminal, updated in place
        // ═══════════════════════════════════════════════════════════════
        function renderEnemyCards() {
            // Enemy info is now shown only in terminal messages - no visual cards needed
            // This function is still called for compatibility but does nothing
        }
        function updateEnemyCards() {
            // No longer needed - enemy info shown in terminal only
        }

        // ═══════════════════════════════════════════════════════════════
        // ACTION BAR – combat buttons / explore buttons / spell & potion menus
        // ═══════════════════════════════════════════════════════════════
        
       // ═══════════════════════════════════════════════════════════════
       // PERSISTENT DUNGEON MAP HELPERS
       // ═══════════════════════════════════════════════════════════════
       
       function ensureDungeonMapStructure(player, dungeonKey, floorNum) {
           // Initialize dungeonMaps if it doesn't exist
           if (!player.dungeonMaps) player.dungeonMaps = {};
           if (!player.dungeonMaps[dungeonKey]) player.dungeonMaps[dungeonKey] = {};
           if (!player.dungeonMaps[dungeonKey][floorNum]) player.dungeonMaps[dungeonKey][floorNum] = new Set();
       }
       
       function saveRoomDiscovery(player, dungeonKey, floorNum, roomId) {
           // Save to persistent map
           ensureDungeonMapStructure(player, dungeonKey, floorNum);
           const scopedKey = `${floorNum}:${roomId}`;
           player.dungeonMaps[dungeonKey][floorNum].add(scopedKey);
       }
       
       function loadDungeonMap(player, dungeonKey, floorNum) {
           // Return the persistent discovered rooms for this dungeon+floor
           ensureDungeonMapStructure(player, dungeonKey, floorNum);
           return new Set(player.dungeonMaps[dungeonKey][floorNum]);
       }
       
       // ═══════════════════════════════════════════════════════════════
       // DUNGEON MAP SYSTEM
       // ═══════════════════════════════════════════════════════════════
       
       function showDungeonMap() {
           const ds = gameState.dungeon;
           if (!ds) return;
           
           if (typeof DUNGEONS === 'undefined') {
               alert('Dungeon data not loaded!');
               return;
           }
           
           const dungeon = DUNGEONS[ds.dungeonKey];
           const floor = dungeon.floors[ds.floor];
           
           // Build ASCII map (pass floor number for scoped keys)
           const mapAscii = generateAsciiMap(floor, ds.currentRoom, ds.discoveredRooms, ds.floor);
           
           // Show map in terminal
           const term = document.getElementById('terminalWindow');
           term.innerHTML = `
               <div style="font-family: monospace; white-space: pre; line-height: 1.2; color: var(--text-color);">
                   <div style="text-align: center; margin-bottom: 10px; color: var(--highlight-color);">
                       === ${dungeon.name} - Floor ${ds.floor} ===
                   </div>
                   <div style="text-align: center; margin-bottom: 15px; color: #8aaa8a; font-size: 14px;">
                       Legend: [@] = You | [ ] = Room | [?] = Undiscovered | <span style="color:#FF4444;">[T]</span> = Trap | <span style="color:#FFD700;">[H]</span> = Start
                   </div>
${mapAscii}
               </div>
           `;
           
           // Update action bar
           const ab = document.getElementById('actionBar');
           ab.innerHTML = '<button onclick="hideDungeonMap()">⬅ BACK TO DUNGEON</button>';
       }
       
       function hideDungeonMap() {
           const ds = gameState.dungeon;
           if (!ds) return;
           
           // Store combat state before clearing
           const wasInCombat = !!gameState.combatState;
           
           termClear();
           
           // Redraw current room
           const dungeon = DUNGEONS[ds.dungeonKey];
           const floor = dungeon.floors[ds.floor];
           const room = floor.rooms[ds.currentRoom];
           
           termAppend('', 'term-separator');
           termAppend(`<strong>${room.name}</strong>`);
           termAppend(room.description, 'term-dim');
           
           const exits = Object.keys(room.exits).map(d => d.toUpperCase()).join(', ');
           termAppend(`You see exits: ${exits}.`, 'term-dim');
           
           // Restore combat state + action bar (renderDungeonActionBar handles both combat and exploration)
           renderDungeonActionBar();
       }
       
       function generateAsciiMap(floor, currentRoom, discoveredRooms, floorNum) {
           const rooms = floor.rooms;
           
           // Helper to build floor-scoped key
           const scopedKey = (roomId) => `${floorNum}:${roomId}`;
           
           // Find map bounds
           let minX = Infinity, maxX = -Infinity;
           let minY = Infinity, maxY = -Infinity;
           
           Object.keys(rooms).forEach(roomId => {
               const room = rooms[roomId];
               if (room.map && discoveredRooms.has(scopedKey(roomId))) {
                   minX = Math.min(minX, room.map.x);
                   maxX = Math.max(maxX, room.map.x);
                   minY = Math.min(minY, room.map.y);
                   maxY = Math.max(maxY, room.map.y);
               }
           });
           
           // Create grid (each room takes 4 chars wide, 2 chars tall for spacing)
           const cellWidth = 4;
           const cellHeight = 2;
           const width = (maxX - minX + 1) * cellWidth + 1;
           const height = (maxY - minY + 1) * cellHeight + 1;
           const grid = Array(height).fill(null).map(() => Array(width).fill(' '));
           
           // Helper to get grid position
           const toGridX = (mapX) => (mapX - minX) * cellWidth;
           const toGridY = (mapY) => (mapY - minY) * cellHeight;
           
           // First pass: Draw all connections
           Object.keys(rooms).forEach(roomId => {
               const room = rooms[roomId];
               if (!room.map || !discoveredRooms.has(scopedKey(roomId))) return;
               
               const x = toGridX(room.map.x);
               const y = toGridY(room.map.y);
               
               // Draw connections to discovered rooms
               Object.keys(room.exits).forEach(dir => {
                   const targetId = room.exits[dir];
                   const targetRoom = rooms[targetId];
                   
                   if (!targetRoom || !targetRoom.map || !discoveredRooms.has(scopedKey(targetId))) return;
                   
                   const direction = dir.toLowerCase();
                   
                   if (direction === 'n') {
                       grid[y - 1][x + 1] = '|';
                   } else if (direction === 's') {
                       grid[y + 2][x + 1] = '|';
                   } else if (direction === 'e') {
                       grid[y + 1][x + 3] = '-';
                   } else if (direction === 'w') {
                       grid[y + 1][x - 1] = '-';
                   } else if (direction === 'ne') {
                       grid[y][x + 2] = '/';
                   } else if (direction === 'nw') {
                       grid[y][x] = '\\';
                   } else if (direction === 'se') {
                       grid[y + 2][x + 2] = '\\';
                   } else if (direction === 'sw') {
                       grid[y + 2][x] = '/';
                   }
               });
           });
           
           // Second pass: Draw rooms (overwrites connections at room positions)
           Object.keys(rooms).forEach(roomId => {
               const room = rooms[roomId];
               if (!room.map || !discoveredRooms.has(scopedKey(roomId))) return;
               
               const x = toGridX(room.map.x);
               const y = toGridY(room.map.y);
               
               // Draw room with markers
               const isPlayer = roomId === currentRoom;
               const isStart = roomId === floor.startRoom && gameState.dungeon.floor === 1;
               
               const hasTrap = room.contents?.trap;
               
               grid[y + 1][x] = '[';
               if (isPlayer) {
                   grid[y + 1][x + 1] = '@'; // Player
               } else if (hasTrap) {
                   grid[y + 1][x + 1] = 'T'; // Trap (red)
               } else if (isStart) {
                   grid[y + 1][x + 1] = 'H'; // Home/start (yellow)
               } else {
                   grid[y + 1][x + 1] = ' '; // Empty room
               }
               grid[y + 1][x + 2] = ']';
           });
           
           // Convert grid to string with proper coloring
           let result = '';
           for (let y = 0; y < height; y++) {
               let line = '';
               for (let x = 0; x < width; x++) {
                   const char = grid[y][x];
                   if (char === '@') {
                       line += `<span style="color:var(--highlight-color);">${char}</span>`;
                   } else if (char === 'T') {
                       line += `<span style="color:#FF4444;">${char}</span>`; // Red for trap
                   } else if (char === 'H') {
                       line += `<span style="color:#FFD700;">${char}</span>`; // Yellow for home/start
                   } else if (char === '[' || char === ']') {
                       line += `<span style="color:var(--border-color);">${char}</span>`;
                   } else {
                       line += char;
                   }
               }
               result += line + '\n';
           }
           
           return result;
       }

       function renderDungeonActionBar() {
    const ab = document.getElementById('actionBar');

    function updateTerminalSafeArea() {
        // No-op with fixed flex layout
    }

    // Clear action bar
    ab.innerHTML = '';
    ab.style.display = 'block';

    const ds = gameState.dungeon;
    if (!ds) return;

    // Safety check for DUNGEONS
    if (typeof DUNGEONS === 'undefined') {
        console.error('⚠️ DUNGEONS not loaded!');
        ab.innerHTML = '<button onclick="returnToTown()">⚠️ ERROR - Return to Town</button>';
        return;
    }

    const dungeon = DUNGEONS[ds.dungeonKey];
    const floor = dungeon.floors[ds.floor];
    const room = floor.rooms[ds.currentRoom];

    const cs = gameState.combatState;
    
    // ═══ COMBAT BUTTONS (if in combat) ═══
if (cs) {
    const maxHits  = cs.pipAvailable
        ? cs.pipAvailable.length
        : calcPlayerHits(gameState.player);

    const hitsLeft = cs.pipAvailable
        ? cs.pipAvailable.filter(x => x).length
        : maxHits;

    const canAct = hitsLeft > 0;
    const pips = '●'.repeat(hitsLeft) + '○'.repeat(maxHits - hitsLeft);
    const mode = cs.actionMode || 'main';

    const combatDiv = document.createElement('div');
    combatDiv.style.cssText =
        'border-bottom:1px solid var(--border-color);padding-bottom:6px;margin-bottom:6px;';

    /* ───────── MAIN COMBAT MENU ───────── */
    if (mode === 'main') {
        const p = gameState.player;
        const isHunter    = (p.baseClass || p.class) === 'hunter';
        const isWarrior   = (p.baseClass || p.class) === 'warrior';
        const isRunesmith = (p.baseClass || p.class) === 'runesmith';
        const trapBtn   = isHunter  ? `<button onclick="(castTrap())" ${p.mp < 10 ? 'disabled' : ''} class="pip-btn" title="Set Trap [T]" style="border-color:#8B4513;">🪤<span class="kb-hint">T</span></button>` : '';
        const shieldBtn = isWarrior ? `<button onclick="playerDefend()" ${!canAct ? 'disabled' : ''} title="Shield — 70% to halve damage">🛡️</button>` : '';

        // Runesmith: overload pip display on spell button, fire glow on attack when charged
        const overloadPips = isRunesmith ? (p.runeOverloadPips || 0) : 0;
        const overloadReady = overloadPips >= 3;
        const pip1 = overloadPips >= 1 ? '🔶' : '⬛';
        const pip2 = overloadPips >= 2 ? '🔶' : '⬛';
        const pip3 = overloadPips >= 3 ? '🔶' : '⬛';
        const attackBtn = isRunesmith
            ? `<button onclick="showAttackMenu()" ${!canAct?'disabled':''} class="pip-btn" id="pipBtn-attack" style="${overloadReady ? 'border-color:#FF4400;animation:runeOverloadPulse 0.7s ease-in-out infinite;outline-offset:0;' : ''}">⚒️</button>`
            : `<button onclick="showAttackMenu()" ${!canAct?'disabled':''} class="pip-btn" id="pipBtn-attack" title="Attack">⚔️</button>`;
        const spellBtn = isRunesmith
            ? `<button onclick="showSpellMenu()" ${!canAct?'disabled':''} class="pip-btn" id="pipBtn-spell" title="Cast Rune" style="border-color:#c8a000;"><span style="font-size:9px;display:block;line-height:1;">${overloadReady ? '⚡READY' : pip1+pip2+pip3}</span>✨</button>`
            : `<button onclick="showSpellMenu()"  ${!canAct?'disabled':''} class="pip-btn" id="pipBtn-spell" title="Spell">✨</button>`;

        combatDiv.innerHTML = `
            <div style="color:var(--highlight-color);font-size:13px;margin-bottom:3px;text-align:center;letter-spacing:3px;">${pips}</div>
            <div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:center;">
                ${attackBtn}
                ${spellBtn}
                ${shieldBtn}
                ${trapBtn}
                <button onclick="attemptFlee()"    ${!canAct ? 'disabled' : ''} title="Flee">🏃</button>
                <button onclick="printStatsToTerminal()" title="Show Stats" style="border-color:#4488ff;">📊</button>
            </div>
        `;
    }

    /* ───────── ATTACK TYPE MENU ───────── */
    else if (mode === 'attack_type') {
        const normalCost  = 1;
        const heavyCost   = 2;
        const showSpecial = hitsLeft >= 3;

        combatDiv.innerHTML = `
            <div style="color:var(--highlight-color);font-size:14px;margin-bottom:4px;text-align:center;">
                ATTACK TYPE
            </div>
            <div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:center;">
                <button onclick="selectAttackType('normal')" ${hitsLeft < normalCost ? 'disabled' : ''}>
                    ⚔️ Normal
                </button>
                <button onclick="selectAttackType('heavy')" ${hitsLeft < heavyCost ? 'disabled' : ''}
                    title="35% miss — hits for 3x!">
                    💥 Heavy<span style="font-size:10px;color:#ff8c00;"> ⚠</span>
                </button>
                ${showSpecial ? `<button onclick="selectAttackType('special')">⭐ Special</button>` : ''}
                <button onclick="cancelAction()">❌</button>
            </div>
        `;
    }

    /* ───────── TARGET SELECTION ───────── */
    else if (mode === 'target_attack' || mode === 'target_spell') {
        const targetBtns = cs.monsters.map((m, i) => `
            <button onclick="executeTargetedAction(${i})">
                #${i + 1} ${m.name}<br>
                <span style="font-size:11px;">HP ${m.hp}/${m.maxHp}</span>
            </button>
        `).join('');

        combatDiv.innerHTML = `
            <div style="color:var(--highlight-color);font-size:14px;margin-bottom:4px;text-align:center;">
                TARGET
            </div>
            <div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:center;">
                ${targetBtns}
                <button onclick="cancelAction()">❌</button>
            </div>
        `;
    }

    /* ───────── SPELL LIST ───────── */
    else if (mode === 'spell_list') {
        const spells = gameState.player.knownSpells || [];

        const spellBtns = spells.map(sk => {
            const spell = SPELLS[sk];
            const disabled = !canAct || gameState.player.mp < spell.mpCost;
            return `
                <button onclick="selectSpell('${sk}')" ${disabled ? 'disabled' : ''}>
                    ${spell.name}<br>
                    <span style="font-size:11px;">${spell.mpCost} MP</span>
                </button>
            `;
        }).join('');

        combatDiv.innerHTML = `
            <div style="color:var(--highlight-color);font-size:14px;margin-bottom:4px;text-align:center;">
                SPELL
            </div>
            <div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:center;">
                ${spellBtns}
                <button onclick="cancelAction()">❌</button>
            </div>
        `;
    }

    actionBar.appendChild(combatDiv);
}


    // ═══ NAVIGATION BUTTONS (always visible) ═══
    const canMove = !cs || !cs.pipAvailable || cs.pipAvailable.every(x => x);
    
    // Show pip status if in combat/recovery
    if (cs && cs.pipAvailable && !canMove) {
        const available = cs.pipAvailable.filter(x => x).length;
        const total = cs.pipAvailable.length;
        const pips = '●'.repeat(available) + '○'.repeat(total - available);
        
        const statusDiv = document.createElement('div');
        statusDiv.style.cssText = 'color:#8aaa8a;font-size:12px;margin-bottom:4px;text-align:center;';
        statusDiv.innerHTML = `⏳ Resting to move: ${pips} (${available}/${total})`;
        ab.appendChild(statusDiv);
    }

    // ═══ STATIC COMPASS + UTILITY ROW ═══════════════════════════════
    // All 8 compass directions always rendered; exits light up, walls grey out.
    // Keyboard input field alongside for typed navigation.

    const navWrap = document.createElement('div');
    navWrap.style.cssText = 'display:flex;align-items:center;gap:6px;flex-wrap:wrap;justify-content:center;';

    // ── 3×3 compass grid ─────────────────────────────────────────────
    // Layout: NW N NE / W · E / SW S SE
    const compassGrid = document.createElement('div');
    compassGrid.id = 'dungeonCompass';
    compassGrid.style.cssText = 'display:grid;grid-template-columns:repeat(3,40px);grid-template-rows:repeat(3,36px);gap:3px;';

    // [row][col] → direction key (null = centre cell)
    const compassMap = [
        ['nw', 'n',  'ne'],
        ['w',  null, 'e' ],
        ['sw', 's',  'se']
    ];
    const compassLabel = {nw:'NW',n:'N',ne:'NE',w:'W',e:'E',sw:'SW',s:'S',se:'SE'};

    compassMap.forEach(row => {
        row.forEach(dir => {
            if (dir === null) {
                // Centre cell — blank spacer
                const spacer = document.createElement('div');
                spacer.style.cssText = 'width:40px;height:36px;display:flex;align-items:center;justify-content:center;';
                spacer.innerHTML = '<span style="color:#1a3a1a;font-size:10px;">✦</span>';
                compassGrid.appendChild(spacer);
                return;
            }
            const hasExit = !!(room.exits && room.exits[dir]);
            const btn = document.createElement('button');
            btn.id = `dBtn-${dir}`;
            btn.textContent = compassLabel[dir];
            btn.title = hasExit ? `Go ${dir.toUpperCase()}` : 'No exit';
            // Always present, styled to show open vs walled
            if (hasExit && canMove) {
                btn.onclick = () => dungeonNav(dir);
                btn.style.cssText = `
                    width:40px;height:36px;padding:0;font-size:13px;font-weight:bold;
                    border:2px solid var(--border-color);background:#0a1a0a;
                    color:var(--text-color);cursor:pointer;`;
            } else if (hasExit && !canMove) {
                // Exit exists but pips not ready
                btn.disabled = true;
                btn.style.cssText = `
                    width:40px;height:36px;padding:0;font-size:13px;font-weight:bold;
                    border:2px solid #1a3a1a;background:#050a05;
                    color:#2a5a2a;cursor:not-allowed;opacity:0.5;`;
            } else {
                // Wall — no exit
                btn.disabled = true;
                btn.style.cssText = `
                    width:40px;height:36px;padding:0;font-size:13px;font-weight:bold;
                    border:2px solid #111;background:#070707;
                    color:#1a1a1a;cursor:default;`;
            }
            compassGrid.appendChild(btn);
        });
    });
    navWrap.appendChild(compassGrid);

    // ── Utility column: Map + Town/Exit + Ladder + keyboard input ────
    const utilCol = document.createElement('div');
    utilCol.style.cssText = 'display:flex;flex-direction:column;gap:3px;align-items:stretch;min-width:60px;';

    // MAP button
    const mapBtn = document.createElement('button');
    mapBtn.textContent = '🗺️ Map';
    mapBtn.onclick = showDungeonMap;
    mapBtn.style.cssText = 'padding:4px 6px;font-size:12px;border-color:var(--highlight-color);';
    utilCol.appendChild(mapBtn);

    // Entrance/town-exit button
    if (ds.currentRoom === floor.startRoom && gameState.dungeon.floor === 1) {
        const startRoom = floor.rooms[floor.startRoom];
        const exitTown  = startRoom.flags?.townExit || null;
        const exitLabel = startRoom.flags?.townExitLabel || '⬅ Town';
        const exitBtn   = document.createElement('button');
        exitBtn.innerHTML = exitLabel;
        exitBtn.onclick = () => returnToTown(exitTown || gameState.currentTown);
        exitBtn.style.cssText = 'padding:4px 6px;font-size:12px;';
        utilCol.appendChild(exitBtn);
    } else {
        const curRoom = floor.rooms[ds.currentRoom];
        if (curRoom?.flags?.townExit) {
            const townId    = curRoom.flags.townExit;
            const label     = curRoom.flags.townExitLabel || `Exit`;
            const portalBtn = document.createElement('button');
            portalBtn.innerHTML = label;
            portalBtn.onclick = () => townExitFromDungeon(townId);
            portalBtn.style.cssText = 'padding:4px 6px;font-size:12px;border-color:#AA88FF;color:#AA88FF;';
            utilCol.appendChild(portalBtn);
        }
    }

    // Ladder button (if present)
    if (room.contents?.ladder) {
        const ladderDir = room.contents.ladder.direction;
        const ladderBtn = document.createElement('button');
        ladderBtn.textContent = ladderDir === 'up' ? '⬆ Up' : '⬇ Down';
        ladderBtn.title = ladderDir === 'up'
            ? `Floor ${room.contents.ladder.leadsTo.floor}`
            : `Floor ${room.contents.ladder.leadsTo.floor}`;
        ladderBtn.onclick = () => dungeonNav(ladderDir);
        ladderBtn.disabled = !canMove;
        ladderBtn.style.cssText = 'padding:4px 6px;font-size:12px;border-color:#FFD700;color:#FFD700;';
        if (!canMove) ladderBtn.style.opacity = '0.4';
        utilCol.appendChild(ladderBtn);
    }

    // ── INVENTORY button (replaces keyboard input) ───────────────────
    const invBtn = document.createElement('button');
    // Count HP and MP potions for the badge
    const invP = gameState.player;
    let hpPotCount = 0, mpPotCount = 0;
    (invP.inventory || []).forEach(ik => {
        const it = ITEMS[ik];
        if (!it) return;
        if (it.subtype === 'heal_hp' || it.subtype === 'full_restore') hpPotCount++;
        if (it.subtype === 'heal_mp' || it.subtype === 'full_restore') mpPotCount++;
    });
    invBtn.innerHTML = `🎒 Inv<br><span style="font-size:10px;color:#ff6666;">❤️${hpPotCount}</span> <span style="font-size:10px;color:#6688ff;">💙${mpPotCount}</span>`;
    invBtn.title = '';
    invBtn.style.cssText = 'padding:4px 6px;font-size:12px;border-color:#8aaa8a;line-height:1.3;';
    // Long-press (3s) → sysop; short tap → inventory
    let _invHoldTimer = null, _invFired = false;
    const _invDown = (e) => { e.preventDefault(); _invFired = false; _invHoldTimer = setTimeout(() => { _invHoldTimer = null; _invFired = true; openSysopOverlay(); }, POT_HOLD_MS); };
    const _invUp   = ()  => { if (_invHoldTimer) { clearTimeout(_invHoldTimer); _invHoldTimer = null; } if (!_invFired) showDungeonInventory(); _invFired = false; };
    const _invCancel = () => { if (_invHoldTimer) { clearTimeout(_invHoldTimer); _invHoldTimer = null; } _invFired = false; };
    invBtn.addEventListener('mousedown',  _invDown);
    invBtn.addEventListener('mouseup',    _invUp);
    invBtn.addEventListener('mouseleave', _invCancel);
    invBtn.addEventListener('touchstart', _invDown, { passive: false });
    invBtn.addEventListener('touchend',   _invUp);
    invBtn.addEventListener('touchcancel',_invCancel);
    utilCol.appendChild(invBtn);

    // STAT POINTS button — only when points available
    const _sp = gameState.player.statPoints || 0;
    if (_sp > 0) {
        const statBtn = document.createElement('button');
        statBtn.innerHTML = `⬆ ${_sp} pts`;
        statBtn.title = `${_sp} stat point${_sp>1?'s':''} to spend`;
        statBtn.style.cssText = 'padding:4px 6px;font-size:12px;border-color:#FFD700;color:#FFD700;font-weight:bold;animation:hpLowPulse 1.2s ease-in-out infinite;';
        statBtn.onclick = () => { showLevelUpModal(); };
        utilCol.appendChild(statBtn);
    }

    navWrap.appendChild(utilCol);
    ab.appendChild(navWrap);
}


// ── Full-screen dungeon inventory (replaces old potion menu) ─────────
function showDungeonInventory() { showInventoryOverlay(); }

// ── Unified full-screen inventory overlay (dungeon + exploration, combat + not) ──
function showInventoryOverlay() {
    const p  = gameState.player;
    const cs = gameState.combatState;
    const inCombat = cs && !cs.combatOver;
    const inDungeon = !!gameState.dungeon;
    const playerClass = p.baseClass || p.class;
    const hasStatPoints = (p.statPoints || 0) > 0;

    function closeOverlay() {
        const ov = document.getElementById('dungeonInvOverlay');
        if (ov) ov.remove();
        if (inDungeon) renderDungeonActionBar();
        else renderActionBar();
    }

    function sellGem(invIndex) {
        const item = p.inventory[invIndex];
        if (item === undefined) return;
        let sellVal = 0;
        let gemName = '';
        if (typeof item === 'string' && item.startsWith('raw_')) {
            const def = ITEMS[item];
            sellVal = def ? (def.sellValue || 25) : 25;
            gemName = def ? def.name : item;
        } else if (typeof item === 'object' && item && item.cut) {
            sellVal = 100;
            gemName = item.name;
        } else return;
        if (!confirm('Sell ' + gemName + ' for ' + sellVal + 'g?')) return;
        p.inventory.splice(invIndex, 1);
        p.gold += sellVal;
        saveGame();
        showInventoryOverlay();
    }

    function potColor(st) {
        if (st==='heal_hp')      return '#ff4444';
        if (st==='heal_mp')      return '#4488ff';
        if (st==='full_restore') return '#FFD700';
        if (st==='recall')       return '#AA88FF';
        if (st?.startsWith('buff_')) return '#00FF88';
        return '#00FF00';
    }
    function potIcon(st) {
        if (st==='heal_hp')      return '❤️';
        if (st==='heal_mp')      return '💙';
        if (st==='full_restore') return '✨';
        if (st==='recall')       return '🌀';
        if (st==='buff_str')     return '💪';
        if (st==='buff_def')     return '🛡️';
        if (st==='buff_magic')   return '🔮';
        if (st==='buff_damage')  return '⚔️';
        if (st==='buff_regen')   return '💚';
        if (st==='buff_crit')    return '🎯';
        if (st?.startsWith('buff_')) return '🧪';
        return '🧪';
    }

    // ── Potions ──────────────────────────────────────────────────────
    const potions = {};
    p.inventory.forEach(ik => {
        const item = ITEMS[ik];
        if (!item) return;
        if (item.subtype === 'recall' && inCombat) return;
        if (['heal_hp','heal_mp','full_restore','recall'].includes(item.subtype) || item.subtype?.startsWith('buff_')) {
            if (!potions[ik]) potions[ik] = { item, count: 0 };
            potions[ik].count++;
        }
    });

    // ── Weapons ──────────────────────────────────────────────────────
    const weapons = p.inventory.filter(ik => {
        const w = WEAPONS[ik];
        return w && !w.unarmed && canUseWeapon(playerClass, w);
    });

    // ── Armor ────────────────────────────────────────────────────────
    const armors = p.inventory.filter(ik => {
        const a = ARMOR[ik];
        return a && !a.unarmored && canUseArmor(playerClass, a);
    });

    // ── Healing spells (out of combat only) ──────────────────────────
    let healingSpellsHtml = '';
    if (!inCombat && p.knownSpells && p.knownSpells.length > 0) {
        const spellTree = CLASS_SPELL_TREES[playerClass]?.spellTree || {};
        const healSpells = p.knownSpells.filter(sk => {
            const sp = SPELLS[sk] || spellTree[sk];
            return sp && (sp.type === 'heal' || sp.type === 'lifesteal');
        });
        if (healSpells.length > 0) {
            healingSpellsHtml = `<div style="color:var(--highlight-color);font-size:15px;letter-spacing:2px;margin:10px 0 6px;">— HEALING SPELLS —</div>
            <div style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:14px;">`;
            healSpells.forEach(sk => {
                const sp = SPELLS[sk] || spellTree[sk];
                const atFull = p.hp >= p.maxHp;
                const noMp   = p.mp < sp.mpCost;
                const dis    = atFull || noMp;
                healingSpellsHtml += `<button onclick="castHealingSpellOutOfCombat('${sk}');showInventoryOverlay();"
                    ${dis?'disabled':''} style="padding:8px 10px;font-size:14px;
                    color:#00FF00;border:2px solid #00FF00;background:#050a05;opacity:${dis?0.4:1};">
                    ✨ ${sp.name}<br><span style="color:#aaa;font-size:11px;">${sp.mpCost} MP</span>
                </button>`;
            });
            healingSpellsHtml += `</div>`;
        }
    }

    // ── Build HTML ───────────────────────────────────────────────────
    let html = `
    <div id="dungeonInvOverlay" style="
        position:fixed;inset:0;z-index:2500;
        display:flex;align-items:stretch;justify-content:center;
        background:rgba(0,0,0,0.7);
        font-family:'VT323',monospace;
    ">
        <!-- Inner panel matches game column width -->
        <div style="
            width:100%;max-width:820px;
            background:#000d00;
            display:flex;flex-direction:column;
            overflow:hidden;
        ">
        <!-- Fixed header -->
        <div style="flex:0 0 auto;padding:10px 12px 8px;border-bottom:2px solid var(--border-color);
                    display:flex;justify-content:space-between;align-items:center;background:#000d00;">
            <span style="color:var(--highlight-color);font-size:20px;letter-spacing:3px;">🎒 INVENTORY</span>
            <span style="color:#8aaa8a;font-size:14px;">
                ❤️ ${p.hp}/${p.maxHp} &nbsp; 💙 ${p.mp}/${p.maxMp}
                ${inCombat ? ' &nbsp;<span style="color:#ff4444;">⚔️ COMBAT</span>' : ''}
            </span>
        </div>

        <!-- Scrollable body -->
        <div style="flex:1 1 0;overflow-y:auto;padding:10px 12px;-webkit-overflow-scrolling:touch;">`;

    // STAT POINTS BUTTON — only when points available
    if (hasStatPoints) {
        html += `
        <div style="margin-bottom:14px;">
            <button onclick="document.getElementById('dungeonInvOverlay').remove();
                             ${inDungeon ? 'renderDungeonActionBar();' : 'renderActionBar();'}
                             showLevelUpModal();"
                style="width:100%;padding:12px;font-size:18px;font-weight:bold;
                       border:2px solid #FFD700;color:#FFD700;background:#0a0800;
                       animation:hpLowPulse 1.2s ease-in-out infinite;">
                ⬆ ${p.statPoints} STAT POINT${p.statPoints>1?'S':''} TO SPEND — Tap to Allocate
            </button>
        </div>`;
    }

    // POTIONS
    html += `<div style="color:var(--highlight-color);font-size:15px;letter-spacing:2px;margin-bottom:6px;">— POTIONS —</div>`;
    const potKeys = Object.keys(potions);
    if (potKeys.length === 0) {
        html += `<div style="color:#555;font-size:13px;margin-bottom:10px;">No potions.</div>`;
    } else {
        html += `<div style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:14px;">`;
        potKeys.forEach(pk => {
            const pd = potions[pk];
            const col = potColor(pd.item.subtype);
            const ico = potIcon(pd.item.subtype);
            const atFull = (pd.item.subtype==='heal_hp' && p.hp>=p.maxHp) ||
                           (pd.item.subtype==='heal_mp' && p.mp>=p.maxMp) ||
                           (pd.item.subtype==='full_restore' && p.hp>=p.maxHp && p.mp>=p.maxMp);
            const useFn = inCombat
                ? `usePotion('${pk}');showInventoryOverlay();`
                : `usePotionExplore('${pk}');showInventoryOverlay();`;
            html += `<button onclick="${useFn}" ${atFull?'disabled':''} style="
                min-width:110px;padding:10px 12px;
                color:${col};border:2px solid ${col};
                background:#050a05;font-size:15px;
                opacity:${atFull?0.4:1};text-align:center;">
                ${ico} ${pd.item.name}<br>
                <span style="color:#aaa;font-size:12px;">x${pd.count}</span>
            </button>`;
        });
        html += `</div>`;
    }

    // HEALING SPELLS
    html += healingSpellsHtml;

    // GEMS — raw and cut
    const rawGems = p.inventory
        .map((item, idx) => ({item, idx}))
        .filter(({item}) => typeof item === 'string' && item.startsWith('raw_'));
    const cutGems_inv = p.inventory
        .map((item, idx) => ({item, idx}))
        .filter(({item}) => typeof item === 'object' && item && item.cut);

    if (rawGems.length > 0 || cutGems_inv.length > 0) {
        html += `<div style="color:var(--highlight-color);font-size:15px;letter-spacing:2px;margin-bottom:6px;">— GEMS —</div>`;
        html += `<div style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:14px;">`;

        rawGems.forEach(({item: ik, idx}) => {
            const def = ITEMS[ik];
            const gemDef = def ? GEM_TYPES[def.gemType] : null;
            const color  = gemDef ? gemDef.color : '#AAFFEE';
            const emoji  = gemDef ? gemDef.emoji : '💎';
            const name   = def ? def.name : ik;
            const tier   = def ? def.gemTier : '?';
            const desc   = def ? def.description : '';
            const sell   = def ? (def.sellValue || 25) : 25;
            html += `<div style="min-width:130px;padding:10px;border:2px solid ${color};background:#050a05;font-size:13px;">
                <div style="color:${color};font-size:15px;">${emoji} ${name}</div>
                <div style="color:#888;font-size:11px;margin:2px 0;">${def ? def.description.split('.')[0] : ''}</div>
                <div style="display:flex;gap:6px;margin-top:6px;">
                    <div style="flex:1;font-size:11px;color:#555;text-align:center;padding:4px 0;">
                        Sell at shop (${sell}g)
                    </div>
                </div>
            </div>`;
        });

        cutGems_inv.forEach(({item: gem, idx}) => {
            const color = gem.color || '#AAFFEE';
            html += `<div style="min-width:130px;padding:10px;border:2px solid ${color};background:#050a05;font-size:13px;">
                <div style="color:${color};font-size:15px;">${gem.emoji || '💎'} ${gem.name}</div>
                <div style="color:#888;font-size:11px;margin:2px 0;">${gem.description || ''}</div>
                <div style="color:#555;font-size:10px;margin:2px 0;">✂️ Already cut</div>
                <div style="display:flex;gap:6px;margin-top:6px;">
                    <div style="flex:1;font-size:11px;color:#555;text-align:center;padding:4px 0;">
                        Sell at shop (100g)
                    </div>
                </div>
            </div>`;
        });

        html += `</div>`;
    }

    // WEAPONS
    html += `<div style="color:var(--highlight-color);font-size:15px;letter-spacing:2px;margin-bottom:6px;">— WEAPONS —</div>`;
    html += `<div style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:14px;">`;
    const eqW = WEAPONS[p.weapon];
    if (eqW && !eqW.unarmed) {
        const qc = QUALITY_CONFIG[eqW.quality];
        html += `<div style="min-width:130px;padding:10px;border:2px solid ${qc?.color||'#0f0'};background:#050a05;font-size:14px;">
            <div style="color:${qc?.color||'#0f0'};">${eqW.name}</div>
            <div style="color:#aaa;font-size:12px;">DMG ${eqW.baseDamage}–${eqW.maxDamage||eqW.baseDamage}</div>
            <div style="color:var(--highlight-color);font-size:12px;">★ EQUIPPED</div>
        </div>`;
    }
    if (weapons.length === 0 && (!eqW || eqW.unarmed)) {
        html += `<div style="color:#555;font-size:13px;">No weapons.</div>`;
    }
    weapons.forEach(ik => {
        if (ik === p.weapon) return;
        const w = WEAPONS[ik];
        const qc = QUALITY_CONFIG[w.quality];
        const closeFn = inDungeon ? 'renderDungeonActionBar()' : 'renderActionBar()';
        html += `<button onclick="equipItem('weapon','${ik}');document.getElementById('dungeonInvOverlay').remove();${closeFn};" style="
            min-width:130px;padding:10px;border:2px solid ${qc?.color||'#0f0'};
            background:#050a05;font-size:14px;text-align:left;cursor:pointer;">
            <div style="color:${qc?.color||'#0f0'};">${w.name}</div>
            <div style="color:#aaa;font-size:12px;">DMG ${w.baseDamage}–${w.maxDamage||w.baseDamage}</div>
            <div style="color:#FFD700;font-size:12px;">▶ EQUIP</div>
        </button>`;
    });
    html += `</div>`;

    // ARMOR
    html += `<div style="color:var(--highlight-color);font-size:15px;letter-spacing:2px;margin-bottom:6px;">— ARMOR —</div>`;
    html += `<div style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:24px;">`;
    const eqA = ARMOR[p.armor];
    if (eqA && !eqA.unarmored) {
        const qc = QUALITY_CONFIG[eqA.quality];
        const eqASlots = getGemSlots(eqA.quality);
        const eqAGems  = eqA.gems || [];
        let eqAGemHtml = '';
        if (eqASlots > 0) {
            for (let i = 0; i < eqASlots; i++) {
                const g = eqAGems[i];
                eqAGemHtml += g
                    ? `<div style="font-size:11px;color:${g.color};">${g.emoji} ${g.name}</div>`
                    : `<div style="font-size:10px;color:#333;">⬤ empty slot</div>`;
            }
        }
        html += `<div style="min-width:130px;padding:10px;border:2px solid ${qc?.color||'#0f0'};background:#050a05;font-size:14px;">
            <div style="color:${qc?.color||'#0f0'};">${eqA.name}</div>
            <div style="color:#aaa;font-size:12px;">DEF ${eqA.baseDefense}</div>
            ${eqAGemHtml}
            <div style="color:var(--highlight-color);font-size:12px;">★ EQUIPPED</div>
        </div>`;
    }
    if (armors.length === 0 && (!eqA || eqA.unarmored)) {
        html += `<div style="color:#555;font-size:13px;">No armor.</div>`;
    }
    armors.forEach(ik => {
        if (ik === p.armor) return;
        const a = ARMOR[ik];
        const qc = QUALITY_CONFIG[a.quality];
        const aSlots = getGemSlots(a.quality);
        const aGems  = a.gems || [];
        let aGemHtml = '';
        if (aSlots > 0) {
            for (let i = 0; i < aSlots; i++) {
                const g = aGems[i];
                aGemHtml += g
                    ? `<div style="font-size:11px;color:${g.color};">${g.emoji} ${g.name}</div>`
                    : `<div style="font-size:10px;color:#333;">⬤ empty slot</div>`;
            }
        }
        const closeFn = inDungeon ? 'renderDungeonActionBar()' : 'renderActionBar()';
        html += `<button onclick="equipItem('armor','${ik}');document.getElementById('dungeonInvOverlay').remove();${closeFn};" style="
            min-width:130px;padding:10px;border:2px solid ${qc?.color||'#0f0'};
            background:#050a05;font-size:14px;text-align:left;cursor:pointer;">
            <div style="color:${qc?.color||'#0f0'};">${a.name}</div>
            <div style="color:#aaa;font-size:12px;">DEF ${a.baseDefense}</div>
            ${aGemHtml}
            <div style="color:#FFD700;font-size:12px;">▶ EQUIP</div>
        </button>`;
    });
    html += `</div>`;

    html += `</div>`; // end scrollable body

    // ── Close button fixed at bottom ──────────────────────────────────
    html += `
        <div style="flex:0 0 auto;padding:8px 12px;border-top:2px solid var(--border-color);background:#000d00;">
            <button onclick="(document.getElementById('dungeonInvOverlay').remove(),${inDungeon?'renderDungeonActionBar()':'renderActionBar()'})"
                style="width:100%;font-size:18px;padding:10px;border-color:#ff4444;color:#ff4444;letter-spacing:2px;">
                ✕ CLOSE INVENTORY
            </button>
        </div>
    </div>`; // end inner panel
    html += `</div>`; // end outer overlay

    const existing = document.getElementById('dungeonInvOverlay');
    if (existing) existing.remove();
    const overlay = document.createElement('div');
    overlay.id = 'dungeonInvOverlay';
    overlay.innerHTML = html;
    // Move the actual overlay div (not wrapper) to body
    const innerEl = overlay.firstElementChild;
    if (innerEl) {
        innerEl.id = 'dungeonInvOverlay';
        overlay.id = '';
        document.body.appendChild(innerEl);
    } else {
        document.body.appendChild(overlay);
    }
}

// ── Central dungeon navigation handler (buttons + keyboard) ──────────
function dungeonNav(input) {
    // Normalise aliases
    const aliases = {
        'north':'n','south':'s','east':'e','west':'w',
        'northeast':'ne','northwest':'nw','southeast':'se','southwest':'sw',
        'up':'up','down':'down','u':'up','d':'down',
        'n':'n','s':'s','e':'e','w':'w',
        'ne':'ne','nw':'nw','se':'se','sw':'sw'
    };
    const dir = aliases[input.toLowerCase()];
    if (!dir) {
        termAppend(`Unknown direction: <span style="color:#ff4444;">${input}</span> — try n, s, e, w, ne, nw, se, sw, up, down`, 'term-warning');
        return;
    }
    moveInDungeon(dir);
}







        
        
        function renderActionBar() {
            const ab = document.getElementById('actionBar');
            showActionBar();
            
            // If in dungeon, always use dungeon action bar with combat overlay
            if (gameState.dungeon) {
                renderDungeonActionBar();
                // Sweep animation + scroll fix (deferred so DOM is settled)
                requestAnimationFrame(() => { updatePipButtons(); stabilizeTerminalLayout(); });
                return;
            }
            
            if (gameState.combatState) {
                const cs       = gameState.combatState;
                const monsters = cs.monsters;
                const p        = gameState.player;
                const maxHits  = cs.pipAvailable ? cs.pipAvailable.length : calcPlayerHits(p);
                const hitsLeft = cs.pipAvailable ? cs.pipAvailable.filter(x => x).length : maxHits;
                const canAct   = hitsLeft > 0;

                // attack-charge pips  ●●○
                const pips = '●'.repeat(hitsLeft) + '○'.repeat(maxHits - hitsLeft);

                // Check what menu mode we're in
                const mode = cs.actionMode || 'main';

                if (mode === 'main') {
                    // Main combat menu — icons only, pip dots only
                    const isHunter    = (p.baseClass || p.class) === 'hunter';
                    const isWarrior   = (p.baseClass || p.class) === 'warrior';
                    const isRunesmith = (p.baseClass || p.class) === 'runesmith';
                    const trapBtn   = isHunter  ? `<button onclick="(castTrap())" ${p.mp < 10 ? 'disabled' : ''} class="action-icon-btn" title="Set Trap [T] - 10 MP" style="border-color:#8B4513;">🪤<span class="kb-hint">T</span></button>` : '';
                    const shieldBtn = isWarrior ? `<button onclick="playerDefend()" ${!canAct?'disabled':''} class="action-icon-btn" title="Shield [4] — Raise defense by 50% this turn" style="border-color:#00CCFF;">🛡️<span class="kb-hint">4</span></button>` : '';

                    // Runesmith overload UI
                    const rsPips = isRunesmith ? (p.runeOverloadPips || 0) : 0;
                    const rsReady = rsPips >= 3;
                    const rp1 = rsPips >= 1 ? '🔶' : '⬛'; const rp2 = rsPips >= 2 ? '🔶' : '⬛'; const rp3 = rsPips >= 3 ? '🔶' : '⬛';
                    const attackBtnHTML = isRunesmith
                        ? `<button onclick="showAttackMenu()" ${!canAct?'disabled':''} class="action-icon-btn pip-btn" id="pipBtn-attack" title="${rsReady ? 'OVERLOAD — Strike! [1]' : 'Attack [1]'}" style="${rsReady ? 'border-color:#FF4400;animation:runeOverloadPulse 0.7s ease-in-out infinite;outline-offset:0;' : ''}">⚒️<span class="kb-hint">1</span></button>`
                        : `<button onclick="showAttackMenu()" ${!canAct?'disabled':''} class="action-icon-btn pip-btn" title="Attack [1]" id="pipBtn-attack">⚔️<span class="kb-hint">1</span></button>`;
                    const spellBtnHTML = isRunesmith
                        ? `<button onclick="showSpellMenu()" ${!canAct?'disabled':''} class="action-icon-btn pip-btn" id="pipBtn-spell" title="Cast Rune [2]" style="border-color:#c8a000;"><span style="font-size:9px;line-height:1;display:block;">${rsReady ? '⚡READY' : rp1+rp2+rp3}</span>✨<span class="kb-hint">2</span></button>`
                        : `<button onclick="showSpellMenu()"  ${!canAct?'disabled':''} class="action-icon-btn pip-btn" title="Cast Spell [2]" id="pipBtn-spell">✨<span class="kb-hint">2</span></button>`;

                    ab.innerHTML = `
                        <div style="color:var(--highlight-color);font-size:13px;line-height:1;margin-bottom:3px;text-align:center;letter-spacing:3px;">${pips}</div>
                        <div style="display:flex;gap:3px;width:100%;">
                            ${attackBtnHTML}
                            ${spellBtnHTML}
                            <button onclick="showCombatInventory()" class="action-icon-btn" title="Inventory [3]" style="border-color:#00FF88;">🎒<span class="kb-hint">3</span></button>
                            ${trapBtn}
                            ${shieldBtn}
                            <button onclick="attemptFlee()"    ${!canAct?'disabled':''} class="action-icon-btn" title="Flee [5]">🏃<span class="kb-hint">5</span></button>
                            <button onclick="printStatsToTerminal()" class="action-icon-btn" title="Show Stats [6]" style="border-color:#4488ff;">📊<span class="kb-hint">6</span></button>
                        </div>
                    `;
                } else if (mode === 'attack_type') {
                    const normalCost = 1;
                    const heavyCost = 2;
                    const showSpecial = hitsLeft >= 3;
                    ab.innerHTML = `
                        <div style="display:flex;gap:3px;width:100%;">
                            <button onclick="selectAttackType('normal')" ${hitsLeft < normalCost ? 'disabled' : ''} class="action-icon-btn" title="Normal Attack [N]">⚔️<span class="kb-hint">N</span></button>
                            <button onclick="selectAttackType('heavy')"  ${hitsLeft < heavyCost  ? 'disabled' : ''} class="action-icon-btn" title="Heavy — 35% miss, 3× dmg [H]" style="border-color:#ff8c00;">💥<span class="kb-hint">H</span></button>
                            ${showSpecial ? `<button onclick="selectAttackType('special')" class="action-icon-btn" title="Special — all pips [S]" style="border-color:#FFD700;">⭐<span class="kb-hint">S</span></button>` : ''}
                            <button onclick="cancelAction()" class="action-icon-btn" title="Cancel [Esc]" style="border-color:#888;">❌<span class="kb-hint">Esc</span></button>
                        </div>
                    `;
                } else if (mode === 'target_attack' || mode === 'target_spell' || mode === 'target_staff_melee') {
                    const targetBtns = monsters.map((m, i) =>
                        `<button onclick="executeTargetedAction(${i})" class="target-btn" style="position:relative;">
                            ${i + 1}. ${m.name}<span class="kb-hint">${i + 1}</span>
                        </button>`
                    ).join('');
                    ab.innerHTML = `
                        <div style="display:flex;flex-wrap:wrap;gap:3px;width:100%;">
                            ${targetBtns}
                            <button onclick="cancelAction()" class="action-icon-btn" style="border-color:#888;position:relative;">❌<span class="kb-hint">Esc</span></button>
                        </div>
                    `;
                } else if (mode === 'spell_list') {
                    // Build numbered spell list
                    const validSpells = p.knownSpells.map(sk => {
                        const spell = ensureSpellExists(sk) || SPELLS[sk];
                        if (!spell) { console.warn(`⚠️ Spell '${sk}' not found`); return null; }
                        return { sk, spell };
                    }).filter(Boolean);

                    const spellBtns = validSpells.map(({sk, spell}, i) => {
                        const canCast = p.mp >= spell.mpCost;
                        const aoeTag  = spell.type === 'aoe_damage' ? ' <span style="color:#FF8800;">AOE</span>' : '';
                        return `<button onclick="selectSpell('${sk}')" ${!canCast?'disabled':''} class="spell-btn" style="position:relative;">
                            ${spell.name}${aoeTag}<br>
                            <span style="font-size:12px;">${spell.mpCost} MP</span>
                            <span class="kb-hint">${i + 1}</span>
                        </button>`;
                    }).join('');

                    ab.innerHTML = `
                        <div style="display:flex;flex-wrap:wrap;gap:3px;width:100%;">
                            ${spellBtns}
                            <button onclick="cancelAction()" class="action-icon-btn" style="border-color:#888;position:relative;">❌<span class="kb-hint">Esc</span></button>
                        </div>
                    `;
                }
            } else {
                // Out of combat - exploring
                // Show pip recovery status if any pips are still cooling down
                const cs2 = gameState.combatState;
                let pipWarning = '';
                let canLeave = true;
                if (cs2 && cs2.pipAvailable) {
                    const ready = cs2.pipAvailable.filter(x => x).length;
                    const total = cs2.pipAvailable.length;
                    canLeave = (ready === total);
                    if (!canLeave) {
                        pipWarning = `<div style="color:#FF8800;font-size:11px;margin-bottom:4px;">
                            ⏳ Pips recovering: ${'●'.repeat(ready) + '○'.repeat(total-ready)} — wait to leave</div>`;
                    }
                }
                const _xpSp = gameState.player.statPoints || 0;
                ab.innerHTML = `
                    ${pipWarning}
                    <div style="display:flex;gap:3px;width:100%;flex-wrap:wrap;">
                        <button onclick="exploreLocation('${gameState.currentLocation}')" style="flex:2;" title="Explore [1]">🔍 Explore<span class="kb-hint">1</span></button>
                        <button onclick="showCombatInventory()" class="action-icon-btn" title="Inventory [3]" style="border-color:#00FF88;">🎒<span class="kb-hint">3</span></button>
                        ${_xpSp > 0 ? `<button onclick="showLevelUpModal()" class="action-icon-btn" title="${_xpSp} stat points to spend" style="border-color:#FFD700;color:#FFD700;font-weight:bold;animation:hpLowPulse 1.2s ease-in-out infinite;">⬆${_xpSp}<span class="kb-hint">S</span></button>` : ''}
                        <button onclick="leaveExploreToTown()" ${canLeave ? '' : 'disabled'}
                            style="flex:1;${canLeave ? '' : 'opacity:0.4;'}border-color:${canLeave ? 'var(--text-color)' : '#888'};" title="Return to Town [5]">
                            🏘️<span class="kb-hint">5</span>
                        </button>
                    </div>
                `;
            }
            // After any button-set change, fix terminal scroll on mobile
            requestAnimationFrame(() => { updatePipButtons(); stabilizeTerminalLayout(); });
        }
        function goBackToTown() {
            leaveExploreToTown();
        }
        
        // ═══════════════════════════════════════════════════════════════
        // NEW DYNAMIC COMBAT MENU SYSTEM
        // ═══════════════════════════════════════════════════════════════
        
        function showAttackMenu() {
            const cs = gameState.combatState;
            if (!cs) return;
            cs.actionMode = 'attack_type';
            renderActionBar();
        }
        
        function selectAttackType(type) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            cs.pendingAttackType = type;
            cs.actionMode = 'target_attack';
            renderActionBar();
        }
        
        function cancelAction() {
            const cs = gameState.combatState;
            if (!cs) return;
            cs.actionMode = 'main';
            cs.pendingAttackType = null;
            cs.pendingSpell = null;
            renderActionBar();
        }
        
        // ═══════════════════════════════════════════════════════════════
        // STAFF MELEE ATTACK (for mages out of MP)
        // ═══════════════════════════════════════════════════════════════
        function staffMeleeAttack() {
            const cs = gameState.combatState;
            if (!cs) return;
            
            // Switch to target selection for staff melee
            cs.actionMode = 'target_staff_melee';
            renderActionBar();
        }
        
        function executeStaffMelee(targetIndex) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            const p = gameState.player;
            const enemy = cs.monsters[targetIndex];
            const weapon = WEAPONS[p.weapon];
            
            // Consume 1 pip
            const consumed = consumePips(cs, 1, getPipCooldown(p));
            if (consumed < 1) {
                termAppend('Not enough action points!', 'term-error');
                return;
            }
            // Wands: full physical damage (their design purpose — better melee than staffs)
            // Staffs: 70% physical + some magic bleed (still a real hit, not a joke)
            const isWand = weapon && weapon.weaponSubtype === 'wand';
            const meleePct = isWand ? 1.0 : 0.7;
            const qBonus   = getQualityBonus(weapon ? weapon.quality : 'normal', weapon ? weapon.baseDamage : 0);
            const minDmg   = (weapon ? weapon.baseDamage : 1) + qBonus;
            const maxDmg   = (weapon ? (weapon.maxDamage || weapon.baseDamage) : 1) + qBonus;
            const rolled   = Math.floor(Math.random() * (maxDmg - minDmg + 1)) + minDmg;

            let baseDamage = Math.floor(rolled * meleePct);
            const strBonus = Math.floor((p.str || p.strength || 0) * (isWand ? 0.8 : 0.4));
            const magicBleed = isWand ? 0 : Math.floor((weapon ? weapon.baseMagicDamage || 0 : 0) * 0.2);
            
            // Total damage
            let totalDamage = baseDamage + strBonus + magicBleed;
            
            // Apply class damage multiplier (if evolved)
            const classMult = getClassDamageMultiplier(p);
            totalDamage = Math.floor(totalDamage * classMult);
            
            // Calculate final damage with enemy defense
            const result = calculateDamage({
                attacker: p,
                defender: enemy,
                base: totalDamage,
                type: 'physical',
                critChance: calcCritChance(p.lck || 0, p) / 100,
                dodgeChance: enemy.dodge || 0,
                armorPiercing: 0
            });
            
            const tName = cs.monsters.length > 1
                ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${targetIndex+1}</span>`
                : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;
            
            if (result.dodged) {
                termAppend(`You strike at ${tName} but they <span style="color:#88ff88;">DODGE!</span>`);
            } else {
                const critTag = result.crit ? ' <span style="color:#FFD700;">★ CRITICAL HIT!</span>' : '';
                const isWand = weapon && weapon.weaponSubtype === 'wand';
                const strikeVerb = isWand
                    ? `snaps <span style="color:#AA88FF;">✦ ${weapon.name}</span> at`
                    : `strikes with <span style="color:#AA88FF;">✦ ${weapon ? weapon.name : 'staff'}</span> at`;
                enemy.hp -= result.damage;
                termAppend(
                    `You ${strikeVerb} ${tName} for <span class="dmg-enemy">${result.damage} damage!</span>${critTag}`,
                    null,
                    () => {
                        checkCombatEnd();
                        updateEnemyCards();
                        updateHud();
                    }
                );
            }
            
            // Return to main combat menu
            cs.actionMode = 'main';
            renderActionBar();
        }
        
        function executeTargetedAction(targetIndex) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            cs.currentTarget = targetIndex;
            
            if (cs.actionMode === 'target_attack') {
                executeAttack(cs.pendingAttackType);
            } else if (cs.actionMode === 'target_spell') {
                castSpellOnTarget(cs.pendingSpell);
            } else if (cs.actionMode === 'target_staff_melee') {
                executeStaffMelee(targetIndex);
            }
            
            // Reset to main menu
            cs.actionMode = 'main';
            cs.pendingAttackType = null;
            cs.pendingSpell = null;
        }
        
        function selectSpell(spellKey) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            const spell = SPELLS[spellKey];
            cs.pendingSpell = spell;
            cs.pendingSpellKey = spellKey;
             
            
            // AOE spells and healing spells don't need target selection - cast immediately
            if (spell && (spell.type === 'aoe_damage' || spell.type === 'heal')) {
                castSpellOnTarget(spell);
                cs.actionMode = 'main';
                cs.pendingSpell = null;
                cs.pendingSpellKey = null;
            } else {
                // Regular spells need target selection
                cs.actionMode = 'target_spell';
                renderActionBar();
            }
        }
        
        // Update showSpellMenu to use the new system
        function showSpellMenuOld() {
            const cs = gameState.combatState;
            if (!cs) return;
            
            cs.actionMode = 'spell_list';
            renderActionBar();
        }
        

        function tryExploreLocation(locKey) {
            checkGameVersion();
            if (!isFullyRested()) {
                termAppend('<span style="color:var(--error-color);">You are too exhausted to continue! Wait for your charges to restore…</span>', 'term-error');
                return;
            }
            // Clear old combat state now that we're starting fresh
            gameState.combatState = null;
            exploreLocation(locKey);
        }
        
        function tryGoBackToTown() {
            // Delegate to leaveExploreToTown — it handles pip check and enemy preservation
            leaveExploreToTown();
        }
        
        function tryViewWorldMap() {
            if (!isFullyRested()) {
                termAppend('<span style="color:var(--error-color);">You are too exhausted to travel! Wait for your charges to restore…</span>', 'term-error');
                return;
            }
            // Preserve combatState — enemies wait here until player returns
            closeTerminalView();
            showExplore();
        }
        
        function selectTarget(index) {
            const cs = gameState.combatState;
            if (!cs || !cs.monsters || index < 0 || index >= cs.monsters.length) return;
            cs.currentTarget = index;
            updateEnemyCards();
            renderActionBar();
        }

        function isFullyRested() {
            const cs = gameState.combatState;
            if (!cs || !cs.pipAvailable) return true;
            // all pips must be available
            return cs.pipAvailable.every(x => x);
        }


      function startCombatTimer() {
    if (gameState.combatTimer) clearInterval(gameState.combatTimer);

    gameState.combatTimer = setInterval(() => {
        const cs = gameState.combatState;

        // No combat state at all → stop timer
        if (!cs) {
            clearInterval(gameState.combatTimer);
            gameState.combatTimer = null;
            return;
        }

        // ─────────────────────────────────────────
        // PIP RECOVERY (always runs)
        // ─────────────────────────────────────────
        let anyRestored = false;
        const pipCooldown = gameState.player ? getPipCooldown(gameState.player) : BASE_PIP_COOLDOWN;

        for (let i = 0; i < cs.pipTimers.length; i++) {
            if (!cs.pipAvailable[i] && cs.pipTimers[i] > 0) {
                cs.pipTimers[i]--;
                if (cs.pipTimers[i] <= 0) {
                    cs.pipAvailable[i] = true;
                    cs.pipTimers[i] = pipCooldown;
                    anyRestored = true;
                }
            }
        }

        if (anyRestored) {
            renderActionBar();
        }
        // Always update pip sweep animation each tick
        updatePipButtons();

        // ── GEM REGEN: bloodstone (HP) and moonstone (MP) tick every second ──
        const _p = gameState.player;
        const _w = _p && _p.weapon ? WEAPONS[_p.weapon] : null;
        if (_p && _w && _w.gems && !cs.combatOver) {
            let totalHpRegen = 0, totalMpRegen = 0;
            for (const _g of _w.gems) {
                if (!_g || !_g.stats) continue;
                totalHpRegen += _g.stats.hpRegen || 0;
                totalMpRegen += _g.stats.mpRegen || 0;
            }
            if (totalHpRegen > 0 && _p.hp < _p.maxHp) {
                _p.hp = Math.min(_p.maxHp, _p.hp + totalHpRegen);
                updateHud();
            }
            if (totalMpRegen > 0 && _p.mp < _p.maxMp) {
                _p.mp = Math.min(_p.maxMp, _p.mp + totalMpRegen);
                updateHud();
            }
        }

        // ─────────────────────────────────────────
        // POST-COMBAT RECOVERY CLEANUP
        // ─────────────────────────────────────────
        if (cs.combatOver) {
            // Once ALL pips are restored, exit recovery
            if (cs.pipAvailable.every(p => p)) {
                gameState.postCombatRecovery = false;
                gameState.combatState = null;

                renderActionBar();
                clearInterval(gameState.combatTimer);
                gameState.combatTimer = null;
            }
            return; // No enemy actions during recovery
        }

        // ─────────────────────────────────────────
        // ENEMY TIMER + INTENT TELEGRAPHING
        // (only while combat is active)
        // ─────────────────────────────────────────
        if (cs.enemyTimer > 0) cs.enemyTimer--;

        // Telegraph intent 2 second before attack
        if (cs.enemyTimer === 2 && !cs.enemyIntent) {
            const enemy = cs.monsters[cs.currentTarget];
            if (enemy) {
                cs.enemyIntent = selectEnemyIntent(enemy);
                termAppend(
                    `<span style="color:${enemy.rarityColor};">${enemy.name}</span> ${cs.enemyIntent.telegraph}`,
                    'term-dim'
                );
            }
        }

        // Execute enemy attack
        if (cs.enemyTimer <= 0) {
            clearInterval(gameState.combatTimer);
            gameState.combatTimer = null;
            enemyAttackSingle();
        }

    }, 1000);
}


 // ═══════════════════════════════════════════════════════════════
// PLAYER ACTIONS
// ═══════════════════════════════════════════════════════════════

// ── RUNESTONE ROOM EVENT ─────────────────────────────────────────
// Called every time a room is entered. If the room has contents.runestone
// and the player doesn't already have it, award it with a dramatic flash.
function checkRunestone(room) {
    if (!room || !room.contents || !room.contents.runestone) return;
    const p = gameState.player;
    if (!p) return;

    const rsId = room.contents.runestone;
    if (!p.runestones) p.runestones = [];
    if (p.runestones.includes(rsId)) return;  // already have it — no repeat

    // Mark as obtained
    p.runestones.push(rsId);
    if (!p.achievements) p.achievements = [];
    p.achievements.push({ id: rsId, name: rsId.replace('_', ' '), earned: Date.now() });

    // Get registry data for color and name
    const rs = (typeof RUNESTONES !== 'undefined' && RUNESTONES[rsId]) ? RUNESTONES[rsId] : null;
    const rsName  = rs ? rs.name  : rsId.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    const rsColor = rs ? rs.color : '#FFFFFF';
    const rsDesc  = rs ? rs.description : 'A mysterious runestone.';

    // ── Dramatic flash cutscene ───────────────────────────────────
    termAppend('', 'term-separator');
    termAppend(
        `<span style="color:#FFFFFF;font-weight:bold;font-size:18px;letter-spacing:2px;">⚡ A FLASH OF BLINDING LIGHT! ⚡</span>`,
        'term-highlight'
    );
    termAppend(
        `<span style="color:${rsColor};font-weight:bold;">You now have the ${rsName} inscribed upon your forehead!</span>`,
        'term-loot'
    );
    termAppend(
        `<span style="color:#aaa;font-style:italic;">${rsDesc}</span>`,
        'term-dim'
    );
    termAppend('', 'term-separator');

    // Flash overlay on the screen
    const flash = document.createElement('div');
    flash.style.cssText = [
        'position:fixed', 'inset:0', 'background:#FFFFFF', 'opacity:0.9',
        'z-index:99999', 'pointer-events:none',
        'transition:opacity 0.6s ease-out'
    ].join(';');
    document.body.appendChild(flash);
    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            flash.style.opacity = '0';
            setTimeout(() => {
                flash.remove();
                // After flash — show colored pip banner
                const banner = document.createElement('div');
                banner.style.cssText = [
                    `position:fixed`, `top:60px`, `left:50%`,
                    `transform:translateX(-50%)`,
                    `background:#0a0a0a`,
                    `border:2px solid ${rsColor}`,
                    `padding:12px 28px`,
                    `color:${rsColor}`,
                    `font-family:'VT323',monospace`,
                    `font-size:20px`,
                    `z-index:9999`,
                    `text-align:center`,
                    `letter-spacing:1px`
                ].join(';');
                banner.innerHTML = `<span style="font-size:22px;">✦</span> ${rsName} <span style="font-size:22px;">✦</span><br><span style="font-size:14px;color:#ccc;">Inscribed upon your forehead</span>`;
                document.body.appendChild(banner);
                setTimeout(() => banner.remove(), 4000);
            }, 650);
        });
    });

    // Update HUD immediately so the pip appears
    updateHud();
    saveGame();
}

function checkRoomEncounter(room) {
    const ds = gameState.dungeon;
    if (!ds) return;
    if (!ds.activeEnemies) ds.activeEnemies = [];

    // ── NEW FORMAT: contents.enemies[] from dungeon editor ────────────
    // Each entry: { key: 'giant_scorpion', drop: 'copper_key', rarity: 'epic' }
    // rarity is optional — omit or leave blank for base/common stats (no random roll in dungeons).
    // Only spawn once per room per dungeon session.
    if (room.contents && Array.isArray(room.contents.enemies) && room.contents.enemies.length > 0) {
        if (!ds.spawnedRooms) ds.spawnedRooms = new Set();
        if (ds.spawnedRooms.has(ds.currentRoom)) return;
        ds.spawnedRooms.add(ds.currentRoom);

        room.contents.enemies.forEach(entry => {
            const monsterId = typeof entry === 'string' ? entry : entry.key;
            const drop      = typeof entry === 'string' ? null  : (entry.drop || null);
            // Default to 'common' so dungeons never get a random rarity roll
            const rarity    = (typeof entry === 'object' && entry.rarity && RARITY_CONFIG?.[entry.rarity])
                              ? entry.rarity : 'common';
            const enemyDef  = ENEMIES[monsterId];
            if (!enemyDef) { console.warn('Dungeon enemy not found:', monsterId); return; }

            const inst = {
                id: crypto.randomUUID(),
                monsterId,
                rarity,
                name:          enemyDef.name,
                currentRoom:   ds.currentRoom,
                leash:         enemyDef.isBoss ? 6 : 3,
                roomsFollowed: 0,
                drop
            };
            ds.activeEnemies.push(inst);
            termAppend(`\u26a0\ufe0f <strong>${inst.name}</strong> steps out of the shadows!`, 'term-warning');
        });
        return;
    }

    // ── OLD FORMAT: room.encounter.monsterId ──────────────────────────
    if (!room || !room.encounter) return;
    if (room.encounter.resolved) return;

    const enemyDef = ENEMIES[room.encounter.monsterId];
    if (!enemyDef) { console.warn('Enemy not found:', room.encounter.monsterId); return; }

    const enemyInstance = {
        id: crypto.randomUUID(),
        monsterId:     room.encounter.monsterId,
        name:          enemyDef.name,
        currentRoom:   ds.currentRoom,
        leash:         enemyDef.isBoss ? 6 : 3,
        roomsFollowed: 0,
        drop:          room.encounter.drop || null
    };

    ds.activeEnemies.push(enemyInstance);
    room.encounter.resolved = true;

    termAppend(`\u26a0\ufe0f <strong>${enemyInstance.name}</strong> steps out of the shadows!`, 'term-warning');
}


function checkDungeonRespawns() {
    const ds = gameState.dungeon;
    if (!ds || !ds.defeatedEnemies || ds.defeatedEnemies.length === 0) return;
    
    const now = Date.now();
    const respawned = [];
    
    // Check each defeated enemy for respawn time
    ds.defeatedEnemies = ds.defeatedEnemies.filter(deadEnemy => {
        if (now >= deadEnemy.respawnTime) {
            // Respawn this enemy - restore to original room with full HP
            const respawnedEnemy = {
                id: deadEnemy.id,
                monsterId: deadEnemy.monsterId,
                name: deadEnemy.name,
                currentRoom: deadEnemy.currentRoom, // Original spawn room
                leash: deadEnemy.leash,
                roomsFollowed: 0,
                drop: deadEnemy.drop,
                isChasing: false, // Reset chase state
                // Reset HP if it was stored (for wounded enemies)
                hp: undefined,
                maxHp: undefined
            };
            
            ds.activeEnemies.push(respawnedEnemy);
            respawned.push(respawnedEnemy);
            
            // Remove from defeated list (filter returns false)
            return false;
        }
        // Keep in defeated list (filter returns true)
        return true;
    });
    
    // Log respawns
    if (respawned.length > 0) {
        console.log(`♻️ ${respawned.length} dungeon enemy(s) respawned after 30 minutes`);
        
        // Only show message if player is in same room as a respawned enemy
        respawned.forEach(enemy => {
            if (enemy.currentRoom === ds.currentRoom) {
                termAppend(`♻️ <strong>${enemy.name}</strong> has respawned in this room!`, 'term-warning');
            }
        });
    }
}


function updateDungeonEnemies() {
    const ds = gameState.dungeon;
    if (!ds || !ds.activeEnemies) return [];

    const dungeon = DUNGEONS[ds.dungeonKey];
    const floor = dungeon.floors[ds.floor];
    const arrived = []; // enemies that just moved into player's room

    ds.activeEnemies.forEach(enemy => {
        const enemyRoom = floor.rooms[enemy.currentRoom];
        if (!enemyRoom) return;

        // Start chase when player enters enemy's room for the first time
        if (!enemy.isChasing && enemy.currentRoom === ds.currentRoom) {
            enemy.isChasing = true;
            enemy.roomsFollowed = 0;
        }

        // Not chasing → do nothing
        if (!enemy.isChasing) return;

        // Already in player's room → nothing to move
        if (enemy.currentRoom === ds.currentRoom) return;

        // Leash exhausted → stop
        if (enemy.roomsFollowed >= enemy.leash) {
            enemy.isChasing = false;
            termAppend(`🛑 <strong>${enemy.name}</strong> stops the chase.`, 'term-dim');
            return;
        }

        // Follow player — find which exit leads toward player's room
        const exits = enemyRoom.exits || {};
        for (const dir in exits) {
            if (exits[dir] === ds.currentRoom) {
                enemy.currentRoom = ds.currentRoom;
                enemy.roomsFollowed++;

                const fromDir = OPPOSITE_DIR[dir] || dir;
                termAppend(
                    `⚠️ <strong>${enemy.name}</strong> enters from the <em>${fromDir}</em>.`,
                    'term-warning'
                );
                arrived.push(enemy);
                return;
            }
        }
    });

    return arrived; // caller decides what to do with arrivals
}




function moveInDungeon(direction) {
    // Check if player has full pips (required for movement)
    const cs = gameState.combatState;
    if (cs && cs.pipAvailable) {
        const hasFullPips = cs.pipAvailable.every(x => x);
        if (!hasFullPips) {
            const available = cs.pipAvailable.filter(x => x).length;
            const total = cs.pipAvailable.length;
            termAppend(`⚡ You're too exhausted to move! (${available}/${total} pips restored)`, 'term-error');
            return;
        }
    }

    if (!gameState.dungeon) {
        console.warn('Not in a dungeon');
        return;
    }

    const ds = gameState.dungeon;
    const dungeonData = DUNGEONS[ds.dungeonKey];

    // ═══════════════════════════════════════════════════════════════
    // LADDER MOVEMENT — "up" or "down"
    // ═══════════════════════════════════════════════════════════════
    if (direction === 'up' || direction === 'down') {
        const currentFloor = dungeonData.floors[ds.floor];
        const currentRoom = currentFloor.rooms[ds.currentRoom];

        if (!currentRoom.contents || !currentRoom.contents.ladder) {
            termAppend(`There is no ladder here.`, 'term-dim');
            return;
        }
        const ladder = currentRoom.contents.ladder;
        if (ladder.direction !== direction) {
            termAppend(`The ladder only goes ${ladder.direction}.`, 'term-dim');
            return;
        }

        const targetFloor = ladder.leadsTo.floor;
        const targetRoom  = ladder.leadsTo.room;

        if (!dungeonData.floors[targetFloor] || !dungeonData.floors[targetFloor].rooms[targetRoom]) {
            termAppend(`⚠️ Ladder leads nowhere (floor ${targetFloor} / ${targetRoom} not found).`, 'term-error');
            return;
        }

        // ── Transition ───────────────────────────────────────────
        ds.floor      = targetFloor;
        ds.currentRoom = targetRoom;
        
        // Load persistent map for the new floor and merge with current session
        const persistentMap = loadDungeonMap(gameState.player, ds.dungeonKey, targetFloor);
        const scopedKey = `${targetFloor}:${targetRoom}`;
        persistentMap.add(scopedKey); // Add current room
        saveRoomDiscovery(gameState.player, ds.dungeonKey, targetFloor, targetRoom); // Save to persistent
        
        ds.discoveredRooms = persistentMap; // Use persistent map for active session

        const destFloorData = dungeonData.floors[targetFloor];
        const destRoom = destFloorData.rooms[targetRoom];
        destRoom.flags = destRoom.flags || {};
        destRoom.flags.discovered = true;

        termAppend('', 'term-separator');
        termAppend(`🪜 You ${direction === 'up' ? 'climb up' : 'descend'} the ladder to <strong>Floor ${targetFloor}</strong>.`, 'term-highlight');
        termAppend(`<strong>${destRoom.name || targetRoom}</strong>`);
        termAppend(destRoom.description || '', 'term-dim');

        // List exits including any ladder in the destination room
        const exitList = buildExitList(destRoom);
        termAppend(`You see exits: ${exitList}.`, 'term-dim');

        // ♻️ Check for enemy respawns (30min timer)
        checkDungeonRespawns();

        checkTownExit(destRoom);
        triggerRoomTrap(destRoom);
        checkRunestone(destRoom);
        checkRoomEncounter(destRoom);
        checkEnemiesInRoom(targetRoom);
        saveGame();
        renderDungeonActionBar();
        return;
    }

    // ═══════════════════════════════════════════════════════════════
    // NORMAL DIRECTION MOVEMENT
    // ═══════════════════════════════════════════════════════════════
    const floor = dungeonData.floors[ds.floor];
    const currentRoom = floor.rooms[ds.currentRoom];

    const nextRoomId = currentRoom.exits[direction];
    if (!nextRoomId) {
        termAppend(`You cannot go that way.`, 'term-dim');
        return;
    }

    // ── DOOR LOCK CHECK ──────────────────────────────────────────────
    // If a locked door exists on this exit, player must have the matching key.
    const door = currentRoom.contents?.doors?.[direction];
    if (door && door.locked) {
        const keyItem = door.type + '_key';   // e.g. 'copper' → 'copper_key'
        const inv = gameState.player.inventory || [];
        const hasKey = inv.includes(keyItem);

        if (!hasKey) {
            // Door color names for flavour text
            const COLOR_NAMES = {
                bronze:'Bronze', copper:'Copper', iron:'Iron', brass:'Brass',
                silver:'Silver', electrum:'Electrum', ruby:'Ruby', topaz:'Topaz',
                diamond:'Diamond', obsidian:'Obsidian', bone:'Bone'
            };
            const doorName = (COLOR_NAMES[door.type] || door.type) + ' door';
            termAppend(
                `🔒 A locked <span style="color:${getDoorColor(door.type)}">${doorName}</span> blocks your path. You need a ${COLOR_NAMES[door.type] || door.type} key.`,
                'term-warning'
            );
            return;
        }

        // Player has the key — keys are permanent collectibles, door unlocks for session
        const COLOR_NAMES2 = {
            bronze:'Bronze', copper:'Copper', iron:'Iron', brass:'Brass',
            silver:'Silver', electrum:'Electrum', ruby:'Ruby', topaz:'Topaz',
            diamond:'Diamond', obsidian:'Obsidian', bone:'Bone'
        };
        termAppend(
            `🔓 Your <span style="color:${getDoorColor(door.type)}">${COLOR_NAMES2[door.type] || door.type} key</span> unlocks the door.`,
            'term-highlight'
        );
        door.locked = false; // door stays unlocked for rest of session
    }

    const nextRoom = floor.rooms[nextRoomId];

    ds.currentRoom = nextRoomId;
    if (!ds.discoveredRooms) ds.discoveredRooms = new Set();
    const scopedKey = `${ds.floor}:${nextRoomId}`;
    ds.discoveredRooms.add(scopedKey); // Active session
    saveRoomDiscovery(gameState.player, ds.dungeonKey, ds.floor, nextRoomId); // Persistent map
    nextRoom.flags = nextRoom.flags || {};
    nextRoom.flags.discovered = true;

    termAppend('', 'term-separator');
    termAppend(`<strong>${nextRoom.name || nextRoomId}</strong>`);
    termAppend(nextRoom.description || '', 'term-dim');

    // ♻️ Check for enemy respawns (30min timer)
    checkDungeonRespawns();

    // 🔥 Spawn encounter (once)
    checkRoomEncounter(nextRoom);

    // ✦ Runestone pickup (once, triggers flash cutscene)
    checkRunestone(nextRoom);

    // 👣 Move any active enemies that can follow; get list of who just arrived
    const arrivals = updateDungeonEnemies();

    // ⚔️ Unified enemy check — handles both pre-existing enemies AND followers
    //    Pass arrivals so followers can JOIN an active combat instead of waiting
    checkEnemiesInRoom(nextRoomId, arrivals);

    const exitList = buildExitList(nextRoom);
    termAppend(`You see exits: ${exitList}.`, 'term-dim');

    // 🌀 Check for town portal exit in this room
    checkTownExit(nextRoom);

    // 🪤 Check for traps
    triggerRoomTrap(nextRoom);

    // 💾 AUTO-SAVE after moving in dungeon
    saveGame();

    // 🔑 update buttons for new room
    renderDungeonActionBar();
}

// Build the exit string including ladder directions
function buildExitList(room) {
    const exits = Object.keys(room.exits || {}).map(d => d.toUpperCase());
    if (room.contents && room.contents.ladder) {
        exits.push(room.contents.ladder.direction === 'up' ? '⬆ UP' : '⬇ DOWN');
    }
    // Mark locked exits
    if (room.contents && room.contents.doors) {
        return exits.map(d => {
            const dl = d.toLowerCase();
            const door = room.contents.doors[dl];
            if (door && door.locked) {
                return `${d}<span style="color:#e8b84a">🔒</span>`;
            }
            return d;
        }).join(', ') || 'none';
    }
    return exits.length ? exits.join(', ') : 'none';
}

// Return the CSS color for a door type (matches dungeon editor palette)
function getDoorColor(type) {
    const DOOR_COLORS = {
        bronze:   '#cd7f32',
        copper:   '#b87333',
        iron:     '#a8a9ad',
        brass:    '#b5a642',
        silver:   '#c0c0c0',
        electrum: '#d4af37',
        ruby:     '#e0455b',
        topaz:    '#ffa07a',
        diamond:  '#aef0ff',
        obsidian: '#9b59b6',
        bone:     '#e8dcc8'
    };
    return DOOR_COLORS[type] || '#aaa';
}

// ═══════════════════════════════════════════════════════════════
// TRAP SYSTEM — triggers when player enters a room with a trap
// Supports both old singular (room.contents.trap) and new array
// (room.contents.traps[]) format from dungeon editor.
// ═══════════════════════════════════════════════════════════════
function triggerRoomTrap(room) {
    if (!room || !room.contents) return;
    const p = gameState.player;
    if (!p) return;

    // Build trap list — support both old (.trap) and new (.traps[]) formats
    let traps = [];
    if (room.contents.traps && Array.isArray(room.contents.traps)) {
        traps = room.contents.traps;                  // new array format
    } else if (room.contents.trap) {
        traps = [room.contents.trap];                 // old single-trap format
    }

    if (!traps.length) return;

    traps.forEach(trap => {
        if (!trap || !trap.type) return;

        // resetOnLeave = re-arm when player leaves (new format); no field = one-shot legacy
        const resetable = (trap.resetOnLeave === true);
        const dotType   = (trap.type === 'poison' || trap.type === 'acid');

        // Skip if already triggered and not resetable (one-shot spent)
        if (trap.triggered && !resetable && !dotType) return;

        const damage = trap.damage || 0;
        const name   = trap.name   || trap.type;

        switch (trap.type) {

            case 'spike':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`⚠️ <span style="color:#FF4444;">SPIKE TRAP!</span> Sharp spikes shoot from the floor — you take <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'stone':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`⚠️ <span style="color:#AA8866;">STONE TRAP!</span> A massive stone swings from the ceiling — you take <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'poison': {
                // DOT: damage spread over duration (default 10s, 5 ticks)
                const duration = trap.duration || 10;
                const ticks = 5;
                const tickInterval = Math.max(1000, (duration * 1000) / ticks);
                const tickDmg = Math.max(1, Math.ceil(damage / ticks));
                termAppend(`☠️ <span style="color:#44FF44;">POISON TRAP!</span> Toxic gas floods the room — you feel your strength seeping away!`, 'term-error');
                let t = 0;
                const timer = setInterval(() => {
                    if (!gameState.player || t >= ticks) { clearInterval(timer); return; }
                    gameState.player.hp = Math.max(1, gameState.player.hp - tickDmg);
                    termAppend(`☠️ Poison deals <strong>${tickDmg}</strong> damage... (${gameState.player.hp}/${gameState.player.maxHp} HP)`, 'term-error');
                    updateHud(); t++;
                }, tickInterval);
                break;
            }

            case 'acid': {
                // Acid: instant damage + short DOT
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`🧪 <span style="color:#a8e63d;">ACID TRAP!</span> Acid spray burns you — <strong>${damage} damage!</strong>`, 'term-error');
                const acidDuration = trap.duration || 5;
                const acidTicks = 3;
                const acidInterval = Math.max(500, (acidDuration * 1000) / acidTicks);
                const acidTickDmg = Math.max(1, Math.ceil(damage * 0.4 / acidTicks));
                let at = 0;
                const acidTimer = setInterval(() => {
                    if (!gameState.player || at >= acidTicks) { clearInterval(acidTimer); return; }
                    gameState.player.hp = Math.max(1, gameState.player.hp - acidTickDmg);
                    termAppend(`🧪 Acid burns for <strong>${acidTickDmg}</strong> more damage...`, 'term-error');
                    updateHud(); at++;
                }, acidInterval);
                if (!resetable) trap.triggered = true;
                break;
            }

            case 'fire':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`🔥 <span style="color:#FF8800;">FIRE TRAP!</span> Flames erupt from hidden vents — you take <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'lightning':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`⚡ <span style="color:#FFDD00;">LIGHTNING TRAP!</span> A bolt of lightning strikes you — <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'arrow':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`🏹 <span style="color:#CCCC44;">ARROW TRAP!</span> A crossbow bolt catches you off guard — you take <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'freeze':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`❄️ <span style="color:#88CCFF;">FREEZE TRAP!</span> A burst of ice envelops you — you take <strong>${damage} damage</strong> and feel sluggish!`, 'term-error');
                if (gameState.combatState && gameState.combatState.pipTimers) {
                    gameState.combatState.pipTimers = gameState.combatState.pipTimers.map(t => t + 8);
                }
                if (!resetable) trap.triggered = true;
                break;

            case 'pit':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`🕳️ <span style="color:#95a5a6;">PIT TRAP!</span> The floor gives way! You fall hard — <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'alarm':
                termAppend(`🔔 <span style="color:#dfe6e9;">ALARM TRAP!</span> A deafening bell rings out — nearby monsters are alerted!`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'web':
                termAppend(`🕸️ <span style="color:#b2bec3;">WEB TRAP!</span> Sticky strands bind your limbs — you're slowed for 2 rounds!`, 'term-error');
                // Disable movement pip for 2 recovery cycles
                if (gameState.combatState && gameState.combatState.pipTimers) {
                    gameState.combatState.pipTimers = gameState.combatState.pipTimers.map(t => t + 5);
                }
                if (!resetable) trap.triggered = true;
                break;

            case 'curse':
                termAppend(`🌀 <span style="color:#a855f7;">CURSE TRAP!</span> Dark energy courses through you — your stats are reduced!`, 'term-error');
                // Temporarily reduce attack by 20% for the session
                if (p.curseStacks === undefined) p.curseStacks = 0;
                p.curseStacks = Math.min(3, p.curseStacks + 1);
                if (!resetable) trap.triggered = true;
                break;

            default:
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`⚠️ <span style="color:#FF4444;">TRAP!</span> A ${name} catches you — you take <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
        }
    });

    updateHud();
}


function getEnemyInRoom(roomId) {
    const ds = gameState.dungeon;
    if (!ds || !ds.activeEnemies) return null;

    return ds.activeEnemies.find(enemy => enemy.currentRoom === roomId) || null;
}



function checkEnemiesInRoom(roomId, newArrivals) {
    const ds = gameState.dungeon;
    if (!ds || !ds.activeEnemies) return;

    const enemiesHere = ds.activeEnemies.filter(e => e.currentRoom === roomId);
    if (enemiesHere.length === 0) return;

    const cs = gameState.combatState;

    // ── Active non-finished combat: add ALL room enemies not yet in this fight ──
    if (cs && !cs.combatOver) {
        const linkedIds = new Set(cs.dungeonEnemyIds || (cs.dungeonEnemyId ? [cs.dungeonEnemyId] : []));

        // Join = any enemy in this room not already tracked in combat
        // (covers both followers from arrivals AND pre-existing room enemies)
        const joining = enemiesHere.filter(e => !linkedIds.has(e.id));
        if (joining.length === 0) return;

        joining.forEach(de => {
            if (!de.monsterId) return;
            const newMonster = spawnMonsterWithRarity(de.monsterId, false, de.rarity || 'common');
            newMonster.index = cs.monsters.length;
            if (de.hp !== undefined && de.hp < de.maxHp) {
                newMonster.hp    = de.hp;
                newMonster.maxHp = de.maxHp;
            }
            cs.monsters.push(newMonster);
            if (!cs.dungeonEnemyIds) cs.dungeonEnemyIds = cs.dungeonEnemyId ? [cs.dungeonEnemyId] : [];
            cs.dungeonEnemyIds.push(de.id);
            linkedIds.add(de.id);
            termAppend(`⚔️ <strong>${newMonster.name}</strong> joins the fight!`, 'term-warning');
        });

        // Ensure combat timer is running and reset actionMode so player sees all targets
        cs.actionMode = 'main';
        if (!gameState.combatTimer) startCombatTimer();
        renderDungeonActionBar();
        return;
    }

    // ── No combat or stale finished combat: clear state and start fresh ──
    if (cs) {
        if (gameState.combatTimer) { clearInterval(gameState.combatTimer); gameState.combatTimer = null; }
        gameState.combatState = null;
        gameState.postCombatRecovery = false;
    }

    if (enemiesHere.length === 1) {
        termAppend(`⚔️ <strong>${enemiesHere[0].name}</strong> confronts you!`, 'term-warning');
    } else {
        const names = enemiesHere.map(e => `<strong>${e.name}</strong>`).join(', ');
        termAppend(`⚔️ ${names} surround you!`, 'term-warning');
    }
    startDungeonCombat(enemiesHere);
}

function startDungeonCombat(dungeonEnemies) {
    // Accept either a single enemy or an array
    if (!Array.isArray(dungeonEnemies)) dungeonEnemies = [dungeonEnemies];
    if (dungeonEnemies.length === 0) return;

    // Clear any stale finished combat state
    if (gameState.combatState && gameState.combatState.combatOver) {
        gameState.combatState = null;
        gameState.postCombatRecovery = false;
    }

    const monsterIds = dungeonEnemies.map(e => e.monsterId).filter(Boolean);
    if (monsterIds.length === 0) {
        console.error('Dungeon enemies missing monsterId:', dungeonEnemies);
        return;
    }

    // Each dungeon enemy carries its rarity from the room definition (default 'common').
    // This prevents any random rarity rolls — dungeon difficulty is author-controlled.
    const forcedRarities = dungeonEnemies.map(e => e.rarity || 'common');

    // Start combat with all enemies in room (useZoneLevel=false for dungeons)
    startCombat(monsterIds, false, forcedRarities);

    if (!gameState.combatState) return;

    // Link ALL dungeon enemy IDs to combat state for post-combat cleanup
    gameState.combatState.dungeonEnemyIds = dungeonEnemies.map(e => e.id);
    // Legacy single-enemy field (keeps drops working for first enemy)
    gameState.combatState.dungeonEnemyId = dungeonEnemies[0].id;

    // Restore saved HP for each monster (matched by index)
    dungeonEnemies.forEach((de, idx) => {
        if (de.hp !== undefined && de.hp < de.maxHp) {
            const monster = gameState.combatState.monsters[idx];
            if (monster) {
                monster.hp  = de.hp;
                monster.maxHp = de.maxHp;
            }
        }
    });

    saveGame();
}


// ─────────────────────────────────────────
// TEMP: DUNGEON TEST HARNESS (SAFE)
// ─────────────────────────────────────────

function returnToTown(townId) {
    console.log('⬅ returnToTown() called');
    // ── Dungeon keys persist in inventory — they are permanent collectibles ──

    // ── Persist defeated-enemy respawn timers so farming is prevented ──
    if (gameState.dungeon && gameState.dungeon.defeatedEnemies && gameState.dungeon.defeatedEnemies.length > 0) {
        const dKey = gameState.dungeon.dungeonKey;
        if (dKey) {
            if (!gameState.player.dungeonTimers) gameState.player.dungeonTimers = {};
            // Merge with any existing timers for this dungeon
            const existing = gameState.player.dungeonTimers[dKey] || [];
            const existingIds = new Set(existing.map(e => e.id));
            const fresh = gameState.dungeon.defeatedEnemies.filter(e => !existingIds.has(e.id));
            gameState.player.dungeonTimers[dKey] = [...existing, ...fresh];
            console.log(`💾 Preserved ${gameState.player.dungeonTimers[dKey].length} enemy timer(s) for ${dKey}`);
        }
    }

    // Clear dungeon state
    gameState.dungeon = null;
    gameState.combatState = null;
    gameState.postCombatRecovery = false;

    if (gameState.combatTimer) {
        clearInterval(gameState.combatTimer);
        gameState.combatTimer = null;
    }

    // Update current town if specified
    if (townId) gameState.currentTown = townId;

    document.body.classList.remove("terminal-mode");
    termClear();

    const ab = document.getElementById('actionBar');
    ab.innerHTML = '';

    gameState._terminalOpen = false;
    gameState._currentExploreArea = null;

    saveGame();
    showTown();
}

// ═══════════════════════════════════════════════════════════════
// CHECK TOWN EXIT FLAG IN DUNGEON ROOMS
// When a room has flags.townExit, show a portal button to that town.
// ═══════════════════════════════════════════════════════════════
function checkTownExit(room) {
    if (!room || !room.flags || !room.flags.townExit) return;
    const townId = room.flags.townExit;
    const label  = room.flags.townExitLabel || `Exit to ${townId}`;
    const firstDiscovery = room.flags.firstDiscovery;

    // Special first-discovery logic: award White Runestone
    if (firstDiscovery && townId === 'town2') {
        const p = gameState.player;
        if (!p.runestones) p.runestones = [];
        if (!p.runestones.includes('white_runestone')) {
            p.runestones.push('white_runestone');
            if (!p.achievements) p.achievements = [];
            p.achievements.push({ id: 'white_runestone', name: 'White Runestone', earned: Date.now() });

            termAppend('', 'term-separator');
            termAppend('✦ <span style="color:#FFFFFF;font-weight:bold;">WHITE RUNESTONE</span> ✦', 'term-highlight');
            termAppend('You have discovered Ashen Harbor! A pale runestone materializes in your hand.', 'term-loot');
            termAppend('The Portal network is now accessible from both towns.', 'term-dim');
            termAppend('', 'term-separator');

            // Don't trigger again
            room.flags.firstDiscovery = false;
            saveGame();
        }
    }

    // Post a clickable portal message in the terminal
    setTimeout(() => {
        termAppend(
            `<span style="color:#AA88FF;cursor:pointer;font-weight:bold;" onclick="townExitFromDungeon('${townId}')">` +
            `[ ${label} ]</span>`,
            'term-highlight'
        );
    }, 300);
}

// Called when player clicks the town exit link from a dungeon room
function townExitFromDungeon(townId) {
    const townDef = (typeof TOWNS !== 'undefined' && TOWNS[townId]) ? TOWNS[townId] : null;
    const townName = townDef ? townDef.name : townId;
    if (confirm(`Leave the dungeon and travel to ${townName}?`)) {
        returnToTown(townId);
    }
}

// ═══════════════════════════════════════════════════════════════
// LEAVE EXPLORATION TO TOWN (allowed when pips are full)
// Enemies are preserved via activeCombat save system
// ═══════════════════════════════════════════════════════════════
function leaveExploreToTown() {
    const cs = gameState.combatState;
    if (cs) {
        const allReady = cs.pipAvailable && cs.pipAvailable.every(x => x);
        if (!allReady) {
            termAppend('<span style="color:var(--error-color);">⚠ You must wait for all pips to recover before leaving!</span>');
            return;
        }
        // Enemies are preserved — activeCombat will save them
    }

    // Clear timers but NOT combatState (save will capture it)
    if (gameState.combatTimer) {
        clearInterval(gameState.combatTimer);
        gameState.combatTimer = null;
    }

    // Stop resting timers
    stopResting();

    document.body.classList.remove("terminal-mode");
    document.getElementById('actionBar').innerHTML = '';
    gameState._terminalOpen = false;
    gameState._currentExploreArea = null;

    saveGame();  // Saves activeCombat with enemies still alive
    showTown();
}

function testDungeon() {
    // Legacy redirect — use town1's dungeon
    startDungeon('Dungeon1');
}



const BASE_PIP_COOLDOWN = 10;
const MIN_PIP_COOLDOWN = 5;

// ── PIP SWEEP BUTTON ANIMATION ─────────────────────────────────────
// Called each tick to update the conic-gradient overlay on Attack/Spell btns.
// Uses total "worst" pip state: sweep = fraction of the longest cooling pip.
function updatePipButtons() {
    const cs = gameState.combatState;
    if (!cs || !cs.pipTimers) return;

    const cd     = gameState.player ? getPipCooldown(gameState.player) : BASE_PIP_COOLDOWN;
    const total  = cs.pipTimers.length;
    const ready  = cs.pipAvailable.filter(Boolean).length;
    const cooling = total - ready;

    // Fraction complete = 1 means "fully cooled" (no overlay)
    // We show the cooldown of the pip that will recover SOONEST (smallest remaining)
    let pct = 1; // default = ready (no overlay)
    if (cooling > 0) {
        // Find the minimum remaining timer among cooling pips
        let minRemaining = Infinity;
        for (let i = 0; i < total; i++) {
            if (!cs.pipAvailable[i]) {
                minRemaining = Math.min(minRemaining, cs.pipTimers[i]);
            }
        }
        // pct = fraction ALREADY elapsed (so sweep goes from full → empty as timer counts down)
        pct = 1 - (minRemaining / cd);
        pct = Math.max(0, Math.min(1, pct));
    }

    // For multi-pip, the dial wraps: each full rotation = one pip recovery
    // We rotate based on: (pips already recovered this cycle) + current pip fraction
    // Visual: dial spins continuously once per pip cooldown duration
    const revolutionsLeft = cooling;  // each remaining pip = one more sweep
    // conic-gradient percentage = fraction of current pip elapsed
    const pipPct = (pct * 100).toFixed(1) + '%';

    // Update all pip-btn elements
    document.querySelectorAll('.pip-btn').forEach(btn => {
        btn.style.setProperty('--pip-pct', pipPct);
        if (cooling > 0) {
            btn.classList.add('cooling');
            btn.classList.remove('all-ready');
            // Show pip badge if >1 pip cooling
            let badge = btn.querySelector('.pip-badge');
            if (cooling > 1) {
                if (!badge) { badge = document.createElement('span'); badge.className='pip-badge'; btn.appendChild(badge); }
                badge.textContent = cooling + '×';
            } else if (badge) {
                badge.remove();
            }
        } else {
            btn.style.setProperty('--pip-pct', '0%');
            btn.classList.remove('cooling');
            btn.classList.add('all-ready');
            const badge = btn.querySelector('.pip-badge');
            if (badge) badge.remove();
        }
    });
}

function getPipCooldown(player){
    // Base is always 10s for all classes regardless of class speed stat.
    // Only active speed_boost buff potions reduce pip recovery time.
    let cooldown = BASE_PIP_COOLDOWN;

    // Check for active speed_boost buff (from speed potions only)
    if (player.buffs) {
        const speedBuff = player.buffs.find(b => b.type === 'speed_boost');
        if (speedBuff) {
            // speedBuff.power is a percentage bonus (e.g. 25 = 25% faster)
            const reduction = Math.floor(cooldown * (speedBuff.power / 100));
            cooldown -= reduction;
        }
    }

    return Math.max(MIN_PIP_COOLDOWN, cooldown);
}




// ═══════════════════════════════════════════════════════════════════════
// MONSTER ABILITY SIDE-EFFECTS
// Called after the damage of an ability attack lands.
// Types: dot_attack, debuff, stun, heavy_hit, drain_hp, drain_mp,
//        rend, burn, intimidate, leech, dispel, summon, aoe
// ═══════════════════════════════════════════════════════════════════════
function executeAbilitySideEffect(abilityDef, p, cs, enemy) {
    const type = abilityDef.type;
    const enemyName   = (enemy && enemy.name) ? enemy.name : 'Enemy';
    const playerClass = p.className || p.class || 'adventurer';

    // ── PHASE II STUB: deduct enemy MP when the system is wired up ──
    // if (enemy && abilityDef.mpCost) {
    //     enemy.mp = Math.max(0, (enemy.mp || 0) - abilityDef.mpCost);
    // }

    // ── helper: start a DOT timer (shared by dot_attack and burn) ───
    function _startDOT(dot) {
        let ticksLeft = dot.ticks;
        const dotTimer = setInterval(() => {
            if (!gameState.combatState || p.hp <= 0) { clearInterval(dotTimer); return; }
            p.hp = Math.max(0, p.hp - dot.damage);
            updateHud();
            termAppend(`<span style="color:#ff8800;">${dot.icon || '💀'} ${dot.name}: ${dot.damage} damage!</span>`, 'term-dim');
            if (p.hp <= 0) { clearInterval(dotTimer); endCombat(false); return; }
            ticksLeft--;
            if (ticksLeft <= 0) {
                clearInterval(dotTimer);
                termAppend(`<span style="color:#888;">${dot.name} fades.</span>`, 'term-dim');
            }
        }, dot.tickInterval);
        if (!cs.dotTimers) cs.dotTimers = {};
        cs.dotTimers[`ability_${abilityDef.id}_${Date.now()}`] = dotTimer;
    }

    // ── helper: display ability message ─────────────────────────────
    function _msg(fallback) {
        const txt = abilityDef.applyMessage
            ? abilityDef.applyMessage(enemyName, playerClass)
            : fallback;
        termAppend(`<span style="color:#ff8800;">${txt}</span>`, 'term-warning');
    }

    // ════════════════════════════════════════════════════════════════
    // 1. DOT_ATTACK — physical hit followed by a damage-over-time
    // ════════════════════════════════════════════════════════════════
    if (type === 'dot_attack' && abilityDef.dot) {
        _msg(`💀 ${abilityDef.dot.name}!`);
        _startDOT(abilityDef.dot);
    }

    // ════════════════════════════════════════════════════════════════
    // 2. DEBUFF — applies a combat-math penalty to the player
    // ════════════════════════════════════════════════════════════════
    else if (type === 'debuff') {
        _msg(`💀 ${abilityDef.debuff}!`);
        const dur = abilityDef.debuffDuration || 4000;

        if (abilityDef.debuff === 'blinded') {
            cs.playerBlindedMissChance = abilityDef.hitMissChance || 0.30;
            cs.playerBlindedHits = 1;
        }
        if (abilityDef.debuff === 'constricted') {
            cs.playerConstricted = true;
            setTimeout(() => {
                if (gameState.combatState) {
                    gameState.combatState.playerConstricted = false;
                    termAppend('<span style="color:#888;">You break free from the constriction.</span>', 'term-dim');
                }
            }, dur);
        }
        if (abilityDef.debuff === 'intimidated') {
            cs.playerIntimidated = abilityDef.damagePenalty || 0.25;
            setTimeout(() => {
                if (gameState.combatState) {
                    gameState.combatState.playerIntimidated = 0;
                    termAppend('<span style="color:#888;">Your courage returns.</span>', 'term-dim');
                }
            }, dur);
        }
        if (abilityDef.debuff === 'silenced') {
            cs.playerSilenced = true;
            setTimeout(() => {
                if (gameState.combatState) {
                    gameState.combatState.playerSilenced = false;
                    termAppend('<span style="color:#888;">You can speak again.</span>', 'term-dim');
                }
            }, dur);
        }
        if (abilityDef.debuff === 'slowed') {
            cs.playerSlowed = true;
            setTimeout(() => {
                if (gameState.combatState) {
                    gameState.combatState.playerSlowed = false;
                    termAppend('<span style="color:#888;">Your movement returns to normal.</span>', 'term-dim');
                }
            }, dur);
        }
    }

    // ════════════════════════════════════════════════════════════════
    // 3. STUN — locks player pip charges
    // ════════════════════════════════════════════════════════════════
    else if (type === 'stun') {
        _msg('💀 Stunned!');
        const stunPips = abilityDef.stunPips || 1;
        const stunSecs = abilityDef.stunDuration || 5;
        let stolen = 0;
        if (cs.pipTimers) {
            for (let i = 0; i < cs.pipTimers.length && stolen < stunPips; i++) {
                cs.pipTimers[i] = Math.max(cs.pipTimers[i] || 0, stunSecs);
                cs.pipAvailable[i] = false;
                stolen++;
            }
        }
        updateHud();
        renderActionBar();
    }

    // ════════════════════════════════════════════════════════════════
    // 4. HEAVY_HIT — pure damage amplifier (damageMult handles it)
    // ════════════════════════════════════════════════════════════════
    else if (type === 'heavy_hit') {
        _msg(`💥 ${enemyName} strikes with crushing force!`);
        // damage multiplier already applied via intent.damageMult — nothing extra needed
    }

    // ════════════════════════════════════════════════════════════════
    // 5. DRAIN_HP — enemy steals HP from player and heals itself
    // ════════════════════════════════════════════════════════════════
    else if (type === 'drain_hp') {
        const drain = abilityDef.drainAmount || 15;
        const healRatio = abilityDef.healPercent !== undefined ? abilityDef.healPercent : 1.0;
        const actualDrain = Math.min(drain, p.hp - 1); // can't drain to 0 via this mechanic alone
        if (actualDrain > 0) {
            p.hp -= actualDrain;
            const healAmt = Math.floor(actualDrain * healRatio);
            if (enemy && healAmt > 0) {
                enemy.hp = Math.min(enemy.maxHp || enemy.hp, enemy.hp + healAmt);
                updateEnemyCards();
            }
            updateHud();
            _msg(`🩸 ${enemyName} drains ${actualDrain} HP from the ${playerClass}!`);
            termAppend(`<span style="color:#ff4488;">❤️ ${enemyName} heals for ${healAmt}!</span>`, 'term-dim');
        }
    }

    // ════════════════════════════════════════════════════════════════
    // 6. DRAIN_MP — enemy drains player mana
    // ════════════════════════════════════════════════════════════════
    else if (type === 'drain_mp') {
        const drain = abilityDef.drainAmount || 20;
        const actualDrain = Math.min(drain, p.mp);
        if (actualDrain > 0) {
            p.mp -= actualDrain;
            updateHud();
        }
        _msg(`💙 ${enemyName} siphons ${actualDrain} MP from the ${playerClass}!`);
    }

    // ════════════════════════════════════════════════════════════════
    // 7. REND — tears armor, temporarily reducing player defense
    // ════════════════════════════════════════════════════════════════
    else if (type === 'rend') {
        const reduction = abilityDef.defReduction || 0.25;
        const dur = abilityDef.rendDuration || 8000;
        if (!cs.playerRendReduction) cs.playerRendReduction = 0;
        cs.playerRendReduction = Math.min(0.60, cs.playerRendReduction + reduction); // cap at 60% total
        _msg(`⚔️ ${enemyName} RENDS the ${playerClass}'s armor! Defense reduced!`);
        setTimeout(() => {
            if (gameState.combatState) {
                gameState.combatState.playerRendReduction = Math.max(0,
                    (gameState.combatState.playerRendReduction || 0) - reduction);
                termAppend('<span style="color:#888;">Your armor holds together again.</span>', 'term-dim');
            }
        }, dur);
    }

    // ════════════════════════════════════════════════════════════════
    // 8. BURN — ranged fire DOT (no physical hit required)
    // ════════════════════════════════════════════════════════════════
    else if (type === 'burn' && abilityDef.dot) {
        _msg(`🔥 ${enemyName} engulfs the ${playerClass} in flames!`);
        _startDOT(abilityDef.dot);
    }

    // ════════════════════════════════════════════════════════════════
    // 9. INTIMIDATE — enemy roar/presence reduces player damage output
    // ════════════════════════════════════════════════════════════════
    else if (type === 'intimidate') {
        const penalty = abilityDef.damagePenalty || 0.25;
        const dur = abilityDef.intimidateDuration || 6000;
        cs.playerIntimidated = penalty;
        _msg(`😨 ${enemyName} lets out a terrifying roar! You hesitate...`);
        setTimeout(() => {
            if (gameState.combatState) {
                gameState.combatState.playerIntimidated = 0;
                termAppend('<span style="color:#888;">You shake off the fear.</span>', 'term-dim');
            }
        }, dur);
    }

    // ════════════════════════════════════════════════════════════════
    // 10. LEECH — physical hit heals enemy for a fraction of damage dealt
    //     (healRatio applied to the damage already dealt this hit)
    // ════════════════════════════════════════════════════════════════
    else if (type === 'leech') {
        const ratio = abilityDef.healRatio || 0.5;
        // cs.lastEnemyDamageDealt is set by enemyAttackSingle after damage lands
        const dmgDealt = cs.lastEnemyDamageDealt || 0;
        const healAmt = Math.max(1, Math.floor(dmgDealt * ratio));
        if (enemy && healAmt > 0) {
            enemy.hp = Math.min(enemy.maxHp || enemy.hp, enemy.hp + healAmt);
            updateEnemyCards();
        }
        _msg(`🩸 ${enemyName} leeches life from the ${playerClass}!`);
        if (healAmt > 0) termAppend(`<span style="color:#ff4488;">❤️ ${enemyName} heals for ${healAmt}!</span>`, 'term-dim');
    }

    // ════════════════════════════════════════════════════════════════
    // 11. DISPEL — removes player's active buff potions
    // ════════════════════════════════════════════════════════════════
    else if (type === 'dispel') {
        const slots = abilityDef.buffSlots || 1;
        const buffs = p.activeBuffs || [];
        let removed = 0;
        for (let i = buffs.length - 1; i >= 0 && removed < slots; i--) {
            const buff = buffs[i];
            if (buff && buff.name) {
                termAppend(`<span style="color:#ff8800;">✨ ${buff.name} dispelled!</span>`, 'term-warning');
                buffs.splice(i, 1);
                removed++;
            }
        }
        if (removed === 0) {
            termAppend(`<span style="color:#888;">${enemyName} attempts to dispel — nothing to cancel.</span>`, 'term-dim');
        } else {
            _msg(`✨ ${enemyName} tears your magical protections away!`);
        }
    }

    // ════════════════════════════════════════════════════════════════
    // 12. SUMMON — calls additional enemies into the fight
    // ════════════════════════════════════════════════════════════════
    else if (type === 'summon') {
        const summonKey = abilityDef.summonKey;
        const count     = abilityDef.summonCount || 1;
        const maxSummons = abilityDef.maxSummons || 2;
        if (!cs.summonCount) cs.summonCount = 0;
        if (cs.summonCount >= maxSummons) {
            if (gameState.sysop && gameState.sysop.authenticated) {
                termAppend('<span style="color:#664400;">  [SUMMON] cap reached — skipped</span>', 'term-dim');
            }
            return;
        }
        _msg(`💀 ${enemyName} calls for reinforcements!`);
        for (let s = 0; s < count && cs.summonCount < maxSummons; s++) {
            if (ENEMIES && ENEMIES[summonKey]) {
                const summoned = spawnMonsterWithRarity(summonKey, false, 'common');
                summoned.index = cs.monsters.length;
                cs.monsters.push(summoned);
                cs.monsterStatusEffects[summoned.index] = [];
                cs.summonCount++;
                termAppend(`<span style="color:#ff4400;">⚡ A ${summoned.name} joins the fight!</span>`, 'term-warning');
            }
        }
        updateEnemyCards();
        renderActionBar();
    }

    // ════════════════════════════════════════════════════════════════
    // 13. AOE — splash damage hits player regardless of dodge
    // ════════════════════════════════════════════════════════════════
    else if (type === 'aoe') {
        _msg(`💥 ${enemyName} unleashes a devastating shockwave!`);
        // damageMult on the intent already handled base damage;
        // AOE ignores dodge — handled via intent.armorPiercing + dodge suppression
        cs.playerConstricted = true; // borrow constrict flag to suppress dodge for this hit
        setTimeout(() => {
            if (gameState.combatState) gameState.combatState.playerConstricted = false;
        }, 500);
    }
}

function selectEnemyIntent(enemy) {
    // ── Default basic attack ─────────────────────────────────────────
    let intent = {
        type: 'basic',
        damageMult: 1,
        armorPiercing: 0,
        telegraph: 'prepares to strike...'
    };

    // ── Boss heavy hit ───────────────────────────────────────────────
    if (enemy.isBoss && Math.random() < 0.4) {
        intent = {
            type: 'heavy',
            damageMult: 1.75,
            armorPiercing: 0.3,
            telegraph: 'draws in power for a devastating attack!'
        };
    }

    // ── Monster ability rolls ────────────────────────────────────────
    // Each ability is checked in order. First one that passes its roll wins.
    // This creates simple AI priority: put scarier abilities first in the array.
    const _dbgAbility = gameState.sysop && gameState.sysop.authenticated;

    // Pure-debuff types replace the physical hit entirely (no damage roll)
    const PURE_DEBUFF_TYPES = ['debuff', 'drain_mp', 'rend', 'intimidate', 'dispel', 'stun', 'burn'];

    if (enemy.abilities && enemy.abilities.length > 0) {
        for (const ability of enemy.abilities) {
            // ── HP threshold check ────────────────────────────────────
            if (ability.hpThreshold !== undefined && ability.hpThreshold !== null) {
                const hpPct = enemy.hp / (enemy.maxHp || enemy.hp);
                if (hpPct < ability.hpThreshold) {
                    if (_dbgAbility) termAppend('<span style="color:#664400;">  [ABILITY] ' + ability.name
                        + ' — skipped (HP ' + Math.round(hpPct*100) + '% < threshold '
                        + Math.round(ability.hpThreshold*100) + '%)</span>', 'term-dim');
                    continue;
                }
            }
            // ── Low-HP threshold check ────────────────────────────────
            if (ability.lowHpThreshold !== undefined && ability.lowHpThreshold !== null) {
                const hpPct = enemy.hp / (enemy.maxHp || enemy.hp);
                if (hpPct > ability.lowHpThreshold) {
                    if (_dbgAbility) termAppend('<span style="color:#664400;">  [ABILITY] ' + ability.name
                        + ' — skipped (HP ' + Math.round(hpPct*100) + '% > lowHP threshold '
                        + Math.round(ability.lowHpThreshold*100) + '%)</span>', 'term-dim');
                    continue;
                }
            }

            // ── Phase II: MP check ────────────────────────────────────
            const _cost = ability.mpCost || 0;
            const _canAfford = _cost === 0 || (enemy.mp || 0) >= _cost;
            if (!_canAfford) {
                // Only show "exhausted" message once per enemy per fight
                if (_dbgAbility) {
                    const _label = enemy.mpDepleted ? '' : ' ← OUT OF MP';
                    termAppend('<span style="color:#664400;">  [ABILITY] ' + ability.name
                        + ' — NO MP (' + (enemy.mp||0) + '/' + (enemy.baseMp||0) + ' needed ' + _cost + ')' + _label
                        + '</span>', 'term-dim');
                    enemy.mpDepleted = true;  // suppress repeated messages
                }
                continue;  // skip this ability, try next (or fall through to basic attack)
            }

            // ── Roll for this ability ─────────────────────────────────
            const _abilityRoll = Math.random();
            const _abilityHit  = _abilityRoll < ability.chance;

            if (_dbgAbility) {
                const _mpTag = _cost > 0 ? ' | MP: ' + (enemy.mp||0) + '→' + ((enemy.mp||0) - _cost) : ' | free';
                const _typeTag = PURE_DEBUFF_TYPES.includes(ability.type) ? ' [DEBUFF-ONLY]' : ' [DMG×' + (ability.damageMult||1) + ']';
                termAppend('<span style="color:#664400;">  🎯 [ABILITY] ' + ability.name
                    + ': rolled ' + (_abilityRoll * 100).toFixed(2) + '% / need ≤'
                    + (ability.chance * 100).toFixed(0) + '% → '
                    + (_abilityHit ? '✅ FIRES' : '❌ miss')
                    + _typeTag + _mpTag
                    + '</span>', 'term-dim');
            }

            if (_abilityHit) {
                // Mark whether this is a pure debuff (replaces hit) or a damage ability
                const _isPureDebuff = PURE_DEBUFF_TYPES.includes(ability.type);
                intent = {
                    type:          ability.type,
                    abilityId:     ability.id,
                    abilityDef:    ability,
                    abilityMpCost: _cost,            // stored so enemyAttackSingle can deduct
                    isPureDebuff:  _isPureDebuff,    // true = skip damage roll
                    damageMult:    _isPureDebuff ? 0 : (ability.damageMult || 1.3),  // default +30%
                    armorPiercing: ability.armorPiercing || 0,
                    telegraph:     ability.telegraph,
                };
                break;
            }
        }
    }

    if (_dbgAbility) {
        const _mpStr = (enemy.baseMp||0) > 0
            ? ' | MP: ' + (enemy.mp||0) + '/' + (enemy.baseMp||0)
            : '';
        termAppend('<span style="color:#664400;">  → intent: <b>' + intent.type + '</b>'
            + (intent.abilityId ? ' [' + intent.abilityId + ']' : '')
            + (intent.isPureDebuff ? ' <b>DEBUFF-ONLY (no damage)</b>' : ' | ×dmg: ' + (intent.damageMult||1))
            + ' | pierce: ' + ((intent.armorPiercing||0)*100).toFixed(0) + '%'
            + _mpStr
            + '</span>', 'term-dim');
    }

    return intent;
}


function consumePips(cs, amount, cooldown) {
    let used = 0;

    for (let i = 0; i < cs.pipAvailable.length && used < amount; i++) {
        if (cs.pipAvailable[i]) {
            cs.pipAvailable[i] = false;
            cs.pipTimers[i] = cooldown;
            used++;
        }
    }
}




        // ═══════════════════════════════════════════════════════════════
        // DAMAGE SCALING (Rebalanced for harder early game)
        // ═══════════════════════════════════════════════════════════════
        const DAMAGE_SCALING = {
            // Monster damage multiplier — 1.0 = no bonus on top of level/rarity scaling.
            // The level-scaling and rarity system already handle enemy power progression.
            // A 1.3x bonus was pushing same-level hits to ~20 on a Rogue with 85 HP.
            monsterDamageMult: 1.0
        };

        // ═══════════════════════════════════════════════════════════════
        // ENEMY DODGE CALCULATION - Based on level difference
        // ═══════════════════════════════════════════════════════════════
        function calculateEnemyDodge(playerLevel, enemyLevel) {
            const levelDiff = enemyLevel - playerLevel;
            
            // Base dodge: 5% when levels are equal
            let dodgeChance = 0.05;
            
            if (levelDiff > 0) {
                // Enemy is higher level: +5% dodge per level difference
                dodgeChance += (levelDiff * 0.05);
            } else if (levelDiff < 0) {
                // Player is higher level: -1% dodge per level difference
                dodgeChance += (levelDiff * 0.01); // levelDiff is negative, so this subtracts
            }
            
            // Cap at 0% minimum (can't go negative)
            dodgeChance = Math.max(0, dodgeChance);
            
            // Cap at 50% maximum (so it's not impossible to hit)
            dodgeChance = Math.min(0.50, dodgeChance);
            
            return dodgeChance;
        }

        // ═══════════════════════════════════════════════════════════════
        // LEVEL-SCALING DAMAGE MODIFIER
        // Per level enemy is ABOVE player: player deals -5%, takes +5%
        // Per level enemy is BELOW player: player deals +5%, takes -5%
        // Capped at ±50%.
        // ═══════════════════════════════════════════════════════════════
        function getLevelDamageMult(playerLevel, enemyLevel) {
            const diff = (enemyLevel || 1) - (playerLevel || 1);
            const PCT  = 0.05;
            const CAP  = 0.50;
            const shift = Math.max(-CAP, Math.min(CAP, diff * PCT));
            return {
                playerDealt: Math.max(0.1, 1 - shift),  // enemy higher → player deals less
                enemyDealt:  Math.max(0.5, 1 + shift)   // enemy higher → player takes more
            };
        }
        
        function calculateDamage({
  attacker,
  defender,
  base,
  type = 'physical', // 'physical' | 'magic'
  critChance = 0,
  critMult = 1.5,
  dodgeChance = 0,
  armorPiercing = 0,
  isSpecial = false
}) {
  // Dodge check
  if (Math.random() < dodgeChance) {
    return { damage: 0, dodged: true, crit: false };
  }

  // Base damage roll
  let damage = base;

  // Defense mitigation — percentage-based damage reduction (DR)
  // Each point of defense = 2.8% DR, hard-capped at 75%.
  // This replaces flat subtraction which let even tiny armor eat huge chunks of
  // low-roll damage while leaving high-roll damage almost untouched.
  // DR is consistent regardless of the hit size — cloth feels like cloth,
  // plate feels like plate, at every level of the game.
  let rawDefense =
    type === 'magic'
      ? (defender.magicDefense || 0)
      : (defender.defense || 0);

  const DR_PER_POINT = 0.028;
  const DR_CAP       = 0.75;
  const effectiveDR  = Math.min(DR_CAP, rawDefense * DR_PER_POINT) * (1 - armorPiercing);

  damage = Math.max(1, Math.floor(damage * (1 - effectiveDR)));

  // Crit check
  let crit = false;
  if (Math.random() < critChance) {
    damage = Math.floor(damage * critMult);
    crit = true;
  }

  return { damage, dodged: false, crit };
}

        
     function executeAttack(attackType) {
    const cs = gameState.combatState;
    if (!cs) return;

    const p  = gameState.player;
    const ti = cs.currentTarget;
    const enemy = cs.monsters[ti];
    let weapon = WEAPONS[p.weapon];
    
    // No weapon equipped → fight with bare fists
    if (!weapon) {
        if (p.weapon && p.weapon !== 'bare_fists') {
            // Weapon key set but missing from DB — silently switch to fists
            console.warn(`⚠️ Weapon '${p.weapon}' not found — fighting unarmed.`);
        }
        p.weapon = 'bare_fists';
        weapon   = WEAPONS['bare_fists'];
    }
    
    const unarmed = !!weapon.unarmed;
    
    const qBonus = getQualityBonus(weapon.quality, weapon.baseDamage);

    // Determine pip cost and damage multiplier
    let pipCost = 1;
    let damageMultiplier = 1;
    let attackName = unarmed ? 'punches' : 'attack';
    let armorPiercing = 0;

    if (attackType === 'normal') {
        pipCost = 1;
    } 
    else if (attackType === 'heavy') {
        // HIGH RISK / HIGH REWARD: costs 2 pips, 35% miss chance, but hits for 3x damage
        pipCost = 2;
        damageMultiplier = 3.0;
        attackName = unarmed
            ? 'winds up a <span style="color:#FF8800;">HAYMAKER</span>'
            : 'winds up a <span style="color:#FF8800;">HEAVY STRIKE</span>';
        armorPiercing = 0.35;
    } 
    else if (attackType === 'special') {
        const availablePips = cs.pipAvailable.filter(x => x).length;
        pipCost = availablePips;
        damageMultiplier = 1 + (availablePips * 0.5);
        attackName = unarmed
            ? `unleashes a <span style="color:#FFD700;">⭐ FLURRY OF BLOWS ⭐</span> (${availablePips} pips)`
            : `unleashes a <span style="color:#FFD700;">⭐ SPECIAL ATTACK ⭐</span> (${availablePips} pips)`;
        armorPiercing = 0.3;
    }

    // Check pip availability
    const availablePips = cs.pipAvailable.filter(x => x).length;
    if (availablePips < pipCost) {
        termAppend('Not enough attack charges!', 'term-error');
        return;
    }

    // Consume pips
    consumePips(cs, pipCost, getPipCooldown(p));
    
    // Always reset action mode to main - whether the attack hits or dodges,
    // the player should see the main combat menu (with updated pips)
    cs.actionMode = 'main';
    
    // ═══════════════════════════════════════════════════════════════
    // ROGUE: SHADOW STRIKE - Guaranteed crit from stealth
    // ═══════════════════════════════════════════════════════════════
    let shadowStrike = false;
    const baseClass = p.baseClass || p.class;
    if (baseClass === 'rogue' && p.shadowStrikeReady) {
        shadowStrike = true;
        p.shadowStrikeReady = false;
        
        // Clear the timer
        if (p.shadowStrikeTimer) {
            clearTimeout(p.shadowStrikeTimer);
            p.shadowStrikeTimer = null;
        }
        
        termAppend('', 'term-separator');
        termAppend('⚫ <span style="color:#8888FF;font-weight:bold;">You leap from the shadows!</span> ⚫', 'term-highlight');
    }

    // ═══════════════════════════════════════════════════════════════
    // RUNESMITH: RUNE OVERLOAD — 3 pips → devastating armor-piercing strike
    // ═══════════════════════════════════════════════════════════════
    let runeOverloadActive = false;
    if (baseClass === 'runesmith' && (p.runeOverloadPips || 0) >= 3) {
        runeOverloadActive = true;
        p.runeOverloadPips = 0;
        termAppend('', 'term-separator');
        termAppend('🔥⚒️ <span style="color:#FF8800;font-weight:bold;">RUNE OVERLOAD!</span> <span style="color:#FFaa00;">The runes detonate — armor is nothing!</span> 🔥⚒️', 'term-highlight');
    }

    // Calculate base damage WITH RANGE ROLLING
    // Roll between baseDamage and maxDamage
    const minDmg = weapon.baseDamage + qBonus;
    const maxDmg = (weapon.maxDamage || weapon.baseDamage) + qBonus;
    let weaponDamage = Math.floor(Math.random() * (maxDmg - minDmg + 1)) + minDmg;

    // ── Apply socketed gem bonuses (weapon + armor) ─────────────────
    const socketed = weapon.gems || [];
    const armorObj = p.armor ? ARMOR[p.armor] : null;
    const armorGems = (armorObj && armorObj.gems) ? armorObj.gems : [];
    const allGems = [...socketed, ...armorGems];
    let gemMeleeDmg = 0, gemMagicDmg = 0, gemCritBonus = 0, gemPierceBonus = 0;
    let gemPoisonChance = 0, gemLightningDmg = 0, gemLifesteal = 0;
    let gemFireDmg = 0, gemFrostDmg = 0, gemSpellLeech = 0;
    let gemHpBonus = 0, gemDefBonus = 0;
    for (const gem of allGems) {
        if (!gem || !gem.stats) continue;
        gemMeleeDmg     += gem.stats.weaponDmg    || 0;
        gemMagicDmg     += gem.stats.spellPower   || 0;
        gemCritBonus    += gem.stats.critBonus    || 0;
        gemPierceBonus  += gem.stats.armorPierce  || 0;
        gemPoisonChance += gem.stats.poisonChance || 0;
        gemLightningDmg += gem.stats.lightningDmg || 0;
        gemLifesteal    += gem.stats.lifesteal     || 0;
        gemFireDmg      += gem.stats.fireDmg      || 0;
        gemFrostDmg     += gem.stats.frostDmg     || 0;
        gemSpellLeech   += gem.stats.spellLeech   || 0;
        gemHpBonus      += gem.stats.hpBonus      || 0;   // ← was never read
        gemDefBonus     += gem.stats.defenseBonus || 0;   // ← was never read
    }

    const physicalBase =
        weaponDamage + Math.floor((p.str || 0) * 1.5) + gemMeleeDmg;

    const magicBase =
        (weapon.baseMagicDamage || 0) +
        Math.floor((p.wis || 0) * 1.5) + gemMagicDmg;  // WIS (point-buy) drives magic-weapon bonus

    // Use whichever damage type is higher for this weapon — don't add both
    let totalBase = Math.floor(
        Math.max(physicalBase, magicBase) * damageMultiplier
    );

    const classMult = getClassDamageMultiplier(p);
    totalBase = Math.floor(totalBase * classMult);

    // Calculate enemy dodge chance based on level difference
    const enemyDodgeChance = calculateEnemyDodge(p.level, enemy.level);

    // ── INTIMIDATED: enemy roar reduces player damage output ────────
    if ((cs.playerIntimidated || 0) > 0) {
        if (gameState.sysop && gameState.sysop.authenticated) {
            termAppend('<span style="color:#003355;">  ⚠️ [INTIMIDATED] damage penalty: -' + Math.round((cs.playerIntimidated||0)*100) + '%</span>', 'term-dim');
        }
        // Applied as a multiplier after all other damage calcs
        // We store it in cs so executeAttack can read it
    }

    // ── SILENCED: prevents spell casting ─────────────────────────────
    // (checked in castSpell before pip consumption)

    // ── BLINDED: goblin dirty strike — player has extra miss chance ───
    if ((cs.playerBlindedMissChance || 0) > 0) {
        const _blindRoll = Math.random();
        const _blindChance = cs.playerBlindedMissChance;
        if (gameState.sysop && gameState.sysop.authenticated) {
            termAppend('<span style="color:#003355;">  ⚠️ [BLIND] miss roll: ' + (_blindRoll*100).toFixed(2) + '% / need >' + (_blindChance*100).toFixed(0) + '% to hit</span>', 'term-dim');
        }
        cs.playerBlindedHits = (cs.playerBlindedHits || 1) - 1;
        if (cs.playerBlindedHits <= 0) {
            cs.playerBlindedMissChance = 0;
            termAppend('<span style="color:#888;">Your vision clears.</span>', 'term-dim');
        }
        if (_blindRoll < _blindChance) {
            const missVerb = unarmed ? 'swing wildly' : 'swing wide';
            termAppend('You ' + missVerb + ' — dirt in your eyes! <span style="color:#ff8c00;">MISS!</span>', 'term-warning');
            updateEnemyCards(); updateHud(); renderActionBar();
            return;
        }
    }

    // ── HEAVY ATTACK: extra 15% miss chance on top of dodge ──────────
    if (attackType === 'heavy' && Math.random() < 0.15) {
        const missVerb = unarmed ? 'swing wildly' : 'overswing';
        termAppend(
            `You ${attackName} but ${missVerb} and <span style="color:#ff8c00;">MISS!</span>`,
            'term-warning'
        );
        updateEnemyCards();
        updateHud();
        renderActionBar();
        return;
    }

    // ── LEVEL SCALING: player damage modifier ────────────────────────
    const lvlMult = getLevelDamageMult(p.level, enemy.level);
    totalBase = Math.max(1, Math.floor(totalBase * lvlMult.playerDealt));

    // ── RUNESMITH OVERLOAD: +50% damage + STR + WIS bonus, full armor pierce, undodgeable ──
    if (runeOverloadActive) {
        const overloadBonus = Math.floor(totalBase * 0.50)
            + Math.floor((p.str || 0) * 2)
            + Math.floor((p.wis || 0) * 2);
        totalBase += overloadBonus;
        armorPiercing = 1.0;
    }

    // Apply gem universal bonuses (lightning, fire, frost) to totalBase (both melee and magic)
    totalBase += gemLightningDmg + gemFireDmg + gemFrostDmg;

    // Apply gem armor pierce (stacks additively)
    const effectiveArmorPierce = Math.min(1.0, armorPiercing + (gemPierceBonus / 100));

    // ── SYSOP DEBUG: pre-roll crit and dodge so we can show the numbers ──
    const _dbgAtk = gameState.sysop && gameState.sysop.authenticated;
    const _critChance  = shadowStrike ? 1.0 : Math.min(0.75, (calcCritChance(p.lck || 0, p) / 100) + (gemCritBonus / 100));
    const _eDodgeChance = runeOverloadActive ? 0 : enemyDodgeChance;
    const _eDodgeRoll  = Math.random();
    const _eDodged     = _eDodgeRoll < _eDodgeChance;
    const _critRoll    = Math.random();
    const _didCrit     = !_eDodged && _critRoll < _critChance;
    const _attackDmgType = magicBase > physicalBase ? 'magic' : 'physical';

    if (_dbgAtk) {
        const _eDR_PP   = 0.028;
        const _eDef     = _attackDmgType === 'magic' ? (enemy.magicDefense || enemy.defense || 0) : (enemy.defense || 0);
        const _eDR      = Math.min(0.75, _eDef * _eDR_PP) * (1 - effectiveArmorPierce);
        const _postDR   = Math.max(1, Math.floor(totalBase * (1 - _eDR)));
        const _critPost = _didCrit ? Math.floor(_postDR * 1.5) : _postDR;
        const minDmgD   = weapon.baseDamage + qBonus;
        const maxDmgD   = (weapon.maxDamage || weapon.baseDamage) + qBonus;
        termAppend(`<span style="color:#003355;">` +
            `🗡️ [PLAYER ATK] ${attackType} | weapon: ${weapon.name} (${minDmgD}–${maxDmgD}) | rolled: ${weaponDamage}` +
            ` | STR bonus: +${Math.floor((p.str||0)*1.5)} | gem dmg: +${gemMeleeDmg}` +
            `${gemLightningDmg+gemFireDmg+gemFrostDmg > 0 ? ` | elem: +${gemLightningDmg+gemFireDmg+gemFrostDmg}` : ''}` +
            ` | physBase: ${physicalBase} | magBase: ${(weapon.baseMagicDamage||0)+Math.floor((p.wis||0)*1.5)+gemMagicDmg}` +
            ` | type: ${_attackDmgType}` +
            `</span>`, 'term-dim');
        termAppend(`<span style="color:#003355;">` +
            `  ×mult: ${damageMultiplier} | ×class: ${getClassDamageMultiplier(p).toFixed(2)} | ×lvl: ${getLevelDamageMult(p.level, enemy.level).playerDealt.toFixed(2)}` +
            `${runeOverloadActive ? ' | RUNE OVERLOAD +50%' : ''}` +
            ` → totalBase: ${totalBase}` +
            ` | pierce: ${(effectiveArmorPierce*100).toFixed(0)}%` +
            ` | eDEF: ${_eDef} | eDR: ${(_eDR*100).toFixed(1)}% | after DR: ${_postDR}` +
            `</span>`, 'term-dim');
        termAppend(`<span style="color:#003355;">` +
            `  crit: rolled ${(_critRoll*100).toFixed(2)}% / need ≤${(_critChance*100).toFixed(1)}% → ${_didCrit ? '★ CRIT ×1.5 → '+_critPost : 'no crit'}` +
            ` | eDodge: rolled ${(_eDodgeRoll*100).toFixed(2)}% / need ≤${(_eDodgeChance*100).toFixed(1)}% → ${_eDodged ? '✅ enemy DODGES' : '❌ no dodge'}` +
            `</span>`, 'term-dim');
    }

    // Resolve damage (dodge and crit already pre-rolled above for debug display)
    const result = _eDodged
        ? { damage: 0, dodged: true, crit: false }
        : (() => {
            let dmg = totalBase;
            const _eDef2 = _attackDmgType === 'magic' ? (enemy.magicDefense || enemy.defense || 0) : (enemy.defense || 0);
            const _eDR2  = Math.min(0.75, _eDef2 * 0.028) * (1 - effectiveArmorPierce);
            dmg = Math.max(1, Math.floor(dmg * (1 - _eDR2)));
            if (_didCrit) dmg = Math.floor(dmg * 1.5);
            return { damage: dmg, dodged: false, crit: _didCrit };
          })();

    const tName = cs.monsters.length > 1
        ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${ti + 1}</span>`
        : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;

    if (result.dodged) {
        termAppend(
            `You ${attackName} but ${tName} <span style="color:#88ff88;">DODGES!</span>`,
            null,
            () => {
                updateEnemyCards();
                updateHud();
                renderActionBar();
            }
        );
    } 
    else {
        const critTag = result.crit
            ? ' <span style="color:#FFD700;">★ CRITICAL HIT!</span>'
            : '';

        // Apply weapon modifiers (elemental damage, status effects, lifesteal)
        const modifierResult = applyWeaponModifiers(p, enemy, result.damage, weapon);
        // ── INTIMIDATED: enemy roar penalty reduces player output ────
        const _intimidPenalty = cs && (cs.playerIntimidated || 0);
        const finalDamage = _intimidPenalty > 0
            ? Math.max(1, Math.floor(modifierResult.totalDamage * (1 - _intimidPenalty)))
            : modifierResult.totalDamage;
        
        if (_dbgAtk) {
            const _modExtra = finalDamage - result.damage;
            termAppend(`<span style="color:#003355;">` +
                `  → after-DR: ${result.damage}` +
                `${result.crit ? ` | ★ CRIT ×1.5` : ''}` +
                `${_modExtra > 0 ? ` | modifier +${_modExtra}` : ''}` +
                ` | <b>FINAL: ${finalDamage} dmg</b>` +
                ` | enemy HP: ${enemy.hp} → ${Math.max(0, enemy.hp - finalDamage)}` +
                `</span>`, 'term-dim');
        }
        enemy.hp -= finalDamage;
        
        // ── HUNTER PET ATTACK ──────────────────────────────────────────
        // Hunter's pet attacks immediately after hunter deals damage
        if (baseClass === 'hunter' && p.activePet && enemy.hp > 0) {
            const petDamage = calculatePetDamage(p, finalDamage);
            if (petDamage > 0) {
                enemy.hp -= petDamage;
                const pet = HUNTER_PETS[p.activePet];
                modifierResult.messages.push(
                    `${pet.icon} <span style="color:#88FF88;">${pet.name} attacks for <span class="dmg-enemy">${petDamage} damage</span>!</span>`
                );
            }
        }
        
        // Check for poison chance on daggers (Venom Spike, Serpent's Tooth, etc.)
        if (weapon.poisonChance && Math.random() < weapon.poisonChance && enemy.hp > 0) {
            applyStatusEffect(enemy, 'poisoned', false);
            modifierResult.messages.push('<span style="color:#00FF00;">💀 Poisoned!</span>');
        }

        // ── GEM PROCS: poison (universal) and lifesteal (melee only) ──
        if (gemPoisonChance > 0 && Math.random() < (gemPoisonChance / 100) && enemy.hp > 0) {
            applyStatusEffect(enemy, 'poisoned', false);
            modifierResult.messages.push('<span style="color:#00EE00;">💎 Emerald: Poisoned!</span>');
        }
        if (gemLifesteal > 0 && finalDamage > 0) {
            const steal = Math.max(1, Math.floor(finalDamage * (gemLifesteal / 100)));
            p.hp = Math.min(p.maxHp, p.hp + steal);
            modifierResult.messages.push(`<span style="color:#FF4488;">💎 Ruby: Lifesteal +${steal} HP</span>`);
        }
        // Voidstone spell leech — converts portion of melee hit to MP (unique: restores mana, not HP)
        if (gemSpellLeech > 0 && finalDamage > 0) {
            const mpSteal = Math.max(1, Math.floor(finalDamage * (gemSpellLeech / 100)));
            p.mp = Math.min(p.maxMp, p.mp + mpSteal);
            modifierResult.messages.push(`<span style="color:#AA55FF;">💎 Voidstone: Drained +${mpSteal} MP</span>`);
        }

        // ── ROGUE DOUBLE-STRIKE ───────────────────────────────────────
        // Every dagger pip fires twice. Roll a second independent hit.
        // Triggers if: classRestriction='rogue' OR weapon name/key contains dagger/shiv
        const isDaggerWeapon = weapon.classRestriction === 'rogue'
            || (weapon.name && (weapon.name.toLowerCase().includes('dagger') || weapon.name.toLowerCase().includes('shiv')))
            || (p.weapon && (p.weapon.toLowerCase().includes('dagger') || p.weapon.toLowerCase().includes('shiv')));
        if (baseClass === 'rogue' && isDaggerWeapon && enemy.hp > 0) {
            const minDmg2 = weapon.baseDamage + qBonus;
            const maxDmg2 = (weapon.maxDamage || weapon.baseDamage) + qBonus;
            let weaponDamage2 = Math.floor(Math.random() * (maxDmg2 - minDmg2 + 1)) + minDmg2;
            const physBase2 = weaponDamage2 + Math.floor((p.str || 0) * 1.5);
            let totalBase2  = Math.floor(Math.max(physBase2, magicBase) * damageMultiplier);
            totalBase2 = Math.floor(totalBase2 * classMult);
            totalBase2 = Math.max(1, Math.floor(totalBase2 * lvlMult.playerDealt));

            const result2 = calculateDamage({
                attacker: p, defender: enemy,
                base: totalBase2,
                type: 'physical',
                critChance: calcCritChance(p.lck || 0, p) / 100,
                dodgeChance: enemyDodgeChance,
                armorPiercing
            });

            if (!result2.dodged) {
                const mod2 = applyWeaponModifiers(p, enemy, result2.damage, weapon);
                enemy.hp -= mod2.totalDamage;
                const crit2Tag = result2.crit
                    ? ' <span style="color:#FFD700;">★ CRIT!</span>'
                    : '';
                modifierResult.messages.push(
                    `↪ Second strike: <span class="dmg-enemy">${mod2.totalDamage} damage</span>${crit2Tag}`
                );
                // Poison on second hit too
                if (weapon.poisonChance && Math.random() < weapon.poisonChance && enemy.hp > 0) {
                    applyStatusEffect(enemy, 'poisoned', false);
                    modifierResult.messages.push('<span style="color:#00FF00;">💀 Poisoned!</span>');
                }
            } else {
                modifierResult.messages.push('↪ Second strike: <span style="color:#88ff88;">DODGED!</span>');
            }
        }
        // ── END ROGUE DOUBLE-STRIKE ───────────────────────────────────

        // Calculate condition text
        const hpPct = Math.max(0, (enemy.hp / enemy.maxHp) * 100);
        let condition = 'healthy';
        if (hpPct < 75) condition = 'injured';
        if (hpPct < 50) condition = 'wounded';
        if (hpPct < 25) condition = 'severely wounded';
        if (hpPct < 10) condition = 'barely standing';

        termAppend(
            `You ${attackName} ${tName} for <span class="dmg-enemy">${finalDamage} damage!</span>${critTag}`,
            null,
            () => {
                // Show modifier messages
                modifierResult.messages.forEach(msg => {
                    termAppend(`→ ${msg}`, 'term-loot');
                });

                if (enemy.hp > 0) {
                    termAppend(
                        `→ ${tName} is <span style="color:#8aaa8a;">${condition}</span>`,
                        'term-dim'
                    );
                }

                updateEnemyCards();
                updateHud();
                renderActionBar();
                checkCombatEnd();
            }
        );
    }

    // Immediate UI update (pip display — callbacks handle full re-render)
    updateEnemyCards();
    updateHud();
    // Note: renderActionBar() is called by termAppend callbacks above
    // to ensure it fires AFTER streaming completes, not before.
}



       // Legacy function kept for compatibility
       function playerAttack() {
    executeAttack('normal');
}

        


            function showSpellMenu() {
            const cs = gameState.combatState;
            if (!cs) return;
            const anyAvail = cs.pipAvailable && cs.pipAvailable.some(x => x);
            if (!anyAvail) return;
            const p = gameState.player;
            if (p.knownSpells.length === 0) {
                termAppend('You have no spells!', 'term-error');
                renderActionBar();
                return;
            }
            
            cs.actionMode = 'spell_list';
            renderActionBar();
        }




            function castSpellOnTarget(spell) {
            const p  = gameState.player;
            const cs = gameState.combatState;
            const spellKey = cs.pendingSpellKey;
            
            if (p.mp < spell.mpCost) {
                termAppend('Not enough MP!', 'term-error');
                return;
            }
            // ── SILENCED: enemy ability prevents spellcasting ────────
            if (cs.playerSilenced) {
                termAppend('<span style="color:#ff8800;">💀 You are silenced and cannot cast spells!</span>', 'term-warning');
                cs.actionMode = 'main';
                cs.pendingSpellKey = null;
                renderActionBar();
                return;
            }
            

// --- Pip check for spells ---
const availablePips = cs.pipAvailable.filter(x => x).length;

if (availablePips < (spell.pipCost || 1)) {
    termAppend('Not enough spell charges!', 'term-error');
    return;
}

// Consume spell pips
consumePips(cs, spell.pipCost || 1, getPipCooldown(p));



            p.mp -= spell.mpCost;
            markMpAction();  // reset 15s MP regen countdown on every spell cast

            // ── RUNESMITH: charge Rune Overload pip on every spell cast ──
            if ((p.baseClass || p.class) === 'runesmith' && (p.runeOverloadPips || 0) < 3) {
                p.runeOverloadPips = (p.runeOverloadPips || 0) + 1;
                const rp = p.runeOverloadPips;
                const rp1 = rp >= 1 ? '🔶' : '⬛'; const rp2 = rp >= 2 ? '🔶' : '⬛'; const rp3 = rp >= 3 ? '🔶' : '⬛';
                if (rp >= 3) {
                    termAppend('⚒️ <span style="color:#FF8800;font-weight:bold;">RUNE OVERLOAD CHARGED!</span> <span style="color:#FFaa00;">Strike now for devastating, armor-piercing power!</span> 🔥');
                } else {
                    termAppend(`⚒️ <span style="color:#c8a000;">Rune charged: ${rp1}${rp2}${rp3}</span>`);
                }
            }

            if (spell.type === 'heal') {
                // Healing spells: 5% chance to fail, random between minPower and maxPower
                const _dbgSpell = gameState.sysop && gameState.sysop.authenticated;
                const _fizzRoll = Math.random();
                const spellFailed = _fizzRoll < 0.05;
                if (_dbgSpell) {
                    termAppend('<span style="color:#004466;">✨ [HEAL] ' + spell.name
                        + ' | cost: ' + spell.mpCost + ' MP'
                        + ' | range: ' + (spell.minPower||10) + '–' + (spell.maxPower||spell.minPower||10)
                        + ' | fizzle roll: ' + (_fizzRoll*100).toFixed(2) + '% / need ≤5% → ' + (spellFailed ? '💀 FIZZLE' : '✅ ok')
                        + '</span>', 'term-dim');
                }
                if (spellFailed) {
                    termAppend(`You cast ${spell.name} but it <span style="color:#ff6666;">fizzles!</span> The gods did not answer.`);
                } else {
                    // Calculate random heal between minPower and maxPower
                    const minHeal = spell.minPower || 10;
                    const maxHeal = spell.maxPower || minHeal;
                    const _healRoll = Math.floor(Math.random() * (maxHeal - minHeal + 1)) + minHeal;
                    const baseHeal = _healRoll;
                    const heal = baseHeal + Math.floor(p.magic * 1.5) + (p.wis || 0);
                    const actualHeal = Math.min(p.maxHp - p.hp, heal);
                    if (_dbgSpell) {
                        termAppend('<span style="color:#004466;">  rolled: ' + _healRoll
                            + ' | +magic ' + Math.floor(p.magic*1.5) + ' | +WIS ' + (p.wis||0)
                            + ' → heal: ' + heal + ' | actual: ' + actualHeal
                            + ' (HP cap: ' + p.hp + '/' + p.maxHp + ')'
                            + '</span>', 'term-dim');
                    }
                    p.hp = Math.min(p.maxHp, p.hp + actualHeal);
                    updateHud();
                    renderActionBar();
                    termAppend(`You cast ${spell.name} and restore <span style="color:#88ff88;">${actualHeal} HP!</span>`);
                }
            } else if (spell.type === 'aoe_damage') {
                // AOE DAMAGE - Hit all enemies for reduced damage each
                const monsters = cs.monsters;
                let totalDamage = 0;
                let hitCount = 0;
                
                if (gameState.sysop && gameState.sysop.authenticated) {
                    const _aoeminP = spell.minPower||spell.power, _aoemaxP = spell.maxPower||spell.power;
                    termAppend('<span style="color:#004466;">✨ [AOE] ' + spell.name
                        + ' | cost: ' + spell.mpCost + ' MP | range: ' + _aoeminP + '–' + _aoemaxP
                        + ' | targets: ' + cs.monsters.filter(m=>m.hp>0).length
                        + '</span>', 'term-dim');
                }
                termAppend(`You cast ${spell.name}!`, 'term-highlight');
                termAppend(`<span style="color:#FF8800;">🔥 AREA OF EFFECT! 🔥</span>`, 'term-victory');
                
                // Check if fire spell for burning
                const spellName = spell.name.toLowerCase();
                const isFire = spellName.includes('fire') || spellName.includes('flame') || 
                               spellName.includes('burn') || spellName.includes('pyro') || 
                               spellName.includes('inferno') || spellName.includes('ember');
                
                monsters.forEach((enemy, i) => {
                    if (enemy.hp > 0) {
                        // Calculate enemy dodge chance
                        const enemyDodgeChance = calculateEnemyDodge(p.level, enemy.level);
                        
                        const tName = monsters.length > 1
                            ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${i+1}</span>`
                            : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;
                        
                        // Check if enemy dodges
                        const _aoeDbg = gameState.sysop && gameState.sysop.authenticated;
                        const _aoeDodgeRoll = Math.random();
                        const _aoeDodged = _aoeDodgeRoll < enemyDodgeChance;
                        if (_aoeDbg) termAppend('<span style="color:#004466;">  [AOE→' + enemy.name + '] dodge: rolled '
                            + (_aoeDodgeRoll*100).toFixed(2) + '% / need ≤' + (enemyDodgeChance*100).toFixed(1) + '% → '
                            + (_aoeDodged ? '✅ DODGE' : '❌ hit') + '</span>', 'term-dim');
                        if (_aoeDodged) {
                            termAppend(`→ ${tName} <span style="color:#88ff88;">DODGES!</span>`);
                            return; // Skip this enemy
                        }
                        
                        // SPELL DAMAGE WITH WIDE RANGE ROLLING (each enemy rolls independently!)
                        const minPower = spell.minPower || spell.power;
                        const maxPower = spell.maxPower || spell.power;
                        const spellRoll = Math.floor(Math.random() * (maxPower - minPower + 1)) + minPower;
                        
                        // Add weapon modifier bonus to offensive spells
                        const modifierBonus = getWeaponModifierSpellBonus();
                        
                        const _aoeCritRoll = Math.random() * 100;
                        const _aoeCritChance = calcCritChance(p.lck || 0, p);
                        let dmg = Math.max(1, (spellRoll + p.magic + (p.wis || 0) + modifierBonus) - Math.floor(enemy.defense / 2));
                        let crit = false;
                        if (_aoeCritRoll < _aoeCritChance) { 
                            dmg = Math.floor(dmg * 1.75); 
                            crit = true; 
                        }
                        if (_aoeDbg) termAppend('<span style="color:#004466;">  roll: ' + spellRoll
                            + ' | +magic ' + p.magic + ' | +WIS ' + (p.wis||0) + ' | +mod ' + modifierBonus
                            + ' | -eDef/2 ' + Math.floor(enemy.defense/2)
                            + ' → pre-crit: ' + Math.max(1, spellRoll + p.magic + (p.wis||0) + modifierBonus - Math.floor(enemy.defense/2))
                            + ' | crit: ' + _aoeCritRoll.toFixed(2) + ' / need ≤' + _aoeCritChance.toFixed(1) + ' → ' + (crit ? '★ CRIT ×1.75' : 'no crit')
                            + '</span>', 'term-dim');
                        
                        // Apply weapon modifiers to spell (status effects + elemental damage)
                        const weapon = WEAPONS[p.weapon];
                        const modifierResult = weapon ? applyWeaponModifiers(p, enemy, dmg, weapon) : { totalDamage: dmg, messages: [] };
                        const finalDamage = modifierResult.totalDamage;
                        
                        enemy.hp -= finalDamage;
                        totalDamage += finalDamage;
                        hitCount++;
                        
                        const critTag = crit ? ' <span style="color:#FFD700;">★ CRIT!</span>' : '';
                        let msg = `→ ${tName} takes <span class="dmg-enemy">${finalDamage} damage!</span>${critTag}`;
                        if (modifierResult.messages.length > 0) {
                            msg += ' ' + modifierResult.messages.join(' ');
                        }
                        termAppend(msg);
                        
                        // Apply burning to each enemy hit (AOE fire spells)
                        if (isFire && Math.random() < 0.5 && enemy.hp > 0) { // 50% chance per target
                            applyStatusEffect(enemy, 'burning', false);
                        }
                    }
                });
                
                termAppend(`<span style="color:#FFD700;">Total: ${totalDamage} damage to ${hitCount} ${hitCount === 1 ? 'enemy' : 'enemies'}!</span>`, 'term-loot');
                checkCombatEnd();
                updateEnemyCards();
                updateHud();
                renderActionBar();
            } else if (spell.type === 'lifesteal') {
                // LIFESTEAL - damage enemy and heal yourself
                const ti = cs.currentTarget;
                const enemy = cs.monsters[ti];
                
                // Calculate enemy dodge chance
                const enemyDodgeChance = calculateEnemyDodge(p.level, enemy.level);
                
                const tName = cs.monsters.length > 1
                    ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${ti+1}</span>`
                    : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;
                
                // Check if enemy dodges
                const _lsDbg = gameState.sysop && gameState.sysop.authenticated;
                const _lsDodgeRoll = Math.random();
                const _lsDodged = _lsDodgeRoll < enemyDodgeChance;
                if (_lsDbg) termAppend('<span style="color:#004466;">✨ [LIFESTEAL] ' + spell.name
                    + ' | cost: ' + spell.mpCost + ' MP | range: ' + (spell.minPower||spell.power) + '–' + (spell.maxPower||spell.power)
                    + ' | dodge: rolled ' + (_lsDodgeRoll*100).toFixed(2) + '% / need ≤' + (enemyDodgeChance*100).toFixed(1) + '% → '
                    + (_lsDodged ? '✅ DODGE' : '❌ hit') + '</span>', 'term-dim');
                if (_lsDodged) {
                    termAppend(`You cast ${spell.name} but ${tName} <span style="color:#88ff88;">DODGES!</span>`);
                    updateEnemyCards();
                    updateHud();
                    cs.actionMode = 'main';
                    cs.pendingSpellKey = null;
                    renderActionBar();
                    return;
                }
                
                // SPELL DAMAGE WITH WIDE RANGE ROLLING
                const minPower = spell.minPower || spell.power;
                const maxPower = spell.maxPower || spell.power;
                const spellRoll = Math.floor(Math.random() * (maxPower - minPower + 1)) + minPower;
                
                // Add weapon modifier bonus to offensive spells
                const modifierBonus = getWeaponModifierSpellBonus();

                // ── Gem bonuses for spells ────────────────────────────────
                const spellWeapon = WEAPONS[p.weapon];
                let gemSpellBonus = 0, gemSpellCrit = 0, gemSpellPoison = 0;
                let gemSpellUniversal = 0; // lightning + fire + frost all apply to spells
                let gemSpellLeechPct = 0;  // voidstone: spell leech → MP
                if (spellWeapon && spellWeapon.gems) {
                    for (const sg of spellWeapon.gems) {
                        if (!sg || !sg.stats) continue;
                        gemSpellBonus    += sg.stats.spellPower    || 0;  // magic-only
                        gemSpellCrit     += sg.stats.critBonus     || 0;  // universal
                        gemSpellPoison   += sg.stats.poisonChance  || 0;  // universal
                        gemSpellUniversal += (sg.stats.lightningDmg || 0)
                                          + (sg.stats.fireDmg       || 0)
                                          + (sg.stats.frostDmg      || 0); // universal elements
                        gemSpellLeechPct += sg.stats.spellLeech    || 0;  // voidstone: MP leech
                    }
                }
                
                const _lsCritRoll = Math.random() * 100;
                const spellCritChance = Math.min(75, calcCritChance(p.lck || 0, p) + gemSpellCrit);
                let dmg = Math.max(1, (spellRoll + p.magic + (p.wis || 0) + modifierBonus + gemSpellBonus + gemSpellUniversal) - Math.floor(enemy.defense / 2));
                let crit = false;
                if (_lsCritRoll < spellCritChance) { dmg = Math.floor(dmg * 1.75); crit = true; }
                if (_lsDbg) termAppend('<span style="color:#004466;">  roll: ' + spellRoll
                    + ' | +magic ' + p.magic + ' | +WIS ' + (p.wis||0) + ' | +mod ' + modifierBonus
                    + ' | +gemSP ' + gemSpellBonus + ' | +elem ' + gemSpellUniversal
                    + ' | -eDef/2 ' + Math.floor(enemy.defense/2)
                    + ' → pre-crit: ' + Math.max(1, spellRoll + p.magic + (p.wis||0) + modifierBonus + gemSpellBonus + gemSpellUniversal - Math.floor(enemy.defense/2))
                    + ' | crit: ' + _lsCritRoll.toFixed(2) + ' / need ≤' + spellCritChance.toFixed(1) + ' → ' + (crit ? '★ CRIT ×1.75' : 'no crit')
                    + ' | lifesteal: ' + (spell.lifestealPercent||25) + '%'
                    + '</span>', 'term-dim');
                
                // Apply weapon modifiers to spell (status effects + elemental damage)
                const weapon = WEAPONS[p.weapon];
                const modifierResult = weapon ? applyWeaponModifiers(p, enemy, dmg, weapon) : { totalDamage: dmg, messages: [] };
                const finalDamage = modifierResult.totalDamage;

                // Gem poison proc on spell (universal gem)
                if (gemSpellPoison > 0 && Math.random() < (gemSpellPoison / 100) && enemy.hp > 0) {
                    applyStatusEffect(enemy, 'poisoned', false);
                    modifierResult.messages.push('<span style="color:#00EE00;">💎 Emerald: Poisoned!</span>');
                }
                
                // Gem lifesteal on spells (ruby — works on both melee and spells per design)
                let gemSpellLifesteal = 0;
                if (spellWeapon && spellWeapon.gems) {
                    for (const sg of spellWeapon.gems) {
                        if (sg && sg.stats) gemSpellLifesteal += sg.stats.lifesteal || 0;
                    }
                }
                if (gemSpellLifesteal > 0) {
                    const lsHeal = Math.max(1, Math.floor(finalDamage * (gemSpellLifesteal / 100)));
                    p.hp = Math.min(p.maxHp, p.hp + lsHeal);
                    modifierResult.messages.push(`<span style="color:#FF4488;">💎 Ruby: Lifesteal +${lsHeal} HP</span>`);
                }
                // Voidstone spell leech → drains MP from enemy (magic absorb, not HP)
                if (gemSpellLeechPct > 0) {
                    const mpDrain = Math.max(1, Math.floor(finalDamage * (gemSpellLeechPct / 100)));
                    p.mp = Math.min(p.maxMp, p.mp + mpDrain);
                    modifierResult.messages.push(`<span style="color:#AA55FF;">💎 Voidstone: Absorbed +${mpDrain} MP</span>`);
                }

                enemy.hp -= finalDamage;
                
                // Heal based on lifesteal percentage (from the final damage including modifiers)
                const lifestealPercent = spell.lifestealPercent || 25;
                const healAmount = Math.floor(finalDamage * (lifestealPercent / 100));
                p.hp = Math.min(p.maxHp, p.hp + healAmount);
                
                const critTag = crit ? ' <span style="color:#FFD700;">★ CRIT!</span>' : '';
                let spellMsg = `You cast ${spell.name} on ${tName} for <span class="dmg-enemy">${finalDamage} damage!</span>${critTag}`;
                if (modifierResult.messages.length > 0) {
                    spellMsg += '<br>' + modifierResult.messages.join('<br>');
                }
                
                termAppend(spellMsg, null, () => {
                    termAppend(`<span style="color:#00FF00;">🩸 Drained ${healAmount} HP!</span>`, 'term-loot');
                    if (enemy.hp > 0) {
                        const hpPct = Math.max(0, (enemy.hp / enemy.maxHp) * 100);
                        let condition = 'healthy';
                        if (hpPct < 75) condition = 'injured';
                        if (hpPct < 50) condition = 'wounded';
                        if (hpPct < 25) condition = 'severely wounded';
                        if (hpPct < 10) condition = 'barely standing';
                        termAppend(`→ ${tName} is <span style="color:#8aaa8a;">${condition}</span>`, 'term-dim');
                    }
                    checkCombatEnd();
                });
            } else {
                // REGULAR DAMAGE SPELL
                const ti    = cs.currentTarget;
                const enemy = cs.monsters[ti];
                
                // Calculate enemy dodge chance based on level difference
                const enemyDodgeChance = calculateEnemyDodge(p.level, enemy.level);
                
                // Check if enemy dodges the spell
                const _regDbg = gameState.sysop && gameState.sysop.authenticated;
                const _regDodgeRoll = Math.random();
                const _regDodged = _regDodgeRoll < enemyDodgeChance;
                const tName = cs.monsters.length > 1
                    ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${ti+1}</span>`
                    : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;
                if (_regDbg) termAppend('<span style="color:#004466;">✨ [SPELL] ' + spell.name
                    + ' | cost: ' + spell.mpCost + ' MP | range: ' + (spell.minPower||spell.power) + '–' + (spell.maxPower||spell.power)
                    + ' | eDodge: rolled ' + (_regDodgeRoll*100).toFixed(2) + '% / need ≤' + (enemyDodgeChance*100).toFixed(1) + '% → '
                    + (_regDodged ? '✅ enemy DODGES' : '❌ hit') + '</span>', 'term-dim');
                if (_regDodged) {
                    termAppend(`You cast ${spell.name} but ${tName} <span style="color:#88ff88;">DODGES!</span>`);
                    updateEnemyCards();
                    updateHud();
                    cs.actionMode = 'main';
                    cs.pendingSpellKey = null;
                    renderActionBar();
                    return;
                }
                
                // SPELL DAMAGE WITH WIDE RANGE ROLLING
                const minPower = spell.minPower || spell.power;
                const maxPower = spell.maxPower || spell.power;
                const spellRoll = Math.floor(Math.random() * (maxPower - minPower + 1)) + minPower;
                
                // Add weapon modifier bonus to offensive spells
                const modifierBonus = getWeaponModifierSpellBonus();
                
                const _regCritRoll = Math.random() * 100;
                const _regCritChance = calcCritChance(p.lck||0, p);
                let dmg = Math.max(1, (spellRoll + p.magic + (p.wis||0) + modifierBonus) - Math.floor(enemy.defense / 2));
                let crit = false;
                if (_regCritRoll < _regCritChance) { dmg = Math.floor(dmg*1.75); crit = true; }
                if (_regDbg) termAppend('<span style="color:#004466;">  roll: ' + spellRoll
                    + ' | +magic ' + p.magic + ' | +WIS ' + (p.wis||0) + ' | +mod ' + modifierBonus
                    + ' | -eDef/2 ' + Math.floor(enemy.defense/2)
                    + ' → pre-crit: ' + Math.max(1, spellRoll + p.magic + (p.wis||0) + modifierBonus - Math.floor(enemy.defense/2))
                    + ' | crit: ' + _regCritRoll.toFixed(2) + ' / need ≤' + _regCritChance.toFixed(1) + ' → ' + (crit ? '★ CRIT ×1.75' : 'no crit')
                    + ' | final: ' + dmg
                    + '</span>', 'term-dim');
                
                // Apply weapon modifiers to spell (status effects + elemental damage)
                const weapon = WEAPONS[p.weapon];
                const modifierResult = weapon ? applyWeaponModifiers(p, enemy, dmg, weapon) : { totalDamage: dmg, messages: [] };
                const finalDamage = modifierResult.totalDamage;
                
                enemy.hp -= finalDamage;
                
                // Check for spell status effects (burning from fire spells, etc.)
                const spellName = spell.name.toLowerCase();
                if ((spellName.includes('fire') || spellName.includes('flame') || spellName.includes('burn') || 
                     spellName.includes('pyro') || spellName.includes('inferno') || spellName.includes('ember')) && 
                    Math.random() < 0.5) { // 50% chance
                    enemy.statusToApply = 'burning';
                } else if ((spellName.includes('ice') || spellName.includes('frost') || spellName.includes('frozen')) && 
                           Math.random() < 0.4) { // 40% chance
                    enemy.statusToApply = 'frozen';
                } else if (spellName.includes('lightning') && Math.random() < 0.2) { // 20% chance
                    enemy.statusToApply = 'stunned';
                } else if (spellName.includes('shadow') && Math.random() < 0.3) { // 30% chance
                    enemy.statusToApply = 'blinded';
                }
                
                const critTag = crit ? ' <span style="color:#FFD700;">★ CRIT!</span>' : '';
                const hpPct = Math.max(0, (enemy.hp / enemy.maxHp) * 100);
                let condition = 'healthy';
                if (hpPct < 75) condition = 'injured';
                if (hpPct < 50) condition = 'wounded';
                if (hpPct < 25) condition = 'severely wounded';
                if (hpPct < 10) condition = 'barely standing';
                
                // Build message with weapon modifier bonuses
                let spellMsg = `You cast ${spell.name} on ${tName} for <span class="dmg-enemy">${finalDamage} damage!</span>${critTag}`;
                if (modifierResult.messages.length > 0) {
                    spellMsg += '<br>' + modifierResult.messages.join('<br>');
                }
                
                termAppend(spellMsg, null, () => {
                    // Apply status effect if flagged
                    if (enemy.statusToApply && enemy.hp > 0) {
                        applyStatusEffect(enemy, enemy.statusToApply, false);
                        enemy.statusToApply = null;
                    }
                    
                    if (enemy.hp > 0) {
                        termAppend(`→ ${tName} is <span style="color:#8aaa8a;">${condition}</span>`, 'term-dim');
                    }
                    checkCombatEnd();
                });
            }
              updateEnemyCards();
                updateHud();
            
            // Reset to main combat menu after spell cast
            cs.actionMode = 'main';
            cs.pendingSpellKey = null;
            renderActionBar();
        }

        // Legacy function for backward compatibility
        function castSpell(spellKey) {
            const spell = SPELLS[spellKey];
            castSpellOnTarget(spell);
        }

        // ═══════════════════════════════════════════════════════════════
        // HUNTER TRAP ABILITY
        // ═══════════════════════════════════════════════════════════════
        
        function castTrap() {
            const cs = gameState.combatState;
            const p = gameState.player;
            
            if (!cs || cs.combatOver) return;
            
            // Check if hunter
            if ((p.baseClass || p.class) !== 'hunter') {
                termAppend('Only hunters can set traps!', 'term-error');
                return;
            }
            
            // Check MP
            if (p.mp < 10) {
                termAppend('Not enough MP to set a trap! (Need 10 MP)', 'term-error');
                return;
            }
            
            // Check if trap already active
            if (cs.trapActive) {
                termAppend('A trap is already set!', 'term-warning');
                return;
            }
            
            // Consume MP
            p.mp -= 10;
            markMpAction();
            
            // Setting the trap...
            termAppend('', 'term-separator');
            termAppend('🪤 <span style="color:#8B4513;">You carefully set a concealed trap...</span>', null, () => {
                // 2 second pause for dramatic effect
                setTimeout(() => {
                    // 15% fail rate
                    const failed = Math.random() < 0.15;
                    
                    if (failed) {
                        termAppend('<span style="color:#ff4444;">💨 The trap mechanism fails! The enemies avoid it!</span>', 'term-error');
                    } else {
                        // Success! Apply 50% slow to enemy timer
                        const slowMultiplier = 0.5; // 50% slow = add 50% to timer
                        const originalDelay = cs.enemyDelay;
                        const slowAmount = Math.floor(originalDelay * slowMultiplier);
                        
                        // Mark trap as active for this combat
                        cs.trapActive = true;
                        cs.trapSlowAmount = slowAmount;
                        
                        // Apply slow to current enemy timer
                        cs.enemyTimer += slowAmount;
                        
                        termAppend(`<span style="color:#00FF88;">⚙️ SNAP! The enemies are caught in the trap!</span>`, 'term-loot');
                        termAppend(`<span style="color:#FFD700;">🐌 Enemy attack speed slowed by 50%! (+${slowAmount}s to attack timer)</span>`, 'term-highlight');
                    }
                    
                    updateHud();
                    renderActionBar();
                }, 2000);
            });
        }

        function playerDefend() {
            const cs = gameState.combatState;
            const p  = gameState.player;
            if (!cs || cs.hitsLeft <= 0) return;
            if ((p.baseClass || p.class) !== 'warrior') return; // Warriors only
            cs.shieldActive = true;
            cs.hitsLeft     = 0;   // end player's turn
            renderActionBar();
            // Calculate the actual defense bonus for the terminal message
            const _arm    = ARMOR[p.armor] || { baseDefense: 0, quality: 'poor' };
            const _qb     = getQualityBonus(_arm.quality, _arm.baseDefense);
            const _baseDef = _arm.baseDefense + _qb + (p.con || 0);
            const _bonusDef = Math.floor(_baseDef * 0.5);
            termAppend(`🛡️ You raise your shield — defense increased by ${_bonusDef} (${_baseDef} → ${_baseDef + _bonusDef}) until next turn.`);
        }

        // ═══════════════════════════════════════════════════════════════
        // SHOW PLAYER STATS
        // ═══════════════════════════════════════════════════════════════
        function showPlayerStats() {
            const p = gameState.player;
            if (!p) return;
            
            termAppend('', 'term-separator');
            termAppend('═══════════════════════════════════════════════════', 'term-highlight');
            termAppend(`📊 CHARACTER STATS - ${p.name.toUpperCase()}`, 'term-highlight');
            termAppend('═══════════════════════════════════════════════════', 'term-highlight');
            termAppend('');
            
            // Basic Info
            const className = p.hasEvolved ? getAdvancedClassName(p) : (p.className || p.class);
            termAppend(`<span style="color:var(--highlight-color);">Name:</span> ${p.name}`);
            termAppend(`<span style="color:var(--highlight-color);">Class:</span> ${className} ${p.hasEvolved ? '<span style="color:#FFD700;">⚡ (Evolved)</span>' : ''}`);
            termAppend(`<span style="color:var(--highlight-color);">Level:</span> ${p.level}`);
            termAppend('');
            
            // Resources
            termAppend(`<span style="color:#ff6666;">❤️  HP:</span> ${p.hp} / ${p.maxHp}`);
            termAppend(`<span style="color:#4488ff;">✨ MP:</span> ${p.mp} / ${p.maxMp}`);
            termAppend(`<span style="color:#FFD700;">💰 Gold:</span> ${p.gold}g`);
            termAppend(`<span style="color:var(--text-color);">⭐ XP:</span> ${p.xp} / ${p.xpToNext} (${Math.floor((p.xp / p.xpToNext) * 100)}%)`);
            termAppend('');
            
            // Combat Stats
            termAppend('<span style="color:var(--highlight-color);">═══ COMBAT STATS ═══</span>');
            
            // Primary Stats (D&D style if they exist)
            if (p.str !== undefined) {
                termAppend(`<span style="color:#FF8800;">STR:</span> ${p.str} (Strength)`);
                termAppend(`<span style="color:#00FF88;">DEX:</span> ${p.dex} (Dexterity)`);
                termAppend(`<span style="color:#8888FF;">WIS:</span> ${p.wis} (Wisdom)`);
                termAppend(`<span style="color:#FF88FF;">CHA:</span> ${p.cha} (Charisma)`);
                termAppend(`<span style="color:#FFAA00;">CON:</span> ${p.con} (Constitution)`);
                termAppend(`<span style="color:#FFD700;">LCK:</span> ${p.lck} (Luck)`);
                termAppend('');
            }
            
            // Legacy stats
            if (p.strength !== undefined) {
                termAppend(`<span style="color:#FF8800;">Strength:</span> ${p.strength}`);
                termAppend(`<span style="color:#00AAFF;">Defense:</span> ${p.defense}`);
                termAppend(`<span style="color:#8888FF;">Magic:</span> ${p.magic}`);
                termAppend(`<span style="color:#00FF88;">Speed:</span> ${p.speed}`);
                termAppend('');
            }
            
            // Derived Stats
            const weapon = WEAPONS[p.weapon];
            const armor = ARMOR[p.armor];
            const weaponDmg = weapon ? `${weapon.baseDamage}-${weapon.maxDamage || weapon.baseDamage}` : '0';
            const weaponMag = weapon && weapon.baseMagicDamage ? `+${weapon.baseMagicDamage}` : '';
            const armorDef = armor ? armor.baseDefense : 0;
            
            termAppend(`<span style="color:#FF4444;">⚔️  Weapon Damage:</span> ${weaponDmg} ${weaponMag}`);
            termAppend(`<span style="color:#4444FF;">🛡️  Armor Defense:</span> ${armorDef}`);
            termAppend(`<span style="color:#FFD700;">🎯 Crit Chance:</span> ${calcCritChance(p.lck || 0, p)}%`);
            
            // Rogue Shadow Strike status
            const baseClass = p.baseClass || p.class;
            if (baseClass === 'rogue') {
                if (p.shadowStrikeReady) {
                    termAppend(`<span style="color:#8888FF;">🌑 Shadow Strike:</span> READY! (Next attack guaranteed crit)`);
                } else {
                    termAppend(`<span style="color:#666666;">🌑 Shadow Strike:</span> On cooldown (activate after 5s out of combat)`);
                }
            }
            
            // Class damage multiplier if evolved
            if (p.hasEvolved) {
                const dmgMult = getClassDamageMultiplier(p);
                termAppend(`<span style="color:#FFD700;">⚡ Damage Multiplier:</span> ${dmgMult}x (Class Evolution)`);
            }
            
            termAppend('');
            
            // Equipment
            termAppend('<span style="color:var(--highlight-color);">═══ EQUIPMENT ═══</span>');
            termAppend(`<span style="color:#FFD700;">Weapon:</span> ${weapon ? weapon.name : 'None'}`);
            termAppend(`<span style="color:#4488FF;">Armor:</span> ${armor ? armor.name : 'None'}`);
            termAppend('');
            
            // Active Buffs
            if (p.activeBuffs && Object.keys(p.activeBuffs).length > 0) {
                termAppend('<span style="color:var(--highlight-color);">═══ ACTIVE BUFFS ═══</span>');
                for (const [buffType, buff] of Object.entries(p.activeBuffs)) {
                    if (Date.now() < buff.endTime) {
                        const timeLeft = Math.ceil((buff.endTime - Date.now()) / 1000);
                        const minutes = Math.floor(timeLeft / 60);
                        const seconds = timeLeft % 60;
                        const timeStr = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                        
                        let buffName = buffType.replace('buff_', '').toUpperCase();
                        termAppend(`<span style="color:#00FF88;">✨ ${buffName}:</span> +${buff.power} (${timeStr})`);
                    }
                }
                termAppend('');
            }
            
            // Progress
            termAppend('<span style="color:var(--highlight-color);">═══ PROGRESSION ═══</span>');
            termAppend(`<span style="color:#FFD700;">Defeated Masters:</span> ${p.defeatedMasters?.length || 0}`);
            termAppend(`<span style="color:#4488FF;">Unlocked Areas:</span> ${p.unlockedAreas?.length || 0}`);
            termAppend(`<span style="color:#FF8800;">Known Spells:</span> ${p.knownSpells?.length || 0}`);
            termAppend(`<span style="color:#00FF88;">Inventory Items:</span> ${p.inventory?.length || 0}`);
            
            termAppend('');
            termAppend('═══════════════════════════════════════════════════', 'term-highlight');
        }

        function attemptFlee() {
            const cs = gameState.combatState;
            if (!cs) return;
            
            // find first available pip
            let pipIndex = -1;
            for (let i = 0; i < cs.pipAvailable.length; i++) {
                if (cs.pipAvailable[i]) {
                    pipIndex = i;
                    break;
                }
            }
            if (pipIndex === -1) return;

            clearInterval(gameState.combatTimer);
            const p        = gameState.player;
            const fleePct  = Math.min(70, 30 + (p.dex||0)*3);
            if (Math.random()*100 < fleePct) {
                gameState.combatState = null;
                termAppend('You successfully fled!', 'term-highlight', () => {
                    renderActionBar();
                });
            } else {
                cs.pipAvailable[pipIndex] = false;
                cs.pipTimers[pipIndex] = gameState.player ? getPipCooldown(gameState.player) : BASE_PIP_COOLDOWN;
                renderActionBar();
                termAppend('Failed to escape!', 'term-error');
                startCombatTimer();
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // POTION MENU (in action bar)
        // ═══════════════════════════════════════════════════════════════
        // ═══════════════════════════════════════════════════════════════
        // UNIFIED COMBAT INVENTORY (replaces old potion menu in exploration)
        // ═══════════════════════════════════════════════════════════════
        function showCombatInventory() { showInventoryOverlay(); }

        function castHealingSpellOutOfCombat(spellKey) {
            const p = gameState.player;
            const classKey = p.baseClass || p.class;
            const spellTree = CLASS_SPELL_TREES[classKey]?.spellTree || {};
            const spell = SPELLS[spellKey] || spellTree[spellKey];
            
            if (!spell) {
                termAppend('Spell not found!', 'term-error');
                return;
            }
            
            // Check if player has enough MP
            if (p.mp < spell.mpCost) {
                termAppend(`Not enough MP to cast ${spell.name}! (Need ${spell.mpCost} MP)`, 'term-error');
                return;
            }
            
            // Check if already at full HP
            if (p.hp >= p.maxHp) {
                termAppend(`You're already at full health!`, 'term-warning');
                return;
            }
            
            // Consume MP
            p.mp -= spell.mpCost;
            
            // Calculate healing amount
            const minPower = spell.minPower || spell.power;
            const maxPower = spell.maxPower || spell.power;
            const healRoll = Math.floor(Math.random() * (maxPower - minPower + 1)) + minPower;
            const healAmount = healRoll + (p.wis || 0);
            
            // Apply healing
            const actualHeal = Math.min(healAmount, p.maxHp - p.hp);
            p.hp = Math.min(p.maxHp, p.hp + actualHeal);
            
            // Show message
            termAppend(`<span style="color:#00FF00;">✨ You cast ${spell.name} and restore <strong>${actualHeal} HP</strong>!</span>`, 'term-loot');
            termAppend(`HP: ${p.hp}/${p.maxHp} | MP: ${p.mp}/${p.maxMp}`, 'term-dim');
            
            // Save game
            saveGame();
            
            // Update UI
            updateHud();
        }

        function showPotionMenu() {
            const cs = gameState.combatState;
            if (!cs) return;
            const p = gameState.player;
            const inDungeon = !!gameState.dungeon;
            const potions = {};
            p.inventory.forEach(ik => {
                const item = ITEMS[ik];
                if (!item) return;
                const isRecall = item.subtype === 'recall';
                // recall only available outside combat (cs exists here so block it)
                if (isRecall) return;
                if (
                    ['heal_hp','heal_mp','full_restore'].includes(item.subtype) ||
                    item.subtype?.startsWith('buff_')
                ) {
                    if (!potions[ik]) potions[ik] = { item: item, count: 0 };
                    potions[ik].count++;
                }
            });
            const keys = Object.keys(potions);
            if (keys.length === 0) {
                termAppend('You have no potions!', 'term-error');
                renderActionBar();
                return;
            }
            
            // Set action mode for potion menu
            cs.actionMode = 'potion_list';
            
            const ab = document.getElementById('actionBar');
            let html = '<div style="color:var(--highlight-color);font-size:10px;margin-bottom:4px;">USE POTION (No pip cost!):</div>';
            html += '<div style="display:flex;flex-wrap:wrap;gap:4px;max-width:100%;justify-content:flex-start;">';
            keys.forEach(pk => {
                const pd  = potions[pk];
                const item = pd.item;
                
                // Color based on potion type
                let col = '#00FF00';
                if (item.subtype === 'recall') col = '#AA88FF';
                else if (item.subtype === 'heal_hp') col = '#ff4444';
                else if (item.subtype === 'heal_mp') col = '#4488ff';
                else if (item.subtype === 'full_restore') col = '#FFD700';
                else if (item.subtype === 'buff_str') col = '#FF8800';
                else if (item.subtype === 'buff_def') col = '#00AAFF';
                else if (item.subtype === 'buff_xp') col = '#FFD700';
                else if (item.subtype === 'buff_gold') col = '#FFD700';
                else if (item.subtype === 'buff_magic') col = '#8888FF';
                else if (item.subtype === 'buff_damage') col = '#FF0000';
                else if (item.subtype === 'buff_invuln') col = '#AAAAAA';
                else if (item.subtype === 'buff_luck') col = '#FFAA00';
                else if (item.subtype === 'buff_regen') col = '#00FF88';
                else if (item.subtype === 'buff_speed') col = '#00FF00';
                else if (item.subtype === 'buff_crit') col = '#FF00FF';
                
                // Icon based on potion type
                let icon = '🧪';
                if (item.subtype === 'recall') icon = '🌀';
                else if (item.subtype === 'heal_hp') icon = '❤️';
                else if (item.subtype === 'heal_mp') icon = '💙';
                else if (item.subtype === 'full_restore') icon = '✨';
                else if (item.subtype === 'buff_str') icon = '💪';
                else if (item.subtype === 'buff_def') icon = '🛡️';
                else if (item.subtype === 'buff_xp') icon = '⭐';
                else if (item.subtype === 'buff_gold') icon = '💰';
                else if (item.subtype === 'buff_magic') icon = '🔮';
                else if (item.subtype === 'buff_damage') icon = '⚔️';
                else if (item.subtype === 'buff_invuln') icon = '🗿';
                else if (item.subtype === 'buff_luck') icon = '🍀';
                else if (item.subtype === 'buff_regen') icon = '💚';
                else if (item.subtype === 'buff_speed') icon = '⚡';
                else if (item.subtype === 'buff_crit') icon = '🎯';
                
                html += `<button onclick="usePotion('${pk}')" style="
                    color:${col};
                    border-color:${col};
                    background:var(--secondary-bg);
                    padding:4px 6px;
                    min-width:70px;
                    max-width:90px;
                    height:auto;
                    font-size:11px;
                    text-align:center;
                    cursor:pointer;
                    border:1px solid ${col};
                    flex:0 0 auto;
                    white-space:nowrap;
                    overflow:hidden;
                    text-overflow:ellipsis;
                ">
                    ${icon} ${item.name.substring(0, 12)}${item.name.length > 12 ? '...' : ''} x${pd.count}
                </button>`;
            });
            html += `<button onclick="renderActionBar();" style="
                padding:4px 8px;
                min-width:60px;
                background:var(--secondary-bg);
                border:1px solid var(--border-color);
                color:var(--text-color);
                cursor:pointer;
                font-size:11px;
                flex:0 0 auto;
            ">❌ Back</button>`;
            html += '</div>';
            ab.innerHTML = html;
        }

        function usePotion(potionKey) {
            const potion = ITEMS[potionKey];
            const p      = gameState.player;
            let msg;

            // ── Recall Potion ──────────────────────────────────────────────
            if (potion.subtype === 'recall') {
                if (!gameState.dungeon) {
                    termAppend('<span style="color:#ff8800;">⚠ Recall Potions only work inside dungeons!</span>');
                    renderActionBar();
                    return;
                }
                if (gameState.combatState) {
                    termAppend('<span style="color:#ff4444;">⚠ You cannot recall while in combat! Defeat or flee your enemies first.</span>');
                    renderActionBar();
                    return;
                }
                // Consume and recall
                const idx = p.inventory.indexOf(potionKey);
                if (idx !== -1) p.inventory.splice(idx, 1);
                updateHud();
                const dest = gameState.currentTown || 'town1';
                termAppend(`<span style="color:#AA88FF;">🌀 The Recall Potion dissolves in your hand — a swirling portal opens beneath you...</span>`);
                termAppend(`<span style="color:#AA88FF;">You are swept away to safety!</span>`);
                setTimeout(() => {
                    gameState.dungeon      = null;
                    gameState.combatState  = null;
                    if (gameState.combatTimer) { clearInterval(gameState.combatTimer); gameState.combatTimer = null; }
                    document.getElementById('actionBar').innerHTML = '';
                    document.body.classList.remove('terminal-mode');
                    gameState._terminalOpen = false;
                    saveGame();
                    showTown(dest);
                }, 1800);
                return;
            }

            if (potion.subtype === 'heal_hp') {
                const actual = Math.min(p.maxHp - p.hp, potion.power);
                p.hp = Math.min(p.maxHp, p.hp + actual);
                msg = `Used ${potion.name} – restored <span style="color:#88ff88;">${actual} HP!</span>`;
            } else if (potion.subtype === 'heal_mp') {
                const actual = Math.min(p.maxMp - p.mp, potion.power);
                p.mp = Math.min(p.maxMp, p.mp + potion.power);
                msg = `Used ${potion.name} – restored <span style="color:#88ff88;">${actual} MP!</span>`;
            } else if (potion.subtype === 'full_restore') {
                const hpR = p.maxHp - p.hp, mpR = p.maxMp - p.mp;
                p.hp = p.maxHp; p.mp = p.maxMp;
                msg = `Used ${potion.name} – fully restored <span style="color:#88ff88;">${hpR} HP & ${mpR} MP!</span>`;
            } else if (potion.subtype === 'buff_xp') {
                // XP Boost buff
                applyBuff(p, 'xp_boost', potion.duration || 900000, potion.power); // 15 min default
                msg = `Used ${potion.name} – <span style="color:#FFD700;">+${potion.power}% XP for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_str') {
                // Strength buff
                applyBuff(p, 'strength_boost', potion.duration || 300000, potion.power); // 5 min default
                msg = `Used ${potion.name} – <span style="color:#FF8800;">+${potion.power} Strength for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_def') {
                // Defense buff
                applyBuff(p, 'defense_boost', potion.duration || 300000, potion.power); // 5 min default
                msg = `Used ${potion.name} – <span style="color:#00AAFF;">+${potion.power} Defense for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_crit') {
                // Crit chance buff
                applyBuff(p, 'crit_boost', potion.duration || 300000, potion.power); // 5 min default
                msg = `Used ${potion.name} – <span style="color:#FFD700;">+${potion.power}% Crit Chance for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_speed') {
                // Speed buff (faster pip regen)
                applyBuff(p, 'speed_boost', potion.duration || 300000, potion.power); // 5 min default
                msg = `Used ${potion.name} – <span style="color:#00FF00;">+${potion.power}% Attack Speed for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_gold') {
                // Gold boost buff
                applyBuff(p, 'gold_boost', potion.duration || 900000, potion.power);
                msg = `Used ${potion.name} – <span style="color:#FFD700;">+${potion.power}% Gold for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_magic') {
                // Magic buff
                applyBuff(p, 'magic_boost', potion.duration || 300000, potion.power);
                msg = `Used ${potion.name} – <span style="color:#8888FF;">+${potion.power} Magic for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_damage') {
                // Damage boost buff
                applyBuff(p, 'damage_boost', potion.duration || 180000, potion.power);
                msg = `Used ${potion.name} – <span style="color:#FF0000;">+${potion.power}% Damage for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_invuln') {
                // Damage reduction buff
                applyBuff(p, 'damage_reduction', potion.duration || 120000, potion.power);
                msg = `Used ${potion.name} – <span style="color:#AAAAAA;">+${potion.power}% Damage Resist for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_luck') {
                // Luck buff
                applyBuff(p, 'luck_boost', potion.duration || 600000, potion.power);
                msg = `Used ${potion.name} – <span style="color:#FFD700;">+${potion.power} Luck for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_regen') {
                // Regeneration buff
                applyBuff(p, 'regen_boost', potion.duration || 300000, potion.power);
                msg = `Used ${potion.name} – <span style="color:#00FF88;">+${potion.power} HP/sec for ${(potion.duration/60000)} minutes!</span>`;
            }
            const idx = p.inventory.indexOf(potionKey);
            if (idx !== -1) p.inventory.splice(idx, 1);
            updateHud();
            
            // Reset to main combat menu after using potion
            const cs = gameState.combatState;
            if (cs) {
                cs.actionMode = 'main';
            }
            
            renderActionBar();
            termAppend(msg);   // no callback – timer keeps ticking, player can still act
        }
        
        // ═══════════════════════════════════════════════════════════════
        // BUFF SYSTEM - Temporary stat boosts from potions
        // ═══════════════════════════════════════════════════════════════
        function applyBuff(player, buffType, duration, power) {
            if (!player.activeBuffs) player.activeBuffs = {};
            
            // If buff already active, extend duration and stack power
            if (player.activeBuffs[buffType]) {
                const existing = player.activeBuffs[buffType];
                clearTimeout(existing.timer);
                existing.power = Math.min(existing.power + power, power * 3); // Cap at 3x
                existing.endTime = Date.now() + duration;
            } else {
                player.activeBuffs[buffType] = {
                    power: power,
                    endTime: Date.now() + duration
                };
            }
            
            // Set timer to remove buff
            player.activeBuffs[buffType].timer = setTimeout(() => {
                delete player.activeBuffs[buffType];
                termAppend(`<span style="color:#888;">Your ${buffType.replace('_', ' ')} has worn off.</span>`, 'term-dim');
            }, duration);
        }
        
        function getActiveBuff(player, buffType) {
            if (!player.activeBuffs || !player.activeBuffs[buffType]) return 0;
            const buff = player.activeBuffs[buffType];
            if (Date.now() > buff.endTime) {
                delete player.activeBuffs[buffType];
                return 0;
            }
            return buff.power;
        }
        
        // ═══════════════════════════════════════════════════════════════
        // POTION MENU - EXPLORATION (Out of Combat)
        // ═══════════════════════════════════════════════════════════════
        function showPotionMenuExplore() {
            const p = gameState.player;
            const ab = document.getElementById('actionBar');
            const inDungeon = !!gameState.dungeon;
            
            // Count all usable potions (healing + buffs + recall if in dungeon)
            const potions = {};
            p.inventory.forEach(ik => {
                const item = ITEMS[ik];
                if (!item) return;
                const isRecall = item.subtype === 'recall';
                if (isRecall && !inDungeon) return; // recall only usable in dungeon
                if (
                    isRecall ||
                    ['heal_hp','heal_mp','full_restore'].includes(item.subtype) ||
                    item.subtype?.startsWith('buff_')
                ) {
                    if (!potions[ik]) potions[ik] = { item, count: 0 };
                    potions[ik].count++;
                }
            });
            
            const keys = Object.keys(potions);
            if (keys.length === 0) {
                ab.innerHTML = `
                    <div style="color:var(--error-color);font-size:10px;margin-bottom:4px;">You have no potions!</div>
                    <button onclick="renderActionBar()">← BACK</button>
                `;
                return;
            }
            
            // Color + icon lookup (mirrors combat potion menu)
            function potionColor(subtype) {
                if (subtype==='recall') return '#AA88FF';
                if (subtype==='heal_hp') return '#ff4444';
                if (subtype==='heal_mp') return '#4488ff';
                if (subtype==='full_restore') return '#FFD700';
                if (subtype==='buff_str') return '#FF8800';
                if (subtype==='buff_def') return '#00AAFF';
                if (subtype==='buff_xp') return '#FFD700';
                if (subtype==='buff_gold') return '#FFD700';
                if (subtype==='buff_magic') return '#8888FF';
                if (subtype==='buff_damage') return '#FF0000';
                if (subtype==='buff_invuln') return '#AAAAAA';
                if (subtype==='buff_luck') return '#FFAA00';
                if (subtype==='buff_regen') return '#00FF88';
                if (subtype==='buff_speed') return '#00FF00';
                if (subtype==='buff_crit') return '#FF00FF';
                return '#00FF00';
            }
            function potionIcon(subtype) {
                if (subtype==='recall') return '🌀';
                if (subtype==='heal_hp') return '❤️';
                if (subtype==='heal_mp') return '💙';
                if (subtype==='full_restore') return '✨';
                if (subtype==='buff_str') return '💪';
                if (subtype==='buff_def') return '🛡️';
                if (subtype==='buff_xp') return '⭐';
                if (subtype==='buff_gold') return '💰';
                if (subtype==='buff_magic') return '🔮';
                if (subtype==='buff_damage') return '⚔️';
                if (subtype==='buff_invuln') return '🗿';
                if (subtype==='buff_luck') return '🍀';
                if (subtype==='buff_regen') return '💚';
                if (subtype==='buff_speed') return '⚡';
                if (subtype==='buff_crit') return '🎯';
                return '🧪';
            }

            let html = `<div style="color:var(--highlight-color);font-size:10px;margin-bottom:4px;">USE POTION (HP: ${p.hp}/${p.maxHp} | MP: ${p.mp}/${p.maxMp}):</div>`;
            html += `<div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:flex-start;">`;
            
            keys.forEach(pk => {
                const pd  = potions[pk];
                const col = potionColor(pd.item.subtype);
                const icon = potionIcon(pd.item.subtype);
                const atFull = (pd.item.subtype === 'heal_hp' && p.hp >= p.maxHp) ||
                               (pd.item.subtype === 'heal_mp' && p.mp >= p.maxMp) ||
                               (pd.item.subtype === 'full_restore' && p.hp >= p.maxHp && p.mp >= p.maxMp);
                const shortName = pd.item.name.length > 12 ? pd.item.name.substring(0,12)+'…' : pd.item.name;
                html += `<button onclick="usePotionExplore('${pk}')" ${atFull ? 'disabled' : ''} style="
                    color:${col}; border:1px solid ${col};
                    background:var(--secondary-bg);
                    padding:4px 6px; min-width:70px; max-width:90px;
                    font-size:11px; flex:0 0 auto;
                    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
                    opacity:${atFull ? 0.4 : 1};
                ">${icon} ${shortName} x${pd.count}</button>`;
            });
            
            html += `<button onclick="renderActionBar()" style="
                padding:4px 8px; min-width:60px; flex:0 0 auto;
                background:var(--secondary-bg); border:1px solid var(--border-color);
                color:var(--text-color); font-size:11px;">❌ Back</button>`;
            html += `</div>`;
            ab.innerHTML = html;
        }
        
        function usePotionExplore(potionKey) {
            const potion = ITEMS[potionKey];
            const p = gameState.player;
            
            // ── Recall Potion ──────────────────────────────────────────────
            if (potion.subtype === 'recall') {
                if (!gameState.dungeon) {
                    termAppend('<span style="color:#ff8800;">⚠ Recall Potions only work inside dungeons!</span>');
                    return;
                }
                const idx2 = p.inventory.indexOf(potionKey);
                if (idx2 !== -1) p.inventory.splice(idx2, 1);
                updateHud();
                const dest = gameState.currentTown || 'town1';
                termAppend(`<span style="color:#AA88FF;">🌀 The Recall Potion dissolves in your hand — a swirling portal opens beneath you...</span>`);
                termAppend(`<span style="color:#AA88FF;">You are swept away to safety!</span>`);
                setTimeout(() => {
                    gameState.dungeon      = null;
                    gameState.combatState  = null;
                    if (gameState.combatTimer) { clearInterval(gameState.combatTimer); gameState.combatTimer = null; }
                    document.getElementById('actionBar').innerHTML = '';
                    document.body.classList.remove('terminal-mode');
                    gameState._terminalOpen = false;
                    saveGame();
                    showTown(dest);
                }, 1800);
                return;
            }

            let msg;
            if (potion.subtype === 'heal_hp') {
                const actual = Math.min(p.maxHp - p.hp, potion.power);
                if (actual === 0) {
                    msg = `You're already at full HP!`;
                } else {
                    p.hp = Math.min(p.maxHp, p.hp + actual);
                    msg = `Used ${potion.name} – restored <span style="color:#88ff88;">${actual} HP!</span>`;
                }
            } else if (potion.subtype === 'heal_mp') {
                const actual = Math.min(p.maxMp - p.mp, potion.power);
                if (actual === 0) {
                    msg = `You're already at full MP!`;
                } else {
                    p.mp = Math.min(p.maxMp, p.mp + potion.power);
                    msg = `Used ${potion.name} – restored <span style="color:#88ff88;">${actual} MP!</span>`;
                }
            } else if (potion.subtype === 'full_restore') {
                const hpR = p.maxHp - p.hp;
                const mpR = p.maxMp - p.mp;
                if (hpR === 0 && mpR === 0) {
                    msg = `You're already fully restored!`;
                } else {
                    p.hp = p.maxHp;
                    p.mp = p.maxMp;
                    msg = `Used ${potion.name} – fully restored <span style="color:#88ff88;">${hpR} HP & ${mpR} MP!</span>`;
                }
            }
            
            // Remove potion from inventory
            const idx = p.inventory.indexOf(potionKey);
            if (idx !== -1) p.inventory.splice(idx, 1);
            
            updateHud();
            termAppend(msg);
            
            // Refresh potion menu to show updated counts
            showPotionMenuExplore();
        }

        // ═══════════════════════════════════════════════════════════════
        // ENEMY ATTACK
        // ═══════════════════════════════════════════════════════════════
       function enemyAttackSingle() {
    // Enemy uses ONE charge, attacks once, then resets its own timer
    const cs       = gameState.combatState;
    const monsters = cs.monsters;
    const p        = gameState.player;

    // Defensive stats
    let armor = ARMOR[p.armor];
    
    // No armor equipped → bare skin (no_armor gives 0 defense)
    if (!armor) {
        if (p.armor && p.armor !== 'no_armor') {
            console.warn(`⚠️ Armor '${p.armor}' not found — treating as unarmored.`);
        }
        p.armor = 'no_armor';
        armor   = ARMOR['no_armor'] || { baseDefense: 0, baseMagicBonus: 0, quality: 'poor' };
    }
    
    const qBonus = getQualityBonus(armor.quality, armor.baseDefense);
    let totalDef = armor.baseDefense + qBonus + (p.con || 0);
    // ── GEM defense bonus ────────────────────────────────────────────
    {
        const _w = p.weapon ? WEAPONS[p.weapon] : null;
        const _a = p.armor  ? ARMOR[p.armor]   : null;
        const _allG = [...(_w?.gems || []), ...(_a?.gems || [])];
        for (const _g of _allG) {
            if (_g?.stats?.defenseBonus) totalDef += _g.stats.defenseBonus;
        }
    }
    // ── REND: temporarily reduced defense ───────────────────────────
    if (cs.playerRendReduction && cs.playerRendReduction > 0) {
        const rendLoss = Math.floor(totalDef * cs.playerRendReduction);
        totalDef = Math.max(0, totalDef - rendLoss);
    }

        // ── Warrior Shield: 70% chance to halve ALL incoming damage each attack ──
    // cs.shieldActive is set by playerDefend() and persists until combat ends.
    // Shield now always adds +50% defense bonus (applied to totalDef below)
    const shieldTriggered = cs.shieldActive;
    if (cs.shieldActive && (gameState.sysop && gameState.sysop.authenticated)) {
        const _shieldBonus = Math.floor(totalDef * 0.5);
        termAppend(`<span style="color:#006688;">🛡️ [SHIELD] active — DEF: ${totalDef} + ${_shieldBonus} (50%) = ${totalDef + _shieldBonus}</span>`, 'term-dim');
    }
    if (shieldTriggered) totalDef = Math.floor(totalDef * 1.5);

    // Pull intent (or fallback)
    const intent = cs.enemyIntent || {
        type: 'basic',
        damageMult: 1,
        armorPiercing: 0
    };

    // Each monster in the pack gets ONE hit
    const hits = [];

    monsters.forEach((enemy, i) => {
        const eName = monsters.length > 1
            ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${i + 1}</span>`
            : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;

        // God mode bypass
        if (p.godMode) {
            hits.push({ eName, godMode: true });
            return;
        }

        // ── SYSOP: enemy stat header (shown once per enemy per attack round) ──
        if (gameState.sysop && gameState.sysop.authenticated) {
            const eMin0 = Math.max(1, enemy.minDamage ?? Math.round(enemy.damage * 0.67));
            const eMax0 = Math.max(eMin0 + 1, enemy.maxDamage ?? Math.round(enemy.damage * 1.33));
            const _mpDisplay = (enemy.baseMp||0) > 0
                ? ` | MP: ${enemy.mp||0}/${enemy.baseMp||0}` : '';
            termAppend(`<span style="color:#553300;">` +
                `📋 [${enemy.name}] HP: ${enemy.hp}/${enemy.maxHp||enemy.hp} | Lv${enemy.level} ${enemy.rarity||'common'}` +
                ` | dmg range: ${eMin0}–${eMax0} | def: ${enemy.defense||0}` +
                _mpDisplay +
                `${enemy.magicAttack ? ' | ✨magic atk' : ''}` +
                `${(enemy.statusEffects||[]).length ? ` | status: ${enemy.statusEffects.map(s=>s.name||s).join(',')}` : ''}` +
                `</span>`, 'term-dim');
        }

        // ── Phase II: deduct MP and handle pure-debuff abilities ──────
        // Pure debuffs (rend, intimidate, blind, stun, etc.) replace the
        // physical hit entirely — no damage is rolled or applied.
        if (intent.isPureDebuff && intent.abilityDef) {
            // Deduct MP
            if ((intent.abilityMpCost || 0) > 0) {
                enemy.mp = Math.max(0, (enemy.mp || 0) - intent.abilityMpCost);
            }
            if (_debugCombat) {
                const _mpLeft = enemy.mp || 0;
                termAppend(`<span style="color:#553300;">  💙 [PURE DEBUFF] ${intent.abilityId} | MP cost: ${intent.abilityMpCost||0} | MP remaining: ${_mpLeft}</span>`, 'term-dim');
            }
            // Execute the debuff side-effect directly (no damage)
            executeAbilitySideEffect(intent.abilityDef, p, cs, enemy);
            hits.push({ eName, dmg: 0, isPureDebuff: true, abilityName: intent.abilityDef.name });
            return; // skip damage roll for this enemy
        }

        // ── Pick a random damage roll within the enemy's min/max range ──
        // Stats are already scaled for level and rarity at spawn.
        // enemyDealt applies an additional 5% reduction per level the player is above the enemy.
        const eMin = Math.max(1, enemy.minDamage ?? Math.round(enemy.damage * 0.67));
        const eMax = Math.max(eMin + 1, enemy.maxDamage ?? Math.round(enemy.damage * 1.33));
        const rolledDamage = eMin + Math.floor(Math.random() * (eMax - eMin + 1));

        const _lvlMult = getLevelDamageMult(p.level, enemy.level);
        const _scaledBase = Math.max(1,
            Math.floor(rolledDamage * intent.damageMult * DAMAGE_SCALING.monsterDamageMult * _lvlMult.enemyDealt)
        );

        // ── SYSOP DEBUG: pre-roll dodge so we can show the number ──
        const _debugCombat = gameState.sysop && gameState.sysop.authenticated;
        // Constricted: player cannot dodge (water snake ability)
        const _constricted = cs.playerConstricted || false;
        const _dodgeChance = _constricted ? 0 : (calcDodgeChance(p.dex || 0) / 100);
        const _dodgeRoll   = Math.random();
        const _didDodge    = !_constricted && _dodgeRoll < _dodgeChance;
        if (_constricted && _debugCombat) termAppend('<span style="color:#553300;">  ⚠️ Player is constricted — dodge suppressed!</span>', 'term-dim');

        if (_debugCombat) {
            const DR_PER_POINT = 0.028;
            const _effectiveDR = Math.min(0.75, totalDef * DR_PER_POINT) * (1 - (intent.armorPiercing || 0));
            const _attackType  = enemy.magicAttack ? 'magic' : 'physical';
            const _postDR      = Math.max(1, Math.floor(_scaledBase * (1 - _effectiveDR)));
            termAppend(`<span style="color:#553300;">` +
                `⚔️ [ENEMY ATK] ${enemy.name} ` +
                `| base dmg: ${enemy.damage} | range: ${eMin}–${eMax} | rolled: ${rolledDamage}` +
                `${intent.damageMult !== 1 ? ` | intent×${intent.damageMult}` : ''}` +
                `${DAMAGE_SCALING.monsterDamageMult !== 1 ? ` | scale×${DAMAGE_SCALING.monsterDamageMult.toFixed(2)}` : ''}` +
                `${_lvlMult.enemyDealt !== 1 ? ` | lvl×${_lvlMult.enemyDealt.toFixed(2)}` : ''}` +
                ` → scaled: ${_scaledBase}` +
                `</span>`, 'term-dim');
            termAppend(`<span style="color:#553300;">` +
                `  [${_attackType}] DEF: ${totalDef} (armor ${(armor.baseDefense + qBonus)} + CON ${p.con||0})` +
                `${(intent.armorPiercing||0) > 0 ? ` | pierce: ${((intent.armorPiercing||0)*100).toFixed(0)}%` : ''}` +
                ` | DR: ${(_effectiveDR*100).toFixed(1)}% | after DR: ${_postDR}` +
                ` | dodge: rolled ${(_dodgeRoll*100).toFixed(2)}% / need ≤${(_dodgeChance*100).toFixed(1)}% → ${_didDodge ? '✅ DODGE' : '❌ no dodge'}` +
                `</span>`, 'term-dim');
        }

        const result = _didDodge
            ? { damage: 0, dodged: true, crit: false }
            : calculateDamage({
                attacker: enemy,
                defender: {
                    defense: totalDef,
                    magicDefense: totalDef
                },
                base: _scaledBase,
                type: enemy.magicAttack ? 'magic' : 'physical',
                dodgeChance: 0,          // already rolled above
                armorPiercing: intent.armorPiercing
            });

        if (result.dodged) {
            if (_debugCombat) termAppend(`<span style="color:#553300;">  → ✅ DODGED</span>`, 'term-dim');
            hits.push({ eName, dodged: true });
            return;
        }

        const finalDmg = result.damage;

        if (_debugCombat) {
            const _critStr = result.crit ? ' | 💀 CRIT!' : '';
            termAppend(`<span style="color:#553300;">  → final: <b>${finalDmg} dmg</b>${_critStr} | player HP: ${p.hp} → ${p.hp - finalDmg}</span>`, 'term-dim');
        }

        p.hp -= finalDmg;
        cs.lastEnemyDamageDealt = finalDmg;   // used by leech ability

        // ── Execute ability side-effects ─────────────────────────────
        // Only runs if this attack was powered by an ability with a type
        // that has additional effects beyond damage.
        const _abilityDef = intent && intent.abilityDef;
        if (_abilityDef) {
            // Deduct enemy MP for damage-dealing abilities
            if ((intent.abilityMpCost || 0) > 0) {
                enemy.mp = Math.max(0, (enemy.mp || 0) - intent.abilityMpCost);
                if (_debugCombat) {
                    termAppend(`<span style="color:#553300;">  💙 MP cost: ${intent.abilityMpCost} | ${enemy.name} MP remaining: ${enemy.mp}/${enemy.baseMp||0}</span>`, 'term-dim');
                }
            }
            if (p.hp > 0) {
                executeAbilitySideEffect(_abilityDef, p, cs, enemy);
            }
        }

        hits.push({
            eName,
            dmg:        finalDmg,
            crit:       result.crit,
            abilityName: _abilityDef ? _abilityDef.name : null,
            shieldBlocked: shieldTriggered
        });
    });

    updateHud();

    // After attack messages stream, reset enemy timer and resume
    const afterAttack = () => {
        cs.enemyIntent = null; // clear intent after execution

        if (p.hp <= 0 && !p.godMode) {
            endCombat(false);
        } else {
            cs.enemyTimer = cs.enemyDelay;
            
            // Apply trap slow if active
            if (cs.trapActive && cs.trapSlowAmount) {
                cs.enemyTimer += cs.trapSlowAmount;
            }
            
            renderActionBar();
            startCombatTimer();
        }
    };

    hits.forEach((hit, i) => {
        const isLast = (i === hits.length - 1);

        if (hit.godMode) {
            termAppend(
                `${hit.eName} attacks but you are <span class="term-highlight">INVINCIBLE!</span>`,
                null,
                isLast ? afterAttack : null
            );
        } else if (hit.dodged) {
            termAppend(
                `${hit.eName} attacks… <span style="color:#88ff88;">DODGED!</span>`,
                null,
                isLast ? afterAttack : null
            );
        } else {
            const critTag    = hit.crit
                ? ' <span style="color:#FF4444;">💀 ENEMY CRITICAL!</span>'
                : '';
            const shieldTag  = hit.shieldBlocked
                ? ' <span style="color:#00CCFF;">🛡️ SHIELD! (+50% DEF)</span>'
                : '';

            const abilityTag = hit.abilityName
                ? ` <span style="color:#FF8800;font-size:12px;">[${hit.abilityName}]</span>`
                : '';
            // Pure-debuff abilities replace the hit — no "X damage" message
            if (hit.isPureDebuff) {
                termAppend(
                    `${hit.eName} uses ${abilityTag}`,
                    null,
                    isLast ? afterAttack : null
                );
            } else {
                termAppend(
                    `${hit.eName} attacks for <span class="dmg-player">${hit.dmg} damage!</span>${critTag}${shieldTag}${abilityTag}`,
                    null,
                    isLast ? afterAttack : null
                );
            }
        }
    });
}
// ═══════════════════════════════════════════════════════════════
// CHECK / END COMBAT
// ═══════════════════════════════════════════════════════════════
function checkCombatEnd() {
    const cs = gameState.combatState;
    if (!cs || !cs.monsters || cs.monsters.length === 0) return;

    let ti = cs.currentTarget;

    // Clamp target index (important after splicing)
    if (ti < 0 || ti >= cs.monsters.length) {
        cs.currentTarget = 0;
        ti = 0;
    }

    const target = cs.monsters[ti];
    if (!target) return;

    if (!cs.defeatedMonsters) cs.defeatedMonsters = [];

    if (target.hp <= 0) {
        const dead = target;

        // Calculate rewards for THIS enemy immediately
        const baseXp = dead.xp || (dead.level * 10);
        const baseGold = dead.gold || (dead.level * 5);
        
        termAppend(
            `<span style="color:${dead.rarityColor};">${dead.name}</span> has been defeated!`,
            'term-victory'
        );
        
        // Show individual rewards immediately
        termAppend(`Gained <span style="color:#FFD700;">${baseXp} XP</span> and <span style="color:#FFD700;">${baseGold} Gold!</span>`, 'term-loot');
        
        // Apply rewards immediately
        const p = gameState.player;
        p.xp += baseXp;
        p.gold += baseGold;
        
        // Check for level up
        if (p.xp >= p.xpToNext) {
            levelUp();
            showLevelUpCeremony(p.level);
            termAppend(`<span style="color:#FFD700;font-size:14px;">+3 Stat Points earned!</span>`, 'term-loot');
            termAppend(`<span style="color:#00FFFF;">→ Tap </span><span style="color:#FFD700;font-weight:bold;">⬆ pts</span><span style="color:#00FFFF;"> in the compass panel, or open </span><span style="color:#00FF88;font-weight:bold;">🎒 Inventory</span><span style="color:#00FFFF;">.</span>`, 'term-loot');
        }
        
        // Add to defeated list and remove from active combat
        cs.defeatedMonsters.push(dead);

        // ── BESTIARY: increment kill count for this monster type ──
        const p2 = gameState.player;
        if (!p2.kills) p2.kills = {};
        const killKey = dead.key || dead.name.toLowerCase().replace(/\s+/g, '_');
        p2.kills[killKey] = (p2.kills[killKey] || 0) + 1;
        // Fire bestiary discovery event so UI can react immediately
        onMonsterKill(killKey, p2.kills[killKey], dead);
        cs.monsters.splice(ti, 1);

        // Adjust target after removal
        if (cs.currentTarget >= cs.monsters.length) {
            cs.currentTarget = Math.max(0, cs.monsters.length - 1);
        }

        // Update cards and HUD immediately
        updateEnemyCards();
        updateHud();
        
        // Check if all enemies dead
        if (cs.monsters.length === 0) {
            // All enemies dead - end combat
            // Don't give rewards again in endCombat
            cs.rewardsAlreadyGiven = true;
            endCombat(true);
        }
    }
}

// ═══════════════════════════════════════════════════════════════
// END COMBAT
// ═══════════════════════════════════════════════════════════════
function endCombat(victory) {

    // ── defeat ──
    if (!victory) {
        clearInterval(gameState.combatTimer);
        gameState.combatTimer = null;

        const p = gameState.player;
        const inDungeon = !!gameState.dungeon;

        // ── Calculate penalties BEFORE applying them ─────────────────
        // Level 1 players are immune to all penalties
        const isLevel1 = p.level <= 1;

        let xpLost   = 0;
        let goldLost = 0;

        if (!isLevel1) {
            // ── XP penalty: 10% of total accumulated XP ────────────────
            // p.xp is now a running total, so it IS the total XP so far.
            xpLost = Math.floor(p.xp * 0.10);

            // Never drop a level — floor XP at the start-of-current-level threshold
            const xpFloor = getXpForLevel(p.class, p.level);
            p.xp = Math.max(xpFloor, p.xp - xpLost);
            // xpToNext stays the same (level doesn't change)

            // ── Gold penalty: lose ALL carried gold (bank is safe) ──────
            goldLost = p.gold;
            p.gold   = 0;
        }

        // Restore HP/MP to full
        p.hp = p.maxHp;
        p.mp = p.maxMp;

        // Clear dungeon / combat state
        gameState.dungeon              = null;
        gameState.combatState          = null;
        gameState.postCombatRecovery   = false;

        updateHud();
        saveGame();  // persist penalties immediately

        // ── Build death screen shown IN THE TERMINAL ──────────────────
        // Separator
        termAppend('', 'term-separator');

        // Big skull header
        termAppend(
            `<span style="color:#ff2222;font-size:26px;letter-spacing:4px;">💀  YOU HAVE DIED  💀</span>`,
            'term-error'
        );
        termAppend('', 'term-separator');

        if (isLevel1) {
            // No penalties at level 1
            termAppend(
                `<span style="color:#88ff88;">You are a <strong>Level 1</strong> adventurer — no penalties apply.</span>`,
                'term-loot'
            );
            termAppend(
                `<span style="color:#aaaaaa;">You wake up bruised but no worse for wear...</span>`
            );
        } else {
            // Show each penalty
            termAppend(
                `<span style="color:#ff6666;">💸 Gold Lost: </span>` +
                `<span style="color:#ffaa00;font-size:18px;">${goldLost.toLocaleString()}g</span>` +
                `<span style="color:#888;"> (gold in your <strong>Bank</strong> is safe)</span>`
            );

            const xpBefore = p.xp + xpLost;
            termAppend(
                `<span style="color:#ff6666;">📉 XP Lost: </span>` +
                `<span style="color:#ff8888;font-size:18px;">${xpLost.toLocaleString()} XP</span>`
            );
            termAppend(
                `<span style="color:#888;">XP: ${xpBefore.toLocaleString()} → ${p.xp.toLocaleString()}` +
                `${p.xp === getXpForLevel(p.class, p.level) ? ' <span style="color:#ff4444;">(floored at level start)</span>' : ''}</span>`
            );

            if (inDungeon) {
                termAppend(
                    `<span style="color:#ff4444;">🏚️ Expelled from the dungeon!</span>`
                );
            }

            termAppend('', 'term-separator');
            termAppend(
                `<span style="color:#666;">Your level remains <strong style="color:#aaa;">Lv ${p.level}</strong>. ` +
                `Gold in your bank is untouched.</span>`
            );
        }

        termAppend('', 'term-separator');
        termAppend(
            `<span style="color:#888888;">Press <strong style="color:#00ff88;">[CONTINUE]</strong> to return to town...</span>`
        );

        // ── Inject CONTINUE button into the action bar ────────────────
        const ab = document.getElementById('actionBar');
        if (ab) {
            ab.innerHTML = `
                <div style="display:flex;gap:6px;width:100%;padding:4px;">
                    <button onclick="confirmDeathReturn()"
                        style="flex:1;font-size:20px;min-height:50px;
                               background:linear-gradient(180deg,#0a0000,#000);
                               color:#ff4444;border:2px solid #ff4444;
                               font-family:'VT323',monospace;letter-spacing:2px;">
                        💀 CONTINUE
                    </button>
                </div>`;
        }
        return;
    }

    // ── victory ──
    const defeated   = gameState.combatState.defeatedMonsters || [];
    const cs = gameState.combatState;
    const isMaster   = defeated.some(m => m.isMaster);
    let masterData   = null;
    let unlockedArea = null;

    if (isMaster) {
        const m = defeated.find(d => d.isMaster);
        masterData   = CLASS_MASTERS[m.masterKey];
        unlockedArea = masterData.unlocks;

        if (!gameState.player.defeatedMasters.includes(m.masterKey))
            gameState.player.defeatedMasters.push(m.masterKey);

        if (!gameState.player.unlockedAreas.includes(unlockedArea))
            gameState.player.unlockedAreas.push(unlockedArea);

        masterData.guaranteedDrops.forEach(ik => {
            if (!defeated[0].possibleDrops) defeated[0].possibleDrops = [];
            if (!defeated[0].possibleDrops.includes(ik))
                defeated[0].possibleDrops.push(ik);

            if (!defeated[0].dropRates) defeated[0].dropRates = {};
            defeated[0].dropRates[
                (WEAPONS[ik] || ARMOR[ik]) ? getItemQuality(ik) : 'common'
            ] = 1.0;
        });
    }

    // Check if rewards were already given during combat (multi-enemy)
    const rewardsAlreadyGiven = cs.rewardsAlreadyGiven;
    
    let totalXp = 0, totalGold = 0, allLoot = [];
    
    // Only calculate if NOT already given
    if (!rewardsAlreadyGiven) {
        defeated.forEach(e => {
            // Calculate XP based on level difference and rarity
            const xpReward = calculateXpReward(e, gameState.player.level);
            totalXp   += xpReward;
            totalGold += e.gold;
            allLoot    = allLoot.concat(rollLoot(e));
        });

        gameState.player.xp   += totalXp;
        gameState.player.gold += totalGold;
    } else {
        // Still roll for loot even if XP/gold already given
        defeated.forEach(e => {
            allLoot = allLoot.concat(rollLoot(e));
        });
    }

    // ── Remove ALL defeated dungeon enemies & award drops ──
    if (gameState.dungeon && gameState.combatState) {
        const cs = gameState.combatState;
        // Collect all dungeon enemy IDs linked to this combat
        const linkedIds = cs.dungeonEnemyIds || (cs.dungeonEnemyId ? [cs.dungeonEnemyId] : []);

        linkedIds.forEach(dungeonEnemyId => {
            const defeatedDungeonEnemy = gameState.dungeon.activeEnemies.find(
                e => e.id === dungeonEnemyId
            );

            // Award the drop item if set
            if (defeatedDungeonEnemy && defeatedDungeonEnemy.drop) {
                const dropKey = defeatedDungeonEnemy.drop;
                if (dropKey && ITEMS[dropKey]) {
                    gameState.player.inventory.push(dropKey);
                    const dropItem = ITEMS[dropKey];
                    const dropIcon = dropItem.icon || '📦';
                    const keyColor = dropItem.subtype === 'dungeon_key' ? '#e8b84a' : '#00FF88';
                    termAppend(
                        `${dropIcon} <span style="color:${keyColor};">${dropItem.name}</span> found on the body!`,
                        'term-loot'
                    );
                }
            }
        });

        // Move defeated enemies to defeatedEnemies with death timestamp for 30min respawn
        if (linkedIds.length > 0) {
            if (!gameState.dungeon.defeatedEnemies) gameState.dungeon.defeatedEnemies = [];
            
            linkedIds.forEach(dungeonEnemyId => {
                const defeatedEnemy = gameState.dungeon.activeEnemies.find(e => e.id === dungeonEnemyId);
                if (defeatedEnemy) {
                    // Store with death timestamp for respawn system
                    gameState.dungeon.defeatedEnemies.push({
                        ...defeatedEnemy,
                        deathTime: Date.now(),
                        respawnTime: Date.now() + (30 * 60 * 1000) // 30 minutes from now
                    });
                }
            });
            
            // Remove from active enemies
            gameState.dungeon.activeEnemies = gameState.dungeon.activeEnemies.filter(
                e => !linkedIds.includes(e.id)
            );
            console.log(`🗑️ Removed ${linkedIds.length} dungeon enemy(s) - will respawn in 30min`);
        }
    }

    // ── terminal output ──
    termAppend('', 'term-separator');

    if (isMaster) {
        termAppend(`🏆 ${masterData.name} HAS BEEN DEFEATED! 🏆`, 'term-victory');
        termAppend(`✨ ${LOCATIONS[unlockedArea].name} IS NOW UNLOCKED! ✨`, 'term-loot');
    }

    if (defeated.length === 1) {
        termAppend(
            `You defeated <span style="color:${defeated[0].rarityColor};">${defeated[0].name}</span>!`,
            'term-highlight'
        );
    } else {
        termAppend(`You defeated ${defeated.length} enemies!`, 'term-highlight');
        defeated.forEach(e =>
            termAppend(`  • <span style="color:${e.rarityColor};">${e.name}</span>`)
        );
    }

    // Only show total XP/Gold if NOT already shown during combat
    if (!rewardsAlreadyGiven) {
        termAppend(
            `Gained <span style="color:#FFD700;">${totalXp} XP</span> and ` +
            `<span style="color:#FFD700;">${totalGold} Gold</span>!`
        );
    }

    if (allLoot.length > 0) {
        termAppend('⚡ LOOT:', 'term-loot');
        allLoot.forEach(ik => {
            // Enforce maxStack for potions (cap = 10)
            const _def = ITEMS[ik];
            const _cap = _def?.maxStack;
            if (_cap) {
                const _held = gameState.player.inventory.filter(k => k === ik).length;
                if (_held >= _cap) {
                    termAppend(
                        `  + <span style="color:#888;">${getItemName(ik)} (bag full — sold for ${_def.sellValue}g)</span>`,
                        'term-loot'
                    );
                    gameState.player.gold += _def.sellValue;
                    return; // skip adding to inventory
                }
            }
            gameState.player.inventory.push(ik);
            termAppend(
                `  + <span style="color:${getItemColor(ik)};">${getItemName(ik)}</span>`,
                'term-loot'
            );
        });
    } else {
        termAppend('No items dropped…', 'term-dim');
    }
    
    // ═══════════════════════════════════════════════════════════
    // WEAPON + ARMOR DROPS 🗡️🛡️
    // ═══════════════════════════════════════════════════════════
    const _debugDrops = gameState.sysop && gameState.sysop.authenticated;
    defeated.forEach((monster, index) => {
        // ── Weapon drop ───────────────────────────────────────
        const _wBase   = 0.04;
        const _wMult   = ({common:1,uncommon:1.5,rare:1.5,epic:2.5,boss:5.0})[monster.rarity||'common'] || 1;
        const _wChance = _wBase * _wMult;
        const _wRoll   = Math.random();
        const _wHit    = _wRoll < _wChance;
        if (_debugDrops) termAppend(`<span style="color:#334466;">🗡️ [WEAPON] ${monster.name} (${monster.rarity||'common'}): rolled <b>${(_wRoll*100).toFixed(2)}%</b> / need ≤${(_wChance*100).toFixed(1)}% → ${_wHit ? '✅ DROP' : '❌ miss'}</span>`, 'term-dim');
        const weaponDrop = _wHit ? generateWeaponDrop(
            gameState.player, 
            monster.level, 
            monster.rarity || 'common',
            true  // skip internal roll — already decided
        ) : null;
        if (_debugDrops && weaponDrop) termAppend(`<span style="color:#334466;">  → ${weaponDrop.quality} ${weaponDrop.type}: ${weaponDrop.name}</span>`, 'term-dim');
        
        if (weaponDrop) {
            // Add to WEAPONS object
            WEAPONS[weaponDrop.id] = weaponDrop;
            
            // Add to player inventory
            gameState.player.inventory.push(weaponDrop.id);
            
            // Show drop message with quality color
            const qualityColor = QUALITY_CONFIG[weaponDrop.quality].color;
            termAppend('', 'term-separator');
            termAppend(`💎 <span style="color:${qualityColor};font-size:18px;font-weight:bold;">WEAPON DROP!</span>`, 'term-victory');
            termAppend(`<span style="color:${qualityColor};">${weaponDrop.name}</span>`, 'term-loot');
            termAppend(`<span style="color:#8aaa8a;">Level ${weaponDrop.level} ${weaponDrop.quality} ${weaponDrop.type}</span>`, 'term-dim');
            termAppend(`<span style="color:#FFD700;">DMG: ${weaponDrop.baseDamage}-${weaponDrop.maxDamage}</span>`);
            // Show gem slots on drop
            const dropSlots = getGemSlots(weaponDrop.quality || 'normal');
            if (dropSlots > 0) {
                const slotCircles = '⬤'.repeat(dropSlots);
                termAppend(`<span style="color:#333;font-size:13px;">${slotCircles}</span> <span style="color:#555;font-size:11px;">${dropSlots} gem slot${dropSlots>1?'s':''} — visit the Blacksmith to socket gems</span>`);
            }
            
            // Show modifiers
            if (weaponDrop.modifiers && weaponDrop.modifiers.length > 0) {
                termAppend('<span style="color:#00FFFF;">Special Properties:</span>');
                weaponDrop.modifiers.forEach(modKey => {
                    const mod = WEAPON_MODIFIERS[modKey];
                    if (mod) {
                        let modText = `  • <span style="color:${mod.color};">${mod.name}`;
                        if (mod.minDamage) {
                            modText += ` (${mod.minDamage}-${mod.maxDamage} dmg)`;
                        }
                        if (mod.statusEffect) {
                            const status = STATUS_EFFECTS[mod.statusEffect];
                            modText += ` - ${Math.floor(mod.statusChance * 100)}% ${status.icon} ${status.name}`;
                        }
                        modText += `</span>`;
                        termAppend(modText, 'term-loot');
                    }
                });
            }
            termAppend('', 'term-separator');
        }

        // ── Armor drop ────────────────────────────────────────
        if (typeof generateArmorDrop !== 'undefined') {
            const _aBase   = 0.04;
            const _aMult   = ({common:1,uncommon:1.5,rare:1.5,epic:2.5,boss:5.0})[monster.rarity||'common'] || 1;
            const _aChance = _aBase * _aMult;
            const _aRoll   = Math.random();
            const _aHit    = _aRoll < _aChance;
            if (_debugDrops) termAppend(`<span style="color:#334466;">🛡️ [ARMOR] ${monster.name} (${monster.rarity||'common'}): rolled <b>${(_aRoll*100).toFixed(2)}%</b> / need ≤${(_aChance*100).toFixed(1)}% → ${_aHit ? '✅ DROP' : '❌ miss'}</span>`, 'term-dim');
            const armorKey = _aHit ? generateArmorDrop(
                gameState.player,
                monster.level,
                monster.rarity || 'common',
                true  // skip internal roll — already decided
            ) : null;
            if (_debugDrops && armorKey && ARMOR[armorKey]) termAppend(`<span style="color:#334466;">  → ${ARMOR[armorKey].quality} ${ARMOR[armorKey].name}</span>`, 'term-dim');

            if (armorKey && typeof ARMOR !== 'undefined' && ARMOR[armorKey]) {
                const armorDef = ARMOR[armorKey];
                // Initialize gems array on dropped armor
                if (!armorDef.gems) armorDef.gems = [];
                gameState.player.inventory.push(armorKey);

                const qColor = QUALITY_CONFIG[armorDef.quality]?.color || '#00FF00';
                const qBonus = getQualityBonus(armorDef.quality, armorDef.baseDefense);
                const totalDef = armorDef.baseDefense + qBonus;
                const dropSlots = getGemSlots(armorDef.quality);

                termAppend('', 'term-separator');
                termAppend(`🛡️ <span style="color:${qColor};font-size:18px;font-weight:bold;">ARMOR DROP!</span>`, 'term-victory');
                termAppend(`<span style="color:${qColor};">${armorDef.name}</span>`, 'term-loot');
                termAppend(`<span style="color:#8aaa8a;">Level ${armorDef.level || 1} ${armorDef.quality} armor</span>`, 'term-dim');
                termAppend(`<span style="color:#00AAFF;">DEF: ${totalDef}${armorDef.baseMagicBonus > 0 ? ` | MAG BONUS: +${armorDef.baseMagicBonus}` : ''}</span>`);
                if (dropSlots > 0) {
                    const slotCircles = '⬤'.repeat(dropSlots);
                    termAppend(`<span style="color:#333;font-size:13px;">${slotCircles}</span> <span style="color:#555;font-size:11px;">${dropSlots} gem slot${dropSlots>1?'s':''} — visit the Blacksmith to socket gems</span>`);
                }
                termAppend('', 'term-separator');
            }
        }
    });

    // Check for level-up (possibly multiple levels)
    while (gameState.player.xp >= gameState.player.xpToNext && gameState.player.level < 25) {
        levelUp();
        showLevelUpCeremony(gameState.player.level);
        termAppend(`<span style="color:#FFD700;font-size:14px;">+3 Stat Points earned!</span>`, 'term-loot');
        if (gameState.dungeon) {
            termAppend(`<span style="color:#00FFFF;">→ Tap </span><span style="color:#FFD700;font-weight:bold;">⬆ pts</span><span style="color:#00FFFF;"> in the compass panel, or open </span><span style="color:#00FF88;font-weight:bold;">🎒 Inventory</span><span style="color:#00FFFF;"> to spend them now.</span>`, 'term-loot');
        } else {
            termAppend(`<span style="color:#00FFFF;">→ Tap </span><span style="color:#00FF88;font-weight:bold;">🎒 Inventory</span><span style="color:#00FFFF;"> to spend them now, or visit </span><span style="color:#FFD700;font-weight:bold;">CHARACTER STATS</span><span style="color:#00FFFF;"> in town.</span>`, 'term-loot');
        }
        
        // Check for class evolution announcement
        if (gameState.player._justEvolved) {
            termAppend('', 'term-separator');
            termAppend(`<span style="color:#FF00FF;font-size:24px;font-weight:bold;">⚡ CLASS EVOLUTION! ⚡</span>`, 'term-victory');
            termAppend(gameState.player._evolutionMessage, 'term-victory');
            termAppend(`<span style="color:#FFD700;">Your power has DOUBLED!</span>`, 'term-loot');
            gameState.player._justEvolved = false;
            gameState.player._evolutionMessage = null;
        }
    }
    
    // Max level message
    if (gameState.player.level >= 25 && gameState.player.xp >= gameState.player.xpToNext) {
        termAppend(`🌟 You have reached MAX LEVEL! (25)`, 'term-victory');
        gameState.player.xp = gameState.player.xpToNext; // Cap at max threshold
    }

    updateHud();
    
    // 💾 AUTO-SAVE after victory
    saveGame();

    // ─────────────────────────────────────────
    // ✅ EXIT COMBAT, ENTER EXHAUSTION
    // ─────────────────────────────────────────
  // Mark combat as finished, but keep state for timers & UI
  cleanupCombatStatusEffects(); // Clear all DOT timers and status effects
gameState.combatState.combatOver = true;
gameState.postCombatRecovery = true;

    // Resume regeneration after combat (normal speed - you're still in the field)
    startMpRegen(false);
    startResting(false);

    const ab = document.getElementById('actionBar');
    
    // Check if we're in a dungeon
    if (gameState.dungeon) {
        // After a short delay, check if more enemies are still in the room
        if (victory) {
            setTimeout(() => {
                const ds = gameState.dungeon;
                if (!ds) return;
                const remaining = ds.activeEnemies.filter(e => e.currentRoom === ds.currentRoom);
                if (remaining.length > 0) {
                    // More enemies in room — start new combat
                    checkEnemiesInRoom(ds.currentRoom);
                } else {
                    // No more enemies — show exploration buttons
                    renderDungeonActionBar();
                    // Fire any Chronicle entries unlocked during this fight
                    if (window._pendingChronicleEntries && window._pendingChronicleEntries.length > 0) {
                        setTimeout(playPendingChronicleEntries, 800);
                    }
                }
            }, 400);
        } else {
            renderDungeonActionBar();
        }
    } else if (isMaster) {
        ab.innerHTML = `
            <button onclick="tryViewWorldMap()">🗺️ VIEW WORLD MAP</button>
            <button onclick="tryGoBackToTown()">🏘️ RETURN TO TOWN</button>`;
        renderActionBar();
    } else {
        ab.innerHTML = `
            <button onclick="tryExploreLocation('${gameState.currentLocation}')">🔍 CONTINUE EXPLORING</button>
            <button onclick="tryGoBackToTown()">🏘️ RETURN TO TOWN</button>`;
        renderActionBar();
        stabilizeTerminalLayout();
        // Fire any Chronicle entries unlocked during this fight
        if (window._pendingChronicleEntries && window._pendingChronicleEntries.length > 0) {
            setTimeout(playPendingChronicleEntries, 800);
        }
    }

    if (!gameState.combatTimer) {
        startCombatTimer();
    }
    
    // ═══════════════════════════════════════════════════════════════
    // ROGUE: SHADOW STRIKE - Activate stealth after combat
    // ═══════════════════════════════════════════════════════════════
    const p = gameState.player;
    const baseClass = p.baseClass || p.class;
    if (baseClass === 'rogue' && victory) {
        // Clear any existing timer
        if (p.shadowStrikeTimer) {
            clearTimeout(p.shadowStrikeTimer);
        }
        
        // Set 5-second timer for Shadow Strike
        p.shadowStrikeTimer = setTimeout(() => {
            p.shadowStrikeReady = true;
            termAppend('', 'term-separator');
            termAppend('🌑 You melt into the shadows... <span style="color:#8888FF;">[Shadow Strike Ready]</span>', 'term-highlight');
        }, 5000);
    }
}

// ═══════════════════════════════════════════════════════════════
// DEATH CONFIRMATION — player presses [CONTINUE] to return to town
// ═══════════════════════════════════════════════════════════════
function confirmDeathReturn() {
    // Start regen fresh in town
    startMpRegen(true);
    startResting(true);
    closeTerminalView();
    showTown();
}

// ═══════════════════════════════════════════════════════════════
// POST-COMBAT EXHAUSTION CHECK
// (used by navigation actions)
// ═══════════════════════════════════════════════════════════════
function continueDungeonExploration() {
    // Clear combat state and show dungeon navigation
    gameState.combatState = null;
    gameState.postCombatRecovery = false;
    
    // Clear combat timer
    if (gameState.combatTimer) {
        clearInterval(gameState.combatTimer);
        gameState.combatTimer = null;
    }
    
    // Return to dungeon navigation
    renderDungeonActionBar();
}

function playerIsExhausted() {
    if (!gameState.postCombatRecovery) return false;

    const cs = gameState.combatState;
    if (!cs || !cs.pipAvailable) return false;

    return cs.pipAvailable.some(p => !p);
}
        // ═══════════════════════════════════════════════════════════════
        // ADVANCED CLASS EVOLUTION (Level 20)
        // ═══════════════════════════════════════════════════════════════
        const ADVANCED_CLASSES = {
            warrior: {
                advancedClass: 'warlord',
                advancedName: 'Warlord',
                description: 'Master of all weapons and combat. Unstoppable in battle.',
                damageMultiplier: 2.0,
                bonusStats: { str: 10, con: 10, dex: 5 },
                newSpells: ['battle_fury', 'titan_strike'],
                announcement: '⚔️ You have mastered the art of war! You are now a WARLORD!'
            },
            rogue: {
                advancedClass: 'shadowmaster',
                advancedName: 'Shadowmaster',
                description: 'Master assassin who strikes from the void itself.',
                damageMultiplier: 2.5,
                bonusStats: { dex: 15, lck: 10, str: 5 },
                newSpells: ['shadow_strike', 'void_step'],
                announcement: '🗡️ You have become one with the shadows! You are now a SHADOWMASTER!'
            },
            acolyte: {
                advancedClass: 'high_priest',
                advancedName: 'High Priest',
                description: 'Chosen of the divine, wielding ultimate holy power.',
                damageMultiplier: 2.0,
                bonusStats: { wis: 15, cha: 10, con: 5 },
                newSpells: ['divine_judgment', 'mass_resurrection', 'holy_nova'],
                announcement: '✨ The gods have chosen you! You are now a HIGH PRIEST!'
            },
            necrolyte: {
                advancedClass: 'lich',
                advancedName: 'Lich',
                description: 'Immortal master of death itself. Reality bends to your will.',
                damageMultiplier: 2.0,
                bonusStats: { wis: 15, magic: 10, con: 5 },
                newSpells: ['death_wave', 'summon_undead_army', 'soul_drain'],
                announcement: '💀 You have transcended mortality! You are now a LICH!'
            },
            archer: {
                advancedClass: 'deadeye',
                advancedName: 'Deadeye',
                description: 'Perfect marksman whose arrows never miss their mark.',
                damageMultiplier: 2.3,
                bonusStats: { dex: 15, lck: 10, str: 5 },
                newSpells: ['piercing_shot', 'rain_of_arrows'],
                announcement: '🏹 Your aim is now perfect! You are now a DEADEYE!'
            },
            druid: {
                advancedClass: 'archdruid',
                advancedName: 'Archdruid',
                description: 'Master of nature and the primal forces of creation.',
                damageMultiplier: 2.0,
                bonusStats: { wis: 15, con: 10, str: 5 },
                newSpells: ['natures_wrath', 'wild_shape', 'earthquake'],
                announcement: '🌿 Nature itself answers your call! You are now an ARCHDRUID!'
            },
            sorceror: {
                advancedClass: 'archmage',
                advancedName: 'Archmage',
                description: 'Master of all magic. Reality itself obeys your command.',
                damageMultiplier: 2.5,
                bonusStats: { wis: 20, magic: 15, cha: 5 },
                newSpells: ['apocalypse', 'time_stop', 'disintegrate'],
                announcement: '🔮 You have mastered all magic! You are now an ARCHMAGE!'
            },
            hunter: {
                advancedClass: 'beastlord',
                advancedName: 'Beastlord',
                description: 'Master of beasts and the wild. Animals bow to your command.',
                damageMultiplier: 2.2,
                bonusStats: { dex: 12, str: 8, con: 8, wis: 5 },
                newSpells: ['beast_stampede', 'primal_bond'],
                announcement: '🐺 All beasts obey you! You are now a BEASTLORD!'
            },
            rogue: {
                advancedClass: 'shadowmaster',
                advancedName: 'Shadowmaster',
                description: 'Master assassin who strikes from the void itself.',
                damageMultiplier: 2.5,
                bonusStats: { dex: 15, lck: 10, str: 5 },
                newSpells: ['shadow_strike', 'void_step'],
                announcement: '🗡️ You have become one with the shadows! You are now a SHADOWMASTER!'
            },
            paladin: {
                advancedClass: 'crusader',
                advancedName: 'Crusader',
                description: 'Holy warrior blessed by the gods themselves.',
                damageMultiplier: 2.2,
                bonusStats: { str: 10, wis: 10, con: 8, cha: 5 },
                newSpells: ['holy_crusade', 'divine_shield', 'smite_evil'],
                announcement: '⚡ The heavens bless your crusade! You are now a CRUSADER!'
            },
            warlock: {
                advancedClass: 'demonlord',
                advancedName: 'Demonlord',
                description: 'Master of dark pacts who commands legions of demons.',
                damageMultiplier: 2.4,
                bonusStats: { wis: 18, cha: 12, con: 5 },
                newSpells: ['summon_demon', 'dark_pact', 'soul_harvest'],
                announcement: '😈 You have bound demons to your will! You are now a DEMONLORD!'
            }
        };

        function evolveClass(player) {
            if (player.level !== 20) return false;
            if (player.hasEvolved) return false; // Already evolved
            
            const baseClass = player.class;
            const evolution = ADVANCED_CLASSES[baseClass];
            
            if (!evolution) return false;
            
            // Store original class
            player.baseClass = baseClass;
            player.class = evolution.advancedClass;
            player.className = evolution.advancedName;
            player.hasEvolved = true;
            
            // Apply bonus stats
            Object.keys(evolution.bonusStats).forEach(stat => {
                if (player[stat] !== undefined) {
                    player[stat] += evolution.bonusStats[stat];
                }
            });
            
            // Apply damage multiplier
            player.advancedClassMultiplier = evolution.damageMultiplier;
            
            // Add new spells
            evolution.newSpells.forEach(spell => {
                if (!player.knownSpells.includes(spell)) {
                    player.knownSpells.push(spell);
                }
            });
            
            // Heal to full and boost HP/MP
            player.maxHp = Math.floor(player.maxHp * 1.5);
            player.maxMp = Math.floor(player.maxMp * 1.5);
            player.hp = player.maxHp;
            player.mp = player.maxMp;
            
            return true;
        }

        function getAdvancedClassName(player) {
            if (player.hasEvolved && ADVANCED_CLASSES[player.baseClass]) {
                return ADVANCED_CLASSES[player.baseClass].advancedName;
            }
            return player.className || player.class;
        }

        function getClassDamageMultiplier(player) {
            return player.advancedClassMultiplier || 1.0;
        }

        // ═══════════════════════════════════════════════════════════════
        // END ADVANCED CLASS SYSTEM
        // ═══════════════════════════════════════════════════════════════

        // ── Dungeon level-up modal — appears over the action bar when levelling in-dungeon ──
        function showLevelUpModal() {
            // Remove any existing modal
            const old = document.getElementById('levelUpModal');
            if (old) old.remove();
            window._statPending = {};
            _renderLevelUpModal();
        }

        function _renderLevelUpModal() {
            const p = gameState.player;
            const old = document.getElementById('levelUpModal');
            if (old) old.remove();

            const pointsLeft   = p.statPoints;
            const pointsQueued = STAT_NAMES.reduce((a,s) => a + (window._statPending[s]||0), 0);
            const hasChanges   = pointsQueued > 0;
            const allSpent     = pointsLeft === 0;

            const modal = document.createElement('div');
            modal.id = 'levelUpModal';
            modal.style.cssText = `
                position:fixed;top:0;left:0;right:0;bottom:0;
                background:rgba(0,0,0,0.88);z-index:3000;
                display:flex;flex-direction:column;align-items:center;justify-content:flex-start;
                overflow-y:auto;padding:16px 12px 24px;box-sizing:border-box;
            `;

            const affinities = CLASS_AFFINITIES[p.baseClass || p.class] || [];
            let rows = '';
            STAT_NAMES.forEach(s => {
                const isAff  = affinities.includes(s);
                const canUp  = pointsLeft > 0;
                const base   = p[s] || 0;
                const queued = window._statPending[s] || 0;
                rows += `
                <div style="display:flex;align-items:center;gap:8px;padding:8px 0;border-bottom:1px solid #1a4a1a;flex-wrap:wrap;">
                    <span style="min-width:38px;color:${isAff?'#FFD700':'#00FF00'};font-weight:bold;">${STAT_LABELS[s]}</span>
                    <span style="flex:1;min-width:100px;font-size:14px;color:#8aaa8a;">${STAT_DESCS[s]}${isAff?' ★':''}</span>
                    <span style="min-width:28px;text-align:center;color:#FFD700;font-size:22px;">${base}</span>
                    ${queued > 0
                        ? `<span style="color:#00FF00;font-size:16px;min-width:24px;">+${queued}</span>`
                        : `<span style="min-width:24px;"></span>`}
                    <button onclick="_statPend('${s}')" ${canUp?'':'disabled'}
                        style="width:38px;height:38px;padding:0;font-size:22px;font-weight:bold;
                               border-color:${canUp?'#00FF00':'#333'};color:${canUp?'#00FF00':'#333'};">+</button>
                </div>`;
            });

            modal.innerHTML = `
                <div style="width:100%;max-width:480px;">
                    <div style="color:#FFD700;font-size:22px;font-weight:bold;text-align:center;margin-bottom:4px;">
                        ⬆ LEVEL UP! — Now Level ${p.level}
                    </div>
                    <div style="color:#00FF00;font-size:13px;text-align:center;margin-bottom:12px;">
                        HP and MP fully restored.
                    </div>

                    <div style="background:#0a1a0a;border:1px solid ${pointsLeft>0?'#FFD700':'#1a4a1a'};
                                border-radius:6px;padding:8px 12px;margin-bottom:10px;display:flex;align-items:center;gap:10px;">
                        <span style="color:${pointsLeft>0?'#FFD700':'#8aaa8a'};">Points to spend:</span>
                        <span style="font-size:26px;color:${pointsLeft>0?'#fff':'#555'};">${pointsLeft}</span>
                        ${pointsLeft>0 ? '<span style="color:#00FF00;font-size:13px;">— tap + to allocate</span>' : ''}
                        <span style="color:#666;font-size:12px;margin-left:auto;">(★ = class affinity)</span>
                    </div>

                    <div style="background:#050f05;border:1px solid #1a3a1a;border-radius:6px;padding:4px 12px;margin-bottom:12px;">
                        ${rows}
                    </div>

                    <div style="background:#0a0a1a;border:1px solid #1a1a3a;border-radius:6px;
                                padding:8px 12px;font-size:13px;color:#8aaa8a;margin-bottom:14px;">
                        HP ${p.hp}/${p.maxHp} &nbsp;|&nbsp; MP ${p.mp}/${p.maxMp} &nbsp;|&nbsp;
                        Crit ${calcCritChance(p.lck,p)}% &nbsp;|&nbsp; Dodge ${calcDodgeChance(p.dex||0)}%
                    </div>

                    ${allSpent ? `
                        <button onclick="_saveStatChanges(()=>{ document.getElementById('levelUpModal').remove(); })"
                            style="width:100%;font-size:18px;padding:12px;border-color:#FFD700;color:#FFD700;font-weight:bold;margin-bottom:8px;">
                            💾 SAVE &amp; CONTINUE
                        </button>
                    ` : `
                        <button onclick="_saveStatChanges(()=>{ document.getElementById('levelUpModal').remove(); })"
                            style="width:100%;font-size:16px;padding:10px;border-color:#555;color:#555;margin-bottom:8px;"
                            ${hasChanges?'':'disabled'}>
                            💾 SAVE &amp; CONTINUE${pointsLeft>0?' ('+pointsLeft+' unspent)':''}
                        </button>
                    `}
                    <button onclick="document.getElementById('levelUpModal').remove();"
                        style="width:100%;font-size:14px;padding:8px;border-color:#336633;color:#336633;">
                        ✕ CLOSE (spend points later in Character Stats)
                    </button>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function levelUp() {
            const p = gameState.player;
            
            // Cap at level 25
            if (p.level >= 25) {
                p.xp = p.xpToNext; // Pin running total at the max threshold
                return;
            }
            
            const oldLevel = p.level;
            p.level++;
            // XP is now a running total — do NOT subtract xpToNext.
            // Just raise the bar to the next level's cumulative threshold.
            p.xpToNext = getXpToNextLevel(p.baseClass || p.class, p.level);

            // HP/MP increases (CON scaling for HP)
            p.maxHp += 15 + (p.con||0);   // CON scales HP gain
            p.hp     = p.maxHp;
            p.maxMp += 10;
            p.mp     = p.maxMp;
            
            // Legacy stats still auto-increase for backwards compatibility
            p.strength += 2;
            p.defense  += 2;
            p.magic    += 2;
            p.speed    += 1;

            // ═══════════════════════════════════════════════════════════════
            // NEW STAT POINT SYSTEM (3 points per level to allocate)
            // ═══════════════════════════════════════════════════════════════
            if (p.statPoints === undefined) {
                p.statPoints = 0; // Initialize if not present (old saves)
            }
            p.statPoints += 3; // Give 3 stat points per level
            
            // Auto-allocate 1 point to each stat (base progression)
            if (p.str !== undefined) {
                p.str++; p.dex++; p.wis++; p.cha++; p.con++; p.lck++;
                // Paladin bonus: extra +1 to both STR and WIS
                if (p.class === 'paladin' || p.baseClass === 'paladin') { 
                    p.str++; p.wis++; 
                }
            }
            
            // ═══════════════════════════════════════════════════════════════
            // CHECK FOR NEW ZONE DISCOVERY
            // ═══════════════════════════════════════════════════════════════
            Object.keys(LOCATIONS).forEach(key => {
                const loc = LOCATIONS[key];
                if (key !== 'town' && loc.requiredLevel === p.level) {
                    // Just reached the level for this zone!
                    termAppend('', 'term-separator');
                    termAppend(`<span style="color:#00FFFF;font-size:18px;">🗺️ NEW AREA DISCOVERED!</span>`, 'term-victory');
                    termAppend(`<span style="color:#FFD700;">${loc.name} is now visible on the world map!</span>`, 'term-loot');
                    termAppend(`<span style="color:#8aaa8a;">Check "Explore World" to visit this area.</span>`, 'term-dim');
                }
            });
            
            // ═══════════════════════════════════════════════════════════════
            // CHECK FOR CLASS EVOLUTION AT LEVEL 20
            // ═══════════════════════════════════════════════════════════════
            if (p.level === 20 && evolveClass(p)) {
                const evolution = ADVANCED_CLASSES[p.baseClass];
                // Evolution message will be shown in endCombat
                p._justEvolved = true;
                p._evolutionMessage = evolution.announcement;
            }

            // ═══════════════════════════════════════════════════════════════
            // CHRONICLE: unlock entries gated to this level
            // ═══════════════════════════════════════════════════════════════
            unlockChronicleEntries(p);
            
            // Spells are no longer auto-learned - must be purchased at temple!

            // ── If player is in a dungeon, show the level-up stat modal immediately ──
            if (gameState.dungeon && gameState.dungeon.active) {
                // Small delay so the level-up terminal messages render first
                setTimeout(showLevelUpModal, 400);
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // LOOT DROP SYSTEM (Phase 1)
        // ═══════════════════════════════════════════════════════════════

        function rollLoot(monster) {
            const loot = [];
            const debugMode = gameState.sysop && gameState.sysop.authenticated;

            // ── GEM DROP: 3% chance, EVERY enemy, runs before any early return ──
            const gemRoll = Math.random();
            const gemChance = 0.04;
            if (debugMode) termAppend(`<span style="color:#336633;">🎲 [LOOT] ${monster.name} — gem roll: ${(gemRoll*100).toFixed(1)}% (need ≤${(gemChance*100).toFixed(0)}%) → ${gemRoll < gemChance ? '✅ HIT' : '❌ miss'}</span>`, 'term-dim');
            if (gemRoll < gemChance) {
                const tier = getGemTier(monster.level || 1);
                const gemTypeKey = GEM_KEYS[Math.floor(Math.random() * GEM_KEYS.length)];
                loot.push(`raw_${gemTypeKey}_t${tier}`);
                if (debugMode) termAppend(`<span style="color:#336633;">  → 💎 Gem: raw_${gemTypeKey}_t${tier}</span>`, 'term-dim');
            }

            const rarityBonus = RARITY_CONFIG[monster.rarity].dropBonus || 0;
            
            if (!monster.possibleDrops || monster.possibleDrops.length === 0) {
                if (debugMode) termAppend(`<span style="color:#336633;">  → No possibleDrops defined for ${monster.name}</span>`, 'term-dim');
                return loot;
            }
            
            monster.possibleDrops.forEach(itemKey => {
                let dropChance = 0;
                let dropType = 'unknown';
                
                // Determine base drop chance
                if (ITEMS[itemKey]) {
                    dropChance = monster.dropRates.common || 0.3;
                    dropType = 'item';
                } else if (WEAPONS[itemKey] || ARMOR[itemKey]) {
                    const quality = getItemQuality(itemKey);
                    dropChance = monster.dropRates[quality] || 0.05;
                    dropType = WEAPONS[itemKey] ? 'weapon' : 'armor';
                }
                
                const lckBonus = gameState.player ? calcLootBonus(gameState.player.lck || 0) / 100 : 0;
                const adjustedChance = Math.min(0.95, dropChance * (1 + rarityBonus * 0.1 + lckBonus));
                const roll = Math.random();
                const hit  = roll < adjustedChance;
                
                if (debugMode) {
                    const itemLabel = getItemName(itemKey) || itemKey;
                    const lckStr = lckBonus > 0 ? ` lck+${(lckBonus*100).toFixed(1)}%` : '';
                    const rarStr = rarityBonus > 0 ? ` rar+${(rarityBonus*0.1*100).toFixed(1)}%` : '';
                    termAppend(`<span style="color:#336633;">  [${dropType}] ${itemLabel}: roll ${(roll*100).toFixed(1)}% / ${(adjustedChance*100).toFixed(1)}% (base ${(dropChance*100).toFixed(1)}%${rarStr}${lckStr}) → ${hit ? '✅ DROP' : '❌ miss'}</span>`, 'term-dim');
                }

                if (hit) {
                    loot.push(itemKey);
                }
            });
            
            // SPECIAL: Magical Butterknife (Red Dragons only!)
            if (monster.key === 'red_dragon' && Math.random() < 0.000001) {
                loot.push('magical_butterknife');
                if (gameState.sysop && gameState.sysop.authenticated) {
                    terminalPrint('⚠️⚠️⚠️ ULTRA RARE DROP: MAGICAL BUTTERKNIFE! ⚠️⚠️⚠️', 'success');
                }
            }

            return loot;
        }

        function getItemName(itemKey) {
            if (WEAPONS[itemKey]) return WEAPONS[itemKey].name;
            if (ARMOR[itemKey]) return ARMOR[itemKey].name;
            if (ITEMS[itemKey]) return ITEMS[itemKey].name;
            if (SPELLS[itemKey]) return SPELLS[itemKey].name;
            // Cut gems stored as objects in inventory
            if (typeof itemKey === 'object' && itemKey && itemKey.cut) {
                return `${itemKey.name} [${itemKey.description}]`;
            }
            // Fallback for any unrecognized raw gem keys
            if (typeof itemKey === 'string' && itemKey.startsWith('raw_')) {
                const parts = itemKey.split('_');
                const typeKey = parts[1];
                const tier = parts[2] ? parts[2].replace('t','') : '1';
                const gem = GEM_TYPES[typeKey];
                return gem ? `T${tier} Raw ${gem.name}` : itemKey;
            }
            return itemKey;
        }

        function getItemColor(itemKey) {
            if (WEAPONS[itemKey]) {
                return QUALITY_CONFIG[WEAPONS[itemKey].quality].color;
            }
            if (ARMOR[itemKey]) {
                return QUALITY_CONFIG[ARMOR[itemKey].quality].color;
            }
            // Raw gems
            if (typeof itemKey === 'string' && itemKey.startsWith('raw_')) {
                const typeKey = itemKey.split('_')[1];
                return (GEM_TYPES[typeKey] && GEM_TYPES[typeKey].color) || '#AAFFEE';
            }
            // Default green for items
            return '#00FF00';
        }

        function getItemQualityText(itemKey) {
            if (WEAPONS[itemKey]) {
                const quality = WEAPONS[itemKey].quality;
                return `[${QUALITY_CONFIG[quality].name}]`;
            }
            if (ARMOR[itemKey]) {
                const quality = ARMOR[itemKey].quality;
                return `[${QUALITY_CONFIG[quality].name}]`;
            }
            return '';
        }

        function getItemQuality(itemKey) {
            if (WEAPONS[itemKey]) return WEAPONS[itemKey].quality;
            if (ARMOR[itemKey]) return ARMOR[itemKey].quality;
            return 'normal';
        }

        // ═══════════════════════════════════════════════════════════════
        // END LOOT DROP SYSTEM
        // ═══════════════════════════════════════════════════════════════


        function respawn() {
            gameState.player.hp = gameState.player.maxHp;
            gameState.player.mp = gameState.player.maxMp;
            gameState.player.gold = Math.floor(gameState.player.gold / 2);
            gameState.combatState = null;
            showTown();
        }

        // ═══════════════════════════════════════════════════════════════
        // ADVENTURE SYSTEM (Choose-Your-Own-Adventure encounters)
        // ═══════════════════════════════════════════════════════════════
        
        function startAdventure(adventure) {
            gameState.currentAdventure = adventure;
            
            termAppend('', 'term-separator');
            termAppend(`<span style="color:#FFD700;font-size:20px;">✨ ${adventure.name}! ✨</span>`, 'term-highlight');
            termAppend('', 'term-separator');
            termAppend(adventure.intro, 'term-dim');
            termAppend('', 'term-separator');
            termAppend('<span style="color:var(--highlight-color);">What do you do?</span>');
            termAppend('', 'term-separator');
            
            // Show choices
            adventure.choices.forEach((choice, index) => {
                termAppend(`<span style="color:var(--highlight-color);">${index + 1}.</span> ${choice.text}`, 'term-highlight');
            });
            
            // Render adventure action bar
            renderAdventureActionBar();
        }
        
        function renderAdventureActionBar() {
            const adventure = gameState.currentAdventure;
            if (!adventure) return;
            
            const ab = document.getElementById('actionBar');
            ab.style.display = 'flex';
            ab.innerHTML = '';
            
            adventure.choices.forEach((choice, index) => {
                const btn = document.createElement('button');
                btn.textContent = `${index + 1}. ${choice.text.substring(0, 30)}${choice.text.length > 30 ? '...' : ''}`;
                btn.style.fontSize = '12px';
                btn.style.padding = '6px';
                btn.onclick = () => chooseAdventurePath(index);
                ab.appendChild(btn);
            });
        }
        
        function chooseAdventurePath(choiceIndex) {
            const adventure = gameState.currentAdventure;
            if (!adventure) return;
            
            const choice = adventure.choices[choiceIndex];
            
            termAppend('', 'term-separator');
            termAppend(`<span style="color:var(--text-color);">► You choose: ${choice.text}</span>`, 'term-highlight');
            termAppend('', 'term-separator');
            
            // Roll for outcome
            let totalWeight = 0;
            choice.outcomes.forEach(o => totalWeight += o.weight);
            
            let roll = Math.random() * totalWeight;
            let selectedOutcome = choice.outcomes[0];
            
            for (const outcome of choice.outcomes) {
                roll -= outcome.weight;
                if (roll <= 0) {
                    selectedOutcome = outcome;
                    break;
                }
            }
            
            // Show outcome
            termAppend(selectedOutcome.text, 'term-highlight');
            
            // Apply rewards
            if (selectedOutcome.rewards) {
                applyAdventureRewards(selectedOutcome.rewards);
            }
            
            // Start combat if needed
            if (selectedOutcome.combat) {
                termAppend('', 'term-separator');
                gameState.currentAdventure = null;
                startCombat(selectedOutcome.combat);
                return;
            }
            
            // Check if this outcome leads to another choice
            if (selectedOutcome.nextChoices && selectedOutcome.nextChoices.length > 0) {
                // Continue the adventure with new choices
                termAppend('', 'term-separator');
                termAppend('<span style="color:var(--highlight-color);">What do you do?</span>');
                termAppend('', 'term-separator');
                
                // Update adventure choices
                adventure.choices = selectedOutcome.nextChoices;
                
                // Show new choices
                adventure.choices.forEach((choice, index) => {
                    termAppend(`<span style="color:var(--highlight-color);">${index + 1}.</span> ${choice.text}`, 'term-highlight');
                });
                
                // Render new choice buttons
                renderAdventureActionBar();
                return;
            }
            
            // Adventure over, return to exploration
            gameState.currentAdventure = null;
            termAppend('', 'term-separator');
            renderActionBar();
        }
        
        function applyAdventureRewards(rewards) {
            const p = gameState.player;
            
            if (rewards.gold) {
                p.gold = Math.max(0, p.gold + rewards.gold);
                if (rewards.gold > 0) {
                    termAppend(`<span style="color:#FFD700;">💰 +${rewards.gold} Gold!</span>`, 'term-loot');
                } else {
                    termAppend(`<span style="color:#FF6666;">💰 ${rewards.gold} Gold (paid)</span>`, 'term-error');
                }
            }
            
            if (rewards.xp) {
                p.xp += rewards.xp;
                termAppend(`<span style="color:#88FF88;">⭐ +${rewards.xp} XP!</span>`, 'term-loot');
                
                // Check for level up
                while (p.xp >= p.xpToNext && p.level < 25) {
                    levelUp();
                    termAppend(`<span style="color:var(--highlight-color);font-size:18px;">⬆️ LEVEL UP! You are now level ${p.level}!</span>`, 'term-victory');
                    termAppend(`<span style="color:#FFD700;">+3 Stat Points earned!</span>`, 'term-loot');
                    termAppend(`<span style="color:#00FFFF;">→ Tap </span><span style="color:#00FF88;font-weight:bold;">🎒 Inventory</span><span style="color:#00FFFF;"> or the </span><span style="color:#FFD700;font-weight:bold;">⬆ pts</span><span style="color:#00FFFF;"> button to spend them now.</span>`, 'term-loot');
                    
                    // Check for class evolution
                    if (p._justEvolved) {
                        termAppend('', 'term-separator');
                        termAppend(`<span style="color:#FF00FF;font-size:24px;font-weight:bold;">⚡ CLASS EVOLUTION! ⚡</span>`, 'term-victory');
                        termAppend(p._evolutionMessage, 'term-victory');
                        termAppend(`<span style="color:#FFD700;">Your power has DOUBLED!</span>`, 'term-loot');
                        p._justEvolved = false;
                        p._evolutionMessage = null;
                    }
                }
            }
            
            if (rewards.damage) {
                p.hp -= rewards.damage;
                termAppend(`<span style="color:#FF6666;">💔 Took ${rewards.damage} damage!</span>`, 'term-error');
                if (p.hp <= 0) {
                    p.hp = 1; // Can't die from adventure damage
                    termAppend(`<span style="color:#FFAA00;">You barely survive!</span>`, 'term-warning');
                }
            }
            
            if (rewards.heal === 'full') {
                p.hp = p.maxHp;
                p.mp = p.maxMp;
                termAppend(`<span style="color:#00FF00;">✨ Fully restored!</span>`, 'term-victory');
            }
            
            if (rewards.items) {
                rewards.items.forEach(itemKey => {
                    p.inventory.push(itemKey);
                    const item = ITEMS[itemKey] || WEAPONS[itemKey] || ARMOR[itemKey];
                    if (item) {
                        termAppend(`<span style="color:#00FFFF;">🎁 Received: ${item.name}!</span>`, 'term-loot');
                    } else {
                        termAppend(`<span style="color:#00FFFF;">🎁 Received: ${itemKey}!</span>`, 'term-loot');
                    }
                });
            }
            
            if (rewards.spell) {
                if (!p.knownSpells.includes(rewards.spell)) {
                    p.knownSpells.push(rewards.spell);
                    termAppend(`<span style="color:#FF00FF;">📖 Learned spell: ${rewards.spell}!</span>`, 'term-victory');
                }
            }
            
            updateHud();
            saveGame();
        }


        // ═══════════════════════════════════════════════════════════════
        // CHARACTER STATS & STAT ALLOCATION
        // ═══════════════════════════════════════════════════════════════
        
        // ── Shared stat-allocation row builder (used by stats page + level-up modal) ──
        // pending = object tracking how many points queued for each stat this session
        function renderLiveStatRows(p, pending, pointsLeft) {
            const affinities = CLASS_AFFINITIES[p.baseClass || p.class] || [];
            let rows = '';
            STAT_NAMES.forEach(s => {
                const isAff  = affinities.includes(s);
                const canUp  = pointsLeft > 0;
                const base   = p[s] || 0;
                const queued = pending[s] || 0;
                const total  = base + queued;
                rows += `
                <div style="display:flex;align-items:center;gap:8px;padding:7px 0;border-bottom:1px solid #1a4a1a;flex-wrap:wrap;">
                    <span style="min-width:38px;color:${isAff?'var(--highlight-color)':'var(--text-color)'};font-weight:bold;">${STAT_LABELS[s]}</span>
                    <span style="flex:1;min-width:110px;font-size:15px;color:#8aaa8a;">${STAT_DESCS[s]}${isAff?' ★':''}</span>
                    <span style="min-width:28px;text-align:center;color:var(--highlight-color);font-size:22px;">${base}</span>
                    ${queued > 0 ? `<span style="color:#00FF00;font-size:16px;">+${queued}</span>` : '<span style="min-width:20px;"></span>'}
                    <button onclick="_statPend('${s}')" ${canUp?'':'disabled'}
                        style="width:36px;height:36px;padding:0;font-size:22px;font-weight:bold;
                               border-color:${canUp?'var(--text-color)':'#333'};
                               color:${canUp?'var(--text-color)':'#333'};">+</button>
                </div>`;
            });
            return rows;
        }

        // Pending points state (reset each time the stats page / modal opens)
        window._statPending = {};
        window._statPend = function(s) {
            const p = gameState.player;
            if (p.statPoints <= 0) return;
            window._statPending[s] = (window._statPending[s] || 0) + 1;
            p.statPoints--;
            // If in dungeon modal, re-render that; otherwise re-render stats page
            if (document.getElementById('levelUpModal')) {
                _renderLevelUpModal();
            } else {
                showCharacterStats();
            }
        };

        window._saveStatChanges = function(backFn) {
            const p = gameState.player;
            // Apply pending to actual stats
            STAT_NAMES.forEach(s => {
                const gained = window._statPending[s] || 0;
                if (gained > 0) {
                    p[s] = (p[s] || 0) + gained;
                    if (s === 'con') { p.maxHp += gained; p.hp = Math.min(p.hp, p.maxHp); }
                }
            });
            window._statPending = {};
            saveGame();
            if (backFn) backFn();
        };

        function buildCombatRecordHtml(p) {
    const kills      = p.kills || {};
    const killKeys   = Object.keys(kills).filter(k => !k.startsWith('_'));
    const totalKills = killKeys.reduce((s, k) => s + (kills[k] || 0), 0);
    const unique     = killKeys.filter(k => kills[k] > 0).length;
    const bestKey    = killKeys.sort((a, b) => (kills[b] || 0) - (kills[a] || 0))[0];
    const bestName   = bestKey ? (BESTIARY_DATA[bestKey]?.name || bestKey) : '—';
    const bestCount  = bestKey ? (kills[bestKey] || 0) : 0;
    return `
        <div class="message" style="border-color:#330000;margin-top:8px;font-size:15px;">
            <span style="color:#8aaa8a;">COMBAT RECORD</span><br>
            <span style="color:#ff8888;">⚔️ Total Kills: </span>
            <span style="color:#ffffff;font-size:18px;font-weight:bold;">${totalKills.toLocaleString()}</span>
            <span style="color:#8aaa8a;font-size:13px;"> across ${unique} creature type${unique !== 1 ? 's' : ''}</span><br>
            <span style="color:#aaa;font-size:13px;">Most slain: <span style="color:#ffcc88;">${bestName}</span> <span style="color:#888;">(${bestCount.toLocaleString()}×)</span></span>
        </div>`;
}

function showCharacterStats() {
            checkGameVersion();
            const p = gameState.player;
            const screen = document.getElementById('mainScreen');
            if (p.statPoints === undefined) p.statPoints = 0;
            // Reset pending when page first loads (not on re-render from +)
            if (!window._statsPageOpen) {
                window._statPending = {};
                window._statsPageOpen = true;
            }
            const pointsLeft   = p.statPoints;
            const pointsQueued = STAT_NAMES.reduce((a,s) => a + (window._statPending[s]||0), 0);
            const hasChanges   = pointsQueued > 0;

            screen.innerHTML = `
                <div class="location-header">📊 CHARACTER STATS</div>
                <button onclick="window._statsPageOpen=false;showTown();" style="margin-bottom:10px;">← BACK TO TOWN</button>

                <div class="message" style="border-color:${pointsLeft>0||hasChanges?'#FFD700':'var(--border-color)'};">
                    <span style="color:${pointsLeft>0?'#FFD700':'var(--highlight-color)'};">Points to spend: </span>
                    <span style="color:${pointsLeft>0?'var(--text-color)':'#888'};font-size:22px;">${pointsLeft}</span>
                    ${pointsLeft>0 ? '<span style="color:#00FF00;font-size:14px;"> — click + to allocate</span>' : ''}
                    <span style="color:#8aaa8a;font-size:13px;"> (★ = class affinity)</span>
                </div>

                <div style="max-width:520px;margin:0 auto;">
                    ${renderLiveStatRows(p, window._statPending, pointsLeft)}
                </div>

                <div class="message" style="border-color:#005500;margin-top:12px;font-size:15px;">
                    <span style="color:#8aaa8a;">DERIVED STATS</span><br>
                    <span style="color:var(--highlight-color);">Lv ${p.level}</span>
                    <span style="color:#8aaa8a;"> | </span>
                    <span style="color:#ff6666;">HP ${p.hp}/${p.maxHp}</span>
                    <span style="color:#8aaa8a;"> | </span>
                    <span style="color:#6688ff;">MP ${p.mp}/${p.maxMp}</span><br>
                    <span style="color:#aaa;">XP: ${p.xp.toLocaleString()}/${p.xpToNext.toLocaleString()} | Crit: ${calcCritChance(p.lck,p)}% | Dodge: ${calcDodgeChance(p.dex||0)}%</span><br>
                    <span style="color:#ffcc88;">Melee: ${calculatePhysicalDamage()} | Magic: ${calculateMagicDamage()} | Def: ${calculateTotalDefense()}</span>
                </div>

                ${buildCombatRecordHtml(p)}

                ${hasChanges ? `
                    <button onclick="_saveStatChanges(()=>{window._statsPageOpen=false;showCharacterStats();})"
                        style="margin-top:12px;font-size:18px;border-color:#00FF00;color:#00FF00;width:100%;">
                        💾 SAVE CHANGES
                    </button>
                ` : ''}
                <button onclick="window._statsPageOpen=false;showTown();" style="margin-top:8px;">← BACK TO TOWN</button>

                <!-- Chronicle & Bestiary launcher -->
                <button class="chronicle-open-btn" onclick="openChronicle()" id="chronicle-launch-btn">
                    📖 The Chronicle &amp; Bestiary
                    <span class="btn-badge" id="chronicle-launch-badge"></span>
                </button>
            `;
        }
        
        function calculatePhysicalDamage() {
            const p = gameState.player;
            const weapon = WEAPONS[p.weapon] || { baseDamage: 1, quality: 'poor' };
            const qBonus = getQualityBonus(weapon.quality, weapon.baseDamage);
            let weaponDamage = weapon.baseDamage + qBonus;
            if (p.level <= 5) weaponDamage = Math.floor(weaponDamage * 0.7);
            return weaponDamage + (p.str || 0);
        }
        
        function calculateMagicDamage() {
            const p = gameState.player;
            const weapon = WEAPONS[p.weapon] || { baseMagicDamage: 0, baseDamage: 0, quality: 'poor' };
            const qBonus = getQualityBonus(weapon.quality, weapon.baseMagicDamage || 0);
            return (weapon.baseMagicDamage || 0) + qBonus + (p.magic || 0) + (p.wis || 0);
        }
        
        /**
         * Get bonus damage from weapon modifiers for offensive spells
         * Only applies to damage/lifesteal spells, not healing
         */
        function getWeaponModifierSpellBonus() {
            const p = gameState.player;
            if (!p || !p.weapon) return 0;
            
            const weapon = WEAPONS[p.weapon];
            if (!weapon || !weapon.modifiers || weapon.modifiers.length === 0) return 0;
            
            // Check if WEAPON_MODIFIERS is available
            if (typeof WEAPON_MODIFIERS === 'undefined') return 0;
            
            let totalBonus = 0;
            weapon.modifiers.forEach(modKey => {
                const mod = WEAPON_MODIFIERS[modKey];
                if (mod && mod.minDamage) {
                    // Roll for bonus damage (min to max)
                    const bonusDmg = Math.floor(Math.random() * (mod.maxDamage - mod.minDamage + 1)) + mod.minDamage;
                    totalBonus += bonusDmg;
                }
            });
            
            return totalBonus;
        }
        
        function calculateTotalDefense() {
            const p = gameState.player;
            const armor = ARMOR[p.armor] || { baseDefense: 0, quality: 'poor' };
            const qBonus = getQualityBonus(armor.quality, armor.baseDefense);
            return armor.baseDefense + qBonus + (p.con || 0);
        }
        

        

        // ═══════════════════════════════════════════════════════════════
        // BLACKSMITH — Cut gems (200g) and Socket gems (100g)
        // ═══════════════════════════════════════════════════════════════
        function showBlacksmith(subview, subview_target) {
            const p = gameState.player;
            const screen = document.getElementById('mainScreen');
            subview = subview || 'main';

            // ── Helper: find raw gems in inventory ──
            function getRawGems() {
                return (p.inventory || []).filter(k => typeof k === 'string' && k.startsWith('raw_'));
            }
            // ── Helper: find cut gems (objects) in inventory ──
            function getCutGems() {
                return (p.inventory || []).filter(k => typeof k === 'object' && k && k.cut);
            }

            const anvil = `<pre style="color:#cc5500;font-size:9.5px;line-height:1.18;text-align:center;font-family:'Courier New',monospace;">
            ___________________
      _____/                   \_____
     /    /   V A L D R A K ' S \    \
    /    /        F O R G E      \    \
   /    /___________________________\   \
   |   /  .  .  A N V I L  .  .  \   |
   |  /____________________________\  |
   | /  _________________________  \ |
   |/ /  ~~~~~~~ FIRE ~~~~~~~~~~  \ \|
   | |   🔥   🔥   🔥   🔥   🔥  | |
   |_|_________________________________|_|
     |        ⚒️  SMITH  ⚒️           |
     |___________________________________|</pre>`;

            if (subview === 'main') {
                const rawCount = getRawGems().length;
                const cutCount = getCutGems().length;
                screen.innerHTML = `
                    <div class="location-header">⚒️ VALDRAK'S FORGE</div>
                    ${anvil}
                    <div class="message" style="color:#cc7733;font-style:italic;text-align:center;margin-bottom:12px;">
                        "Bring me your rough stones and I'll make them sing."<br>
                        <span style="font-size:11px;color:#664422;">— Valdrak, Master Smith</span>
                    </div>
                    <div style="margin:16px 0;">
                        <div class="menu-option" onclick="showBlacksmith('cut')" style="border-color:#FF7722;">
                            ► 💎 CUT GEMS <span style="color:#888;font-size:12px;">(200g each — ${rawCount} raw gem${rawCount!==1?'s':''} in bag)</span>
                        </div>
                        <div class="menu-option" onclick="showBlacksmith('socket')" style="border-color:#c8a000;">
                            ► ⚙️ SOCKET GEM INTO WEAPON <span style="color:#888;font-size:12px;">(100g — ${cutCount} cut gem${cutCount!==1?'s':''} available)</span>
                        </div>
                        <div class="menu-option" onclick="showBlacksmith('info')" style="border-color:#444;">
                            ► 📖 HOW GEMS WORK
                        </div>
                        <div class="menu-option" onclick="showTown()">← BACK TO TOWN</div>
                    </div>`;
            }

            else if (subview === 'cut') {
                const rawGems = getRawGems();
                if (rawGems.length === 0) {
                    screen.innerHTML = `
                        <div class="location-header">⚒️ CUT GEMS</div>
                        ${anvil}
                        <div class="message" style="color:#888;text-align:center;padding:20px;">
                            You have no raw gems to cut.<br>
                            <span style="font-size:12px;color:#555;">Gems drop from any enemy (4% chance). Keep adventuring!</span>
                        </div>
                        <button onclick="showBlacksmith()" style="margin-top:10px;">← BACK</button>`;
                    return;
                }
                let gemListHtml = rawGems.map(gk => {
                    const parts = gk.split('_');
                    const typeKey = parts[1];
                    const tier = parts[2] ? parseInt(parts[2].replace('t','')) : 1;
                    const gem = GEM_TYPES[typeKey];
                    const canAfford = p.gold >= 200;
                    return `<div style="display:flex;align-items:center;justify-content:space-between;padding:8px 12px;margin:4px 0;border:1px solid ${gem?gem.color:'#444'};background:rgba(0,0,0,0.3);">
                        <span style="color:${gem?gem.color:'#ccc'};">${gem?gem.emoji:'💎'} T${tier} Raw ${gem?gem.name:typeKey} <span style="color:#555;font-size:11px;">${gem?gem.desc:''}</span></span>
                        <button onclick="doCutGem('${gk}')" ${canAfford?'':'disabled title="Not enough gold"'}
                            style="border-color:#FF7722;color:#FF7722;font-size:12px;padding:4px 10px;">CUT (200g)</button>
                    </div>`;
                }).join('');
                screen.innerHTML = `
                    <div class="location-header">⚒️ CUT GEMS — ${p.gold}g</div>
                    ${anvil}
                    <div class="message" style="color:#888;font-size:12px;text-align:center;">
                        Cutting reveals a gem's permanent stats at random. Stats cannot be rerolled.
                    </div>
                    <div style="margin:10px 0;">${gemListHtml}</div>
                    <button onclick="showBlacksmith()" style="margin-top:8px;">← BACK</button>`;
            }

            else if (subview === 'socket') {
                const socketTarget = subview_target || 'weapon'; // 'weapon' or 'armor'
                const weapon = p.weapon ? WEAPONS[p.weapon] : null;
                const armor  = p.armor  ? ARMOR[p.armor]   : null;
                const cutGems = getCutGems();

                // Build item card HTML for weapon or armor
                function itemSocketCard(item, itemName, isArmor) {
                    if (!item) return `<div style="color:#555;font-size:13px;padding:8px;">No ${isArmor?'armor':'weapon'} equipped.</div>`;
                    const slots    = getGemSlots(item.quality);
                    const usedSlots = (item.gems || []).length;
                    const openSlots = slots - usedSlots;
                    const slotsHtml = slots === 0
                        ? `<span style="color:#555;font-size:11px;">No gem slots (need rare+ quality drop)</span>`
                        : Array.from({length:slots}).map((_,i) => {
                            const g = (item.gems||[])[i];
                            return g
                                ? `<span style="color:${g.color};">${g.emoji} ${g.name} [${g.description}]</span>`
                                : `<span style="color:#444;">[ OPEN SLOT ]</span>`;
                          }).join('<br>');
                    const active = socketTarget === (isArmor?'armor':'weapon');
                    return `<div style="padding:10px 16px;border:2px solid ${active?'#c8a000':'#333'};margin:6px 0;cursor:pointer;"
                                onclick="showBlacksmith('socket','${isArmor?'armor':'weapon'}')">
                        <div style="color:#ccc;font-size:13px;margin-bottom:2px;">${isArmor?'🛡️':'⚔️'} ${item.name} <span style="color:#888;font-size:11px;">[${item.quality}]</span></div>
                        <div style="font-size:12px;color:#888;">Slots: ${usedSlots}/${slots} used</div>
                        <div style="margin-top:4px;font-size:12px;">${slotsHtml}</div>
                    </div>`;
                }

                const activeItem = socketTarget === 'armor' ? armor : weapon;
                const activeSlots = activeItem ? getGemSlots(activeItem.quality) : 0;
                const activeUsed  = activeItem ? (activeItem.gems||[]).length : 0;
                const openSlots   = activeSlots - activeUsed;

                if (cutGems.length === 0) {
                    screen.innerHTML = `<div class="location-header">⚒️ SOCKET GEM</div>${anvil}
                        <div class="message" style="color:#888;text-align:center;padding:20px;">
                            You have no cut gems to socket.<br>
                            <span style="font-size:12px;">Cut a raw gem first at the forge.</span>
                        </div>
                        <button onclick="showBlacksmith()">← BACK</button>`;
                    return;
                }

                const gemButtons = (activeItem && openSlots > 0) ? cutGems.map((g,idx) =>
                    `<div style="display:flex;align-items:center;justify-content:space-between;padding:8px 12px;margin:4px 0;border:1px solid ${g.color};background:rgba(0,0,0,0.3);">
                        <span style="color:${g.color};">${g.emoji} ${g.name}<br><span style="color:#888;font-size:11px;">${g.description}</span></span>
                        <button onclick="doSocketGem(${idx},'${socketTarget}')" ${p.gold>=100?'':'disabled title="Need 100g"'}
                            style="border-color:#c8a000;color:#c8a000;font-size:12px;padding:4px 10px;">SOCKET (100g)</button>
                    </div>`).join('')
                : `<div style="color:#888;text-align:center;padding:10px;">${activeItem && activeSlots===0 ? 'Equipped item has no gem slots.' : 'No open slots — gems are permanent once socketed.'}</div>`;

                screen.innerHTML = `
                    <div class="location-header">⚒️ SOCKET GEM — ${p.gold}g</div>
                    ${anvil}
                    <div style="color:#aaa;font-size:12px;margin:4px 0 2px;">Select item to socket into:</div>
                    ${itemSocketCard(weapon, weapon?.name, false)}
                    ${itemSocketCard(armor,  armor?.name,  true)}
                    <div style="margin-top:10px;color:#aaa;font-size:12px;text-align:center;">⚠️ Socketed gems are permanent and cannot be removed.</div>
                    <div style="margin:8px 0;">${gemButtons}</div>
                    <button onclick="showBlacksmith()" style="margin-top:8px;">← BACK</button>`;
            }

            else if (subview === 'info') {
                screen.innerHTML = `
                    <div class="location-header">⚒️ HOW GEMS WORK</div>
                    ${anvil}
                    <div class="message" style="font-size:13px;line-height:1.6;">
                        <p><strong style="color:#FF7722;">Finding Gems</strong><br>
                        Raw gems have a <strong>4% drop chance</strong> from any enemy. Enemy level determines gem tier:<br>
                        Lv1-6 = Tier 1 &nbsp;|&nbsp; Lv7-12 = Tier 2 &nbsp;|&nbsp; Lv13-18 = Tier 3 &nbsp;|&nbsp; Lv19+ = Tier 4</p>
                        <p><strong style="color:#c8a000;">Cutting (200g)</strong><br>
                        Cutting a raw gem gives it permanent random stats. Higher tier gems roll stronger bonuses. Stats cannot be rerolled — choose wisely.</p>
                        <p><strong style="color:#00FF88;">Socketing (100g)</strong><br>
                        Socket a cut gem into your equipped weapon or armor. Once socketed, a gem <strong>cannot be removed or replaced</strong>.</p>
                        <p><strong style="color:#AA88FF;">Gem Slots by Quality (Weapons &amp; Armor)</strong><br>
                        Rare: 1 slot &nbsp;|&nbsp; Epic: 2 slots &nbsp;|&nbsp; Legendary: 3 slots &nbsp;|&nbsp; Godly: 4 slots<br>
                        <span style="color:#555;font-size:11px;">Only dropped gear has gem slots — shop gear does not.</span></p>
                        <p><strong style="color:#FF6688;">Gem Colors — Original</strong><br>
                        🔴 Ruby: Weapon DMG + Lifesteal &nbsp;|&nbsp; 🔵 Sapphire: Spell Power + MP<br>
                        🟡 Topaz: Crit + Lightning &nbsp;|&nbsp; 🟢 Emerald: Poison + STR<br>
                        🟣 Amethyst: Defense + HP &nbsp;|&nbsp; ⬛ Onyx: Armor Pierce + Speed<br>
                        🔷 Opal: Luck + Gold Find &nbsp;|&nbsp; 🟤 Garnet: STR + CON</p>
                        <p><strong style="color:#FF6688;">Gem Colors — Rare</strong><br>
                        🩸 Bloodstone: Max HP + HP Regen per turn<br>
                        🌙 Moonstone: MP Regen per turn + Cooldown reduction<br>
                        ☀️ Sunstone: Fire DMG + STR (works on spells)<br>
                        🔮 Voidstone: Spell Leech → absorbs MP + WIS<br>
                        🩶 Ironheart: Defense + CON<br>
                        ⛈️ Stormglass: Lightning DMG + Frost DMG (both elements, both damage types)</p>
                        <p style="color:#888;font-size:11px;">Lightning, Fire, Frost, Poison all apply to both melee and spells.<br>
                        Weapon DMG (Ruby) is melee only. Spell Power (Sapphire) is spells only.<br>
                        Lifesteal (Ruby) works on both melee and spells.</p>
                    </div>
                    <button onclick="showBlacksmith()">← BACK</button>`;
            }
        }

        function doCutGem(rawGemKey) {
            const p = gameState.player;
            if (p.gold < 200) { alert("You need 200 gold to cut a gem."); return; }
            const idx = p.inventory.indexOf(rawGemKey);
            if (idx < 0) { alert("Gem not found in inventory."); return; }
            p.gold -= 200;
            p.inventory.splice(idx, 1);
            const cut = cutGem(rawGemKey);
            if (!cut) { alert("Could not cut gem — unknown type."); p.gold += 200; return; }
            p.inventory.push(cut);
            saveGame();
            const parts = rawGemKey.split('_');
            const typeKey = parts[1];
            const gem = GEM_TYPES[typeKey];
            // Show result flash
            const flash = document.createElement('div');
            flash.style.cssText = `position:fixed;top:15px;left:50%;transform:translateX(-50%);background:#0a0a0a;border:2px solid ${gem?gem.color:'#FF7722'};padding:14px 24px;color:${gem?gem.color:'#FF7722'};font-size:15px;z-index:9999;text-align:center;max-width:340px;`;
            flash.innerHTML = `⚒️ <strong>Gem Cut!</strong><br><span style="font-size:12px;color:#ccc;">${cut.name}<br>${cut.description}</span>`;
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 3500);
            showBlacksmith('cut');
        }

        function doSocketGem(cutGemInventoryIndex, target) {
            const p = gameState.player;
            if (p.gold < 100) { alert("You need 100 gold to socket a gem."); return; }
            const isArmor = target === 'armor';
            const item = isArmor
                ? (p.armor ? ARMOR[p.armor] : null)
                : (p.weapon ? WEAPONS[p.weapon] : null);
            const itemLabel = isArmor ? 'armor' : 'weapon';
            if (!item) { alert(`No ${itemLabel} equipped.`); return; }
            if (!item.gems) item.gems = [];
            const slots = getGemSlots(item.quality);
            if (item.gems.length >= slots) { alert(`No open slots on this ${itemLabel}.`); return; }
            const cutGems = p.inventory.filter(k => typeof k === 'object' && k && k.cut);
            const gem = cutGems[cutGemInventoryIndex];
            if (!gem) { alert("Gem not found."); return; }
            const invIdx = p.inventory.indexOf(gem);
            if (invIdx < 0) { alert("Gem not in inventory."); return; }
            if (!confirm(`Socket ${gem.name} into ${item.name}? This is permanent and cannot be undone.`)) return;
            p.gold -= 100;
            p.inventory.splice(invIdx, 1);
            item.gems.push(gem);
            saveGame();
            const flash = document.createElement('div');
            flash.style.cssText = `position:fixed;top:15px;left:50%;transform:translateX(-50%);background:#0a0a0a;border:2px solid ${gem.color};padding:14px 24px;color:${gem.color};font-size:15px;z-index:9999;text-align:center;max-width:340px;`;
            flash.innerHTML = `⚙️ <strong>Gem Socketed!</strong><br><span style="font-size:12px;color:#ccc;">${gem.name} fused into ${item.name} permanently.</span>`;
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 3500);
            showBlacksmith('socket', target);
        }

        // ═══════════════════════════════════════════════════════════════
        // TEMPLE OF REBIRTH (Stat Reset)
        // ═══════════════════════════════════════════════════════════════
        
        function showTemple() {
            checkGameVersion();
            const p = gameState.player;
            const screen = document.getElementById('mainScreen');
            
            // Calculate total stat points that have been allocated
            const totalAllocated = calculateTotalAllocatedPoints();
            const respecCost = calculateRespecCost(p.level);
            
            screen.innerHTML = `
                <div class="location-header">⛪ TEMPLE</div>
                <button onclick="showTown()" style="margin-bottom:10px;">← BACK TO TOWN</button>
                ${renderPlayerStats()}
                
                <div class="message">
                    <p style="color:var(--highlight-color);font-size:16px;">
                        <strong>Welcome to the Temple</strong>
                    </p>
                    <p>
                        Here, the priests offer spiritual services: ${(p.baseClass || p.class) === 'hunter' ? 'pet training,' : ''} spell training${(p.baseClass || p.class) === 'hunter' ? ',' : ''} and personal rebirth.
                    </p>
                </div>
                
                <div style="margin: 20px 0;">
                    ${(p.baseClass || p.class) === 'hunter' ? '<div class="menu-option" onclick="showPetTrainer()">🐺 PET TRAINING</div>' : ''}
                    <div class="menu-option" onclick="showSpellShop()">📖 SPELL TRAINING</div>
                    <div class="menu-option" onclick="showRespec()">🔄 STAT RESPEC (${respecCost}g)</div>
                    <button onclick="showTown()">← BACK TO TOWN</button>
                </div>
            `;
        }
        
        function showRespec() {
            const p = gameState.player;
            const screen = document.getElementById('mainScreen');
            
            const totalAllocated = calculateTotalAllocatedPoints();
            const respecCost = calculateRespecCost(p.level);
            
            screen.innerHTML = `
                <div class="location-header">🔄 STAT RESPEC</div>
                <button onclick="showTemple()" style="margin-bottom:10px;">← BACK</button>
                ${renderPlayerStats()}
                
                <div class="message" style="border-color:#8aaa8a;">
                    <p>Refund all allocated stat points to rebuild your character.</p>
                </div>
                
                <div class="message" style="border-color:#FFD700;">
                    <h3 style="color:#FFD700;">Respec Info</h3>
                    <p><span class="stat-label">Level:</span> ${p.level}</p>
                    <p><span class="stat-label">Allocated:</span> ${totalAllocated}</p>
                    <p><span class="stat-label">Available:</span> ${p.statPoints || 0}</p>
                    <p><span class="stat-label">Cost:</span> <span style="color:#FFD700;">${respecCost}g</span></p>
                </div>
                
                <div class="message" style="border-color:var(--error-color);">
                    <p style="color:var(--error-color);"><strong>⚠️ Warning:</strong> This resets ALL stat points.</p>
                </div>
                
                <div style="margin: 20px 0;">
                    ${p.gold >= respecCost ? `<button onclick="confirmRespec()" style="border-color:#FFD700;">💰 RESPEC (${respecCost}g)</button>` : `<button disabled>Need ${respecCost - p.gold}g more</button>`}
                    <button onclick="showTemple()">← BACK</button>
                </div>
            `;
        }
        
        function calculateTotalAllocatedPoints() {
            const p = gameState.player;
            // Each level gives 3 points, so total available = level * 3
            const totalAvailable = (p.level - 1) * 3; // -1 because level 1 has no points yet
            const remaining = p.statPoints || 0;
            return totalAvailable - remaining;
        }
        
        function calculateRespecCost(level) {
            // Cost scales with level: 1000g per level
            return level * 1000;
        }
        
        function confirmRespec() {
            const p = gameState.player;
            const cost = calculateRespecCost(p.level);
            
            if (p.gold < cost) {
                alert('Not enough gold!');
                return;
            }
            
            if (!confirm(`Are you sure you want to respec for ${cost} gold? This will refund all your allocated stat points.`)) {
                return;
            }
            
            performRespec();
        }
        
        function performRespec() {
            const p = gameState.player;
            const cost = calculateRespecCost(p.level);
            
            // Deduct gold
            p.gold -= cost;
            
            // Calculate how many points were manually allocated
            const totalLevelPoints = (p.level - 1) * 3;
            
            // Reset stats to base (level 1 + auto-gains)
            // Auto-gains: +1 to each stat per level (except paladin gets +2 str/wis)
            const baseLevels = p.level - 1; // Levels gained beyond 1
            
            p.str = 10 + baseLevels; // Base 10 + 1 per level
            p.dex = 10 + baseLevels;
            p.wis = 10 + baseLevels;
            p.cha = 10 + baseLevels;
            p.con = 10 + baseLevels;
            p.lck = 10 + baseLevels;
            
            // Paladin bonus (gets extra str/wis each level)
            if (p.class === 'paladin' || p.baseClass === 'paladin') {
                p.str += baseLevels;
                p.wis += baseLevels;
            }
            
            // Refund all allocated points
            p.statPoints = totalLevelPoints;
            
            // Recalculate HP based on new CON
            p.maxHp = 100 + (p.level - 1) * 15 + ((p.level - 1) * (p.con - 10)); // Base + level gains + con bonus
            p.hp = Math.min(p.hp, p.maxHp);
            
            saveGame();
            
            alert(`Respec complete! You have ${p.statPoints} stat points to reallocate.`);
            showCharacterStats();
        }
        
        // ═══════════════════════════════════════════════════════════════
        // SPELL SHOP - Temple Spell Training
        // ═══════════════════════════════════════════════════════════════
        
        function showSpellShop() {
            const p = gameState.player;
            const screen = document.getElementById('mainScreen');
            
            // Get class spell tree
            const classKey = p.baseClass || p.class;
            const spellTree = CLASS_SPELL_TREES[classKey];
            
            if (!spellTree) {
                screen.innerHTML = `
                    <div class="location-header">📖 SPELL TRAINING</div>
                    ${renderPlayerStats()}
                    <div class="message" style="border-color:var(--error-color);">
                        <p>Your class (${classKey}) does not have spell training available.</p>
                    </div>
                    <button onclick="showTemple()">← BACK TO TEMPLE</button>
                `;
                return;
            }
            
            // Build spell lists
            const availableSpells = [];   // can learn now
            const upcomingSpells  = [];   // locked by level (but prereq met or no prereq)
            const currentSpells   = [];   // already known

            Object.entries(spellTree.spellTree).forEach(([key, spell]) => {
                const hasSpell       = p.knownSpells.includes(key);
                const levelReq       = p.level >= spell.level;
                const meetsReq       = !spell.requires || p.knownSpells.includes(spell.requires);
                const canAfford      = p.gold >= spell.cost;

                // Check if this spell has already been superseded — i.e. the player knows
                // a spell that lists this one as its 'requires' (meaning they skipped past it).
                const alreadySuperseded = Object.values(spellTree.spellTree).some(
                    s => s.requires === key && p.knownSpells.includes(s.requires === key ? s.requires : null)
                ) || p.knownSpells.some(known => {
                    const knownSpell = spellTree.spellTree[known];
                    return knownSpell && knownSpell.requires === key;
                });

                if (hasSpell) {
                    currentSpells.push({ key, spell });
                } else if (!alreadySuperseded && levelReq && meetsReq) {
                    availableSpells.push({ key, spell, canAfford });
                } else if (!hasSpell && !levelReq && meetsReq && !alreadySuperseded) {
                    // Coming soon — player hasn't reached the level yet
                    upcomingSpells.push({ key, spell });
                }
            });
            
            let html = `
                <div class="location-header">📖 SPELL TRAINING</div>
                <button onclick="showTemple()" style="margin-bottom:10px;">← BACK</button>
                ${renderPlayerStats()}
                
                <div class="message">
                    <p style="color:var(--highlight-color);"><strong>The priests offer to teach you the sacred arts</strong></p>
                    <p style="color:#8aaa8a;">Learn new spells or upgrade existing ones</p>
                </div>
            `;
            
            // Show current spells
            if (currentSpells.length > 0) {
                html += `<div class="message" style="border-color:#00FF00;"><h3 style="color:#00FF00;">Your Known Spells</h3>`;
                currentSpells.forEach(({ key, spell }) => {
                    const typeColor = spell.type === 'heal' || spell.type === 'lifesteal' ? '#00FF00' : '#FF6666';
                    const typeIcon = spell.type === 'heal' ? '💚' : spell.type === 'lifesteal' ? '🩸' : spell.type === 'aoe_damage' ? '🔥' : '💥';
                    const lifestealInfo = spell.lifestealPercent ? ` (${spell.lifestealPercent}%)` : '';
                    const aoeTag = spell.type === 'aoe_damage' ? ' <span style="color:#FF8800;">[AOE]</span>' : '';
                    const powerDisplay = spell.minPower !== undefined ? `${spell.minPower}–${spell.maxPower}` : '?';
                    html += `<p>${typeIcon} <strong>${spell.name}${aoeTag}</strong> - <span style="color:${typeColor};">${powerDisplay} ${spell.type === 'heal' ? 'HP' : 'DMG'}${lifestealInfo}</span> (${spell.mpCost} MP)${spell.upgradesTo ? `<br><span style="color:#FFD700;font-size:12px;">→ Upgrade available</span>` : ''}</p>`;
                });
                html += `</div>`;
            }
            
            // Show available spells
            if (availableSpells.length > 0) {
                html += `<div class="message" style="border-color:#FFD700;"><h3 style="color:#FFD700;">Available Training</h3>`;
                availableSpells.forEach(({ key, spell, canAfford }) => {
                    const typeColor = spell.type === 'heal' || spell.type === 'lifesteal' ? '#00FF00' : '#FF6666';
                    const typeIcon = spell.type === 'heal' ? '💚' : spell.type === 'lifesteal' ? '🩸' : spell.type === 'aoe_damage' ? '🔥' : '💥';
                    const lifestealInfo = spell.lifestealPercent ? ` (${spell.lifestealPercent}% lifesteal)` : '';
                    const aoeTag = spell.type === 'aoe_damage' ? ' <span style="color:#FF8800;">[AOE]</span>' : '';
                    const isUpgrade = spell.requires && p.knownSpells.includes(spell.requires);
                    
                    const powerDisplay2 = spell.minPower !== undefined ? `${spell.minPower}–${spell.maxPower}` : '?';
                    html += `<div style="margin:10px 0;padding:10px;border:1px solid ${canAfford ? '#FFD700' : '#666'};"><p>${typeIcon} <strong style="color:${typeColor};">${spell.name}${aoeTag}</strong> ${isUpgrade ? '(Upgrade)' : '(New)'}<br><span style="font-size:12px;">${spell.description}</span><br><span style="color:${typeColor};">${powerDisplay2} ${spell.type === 'heal' ? 'HP' : 'DMG'}${lifestealInfo}</span> | ${spell.mpCost} MP | Level ${spell.level}<br><span style="color:#FFD700;">Cost: ${spell.cost}g</span></p>${canAfford ? `<button onclick="learnSpell('${key}')" style="border-color:#FFD700;">💰 Learn (${spell.cost}g)</button>` : `<button disabled style="opacity:0.5;">Need ${spell.cost - p.gold}g more</button>`}</div>`;
                });
                html += `</div>`;
            } else {
                html += `<div class="message"><p style="color:#888;">No new spells available at your level.</p></div>`;
            }

            // Show upcoming locked spells
            if (upcomingSpells.length > 0) {
                html += `<div class="message" style="border-color:#444;"><h3 style="color:#888;">Coming Soon</h3>`;
                upcomingSpells.forEach(({ key, spell }) => {
                    const typeIcon = spell.type === 'heal' ? '💚' : spell.type === 'lifesteal' ? '🩸' : spell.type === 'aoe_damage' ? '🔥' : '💥';
                    const aoeTag = spell.type === 'aoe_damage' ? ' <span style="color:#664400;">[AOE]</span>' : '';
                    html += `<div style="margin:8px 0;padding:8px;border:1px solid #333;opacity:0.6;">
                        <p>${typeIcon} <strong style="color:#666;">${spell.name}${aoeTag}</strong> — Unlocks at <span style="color:#888;">Level ${spell.level}</span><br>
                        <span style="font-size:12px;color:#555;">${spell.description}</span><br>
                        <span style="color:#666;">${spell.mpCost} MP | Cost: ${spell.cost}g</span></p>
                    </div>`;
                });
                html += `</div>`;
            }
            
            html += `<button onclick="showTemple()">← BACK</button>`;
            screen.innerHTML = html;
        }
        
        function learnSpell(spellKey) {
            const p = gameState.player;
            const classKey = p.baseClass || p.class;
            const spell = CLASS_SPELL_TREES[classKey].spellTree[spellKey];
            
            if (!spell || p.gold < spell.cost || p.level < spell.level) {
                alert('Cannot learn this spell!');
                return;
            }
            
            if (spell.requires && !p.knownSpells.includes(spell.requires)) {
                alert('Learn previous spell first!');
                return;
            }
            
            p.gold -= spell.cost;
            
            // Remove old spell if upgrade
            if (spell.requires) {
                const idx = p.knownSpells.indexOf(spell.requires);
                if (idx > -1) p.knownSpells.splice(idx, 1);
            }
            
            p.knownSpells.push(spellKey);
            
            // Add to SPELLS if not present
            if (!SPELLS[spellKey]) {
                SPELLS[spellKey] = { ...spell, pipCost: 1 };
            }

            // ── Enforce slot order after every learn ───────────────────────
            // Slot 1 = single-target (damage / heal for healers)
            // Slot 2 = AOE (heal for healers)
            // Rule: for healer classes damage goes first, for others single-target damage first, AOE second
            const healerClasses = ['cleric','priest','paladin','shaman'];
            const isHealer = healerClasses.includes(classKey);

            p.knownSpells.sort((a, b) => {
                const sa = SPELLS[a] || CLASS_SPELL_TREES[classKey]?.spellTree?.[a];
                const sb = SPELLS[b] || CLASS_SPELL_TREES[classKey]?.spellTree?.[b];
                if (!sa || !sb) return 0;
                function rank(s) {
                    if (isHealer) {
                        // healers: damage=0 (slot1), heal=1 (slot2), aoe=2
                        if (s.type === 'damage') return 0;
                        if (s.type === 'heal' || s.type === 'lifesteal') return 1;
                        if (s.type === 'aoe_damage') return 2;
                        return 3;
                    } else {
                        // mages/others: single-target damage=0 (slot1), aoe=1 (slot2), heal=2
                        if (s.type === 'damage') return 0;
                        if (s.type === 'aoe_damage') return 1;
                        if (s.type === 'heal' || s.type === 'lifesteal') return 2;
                        return 3;
                    }
                }
                return rank(sa) - rank(sb);
            });
            
            saveGame();
            alert(`Learned ${spell.name}!`);
            showSpellShop();
        }
        
        // ═══════════════════════════════════════════════════════════════
        // PET TRAINER (Hunter Only)
        // ═══════════════════════════════════════════════════════════════
        
        function showPetTrainer() {
            const p = gameState.player;
            const screen = document.getElementById('mainScreen');
            
            if ((p.baseClass || p.class) !== 'hunter') {
                screen.innerHTML = `
                    <div class="location-header">🐺 PET TRAINING</div>
                    ${renderPlayerStats()}
                    <div class="message" style="border-color:var(--error-color);">
                        <p>The beast trainer shakes their head. "Only hunters may bond with beasts."</p>
                    </div>
                    <button onclick="showTemple()">← BACK TO TEMPLE</button>
                `;
                return;
            }
            
            // Determine current and next pet
            const currentPet = p.activePet ? HUNTER_PETS[p.activePet] : null;
            const nextPetKey = currentPet?.upgradesTo || (p.level >= 3 ? 'hunting_dog' : null);
            const nextPet = nextPetKey ? HUNTER_PETS[nextPetKey] : null;
            
            let html = `
                <div class="location-header">🐺 PET TRAINING</div>
                <button onclick="showTemple()" style="margin-bottom:10px;">← BACK</button>
                ${renderPlayerStats()}
                
                <div class="message">
                    <p style="color:var(--highlight-color);"><strong>The Beast Trainer greets you with a pack of loyal companions</strong></p>
                    <p style="color:#8aaa8a;">Bond with a beast to fight alongside you in battle</p>
                </div>
            `;
            
            // Show current pet
            if (currentPet) {
                html += `
                    <div class="message" style="border-color:#00FF00;">
                        <h3 style="color:#00FF00;">Your Current Companion</h3>
                        <p>${currentPet.icon} <strong style="color:#00FF00;">${currentPet.name}</strong> (Level ${currentPet.level})</p>
                        <p style="font-size:14px;color:#8aaa8a;">${currentPet.description}</p>
                        <p><span style="color:#FFD700;">Damage:</span> ${Math.floor(currentPet.damagePercent * 100)}% of weapon damage + ${currentPet.bonusDamage}</p>
                        ${currentPet.upgradesTo ? '<p style="color:#FFD700;font-size:12px;">→ Upgrade available!</p>' : '<p style="color:#888;">Max level companion</p>'}
                    </div>
                `;
            } else {
                html += `
                    <div class="message" style="border-color:#666;">
                        <p style="color:#888;">You don't have a companion yet.</p>
                        ${p.level >= 3 ? '<p style="color:#FFD700;">You can bond with your first pet!</p>' : `<p style="color:#888;">Reach level 3 to bond with a pet.</p>`}
                    </div>
                `;
            }
            
            // Show available upgrade
            if (nextPet && p.level >= nextPet.level) {
                const canAfford = p.gold >= nextPet.cost;
                html += `
                    <div class="message" style="border-color:#FFD700;">
                        <h3 style="color:#FFD700;">${currentPet ? 'Available Upgrade' : 'First Companion'}</h3>
                        <div style="margin:10px 0;padding:10px;border:1px solid ${canAfford ? '#FFD700' : '#666'};">
                            <p>${nextPet.icon} <strong style="color:#FFD700;">${nextPet.name}</strong> ${currentPet ? '(Upgrade)' : '(Bond)'}</p>
                            <p style="font-size:12px;color:#8aaa8a;">${nextPet.description}</p>
                            <p><span style="color:#FFD700;">Damage:</span> ${Math.floor(nextPet.damagePercent * 100)}% of weapon damage + ${nextPet.bonusDamage}</p>
                            <p style="font-size:12px;">Requires Level ${nextPet.level} | Cost: <span style="color:#FFD700;">${nextPet.cost}g</span></p>
                            ${canAfford 
                                ? `<button onclick="upgradePet('${nextPetKey}')" style="border-color:#FFD700;">💰 ${currentPet ? 'Upgrade' : 'Bond'} (${nextPet.cost}g)</button>`
                                : `<button disabled style="opacity:0.5;">Need ${nextPet.cost - p.gold}g more</button>`
                            }
                        </div>
                    </div>
                `;
            } else if (nextPet) {
                html += `
                    <div class="message" style="border-color:#444;">
                        <h3 style="color:#888;">Coming Soon</h3>
                        <div style="margin:8px 0;padding:8px;border:1px solid #333;opacity:0.6;">
                            <p>${nextPet.icon} <strong style="color:#666;">${nextPet.name}</strong> — Unlocks at Level ${nextPet.level}</p>
                            <p style="font-size:12px;color:#555;">${nextPet.description}</p>
                            <p style="color:#666;">${Math.floor(nextPet.damagePercent * 100)}% weapon damage + ${nextPet.bonusDamage} | Cost: ${nextPet.cost}g</p>
                        </div>
                    </div>
                `;
            }
            
            // Show pet progression path
            html += `
                <div class="message" style="border-color:#444;">
                    <h3 style="color:#8aaa8a;">Companion Progression</h3>
                    <p style="font-size:12px;color:#666;">
                        Lv 3: 🐕 Dog (35%) → Lv 6: 🐺 Wolf (40%) → Lv 9: 🐺 Dire Wolf (45%) → <br>
                        Lv 12: 👻🐕 Shadow Hound (50%) → Lv 15: 🐺 Warg (55%) → <br>
                        Lv 18: 🔥🐕 Hellhound (60%) → Lv 21: 🌙🐺 Fenrir (70%)
                    </p>
                </div>
            `;
            
            html += `<button onclick="showTemple()">← BACK</button>`;
            screen.innerHTML = html;
        }
        
        function upgradePet(petKey) {
            const p = gameState.player;
            const pet = HUNTER_PETS[petKey];
            
            if (!pet || p.gold < pet.cost || p.level < pet.level) {
                alert('Cannot bond with this companion!');
                return;
            }
            
            // Deduct gold and set new pet
            p.gold -= pet.cost;
            p.activePet = petKey;
            
            saveGame();
            alert(`${pet.icon} You bonded with ${pet.name}! They will fight by your side!`);
            showPetTrainer();
        }


        // Start the game
        
        // Load all class spells from CLASS_SPELL_TREES
        if (typeof CLASS_SPELL_TREES !== 'undefined') {
            loadAllClassSpells();
        }
        
        checkGameVersion();
        initGame();



    </script>
<!-- ═══════════════════════════════════════════════════════════════════
     CHRONICLE & BESTIARY OVERLAY
     Full-screen parchment overlay. Opened from character stats screen.
     ═══════════════════════════════════════════════════════════════════ -->
<div id="chronicle-overlay" role="dialog" aria-modal="true" aria-label="The Chronicle">

  <div class="chronicle-book">

    <!-- Header -->
    <div class="chronicle-header">
      <div>
        <div class="chronicle-title">📖 The Chronicle</div>
        <div class="chronicle-subtitle" id="chronicle-header-sub">The world remembers everything.</div>
      </div>
      <button class="chronicle-close" onclick="closeChronicle()" title="Close">✕</button>
    </div>

    <!-- Tab bar -->
    <div class="chronicle-tabs">
      <button class="chronicle-tab active" id="tab-chronicle"
              onclick="switchChronicleTab('chronicle')">
        Chronicle
        <span class="tab-badge" id="chronicle-badge"></span>
      </button>
      <button class="chronicle-tab" id="tab-bestiary"
              onclick="switchChronicleTab('bestiary')">
        Bestiary
        <span class="tab-badge" id="bestiary-badge"></span>
      </button>
    </div>

    <!-- Scrollable body — hosts both panels, only one shown at a time -->
    <div class="chronicle-body" id="chronicle-body">

      <!-- ── CHRONICLE PANEL ── -->
      <div id="panel-chronicle">
        <!-- Entry list (index view) -->
        <div class="chronicle-entry-list" id="chronicle-entry-list"></div>
        <!-- Entry reader (reading view, hidden until an entry is clicked) -->
        <div class="chronicle-reader" id="chronicle-reader">
          <div class="chronicle-reader-back" onclick="closeChronicleReader()">
            ← Back to all entries
          </div>
          <div class="chronicle-page" id="chronicle-page-content"></div>
          <div class="chronicle-page-nav">
            <button class="chronicle-nav-btn" id="chron-prev" onclick="navigateChronicle(-1)">← Previous</button>
            <span id="chron-page-num" style="color:#5a4020;font-size:13px;align-self:center;"></span>
            <button class="chronicle-nav-btn" id="chron-next" onclick="navigateChronicle(1)">Next →</button>
          </div>
        </div>
      </div>

      <!-- ── BESTIARY PANEL (hidden by default) ── -->
      <div id="panel-bestiary" style="display:none;">
        <!-- Monster list -->
        <div id="bestiary-list"></div>
        <!-- Monster detail (hidden until a monster is clicked) -->
        <div class="chronicle-reader" id="bestiary-reader">
          <div class="chronicle-reader-back" onclick="closeBestiaryReader()">
            ← Back to bestiary
          </div>
          <div class="bestiary-detail" id="bestiary-detail-content"></div>
        </div>
      </div>

    </div>
  </div>
</div>


<!-- ═══════════════════════════════════════════════════════════════════
     WELCOME / INTRO SCREEN
     Shown once after a brand-new character is created.
     ═══════════════════════════════════════════════════════════════════ -->
<div id="welcome-overlay">
  <div class="welcome-scroll">

    <div class="welcome-header">
      <span class="welcome-dragon-icon">🐉</span>
      <div class="welcome-title">The Age of Calamity Begins</div>
      <div class="welcome-name" id="welcome-char-name"></div>
      <div class="welcome-class" id="welcome-char-class"></div>
    </div>

    <div class="welcome-body" id="welcome-body"></div>

    <div class="welcome-footer">
      <button class="welcome-skip" onclick="skipWelcome()">[ skip ]</button>
      <button class="welcome-begin-btn" id="welcome-begin-btn" onclick="beginAdventure()">
        Begin Your Adventure →
      </button>
    </div>

  </div>
</div>


<!-- ═══════════════════════════════════════════════════════════════════
     LEVEL-UP FLASH + ANNOUNCEMENT
     ═══════════════════════════════════════════════════════════════════ -->
<div id="levelup-flash"></div>
<div id="levelup-announce">
  <div class="levelup-burst" id="levelup-burst">
    <div class="levelup-stars">✦ ✦ ✦</div>
    <div class="levelup-headline">Level Up</div>
    <div class="levelup-number" id="levelup-num">2</div>
    <div class="levelup-subtitle" id="levelup-sub">The journey continues</div>
  </div>
</div>

</body>
</html>