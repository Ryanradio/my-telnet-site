<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
   <!-- PWA: standalone mode removes browser chrome on iOS/Android -->
   <meta name="apple-mobile-web-app-capable" content="yes">
   <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
   <meta name="apple-mobile-web-app-title" content="Dungeon Quest">
   <meta name="mobile-web-app-capable" content="yes">
   <meta name="theme-color" content="#000000">

    <title>âš”ï¸ DUNGEON QUEST  âš”ï¸</title>
   
   
   <style>




    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ GLOBAL LAYOUT FIX (PUT THIS FIRST) â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
*,
*::before,
*::after {
    box-sizing: border-box;
}

html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    /* let each child manage its own overflow */
}

body {
    -webkit-user-select: none;
    user-select: none;
    touch-action: manipulation;
}

/* â”€â”€ Menu container (town/shop) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#menuContainer {
    height: 100%;
    height: 100dvh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    max-width: 900px;
    margin: 0 auto;
}

/* â”€â”€ Gameplay wrapper â€” full viewport, column flex â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#gameWrapper {
    position: fixed;
    inset: 0;
    display: none;
    flex-direction: column;
    overflow: hidden;
    padding-bottom: env(safe-area-inset-bottom, 0px);
    box-sizing: border-box;
    /* â”€â”€ Desktop: cap width, centre, add side backdrop â”€â”€ */
    background: #000;
}

/* Desktop: constrain play area to readable column */
@media (min-width: 769px) {
    #gameWrapper {
        /* Dark backdrop fills full viewport, game column sits centred */
        background: #050505;
    }
    #gameWrapper > * {
        /* All direct children get the same max-width and centring */
        max-width: 820px;
        width: 100%;
        margin-left: auto;
        margin-right: auto;
        box-sizing: border-box;
    }
    /* Terminal itself also needs width constraint but stretches vertically */
    #terminalWindow {
        max-width: 820px !important;
    }
    /* HUD strip: same max-width, let it sit at bottom */
    #hud {
        max-width: 820px !important;
    }
    /* Status bars: same max-width */
    #statusBars {
        max-width: 820px !important;
    }
    /* Desktop: taller action bar buttons, easier mouse click */
    #actionBar button { min-height: 48px !important; font-size: 22px !important; }
    .action-icon-btn  { min-height: 48px !important; font-size: 24px !important; }
}

/* Shown in terminal mode */
body.terminal-mode #gameWrapper {
    display: flex;
}

/* â”€â”€ Desktop HUD (top) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#hud {
    flex: 0 0 auto;
    display: none;
}
body.terminal-mode #hud {
    display: block;
    order: 3;   /* terminal=1, statusBars=2, hud=3, actionBar=4 */
}

/* â”€â”€ Mobile HUD text strip â€” hidden in terminal mode (bars replace it) */
#mobileHud {
    display: none;
    flex: 0 0 auto;
    box-sizing: border-box;
    order: 2;
}

/* â”€â”€ Legacy bottomHud â€” always hidden â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#bottomHud { display: none !important; }

/* â”€â”€ Terminal â€” takes ALL leftover space, scrolls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#terminalWindow {
    flex: 1 1 0;
    min-height: 0;
    overflow-y: scroll;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior-y: contain;
    display: none;
    order: 1;
}
body.terminal-mode #terminalWindow { display: block; }

/* â”€â”€ Action bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#actionBar {
    flex: 0 0 auto;
    display: none;
    overflow: visible;
    box-sizing: border-box;
    order: 4;
    padding: 4px;
    /* safe area handled by XP bar below â€” just normal padding here */
    padding-bottom: 4px;
}
body.terminal-mode #actionBar { display: block; }

/* default button sizing */
#actionBar button {
    min-width: 0;
    min-height: 44px;       /* taller â€” easier to tap/click */
    border-radius: 5px;
    font-size: 20px;
}

/* â”€â”€ Status bars (HP/MP/XP) â€” sits just below terminal, above action bar â”€â”€ */
#statusBars {
    flex: 0 0 auto;
    display: none;
    order: 2;
    padding: 0;
    box-sizing: border-box;
    background: #000;
}
body.terminal-mode #statusBars { display: block; }

/* HP + MP side-by-side row */
#sbHpMpRow {
    display: flex;
    height: 7px;
    gap: 2px;
    padding: 0 2px;
}

/* HP track */
#sbHpTrack {
    flex: 1;
    background: #1a0000;
    border-radius: 2px;
    overflow: hidden;
    position: relative;
}
#sbHpFill {
    height: 100%;
    background: linear-gradient(90deg, #cc0000, #ff3333);
    box-shadow: 0 0 4px #ff0000, 0 0 8px rgba(255,0,0,0.4);
    transition: width 0.4s ease;
    border-radius: 2px;
}

/* MP track */
#sbMpTrack {
    flex: 1;
    background: #00001a;
    border-radius: 2px;
    overflow: hidden;
}
#sbMpFill {
    height: 100%;
    background: linear-gradient(90deg, #0044cc, #4499ff);
    box-shadow: 0 0 4px #0066ff, 0 0 8px rgba(0,102,255,0.4);
    transition: width 0.4s ease;
    border-radius: 2px;
    animation: mpPulse 3s ease-in-out infinite;
}
@keyframes mpPulse {
    0%, 100% { opacity: 1; }
    50%       { opacity: 0.75; }
}
@keyframes runeOverloadPulse {
    0%   { border-color:#FF4400; box-shadow:0 0 6px #FF4400, 0 0 14px #FF8800; }
    50%  { border-color:#FFaa00; box-shadow:0 0 14px #FF8800, 0 0 28px #FFaa00; }
    100% { border-color:#FF4400; box-shadow:0 0 6px #FF4400, 0 0 14px #FF8800; }
}
@keyframes hpLowPulse {
    0%, 100% { opacity: 1;    box-shadow: 0 0 6px #ff0000, 0 0 12px rgba(255,0,0,0.6); }
    50%       { opacity: 0.6; box-shadow: 0 0 2px #ff0000; }
}

/* XP bar wrapper â€” pinned below action bar, very bottom of screen */
#sbXpBar {
    flex: 0 0 auto;
    display: none;
    order: 5;   /* below actionBar (order:4) */
    padding: 0;
    box-sizing: border-box;
    background: #000;
    /* safe area for iPhone home indicator sits BELOW the XP bar */
    padding-bottom: env(safe-area-inset-bottom, 0px);
}
body.terminal-mode #sbXpBar { display: block; }

/* XP track â€” full width, doubled height */
#sbXpTrack {
    height: 8px;
    background: #0d0d00;
    margin: 0;
    border-radius: 0;
    overflow: hidden;
}
#sbXpFill {
    height: 100%;
    background: linear-gradient(90deg, #886600, #ffdd00);
    box-shadow: 0 0 4px #ffaa00, 0 0 8px #cc8800;
    transition: width 0.5s ease;
    border-radius: 0;
}

        @import url('https://fonts.googleapis.com/css2?family=VT323&family=Press+Start+2P&display=swap');

        :root {
            --primary-bg: #000080;
            --secondary-bg: #000000;
            --text-color: #00FF00;
            --highlight-color: #FFFF00;
            --error-color: #FF0000;
            --border-color: #00FFFF;
            --menu-color: #FFFFFF;
        }

        body {
            background: var(--primary-bg);
            color: var(--text-color);
            font-family: 'VT323', monospace;
            font-size: 20px;
            line-height: 1.4;
        }

        .scanline {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                transparent 50%,
                rgba(0, 0, 0, 0.25) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 1000;
            animation: flicker 0.15s infinite;
        }

        @keyframes flicker {
            0% { opacity: 0.95; }
            50% { opacity: 1; }
            100% { opacity: 0.95; }
        }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }

        @keyframes flashRed {
            0%, 100% { color: #FF8C00; text-shadow: 0 0 6px #FF8C00; }
            50%      { color: #FFD700; text-shadow: 0 0 14px #FFD700; }
        }

        @keyframes flashOrange {
            0%, 100% { color: #FF0000; text-shadow: 0 0 6px #FF0000; }
            50%      { color: #FF4444; text-shadow: 0 0 14px #FF4444; }
        }

        .dmg-player {
            animation: flashOrange 0.6s ease-in-out infinite;
            font-weight: bold;
        }

        .dmg-enemy {
            animation: flashRed 0.6s ease-in-out infinite;
            font-weight: bold;
        }

     .container {
    height: 100%;
    max-width: 900px;
    margin: 0 auto;
    padding: 0;
    display: flex;
    flex-direction: column;
    overflow: hidden; /* prevent container overflow */
}


        .header {
            flex-shrink: 0; /* prevent header from shrinking */
            text-align: center;
            border: 3px double var(--border-color);
            padding: 8px;
            margin-bottom: 8px;
            background: var(--secondary-bg);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .header h1 {
            font-family: 'Press Start 2P', monospace;
            font-size: 20px;
            color: var(--highlight-color);
            text-shadow: 2px 2px var(--error-color);
            margin-bottom: 5px;
            animation: titlePulse 2s infinite;
            transition: all 0.3s ease;
        }
        
        .header p {
            margin: 0;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        /* Compact header during gameplay */
        body.terminal-mode .header {
            padding: 4px;
            margin-bottom: 4px;
            border-width: 2px;
        }
        
        body.terminal-mode .header h1 {
            font-size: 12px;
            margin-bottom: 2px;
            animation: none; /* disable pulse during gameplay */
        }
        
        body.terminal-mode .header > div {
            display: none; /* hide decorative lines and subtitle */
        }

        @keyframes titlePulse {
            0%, 100% { text-shadow: 2px 2px var(--error-color); }
            50% { text-shadow: 2px 2px var(--error-color), 0 0 10px var(--highlight-color); }
        }
        
        @keyframes flash-green {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3) hue-rotate(10deg); }
        }
        
        @keyframes flash-blue {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2) hue-rotate(-20deg); }
        }

        /* â”€â”€â”€ LOW HP heartbeat border on terminal â”€â”€â”€ */
        /* Two quick beats then a long pause â€” like a real heartbeat */
        @keyframes heartbeat-border {
            0%   { box-shadow: inset 0 0 40px rgba(0,255,0,0.07), 0 0 0px rgba(255,0,0,0);   border-color: var(--border-color); }
            6%   { box-shadow: inset 0 0 40px rgba(0,255,0,0.07), 0 0 18px rgba(255,0,0,0.9); border-color: #ff2222; }
            12%  { box-shadow: inset 0 0 40px rgba(0,255,0,0.07), 0 0 4px  rgba(255,0,0,0.3); border-color: #881111; }
            18%  { box-shadow: inset 0 0 40px rgba(0,255,0,0.07), 0 0 18px rgba(255,0,0,0.9); border-color: #ff2222; }
            30%  { box-shadow: inset 0 0 40px rgba(0,255,0,0.07), 0 0 0px  rgba(255,0,0,0);   border-color: var(--border-color); }
            100% { box-shadow: inset 0 0 40px rgba(0,255,0,0.07), 0 0 0px  rgba(255,0,0,0);   border-color: var(--border-color); }
        }

        #terminalWindow.danger-heartbeat {
            animation: heartbeat-border 1.4s ease-in-out infinite;
            border-color: #881111;
        }

        /* â”€â”€â”€ main screen used by town / shop / menus â”€â”€â”€ */
        .screen {
            flex: 1 1 auto; /* allow screen to grow/shrink */
            min-height: 0; /* critical for flex scrolling */
            overflow-y: auto; /* enable scrolling */
            -webkit-overflow-scrolling: touch; /* smooth scrolling on iOS */
            
            background: var(--secondary-bg);
            border: 2px solid var(--border-color);
            padding: 12px;
            margin-bottom: 8px;
            box-shadow: inset 0 0 50px rgba(0, 255, 0, 0.1);
        }
        
        .menu-option {
            color: var(--menu-color);
            cursor: pointer;
            padding: 8px;
            margin: 5px 0;
            transition: all 0.1s;
        }
        .menu-option:hover {
            background: var(--primary-bg);
            color: var(--highlight-color);
            padding-left: 20px;
        }
        .menu-option.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            color: #666;
        }
        .menu-option.disabled:hover {
            background: transparent;
            padding-left: 8px;
        }

        /* â”€â”€â”€ desktop HUD visual styles â”€â”€â”€ */
#hud {
    background: var(--secondary-bg);
    border: 2px solid var(--border-color);
    border-bottom: none;
    padding: 6px 10px;
    box-shadow: inset 0 0 30px rgba(0,255,0,0.08);
}

        /* mobileHud text spans â€” hidden in terminal mode, bars take over */
#mobileHud span { display: none; }

/* Hide XP and gold on very narrow screens â€” bars show it visually */
@media (max-width: 420px) {
    #mobileHud .mhud-xp   { display: none !important; }
    #mobileHud .mhud-gold { display: none !important; }
}

/* â”€â”€â”€ Desktop HUD: compact strip in terminal-mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
body.terminal-mode #hud {
    padding: 3px 10px !important;
    border-width: 1px !important;
    border-top: 1px solid #1a3a1a !important;
    border-bottom: none !important;
    box-shadow: none !important;
    background: #050a05 !important;
}
body.terminal-mode .hud-inner {
    display: flex !important;
    flex-wrap: nowrap;
    align-items: center;
    gap: 10px;
    justify-content: flex-start;
}
body.terminal-mode #hudName {
    font-size: 14px !important;
    color: var(--highlight-color) !important;
    white-space: nowrap;
    overflow: visible;
    max-width: 280px;
    flex-shrink: 1;
}
body.terminal-mode .hud-stats {
    display: flex !important;
    flex-wrap: nowrap;
    gap: 12px;
    font-size: 14px !important;
    align-items: center;
    flex: 1;
}
body.terminal-mode .hud-stats span {
    white-space: nowrap;
    font-size: 14px !important;
}
/* On mobile the desktop HUD is hidden â€” mobileHud takes over */
@media (max-width: 768px) {
    body.terminal-mode #hud { display: none !important; }
}


        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 4px;
        }
        .hud-top .hud-name { color: var(--highlight-color); font-size: 18px; }
        .hud-top .hud-gold { color: #FFD700; font-size: 16px; }
        .hud-bars {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }
        .hud-bar-group label {
            color: var(--highlight-color);
            font-size: 14px;
            display: block;
            margin-bottom: 2px;
        }
        .hud-bar-group .bar-nums { color: var(--text-color); font-size: 14px; }
        .progress-bar {
            width: 100%;
            height: 12px;
            background: #111;
            border: 1px solid var(--border-color);
            margin-top: 2px;
        }
        .progress-fill { height: 100%; transition: width 0.35s ease; }
        .hp-bar { background: var(--error-color); }
        .mp-bar { background: #4488ff; }
        .xp-bar { background: var(--text-color); }

        /* â”€â”€â”€ scrolling terminal visual styles â”€â”€â”€ */
#terminalWindow {
    background: var(--secondary-bg);
    border: 2px solid var(--border-color);
    border-top: 1px solid #333;
    padding: 8px 10px;
    box-shadow: inset 0 0 40px rgba(0,255,0,0.07);
    /* NOTE: no scroll-behavior:smooth â€” it fights with programmatic scrollTop on mobile */
}

        .term-line {
            padding: 2px 0;
            font-size: 16px;
            color: var(--text-color);
            line-height: 1.3;
        }
        .term-line.term-dim       { color: #3a7a3a; }
        .term-line.term-highlight { color: var(--highlight-color); }
        .term-line.term-enemy     { color: var(--border-color); font-size: 17px; }
        .term-line.term-loot      { font-size: 17px; }
        .term-line.term-system    { color: #888; font-style: italic; }
        .term-line.term-separator { margin-top: 6px; padding-top: 6px; border-top: 1px solid #2a4a2a; }

        /* â”€â”€â”€ action bar visual styles â”€â”€â”€ */
#actionBar {
    background: var(--secondary-bg);
    border-top: 2px solid var(--border-color);
    padding: 5px 6px;
    gap: 4px;
}


        #actionBar button {
            background: linear-gradient(180deg, #1a1a1a 0%, #0a0a0a 100%);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            padding: 6px 8px;
            font-family: 'VT323', monospace;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.15s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            min-width: 0;
            min-height: 0;
            box-sizing: border-box;
        }
        
        /* Combat action buttons â€” one tight row */
        .action-icon-btn {
            flex: 1 1 0;
            min-width: 0 !important;
            padding: 6px 4px !important;
            text-align: center;
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
        }
        
        /* Target selection buttons */
        .target-btn {
            flex: 1 1 0;
            min-width: 0 !important;
            padding: 6px 5px !important;
            background: linear-gradient(180deg, #0a2a0a 0%, #051505 100%) !important;
            border-color: var(--text-color) !important;
        }
        
        .target-btn:hover:not(:disabled) {
            background: linear-gradient(180deg, #0f3f0f 0%, #0a2a0a 100%) !important;
            border-color: var(--highlight-color) !important;
            color: var(--highlight-color) !important;
        }
        
        /* Spell selection buttons */
        .spell-btn {
            flex: 1 1 0;
            min-width: 0 !important;
            padding: 6px 4px !important;
            background: linear-gradient(180deg, #1a1a2a 0%, #0a0a15 100%) !important;
            border-color: #4488ff !important;
            font-size: 13px;
            line-height: 1.2;
        }
        
        .spell-btn:hover:not(:disabled) {
            background: linear-gradient(180deg, #2a2a4a 0%, #1a1a2a 100%) !important;
            border-color: #88bbff !important;
            color: #88bbff !important;
        }

        /* â”€â”€ PIP COOLDOWN SWEEP (Diablo/WoW style) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .pip-btn {
            position: relative;
            overflow: hidden;
            isolation: isolate;
        }
        .pip-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            background: conic-gradient(
                rgba(0,255,136,0.25) var(--pip-pct, 0%),
                transparent           var(--pip-pct, 0%)
            );
            pointer-events: none;
            z-index: 1;
            transition: none;
        }
        .pip-btn > *, .pip-btn span { position: relative; z-index: 2; }
        .pip-btn.cooling {
            border-color: #ff8c00 !important;
            box-shadow: 0 0 8px rgba(255,140,0,0.35) !important;
        }
        .pip-btn.all-ready {
            border-color: #00ff88 !important;
            box-shadow: 0 0 10px rgba(0,255,136,0.5) !important;
        }
        .pip-badge {
            position: absolute;
            top: 2px; right: 4px;
            font-size: 10px; line-height: 1;
            color: #ff8c00;
            z-index: 3;
            pointer-events: none;
        }

        #actionBar button:hover {
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
            color: var(--highlight-color);
            border-color: var(--highlight-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 255, 0, 0.3);
        }
        #actionBar button:active {
            transform: translateY(0);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.8);
        }
        #actionBar button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }



        .term-line.term-victory   { color: var(--border-color); font-size: 22px; }
        .term-line.term-loot      { color: #FFD700; }
        .term-line.term-error     { color: var(--error-color); }
        .term-line.term-separator { border-top: 1px solid #2a5a2a; margin: 6px 0 4px; padding-top: 4px; }
        .enemy-card {
            border: 2px solid var(--error-color);
            padding: 8px 12px;
            margin: 6px 0;
            background: rgba(255,0,0,0.05);
            display: inline-block;
            min-width: 260px;
            vertical-align: top;
        }
        .enemy-card.is-target { border-color: var(--highlight-color); }
        .enemy-card .ec-name  { font-size: 21px; margin-bottom: 4px; }
        .enemy-card .ec-hp    { font-size: 18px; color: var(--text-color); }

   
   
/* stale actionBar block removed */





        #actionBar .action-label { color: var(--highlight-color); font-size: 18px; margin-bottom: 6px; }
        #actionBar .timer-line   { color: var(--highlight-color); font-size: 19px; margin-bottom: 4px; }

        /* â”€â”€â”€ legacy helpers for shop / inventory / town â”€â”€â”€ */
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid var(--border-color);
            background: rgba(0,128,0,0.1);
        }
        .stat       { color: var(--text-color); }
        .stat-label { color: var(--highlight-color); }
        .message {
            padding: 10px;
            margin: 10px 0;
            border-left: 3px solid var(--border-color);
        }
        .combat-message  { color: var(--highlight-color); font-weight: bold; }
        .error-message   { color: var(--error-color); }
        .success-message { color: var(--border-color); }

        button {
            background: var(--secondary-bg);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            padding: 10px 20px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) {
            background: var(--primary-bg);
            color: var(--highlight-color);
            box-shadow: 0 0 10px var(--border-color);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        input {
            background: var(--secondary-bg);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            padding: 10px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            width: 100%;
            margin: 10px 0;
        }

        .character-select {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .class-card {
            border: 2px solid var(--border-color);
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--secondary-bg);
        }

        .class-card:hover {
            background: var(--primary-bg);
            box-shadow: 0 0 15px var(--border-color);
            transform: scale(1.05);
        }

        .class-card.selected {
            border-color: var(--highlight-color);
            background: var(--primary-bg);
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .item-card {
            border: 1px solid var(--border-color);
            padding: 10px;
            background: rgba(0, 128, 0, 0.05);
        }

        .equipped {
            border-color: var(--highlight-color);
            background: rgba(255, 255, 0, 0.1);
        }

        .cursor {
            display: inline-block;
            width: 10px;
            height: 20px;
            background: var(--text-color);
            animation: blink 1s infinite;
            margin-left: 5px;
        }

        .location-header {
            font-family: 'Press Start 2P', monospace;
            font-size: 16px;
            color: var(--border-color);
            text-align: center;
            padding: 10px;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: 15px;
        }

        .enemy-display {
            text-align: center;
            padding: 20px;
            border: 2px solid var(--error-color);
            margin: 15px 0;
            background: rgba(255, 0, 0, 0.05);
        }

        .ascii-art {
            font-family: monospace;
            font-size: 14px;
            line-height: 1.2;
            white-space: pre;
            color: var(--text-color);
        }

        /* SYSOP Terminal Styles */
        .terminal-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--secondary-bg);
            border-top: 3px solid var(--error-color);
            padding: 10px 20px;
            z-index: 999;
            max-height: 300px;
            overflow-y: auto;
            display: none;
            box-shadow: 0 -5px 20px rgba(255, 0, 0, 0.5);
        }

        .terminal-container.active {
            display: block;
            animation: terminalSlideUp 0.3s;
        }

        @keyframes terminalSlideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        .terminal-header {
            color: var(--error-color);
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            margin-bottom: 10px;
            text-align: center;
            border-bottom: 1px solid var(--error-color);
            padding-bottom: 5px;
        }

        .terminal-output {
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
            color: var(--text-color);
        }

        .terminal-line {
            margin: 3px 0;
        }

        .terminal-error {
            color: var(--error-color);
        }

        .terminal-success {
            color: var(--border-color);
        }

        .terminal-warning {
            color: var(--highlight-color);
        }

        .terminal-input-line {
            display: flex;
            align-items: center;
        }

        .terminal-prompt {
            color: var(--error-color);
            margin-right: 10px;
        }

        .terminal-input {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--text-color);
            font-family: 'VT323', monospace;
            font-size: 20px;
            outline: none;
        }

        .sysop-badge {
            position: fixed;
            top: 10px;
            right: 10px;
            background: var(--error-color);
            color: var(--secondary-bg);
            padding: 5px 10px;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            border: 2px solid var(--highlight-color);
            z-index: 998;
            display: none;
            animation: badgePulse 2s infinite;
        }

        .sysop-badge.active {
            display: block;
        }

        @keyframes badgePulse {
            0%, 100% { box-shadow: 0 0 5px var(--error-color); }
            50% { box-shadow: 0 0 20px var(--error-color); }
        }

        /* quit button is now a plain .menu-option */

        /* â”€â”€â”€ Full-screen SYSOP Overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        #sysopOverlay {
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 2000;
            display: none;
            flex-direction: column;
            overflow: hidden;
            height: 100%;
            width: 100%;
        }
        #sysopOverlay.open { display: flex; }

        /* Sticky header â€” never scrolls away */
        #sysopOverlayHeader {
            flex: 0 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 2px solid #ff4444;
            padding: 8px 12px;
            background: #000;
        }

        /* Scrollable content area â€” gets all remaining height */
        #sysopOverlayInner {
            flex: 1 1 0;
            min-height: 0;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 10px 12px 30px;
        }

        /* .syo-header replaced by #sysopOverlayHeader (fixed, outside scroll) */
        .syo-title {
            color: #ff4444;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            letter-spacing: 1px;
        }
        .syo-close {
            background: none;
            border: 1px solid #ff4444;
            color: #ff4444;
            font-family: 'VT323', monospace;
            font-size: 20px;
            padding: 2px 10px;
            cursor: pointer;
        }

        /* Output log */
        .syo-log {
            background: #050505;
            border: 1px solid #1a3a1a;
            color: #00FF41;
            font-family: 'VT323', monospace;
            font-size: 15px;
            padding: 6px 8px;
            max-height: 100px;
            overflow-y: auto;
            margin-bottom: 10px;
            white-space: pre-wrap;
            line-height: 1.3;
        }

        /* Section */
        .syo-section { margin-bottom: 12px; }
        .syo-section-title {
            color: #ff8c00;
            font-family: 'Press Start 2P', monospace;
            font-size: 9px;
            letter-spacing: 1px;
            margin-bottom: 6px;
            padding-bottom: 3px;
            border-bottom: 1px solid #2a2a00;
        }

        /* Button grid */
        .syo-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        .syo-grid.cols3 { grid-template-columns: 1fr 1fr 1fr; }
        .syo-btn {
            background: #050505;
            border: 1px solid #2a4a2a;
            color: #00FF41;
            font-family: 'VT323', monospace;
            font-size: 18px;
            padding: 10px 6px;
            cursor: pointer;
            text-align: center;
            transition: background 0.1s;
        }
        .syo-btn:active  { background: #0a1a0a; }
        .syo-btn.red     { border-color:#ff4444; color:#ff4444; }
        .syo-btn.orange  { border-color:#ff8c00; color:#ff8c00; }
        .syo-btn.yellow  { border-color:#FFD700; color:#FFD700; }
        .syo-btn.full    { grid-column: 1 / -1; }

        /* Sub form */
        .syo-sub {
            border: 1px solid #1a3a1a;
            padding: 10px;
            margin-top: 8px;
            background: #020a02;
        }
        .syo-sub-title {
            color: #00FF41;
            font-size: 13px;
            margin-bottom: 6px;
            font-family: 'VT323', monospace;
        }
        .syo-label {
            color: #5a8a5a;
            font-family: 'VT323', monospace;
            font-size: 15px;
            margin: 4px 0 2px;
        }
        .syo-input {
            width: 100%;
            background: #000;
            border: 1px solid #2a4a2a;
            color: #00FF41;
            font-family: 'VT323', monospace;
            font-size: 20px;
            padding: 6px 8px;
            box-sizing: border-box;
            margin-bottom: 6px;
            outline: none;
        }
        .syo-input:focus { border-color: #00FF41; }
        select.syo-input { font-size: 16px; }

        /* â”€â”€ Sysop list panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .syo-list-panel {
            border: 1px solid #1a3a1a;
            background: #020a02;
            margin-top: 8px;
        }
        .syo-list-search {
            display: flex;
            gap: 6px;
            padding: 8px 8px 0;
        }
        .syo-list-search input {
            flex: 1;
            background: #000;
            border: 1px solid #00FF41;
            color: #00FF41;
            font-family: 'VT323', monospace;
            font-size: 20px;
            padding: 4px 8px;
            outline: none;
        }
        .syo-list-body {
            max-height: 340px;
            overflow-y: auto;
            padding: 6px 8px 10px;
        }
        .syo-list-row {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 5px 4px;
            border-bottom: 1px solid #0d1f0d;
            cursor: pointer;
            transition: background 0.1s;
        }
        .syo-list-row:hover { background: #0a1a0a; }
        .syo-list-key {
            color: #ff8c00;
            font-family: 'VT323', monospace;
            font-size: 14px;
            min-width: 140px;
            word-break: break-all;
        }
        .syo-list-name {
            color: #00FF41;
            font-family: 'VT323', monospace;
            font-size: 16px;
            flex: 1;
        }
        .syo-list-meta {
            color: #5a8a5a;
            font-family: 'VT323', monospace;
            font-size: 14px;
            text-align: right;
            min-width: 80px;
        }
        .syo-list-count {
            color: #5a8a5a;
            font-family: 'VT323', monospace;
            font-size: 13px;
            padding: 4px 8px 0;
        }

        /* Login form */
        .syo-login-art {
            color: #ff4444;
            font-family: 'Press Start 2P', monospace;
            font-size: 9px;
            text-align: center;
            line-height: 1.6;
            margin: 10px 0 14px;
            letter-spacing: 1px;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1001;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: var(--secondary-bg);
            border: 3px solid var(--error-color);
            padding: 20px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 30px var(--error-color);
        }


        .action-icon-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 2px solid var(--border-color);
            background: var(--secondary-bg);
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .action-icon-btn:hover:not(:disabled) {
            background: var(--primary-bg);
            border-color: var(--highlight-color);
            transform: scale(1.05);
        }
        
        .action-icon-btn:active:not(:disabled) {
            transform: scale(0.95);
        }
        
        .action-icon-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RESPONSIVE â€” mobile first, clean
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        /* All phones/tablets â‰¤768px */
        @media (max-width: 768px) {
            body { font-size: 15px; }

            /* Menu screen */
            #menuContainer { padding: 4px; }
            .header { padding: 5px 6px; margin-bottom: 3px; }
            .header h1 { font-size: 15px; margin-bottom: 2px; }
            .screen { padding: 8px; }

            /* Desktop HUD: hidden on mobile â€” status bars replace it */
            body.terminal-mode #hud { display: none !important; }

            /* Terminal: smallest still-readable text, maximise screen space */
            #terminalWindow { padding: 3px 5px; }
            .term-line { font-size: 13px; line-height: 1.2; margin: 0; padding: 0; }

            /* Action bar â€” taller buttons on mobile for easier tapping */
            #actionBar { padding: 4px 3px 2px; }
            #actionBar button { font-size: 18px; padding: 6px 7px; min-height: 46px; border-radius: 5px; }
            .action-icon-btn { font-size: 20px; padding: 6px 6px !important; min-height: 46px; }
            .spell-btn  { font-size: 12px; padding: 4px 5px !important; }
            .target-btn { font-size: 13px; padding: 5px 6px !important; }

            /* Status bars â€” slightly taller on small screens for visibility */
            #sbHpMpRow { height: 8px; }
            #sbXpTrack { height: 5px; }

            /* Other UI */
            .menu-option { padding: 8px; font-size: 16px; margin: 4px 0; }
            button { padding: 7px 10px; font-size: 14px; margin: 3px 1px; }
            .character-select { grid-template-columns: 1fr; gap: 8px; }
            .inventory-grid { grid-template-columns: repeat(2, 1fr); gap: 6px; }
            .item-card { padding: 6px; font-size: 13px; }
            .ascii-art { font-size: 9px; line-height: 1.1; }
        }

        /* Very small phones â‰¤390px */
        @media (max-width: 390px) {
            .term-line { font-size: 12px; line-height: 1.15; }
            #actionBar { padding: 3px 2px 1px; }
            #actionBar button { font-size: 17px; padding: 5px 5px; min-height: 42px; }
            .action-icon-btn { font-size: 19px; padding: 5px 4px !important; min-height: 42px; }
        }

        /* Landscape tablets */
        @media (min-width: 769px) and (max-width: 1024px) {
            #menuContainer { max-width: 95%; padding: 12px; }
            .character-select { grid-template-columns: repeat(2, 1fr); }
            .inventory-grid { grid-template-columns: repeat(3, 1fr); }
        }

        /* â”€â”€ Keyboard shortcut hints on action buttons (desktop only) â”€â”€ */
        .kb-hint {
            display: none;  /* hidden by default, shown on desktop below */
            position: absolute;
            bottom: 2px;
            right: 3px;
            font-size: 9px;
            line-height: 1;
            color: #556655;
            font-family: monospace;
            pointer-events: none;
            z-index: 3;
        }
        /* Show hints on devices with a real pointer (desktop) */
        @media (hover: hover) and (pointer: fine) {
            .kb-hint { display: block; }
            .action-icon-btn { position: relative; }
        }
        /* Touch: no hover lift, tap highlight */
        @media (hover: none) and (pointer: coarse) {
            button, .menu-option, .class-card, .item-card {
                -webkit-tap-highlight-color: rgba(0,255,0,0.2);
                user-select: none; -webkit-user-select: none;
            }
            #actionBar button:hover { transform: none; box-shadow: none; }
            .action-icon-btn:hover:not(:disabled) { transform: none; }
        }

       
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   TERMINAL MODE â€“ show/hide rules
   (layout is handled by #gameWrapper fixed-position rules above)
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* Hide menu container in terminal mode */
body.terminal-mode #menuContainer {
    display: none;
}

/* â”€â”€ Fullscreen toggle button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#fsBtn {
    position: fixed;
    bottom: calc(env(safe-area-inset-bottom, 0px) + 6px);
    right: 8px;
    z-index: 1500;
    background: rgba(0,0,0,0.7);
    border: 1px solid #2a5a2a;
    color: #00FF41;
    font-size: 18px;
    width: 34px;
    height: 34px;
    border-radius: 6px;
    cursor: pointer;
    display: none;         /* shown only on mobile */
    align-items: center;
    justify-content: center;
    padding: 0;
    line-height: 1;
    opacity: 0.75;
    transition: opacity 0.2s;
}
#fsBtn:active { opacity: 1; transform: scale(0.92); }
/* Show on touch devices */
@media (hover: none) and (pointer: coarse) {
    #fsBtn { display: flex; }
}
/* Hide when game wrapper is active (move above status bars) */
body.terminal-mode #fsBtn { bottom: calc(env(safe-area-inset-bottom, 0px) + 70px); opacity: 0.45; }

/* â”€â”€ Install modal overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#installModal.open { display: flex !important; }
#installModalBox .install-step {
    padding: 6px 0;
    font-size: 17px;
    border-bottom: 1px solid #0d1f0d;
    line-height: 1.35;
}
#installModalBox .install-step:last-child { border-bottom: none; }
#installModalBox .install-highlight { color: var(--highlight-color); }
#installModalBox .install-icon { font-size: 22px; margin-right: 6px; }


        
    </style>
</head>
<body>
    <div class="scanline"></div>

    <!-- Fullscreen toggle (mobile only) -->
    <button id="fsBtn" onclick="toggleFullscreen()" title="Fullscreen">â›¶</button>

    <!-- Install modal (replaces old bottom-strip banner) -->
    <div id="installModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.88);z-index:3000;align-items:center;justify-content:center;">
        <div id="installModalBox" style="
            background:#050a05;border:2px solid var(--border-color);
            max-width:420px;width:90%;padding:20px 22px 18px;
            font-family:'VT323',monospace;color:var(--text-color);
            box-shadow:0 0 40px rgba(0,255,65,0.2);
            position:relative;box-sizing:border-box;">
            <div style="font-size:22px;color:var(--highlight-color);margin-bottom:14px;border-bottom:1px solid #1a3a1a;padding-bottom:8px;">
                ğŸ“± INSTALL DUNGEON QUEST
            </div>
            <div id="installModalBody"></div>
            <button onclick="closeInstallModal()" style="margin-top:14px;width:100%;font-size:18px;border-color:#555;">âœ• CLOSE</button>
        </div>
    </div>
    
    <!-- MENU WRAPPER (town/shop/etc) -->
    <div class="container" id="menuContainer">
        <div class="header">
            <h1>âš”ï¸ DUNGEON QUEST âš”ï¸</h1>
            <div style="color: var(--border-color);">â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</div>
            <div style="color: var(--menu-color); font-size: 16px;">A Classic Text Adventure</div>
        </div>
        <div class="screen" id="mainScreen">
            <!-- Menu / town content -->
        </div>
    </div>

<!-- GAMEPLAY WRAPPER â€” lives at body level, full viewport -->
<div id="gameWrapper">

    <!-- HUD (desktop: top of screen) -->
    <div id="hud">
        <div class="hud-inner">
            <div id="hudName"></div>
            <div class="hud-stats">
                <span id="hudHpNums"></span>
                <span id="hudMpNums"></span>
                <span id="hudXpNums"></span>
                <span id="hudGold"></span>
            </div>
        </div>
    </div>

    <!-- TERMINAL â€” fills all remaining space -->
    <div id="terminalWindow"></div>

    <!-- MOBILE HUD text strip â€” desktop name/gold only, hidden on mobile in terminal mode -->
    <div id="mobileHud">
        <span id="mhHp"></span>
        <span id="mhMp"></span>
        <span id="mhXp" class="mhud-xp"></span>
        <span id="mhGold" class="mhud-gold"></span>
    </div>

    <!-- BOTTOM HUD (legacy, kept for compatibility) -->
    <div id="bottomHud">
        <span id="bottomHudName"></span>
        <span id="bottomHudHp"></span>
        <span id="bottomHudMp"></span>
        <span id="bottomHudXp"></span>
        <span id="bottomHudGold"></span>
    </div>

    <!-- ACTION BAR -->
    <div id="actionBar"></div>

    <!-- STATUS BARS â€” HP/MP thin bars, above action bar -->
    <div id="statusBars">
        <!-- HP + MP row -->
        <div id="sbHpMpRow">
            <div id="sbHpTrack"><div id="sbHpFill"></div></div>
            <div id="sbMpTrack"><div id="sbMpFill"></div></div>
        </div>
    </div>

    <!-- XP BAR â€” pinned to very bottom of screen, below action bar -->
    <div id="sbXpBar">
        <div id="sbXpTrack"><div id="sbXpFill"></div></div>
    </div>

</div>    

    <!-- SYSOP Terminal -->
    <div class="sysop-badge" id="sysopBadge">âš  SYSOP MODE âš </div>
    <div class="terminal-container" id="terminalContainer">
        <div class="terminal-header">â•â•â• SYSOP TERMINAL â•â•â•</div>
        <div class="terminal-output" id="terminalOutput"></div>
        <div id="termHints" style="display:none;font-family:'VT323',monospace;font-size:14px;padding:3px 8px;border-top:1px solid #1a3a1a;border-bottom:1px solid #1a3a1a;background:#020a02;max-height:80px;overflow-y:auto;line-height:1.4;"></div>
        <div class="terminal-input-line">
            <span class="terminal-prompt">root@dungeon:~#</span>
            <input type="text" class="terminal-input" id="terminalInput" autocomplete="off" spellcheck="false" autocorrect="off">
        </div>
    </div>

    <!-- SYSOP Full-Screen Overlay -->
    <div id="sysopOverlay">
        <!-- Header is fixed â€” never scrolls -->
        <div id="sysopOverlayHeader">
            <span class="syo-title">âš  SYSOP TERMINAL âš </span>
            <button class="syo-close" onclick="closeSysopOverlay()">âœ• CLOSE</button>
        </div>
        <!-- Scrollable content -->
        <div id="sysopOverlayInner">
            <div id="sysopOverlayContent"></div>
        </div>
    </div>

    <!-- Modal for forms -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal-content" id="modalContent"></div>
    </div>

    <!-- External Game Data Files -->
    <script src="gameversion.js"></script>
    <script src="dungeon-data.js"></script>
    <script src="Dungeon1.js"></script>
    <script src="town1.js"></script>
    <script src="town2.js"></script>
    <script src="monsters-expanded.js"></script>
    <script src="weapons.js"></script>
    <script src="armor.js"></script>
    <script src="items.js"></script>
    <script src="class-masters.js"></script>
    <script src="class-spells.js"></script>
    <script src="status-effects.js"></script>
    <script src="weapon-drops.js"></script>
    <script src="exploration-zones.js"></script>
    <script src="adventures.js"></script>
    <script src="hunter-pets.js"></script>

    <script>

        // ğŸ”‘ Prevent UI reset after restore (mobile fix)
// gameState.hasRestoredGame = false;


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RARITY CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const RARITY_CONFIG = {
    common:    { name: "Common",    color: "#cccccc", multiplier: 1.0, spawnWeight: 60,  dropBonus: 0 },
    uncommon:  { name: "Uncommon",  color: "#4caf50", multiplier: 1.1, spawnWeight: 25,  dropBonus: 1 },
    rare:      { name: "Rare",      color: "#2196f3", multiplier: 1.2, spawnWeight: 10,  dropBonus: 2 },
    epic:      { name: "Epic",      color: "#9c27b0", multiplier: 1.3, spawnWeight: 4,   dropBonus: 3 },
    legendary: { name: "Legendary", color: "#ff9800", multiplier: 1.4, spawnWeight: 0.9, dropBonus: 4 },
    mythic:    { name: "Mythic",    color: "#ff4444", multiplier: 1.5, spawnWeight: 0.1, dropBonus: 5 }
};



// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GEM SYSTEM â€” Raw gems drop from enemies, cut at blacksmith,
// socket into weapons for permanent bonuses.
// Tier by enemy level: 1-6=T1, 7-12=T2, 13-18=T3, 19-24=T4
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const GEM_TYPES = {
    ruby:     { name: 'Ruby',     color: '#FF2244', emoji: 'ğŸ”´', tier_color: '#FF2244',
                desc: 'Red â€” Damage & Lifesteal',
                stats: ['weaponDmg','weaponDmg','lifesteal'],
                rolls: { weaponDmg: [2,8], lifesteal: [3,10] } },
    sapphire: { name: 'Sapphire', color: '#2266FF', emoji: 'ğŸ”µ', tier_color: '#2266FF',
                desc: 'Blue â€” Spell Power & MP',
                stats: ['spellPower','spellPower','mpBonus'],
                rolls: { spellPower: [3,10], mpBonus: [8,25] } },
    topaz:    { name: 'Topaz',    color: '#FFD700', emoji: 'ğŸŸ¡', tier_color: '#FFD700',
                desc: 'Yellow â€” Crit Chance & Lightning Dmg',
                stats: ['critBonus','critBonus','lightningDmg'],
                rolls: { critBonus: [2,6], lightningDmg: [3,9] } },
    emerald:  { name: 'Emerald',  color: '#00CC44', emoji: 'ğŸŸ¢', tier_color: '#00CC44',
                desc: 'Green â€” Poison & STR',
                stats: ['poisonChance','poisonChance','strBonus'],
                rolls: { poisonChance: [5,15], strBonus: [1,4] } },
    amethyst: { name: 'Amethyst', color: '#AA44FF', emoji: 'ğŸŸ£', tier_color: '#AA44FF',
                desc: 'Purple â€” Defense & HP',
                stats: ['defenseBonus','defenseBonus','hpBonus'],
                rolls: { defenseBonus: [2,7], hpBonus: [10,30] } },
    onyx:     { name: 'Onyx',     color: '#888888', emoji: 'â¬›', tier_color: '#888888',
                desc: 'Black â€” Armor Pierce & Speed',
                stats: ['armorPierce','armorPierce','speedBonus'],
                rolls: { armorPierce: [3,10], speedBonus: [2,5] } },
    opal:     { name: 'Opal',     color: '#AADDFF', emoji: 'ğŸ”·', tier_color: '#AADDFF',
                desc: 'White â€” Luck & Gold Find',
                stats: ['lckBonus','lckBonus','goldFind'],
                rolls: { lckBonus: [1,4], goldFind: [5,15] } },
    garnet:   { name: 'Garnet',   color: '#CC1133', emoji: 'ğŸŸ¤', tier_color: '#CC1133',
                desc: 'Garnet â€” STR & CON',
                stats: ['strBonus','conBonus','strBonus'],
                rolls: { strBonus: [1,4], conBonus: [1,4] } },

    // â”€â”€ EXPANSION GEMS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    bloodstone: { name: 'Bloodstone', color: '#880022', emoji: 'ğŸ©¸', tier_color: '#880022',
                desc: 'Dark Red â€” Max HP & HP Regeneration',
                stats: ['hpBonus','hpBonus','hpRegen'],
                rolls: { hpBonus: [15,40], hpRegen: [1,4] } },

    moonstone:  { name: 'Moonstone',  color: '#CCEEFF', emoji: 'ğŸŒ™', tier_color: '#CCEEFF',
                desc: 'Silver-White â€” MP Regen & Spell Cooldown',
                stats: ['mpRegen','mpRegen','cdReduce'],
                rolls: { mpRegen: [2,6], cdReduce: [3,8] } },

    sunstone:   { name: 'Sunstone',   color: '#FF7700', emoji: 'â˜€ï¸', tier_color: '#FF7700',
                desc: 'Amber â€” Fire Damage & STR (universal)',
                stats: ['fireDmg','fireDmg','strBonus'],
                rolls: { fireDmg: [4,12], strBonus: [1,3] } },

    voidstone:  { name: 'Voidstone',  color: '#6600BB', emoji: 'ğŸ”®', tier_color: '#6600BB',
                desc: 'Dark Purple â€” Spell Leech & WIS',
                stats: ['spellLeech','spellLeech','wisBonus'],
                rolls: { spellLeech: [3,10], wisBonus: [1,3] } },

    ironheart:  { name: 'Ironheart',  color: '#AAAAAA', emoji: 'ğŸ©¶', tier_color: '#AAAAAA',
                desc: 'Iron-Grey â€” Defense & CON',
                stats: ['defenseBonus','defenseBonus','conBonus'],
                rolls: { defenseBonus: [3,9], conBonus: [1,4] } },

    stormglass: { name: 'Stormglass', color: '#44DDFF', emoji: 'â›ˆï¸', tier_color: '#44DDFF',
                desc: 'Ice-Blue â€” Lightning & Frost (universal, both elements stack)',
                stats: ['lightningDmg','frostDmg','lightningDmg'],
                rolls: { lightningDmg: [4,12], frostDmg: [3,10] } },
};

// Gem tier multiplier for rolls (higher tier = stronger bonuses)
const GEM_TIER_MULT = { 1: 1.0, 2: 1.5, 3: 2.2, 4: 3.2 };

// Get tier from enemy level
function getGemTier(enemyLevel) {
    if (enemyLevel <= 6)  return 1;
    if (enemyLevel <= 12) return 2;
    if (enemyLevel <= 18) return 3;
    return 4;
}

// Gem types as an array for random selection
const GEM_KEYS = Object.keys(GEM_TYPES);

// Cut a raw gem into a finished gem with permanent random stats
function cutGem(gemKey) {
    const tier = gemKey.includes('_t') ? parseInt(gemKey.split('_t')[1]) : 1;
    const typeKey = gemKey.replace(/_t\d+$/, '').replace('raw_','');
    const gemDef = GEM_TYPES[typeKey];
    if (!gemDef) return null;
    const mult = GEM_TIER_MULT[tier] || 1.0;
    // Roll 2 stats from the gem's stat pool
    const statPool = [...gemDef.stats];
    const chosen = [];
    const statValues = {};
    // Pick up to 2 unique stats
    const shuffled = statPool.sort(() => Math.random()-0.5);
    const picked = [...new Set(shuffled)].slice(0, 2);
    for (const stat of picked) {
        const [lo, hi] = gemDef.rolls[stat];
        const val = Math.floor((lo + Math.random()*(hi-lo+1)) * mult);
        statValues[stat] = (statValues[stat] || 0) + val;
    }
    return {
        id: `gem_${typeKey}_t${tier}_${Date.now()}`,
        type: typeKey,
        tier,
        name: `${['','T1 ','T2 ','T3 ','T4 '][tier]}${gemDef.name}`,
        color: gemDef.color,
        emoji: gemDef.emoji,
        cut: true,
        stats: statValues,
        description: describeGemStats(statValues)
    };
}

function describeGemStats(stats) {
    const labels = {
        weaponDmg:    'Weapon DMG',   lifesteal:    'Lifesteal %',
        spellPower:   'Spell Power',  mpBonus:      'Max MP',
        critBonus:    'Crit %',       lightningDmg: 'Lightning DMG',
        poisonChance: 'Poison %',     strBonus:     'STR',
        conBonus:     'CON',          defenseBonus: 'Defense',
        hpBonus:      'Max HP',       armorPierce:  'Armor Pierce %',
        speedBonus:   'Speed',        lckBonus:     'LCK',
        goldFind:     'Gold Find %',
        // New gem stats
        hpRegen:      'HP Regen/turn', mpRegen:     'MP Regen/turn',
        cdReduce:     'Cooldown %',    fireDmg:     'Fire DMG',
        frostDmg:     'Frost DMG',     spellLeech:  'Spell Leech %',
        wisBonus:     'WIS',
    };
    return Object.entries(stats).map(([k,v]) => `+${v} ${labels[k]||k}`).join(', ');
}

// How many gem slots does a weapon quality get?
// Shop-bought gear (normal/poor) has no slots â€” slots are a perk of dropped gear.
// Drops come with quality from the drop system: rare=1, epic=2, legendary=3, godly=4.
function getGemSlots(quality) {
    const map = { poor:0, normal:0, uncommon:1, rare:1, epic:2, legendary:3, godly:4 };
    return map[quality] || 0;
}

// Apply socketed gem stats to player during combat (additive bonuses)
function applyGemBonuses(player, weapon) {
    if (!weapon || !weapon.gems || weapon.gems.length === 0) return;
    for (const gem of weapon.gems) {
        if (!gem || !gem.stats) continue;
        const s = gem.stats;
        if (s.hpBonus)      player._gemHpBonus  = (player._gemHpBonus  || 0) + s.hpBonus;
        if (s.mpBonus)      player._gemMpBonus  = (player._gemMpBonus  || 0) + s.mpBonus;
        if (s.strBonus)     player._gemStr      = (player._gemStr      || 0) + s.strBonus;
        if (s.conBonus)     player._gemCon      = (player._gemCon      || 0) + s.conBonus;
        if (s.lckBonus)     player._gemLck      = (player._gemLck      || 0) + s.lckBonus;
        if (s.defenseBonus) player._gemDef      = (player._gemDef      || 0) + s.defenseBonus;
        if (s.critBonus)    player._gemCrit     = (player._gemCrit     || 0) + s.critBonus;
        if (s.weaponDmg)    player._gemWepDmg   = (player._gemWepDmg   || 0) + s.weaponDmg;
        if (s.spellPower)   player._gemSpell    = (player._gemSpell    || 0) + s.spellPower;
        if (s.lifesteal)    player._gemLifesteal= (player._gemLifesteal|| 0) + s.lifesteal;
        if (s.armorPierce)  player._gemPierce   = (player._gemPierce   || 0) + s.armorPierce;
        if (s.goldFind)     player._gemGold     = (player._gemGold     || 0) + s.goldFind;
        if (s.poisonChance) player._gemPoison   = (player._gemPoison   || 0) + s.poisonChance;
    }
}

function updateTerminalSafeArea() {
    // No-op: layout handled by fixed-position flex column.
    // Terminal fills remaining space; actionBar sits below it naturally.
}



// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Direction helpers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const OPPOSITE_DIR = {
    N: 'South',
    S: 'North',
    E: 'West',
    W: 'East',
    NE: 'Southwest',
    NW: 'Southeast',
    SE: 'Northwest',
    SW: 'Northeast'
};



        // Game Data Structures
        const CLASSES = {
            warrior: {
                name: 'Warrior',
                hp: 120,
                mp: 20,
                strength: 15,
                defense: 12,
                magic: 3,
                speed: 7,
                description: 'Master of melee combat with high HP and defense',
                startWeapon: 'iron_sword',
                startArmor: 'leather_armor'
            },
            rogue: {
                name: 'Rogue',
                hp: 80,
                mp: 30,
                strength: 10,
                defense: 6,
                magic: 5,
                speed: 15,
                description: 'Swift and deadly, strikes first with critical hits',
                startWeapon: 'rusty_shiv',
                startArmor: 'leather_vest'
            },
            paladin: {
                name: 'Paladin',
                hp: 100,
                mp: 50,
                strength: 12,
                defense: 10,
                magic: 8,
                speed: 8,
                description: 'Holy warrior with healing magic and strong defense',
                startWeapon: 'mace',
                startArmor: 'chain_mail'
            },
            mage: {
                name: 'Mage',
                hp: 60,
                mp: 100,
                strength: 5,
                defense: 4,
                magic: 18,
                speed: 9,
                description: 'Powerful spellcaster with devastating magic',
                startWeapon: 'staff',
                startArmor: 'cloth_robes'
            },
            cleric: {
                name: 'Cleric',
                hp: 90,
                mp: 100,
                strength: 8,
                defense: 8,
                magic: 12,
                speed: 7,
                description: 'Divine healer with support spells and moderate combat',
                startWeapon: 'mace',
                startArmor: 'leather_armor'
            },
            //ranger: {
            //    name: 'Ranger',
            //    hp: 85,
            //    mp: 40,
            //   strength: 11,
            //    defense: 7,
            //    magic: 6,
            //    speed: 13,
            //    description: 'Skilled archer with nature magic and tracking',
            //    startWeapon: 'bow',
            //    startArmor: 'leather_armor'
            // },

            hunter: {
                name: 'Hunter',
                hp: 85,
                mp: 40,
                strength: 11,
                defense: 7,
                magic: 6,
                speed: 13,
                description: 'Skilled archer with nature magic and tracking',
                startWeapon: 'bow',
                startArmor: 'leather_armor'
            },

            
            warlock: {
                name: 'Warlock',
                hp: 70,
                mp: 90,
                strength: 6,
                defense: 5,
                magic: 16,
                speed: 8,
                description: 'Dark mage who drains life from enemies with shadow magic',
                startWeapon: 'staff',
                startArmor: 'cloth_robes'
            },
            runesmith: {
                name: 'Runesmith',
                hp: 95,
                mp: 70,
                strength: 12,
                defense: 9,
                magic: 10,
                speed: 8,
                description: 'Cast 3 runes to charge Overload â€” then strike for devastating armor-piercing damage. Master of hybrid physical/arcane combat.',
                startWeapon: 'chipped_mattock',
                startArmor: 'leather_armor'
            }
        };


        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STAT SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const STAT_BUDGET  = 10;
        const STAT_NAMES   = ['str','dex','wis','cha','con','lck'];
        const STAT_LABELS  = { str:'STR', dex:'DEX', wis:'WIS', cha:'CHA', con:'CON', lck:'LCK' };
        const STAT_DESCS   = {
            str:'Physical damage & multi-hit',
            dex:'Dodge chance & flee success',
            wis:'Spell power & magic resist',
            cha:'Shop prices & negotiation',
            con:'Max HP bonus & defense',
            lck:'Crit chance & loot luck'
        };
        // Opposed pairs: reroll engine biases against extremes in both.
        // Paladin is EXEMPT from str<->wis opposition.
        const OPPOSED_PAIRS = [['str','wis'],['dex','cha'],['con','lck']];

        const CLASS_STAT_PRESETS = {
            // Sums to exactly 10; biased toward class identity, min 0
            warrior : { str:3, dex:1, wis:0, cha:1, con:3, lck:2 },
            rogue   : { str:1, dex:4, wis:0, cha:1, con:1, lck:3 },
            paladin : { str:2, dex:1, wis:3, cha:2, con:2, lck:0 },
            mage    : { str:0, dex:1, wis:4, cha:1, con:1, lck:3 },
            cleric  : { str:1, dex:0, wis:4, cha:2, con:2, lck:1 },
            ranger  : { str:1, dex:3, wis:1, cha:1, con:2, lck:2 },
            hunter  : { str:1, dex:3, wis:1, cha:1, con:2, lck:2 },
            warlock : { str:0, dex:1, wis:4, cha:2, con:1, lck:2 },
            runesmith: { str:2, dex:0, wis:3, cha:1, con:3, lck:1 }
        };
        const CLASS_AFFINITIES = {
            warrior :['str','con'],
            rogue   :['dex','lck'],
            paladin :['str','wis','cha'],
            mage    :['wis','lck'],
            cleric  :['wis','cha'],
            hunter  :['dex','lck'],
            ranger  :['dex','lck'],
            warlock :['wis','cha'],
            runesmith:['str','wis']
        };

        // â”€â”€ derived-stat helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Compute quality bonus as a % of the weapon/armor base damage/defense
        // QUALITY_CONFIG now uses bonusPct instead of a flat bonus
        function getQualityBonus(quality, baseStat) {
            const cfg = QUALITY_CONFIG[quality];
            if (!cfg) return 0;
            // Support old flat bonus saves gracefully
            if (cfg.bonusPct !== undefined) return Math.floor(baseStat * cfg.bonusPct);
            return cfg.bonus || 0;
        }

                function calcPlayerHits(p) {
            const baseClass = p.baseClass || p.class;
            
            // ALL CLASSES: Pip progression â€” Lv1=1  Lv5=2  Lv10=3  Lv15=4  (hard cap 4)
            // Rogue pips also fire twice (double-strike with daggers)
            if (p.level >= 15) return 4;
            if (p.level >= 10) return 3;
            if (p.level >= 5)  return 2;
            return 1;
        }
        function calcChaDiscount(cha) { return Math.min(30, (cha||0) * 2); }   // buy %  off
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CLASS EQUIPMENT RESTRICTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        

        // â”€â”€ Build gem slot display for a weapon card â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function buildGemSlotHtml(weapon) {
            if (!weapon) return '';
            // Ensure quality fallback â€” drop weapons may not have quality set yet
            const quality = weapon.quality || 'normal';
            const slots = getGemSlots(quality);
            if (slots === 0) return '';
            if (!weapon.gems) weapon.gems = [];  // initialize if missing
            const socketed = weapon.gems;
            const filledCount = socketed.length;
            let html = `<div style="margin-top:5px;font-size:11px;line-height:1.6;">`;
            for (let i = 0; i < slots; i++) {
                const gem = socketed[i];
                if (gem && gem.cut) {
                    // Filled slot â€” colored gem circle + stat text
                    html += `<div style="display:flex;align-items:center;gap:5px;flex-wrap:wrap;">
                        <span style="color:${gem.color};font-size:15px;line-height:1;">â¬¤</span>
                        <span style="color:${gem.color};font-weight:bold;">${gem.emoji} ${gem.name}</span>
                        <span style="color:#888;font-size:10px;">${gem.description}</span>
                    </div>`;
                } else {
                    // Empty slot â€” dark circle
                    html += `<div style="display:flex;align-items:center;gap:5px;">
                        <span style="color:#1a1a1a;font-size:15px;line-height:1;text-shadow:0 0 1px #555;">â¬¤</span>
                        <span style="color:#3a3a3a;font-size:10px;font-style:italic;">empty socket</span>
                    </div>`;
                }
            }
            if (slots > 1) {
                html += `<div style="color:#555;font-size:10px;margin-top:2px;">${filledCount}/${slots} gems socketed</div>`;
            }
            html += '</div>';
            return html;
        }

        // â”€â”€ Build damage line for a weapon (MELEE / MAGIC clearly split) â”€â”€
        function buildWeaponDmgLine(weapon, quality) {
            const qc = QUALITY_CONFIG[quality || weapon.quality];
            const qb = getQualityBonus(weapon.quality, weapon.baseDamage);
            const tMin = weapon.baseDamage + qb;
            const tMax = weapon.maxDamage ? weapon.maxDamage + getQualityBonus(weapon.quality, weapon.maxDamage - weapon.baseDamage) : tMin;
            const tMag = (weapon.baseMagicDamage || 0) + Math.floor((weapon.baseMagicDamage || 0) * (qc?.bonusPct || 0));
            let line = `<span style="color:#ffcc88;">MELEE: ${tMin}${tMax > tMin ? '-'+tMax : ''}</span>`;
            if (tMag > 0) {
                line += ` <span style="color:#88aaff;">| MAGIC: +${tMag}</span>`;
            }
            return line;
        }

        function canUseWeapon(playerClass, weapon) {
            // Bare fists â€” always usable by everyone
            if (weapon.unarmed) return true;
            // If weapon has allowedClasses, check it
            if (weapon.allowedClasses) {
                return weapon.allowedClasses.includes(playerClass);
            }
            // RUNESMITH: can use staves, hammers, maces, and swords â€” the hybrid fighter/caster
            if (playerClass === 'runesmith') {
                if (!weapon.name) return false;
                const wn = weapon.name.toLowerCase();
                return weapon.weaponSubtype === 'staff'
                    || wn.includes('staff')
                    || wn.includes('hammer')
                    || wn.includes('mace')
                    || wn.includes('sword')
                    || wn.includes('mattock')
                    || wn.includes('maul')
                    || wn.includes('axe')
                    || weapon.type === 'hammer'
                    || weapon.type === 'staff'
                    || weapon.type === 'sword';
            }
            
            // ROGUE: daggers only â€” no exceptions
            // Also allow dropped weapons with type 'dagger' or 'poison_dagger' / 'assassin_blade' etc.
            if (playerClass === 'rogue') {
                const isDagger = weapon.classRestriction === 'rogue'
                    || weapon.type === 'dagger'
                    || weapon.type === 'poison_dagger'
                    || weapon.type === 'assassin_blade'
                    || weapon.type === 'short_sword'
                    || (weapon.name && weapon.name.toLowerCase().includes('dagger'))
                    || (weapon.name && weapon.name.toLowerCase().includes('shiv'))
                    || (weapon.name && weapon.name.toLowerCase().includes('stiletto'))
                    || (weapon.name && weapon.name.toLowerCase().includes('dirk'))
                    || (weapon.name && weapon.name.toLowerCase().includes('blade'));
                return isDagger;
            }

            // Default restrictions based on weapon type/name
            const weaponName = weapon.name.toLowerCase();
            const SPELL_CLASSES = ['mage', 'warlock', 'cleric', 'acolyte', 'necrolyte', 'druid', 'sorceror', 'runesmith'];
            
            // Staffs - magic users only
            if (weaponName.includes('staff') || weapon.weaponSubtype === 'staff') {
                return SPELL_CLASSES.includes(playerClass);
            }
            
            // Wands - magic users only (but also accessible from shop for magic classes)
            if (weaponName.includes('wand') || weapon.weaponSubtype === 'wand') {
                return SPELL_CLASSES.includes(playerClass);
            }
            
            // Also catch high-magic weapons by baseMagicDamage ratio
            if (weapon.baseMagicDamage > weapon.baseDamage) {
                return SPELL_CLASSES.includes(playerClass);
            }

            // Tomes, orbs, shadow_orb â€” magic users only (drop types with no keyword in name)
            if (weapon.type === 'tome' || weapon.type === 'orb' || weapon.type === 'shadow_orb'
                || weaponName.includes('tome') || weaponName.includes(' orb')) {
                return SPELL_CLASSES.includes(playerClass);
            }
            
            // Bows - rangers and archers only
            if (weaponName.includes('bow')) {
                return ['ranger', 'archer', 'hunter'].includes(playerClass);
            }
            
            // Daggers - rogues handled above; rangers/hunters can use too
            if (weaponName.includes('dagger') || weapon.classRestriction === 'rogue') {
                return ['ranger', 'hunter'].includes(playerClass);
            }
            
            // Maces - paladins and clerics
            if (weaponName.includes('mace')) {
                return ['paladin', 'cleric', 'acolyte'].includes(playerClass);
            }
            
            // Swords and axes - warriors and melee classes
            if (weaponName.includes('sword') || weaponName.includes('axe') || weaponName.includes('hammer')) {
                return ['warrior', 'paladin'].includes(playerClass);
            }
            
            // Default: everyone except rogue can use
            return true;
        }
        
        function canUseArmor(playerClass, armor) {
            // No Armor â€” always usable by everyone
            if (armor.unarmored) return true;
            // If armor has allowedClasses, check it
            if (armor.allowedClasses) {
                return armor.allowedClasses.includes(playerClass);
            }
            
            // Default restrictions based on armor type/name
            const armorName = armor.name.toLowerCase();
            
            // Robes - magic users only (runesmith cannot â€” too fragile for frontline)
            if (armorName.includes('robe')) {
                return ['mage', 'warlock', 'cleric', 'acolyte', 'necrolyte', 'druid', 'sorceror'].includes(playerClass);
            }
            
            // Plate armor - heavy fighters only (runesmith cannot â€” too restrictive for rune casting)
            if (armorName.includes('plate')) {
                return ['warrior', 'paladin'].includes(playerClass);
            }
            
            // Chainmail - medium armor (runesmith can wear â€” mobile enough for rune work)
            if (armorName.includes('chain')) {
                return ['warrior', 'paladin', 'cleric', 'ranger', 'runesmith'].includes(playerClass);
            }
            
            // Scale / hide / studded â€” medium-heavy, runesmith fits here
            if (armorName.includes('scale') || armorName.includes('hide') || armorName.includes('studded')) {
                return ['warrior', 'paladin', 'cleric', 'ranger', 'hunter', 'runesmith'].includes(playerClass);
            }
            
            // Leather - light armor, most classes
            if (armorName.includes('leather')) {
                return ['warrior', 'rogue', 'ranger', 'hunter', 'cleric', 'paladin', 'runesmith'].includes(playerClass);
            }
            
            // Cloth - everyone can wear
            return true;
        }
        function calcChaSellBonus(cha){ return Math.min(15, (cha||0) * 1); }   // sell %  bonus
        function calcInnCost(cha)     { return Math.max(20, 50 - (cha||0)); }
        function calcCritChance(lck, player)  { 
            // Base: 3% + 0.5% per LCK (not 1%) â€” prevents LCK-dumping giving 30%+ at level 1
            let baseCrit = 3 + Math.floor((lck || 0) * 0.5);
            
            if (player) {
                const baseClass = player.baseClass || player.class;
                const lvl = player.level || 1;
                if (baseClass === 'rogue') {
                    // Rogue: 5% base + 0.75% per LCK + 1% per 2 levels
                    // This gives ~15% at level 3 with 17 LCK (fun but not broken)
                    // and scales to ~50% at level 20 (exciting endgame)
                    baseCrit = 5 + Math.floor((lck || 0) * 0.75) + Math.floor(lvl / 2);
                }
            }
            
            const cap = (player && (player.baseClass || player.class) === 'rogue') ? 75 : 30;
            return Math.min(cap, baseCrit);
        }  // %
        function calcDodgeChance(dex) { return Math.min(40, (dex||0) * 2); }   // %
        function calcLootBonus(lck)   { return Math.min(25, (lck||0) * 2); }   // extra %

        // random reroll: scatter STAT_BUDGET among 6 stats (min 1 each)
        function rerollStats(classKey) {
            const s = { str:0, dex:0, wis:0, cha:0, con:0, lck:0 };
            let rem = STAT_BUDGET;  // all 10 points distributed randomly
            while (rem-- > 0) s[STAT_NAMES[Math.floor(Math.random()*6)]]++;
            return s;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // RUNESTONES â€” World-progression keystones, one per major arc.
        // Each runestone unlocks a portal, a region, or a world secret.
        // Colors: white, yellow, green, blue, purple, brown, black, red
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const RUNESTONES = {
            white_runestone: {
                id:          'white_runestone',
                name:        'White Runestone',
                color:       '#FFFFFF',
                badgeSymbol: 'âœ¦',
                description: 'A pale stone humming with quiet energy. It unlocks passage to Ashen Harbor.',
                lore:        'Found at the heart of Dungeon1. Its surface is smooth and cold as winter.',
                unlocksPortal: { from: 'town1', to: 'town2' }
            },
            yellow_runestone: {
                id:          'yellow_runestone',
                name:        'Yellow Runestone',
                color:       '#FFD700',
                badgeSymbol: 'âœ¦',
                description: 'A warm golden stone radiating faint heat. Its purpose is not yet known.',
                lore:        'Ancient texts speak of a sunken city where this stone once served as a key.',
                unlocksPortal: null  // destination TBD
            },
            green_runestone: {
                id:          'green_runestone',
                name:        'Green Runestone',
                color:       '#00FF88',
                badgeSymbol: 'âœ¦',
                description: 'A mossy stone pulsing with natural energy. The forest seems to breathe around it.',
                lore:        'Those who carry it claim to hear the Whispering Forest even in silence.',
                unlocksPortal: null
            },
            blue_runestone: {
                id:          'blue_runestone',
                name:        'Blue Runestone',
                color:       '#44AAFF',
                badgeSymbol: 'âœ¦',
                description: 'A cool blue stone that drips condensation even in dry air.',
                lore:        'Said to be a fragment of a glacier that froze during the Age of Storms.',
                unlocksPortal: null
            },
            purple_runestone: {
                id:          'purple_runestone',
                name:        'Purple Runestone',
                color:       '#BB66FF',
                badgeSymbol: 'âœ¦',
                description: 'A violet stone swirling with arcane light. It vibrates in the presence of magic.',
                lore:        'Mages covet these. Some have gone mad trying to decode what it whispers.',
                unlocksPortal: null
            },
            brown_runestone: {
                id:          'brown_runestone',
                name:        'Brown Runestone',
                color:       '#CC8844',
                badgeSymbol: 'âœ¦',
                description: 'A rough earthen stone worn smooth by centuries. It feels impossibly heavy.',
                lore:        'Dwarven records suggest an entire mountain was carved to produce one of these.',
                unlocksPortal: null
            },
            black_runestone: {
                id:          'black_runestone',
                name:        'Black Runestone',
                color:       '#888888',
                badgeSymbol: 'âœ¦',
                description: 'A void-black stone that seems to absorb the light around it. Cold to the touch.',
                lore:        'No one knows where it came from. No one who has seen where it goes has returned.',
                unlocksPortal: null
            },
            red_runestone: {
                id:          'red_runestone',
                name:        'Red Runestone',
                color:       '#FF3333',
                badgeSymbol: 'âœ¦',
                description: 'A blood-red stone that pulses like a heartbeat. It grows warm when danger is near.',
                lore:        'The last bearer scratched a single word on the wall before vanishing: "Run."',
                unlocksPortal: null
            }
        };

        const SPELLS = {
    heal: {
        name: 'Heal',
        mpCost: 15,
        pipCost: 1,
        power: 30,
        type: 'heal',
        level: 1,
        description: 'Restore HP'
    },
    fireball: {
        name: 'Fireball',
        mpCost: 20,
        pipCost: 1,
        power: 35,
        type: 'attack',
        level: 2,
        description: 'Fiery attack'
    },
    lightning: {
        name: 'Lightning',
        mpCost: 25,
        pipCost: 2,
        power: 45,
        type: 'attack',
        level: 4,
        description: 'Electric damage'
    },
    greater_heal: {
        name: 'Greater Heal',
        mpCost: 30,
        pipCost: 2,
        power: 60,
        type: 'heal',
        level: 5,
        description: 'Major healing'
    },
    ice_storm: {
        name: 'Ice Storm',
        mpCost: 35,
        pipCost: 2,
        power: 55,
        type: 'attack',
        level: 6,
        description: 'Freezing assault'
    },
    holy_light: {
        name: 'Holy Light',
        mpCost: 20,
        pipCost: 1,
        power: 25,
        type: 'attack',
        level: 3,
        description: 'Divine damage'
    },
    meteor: {
        name: 'Meteor',
        mpCost: 50,
        pipCost: 3,
        power: 80,
        type: 'attack',
        level: 8,
        description: 'Devastating spell'
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SPELL HELPER - Dynamically add spells from CLASS_SPELL_TREES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function ensureSpellExists(spellKey) {
    // If spell already exists, return it
    if (SPELLS[spellKey]) return SPELLS[spellKey];
    
    // Try to find it in CLASS_SPELL_TREES
    if (typeof CLASS_SPELL_TREES === 'undefined') return null;
    
    for (const classKey in CLASS_SPELL_TREES) {
        const classTree = CLASS_SPELL_TREES[classKey];
        if (classTree.spellTree && classTree.spellTree[spellKey]) {
            const spell = classTree.spellTree[spellKey];
            // Add it to SPELLS with pipCost
            SPELLS[spellKey] = {
                ...spell,
                pipCost: 1 // Default pip cost
            };
            console.log(`âœ… Dynamically added spell '${spellKey}' to SPELLS`);
            return SPELLS[spellKey];
        }
    }
    
    return null;
}

// Load all spells from CLASS_SPELL_TREES into SPELLS
function loadAllClassSpells() {
    if (typeof CLASS_SPELL_TREES === 'undefined') {
        console.warn('âš ï¸ CLASS_SPELL_TREES not loaded yet');
        return;
    }
    
    let count = 0;
    for (const classKey in CLASS_SPELL_TREES) {
        const classTree = CLASS_SPELL_TREES[classKey];
        if (classTree.spellTree) {
            for (const spellKey in classTree.spellTree) {
                if (!SPELLS[spellKey]) {
                    const spell = classTree.spellTree[spellKey];
                    SPELLS[spellKey] = {
                        ...spell,
                        pipCost: 1
                    };
                    count++;
                }
            }
        }
    }
    
    if (count > 0) {
        console.log(`âœ… Loaded ${count} class spells into SPELLS object`);
    }
}



        const LOCATIONS = {
    town: {
        name: 'Silverdale Town',
        description: 'A peaceful town with shops and an inn. Your adventure begins here.',
        canRest: true,
        hasShop: true
    },
    
  

    forest: {
        name: 'Whispering Forest',
        description: 'A dark forest filled with minor creatures.',
        enemyLevelRange: [1, 5],
        encounters: ['goblin', 'wolf', 'giant_spider'],
        requiredLevel: 1,
        locked: false
    },

  riverside: {
        name: 'Misty Riverside',
        description: 'A foggy riverbank where strange creatures lurk in the shallows.',
        enemyLevelRange: [4, 6],
        encounters: ['river_troll', 'swamp_lurker', 'giant_frog', 'water_snake', 'bandit',
                     'mudskipper', 'river_pirate', 'snapping_turtle', 'kelp_strangler', 'bog_witch',
                     'harpy', 'gnoll', 'lizardfolk', 'giant_wasp', 'bandit_scout'],
        requiredLevel: 4,
        locked: true,
        town: 'town1',
        unlockMessage: 'Defeat your class master in the forest to unlock this area!',
        
    },

    plains: {
        name: 'Endless Plains',
        description: 'Open grasslands with roaming beasts.',
        enemyLevelRange: [6, 10],
        encounters: ['orc', 'dire_wolf', 'bandit'],
        requiredLevel: 6,
        locked: true,
        unlockMessage: 'Defeat your class master in the forest to unlock this area!'
    },

    cave: {
        name: 'Shadow Cavern',
        description: 'A dungeon filled with dangerous monsters.',
        enemyLevelRange: [11, 15],
        encounters: ['troll', 'skeleton_warrior', 'dark_mage'],
        requiredLevel: 11,
        locked: true,
        unlockMessage: 'Defeat your class master in the plains to unlock this area!'
    },

    crypt: {
        name: 'Ancient Crypt',
        description: 'An ancient tomb haunted by the undead.',
        enemyLevelRange: [16, 20],
        encounters: ['lich', 'death_knight', 'wraith'],
        requiredLevel: 16,
        locked: true,
        unlockMessage: 'Defeat your class master in the cave to unlock this area!'
    },

    volcano: {
        name: 'Volcanic Wastes',
        description: 'A scorched wasteland of fire and ash.',
        enemyLevelRange: [21, 25],
        encounters: ['fire_elemental', 'lava_golem', 'phoenix'],
        requiredLevel: 21,
        locked: true,
        unlockMessage: 'Defeat your class master in the crypt to unlock this area!'
    },

    fireMountain: {
        name: 'Fire Mountain',
        description: 'A volcanic peak home to fierce creatures.',
        enemyLevelRange: [8, 12],
        encounters: ['fire_elemental', 'red_dragon', 'demon'],
        requiredLevel: 12,
        locked: true,
        unlockMessage: 'Defeat your class master in the crypt to unlock this area!'
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MERGE EXPANDED ZONES (if exploration-zones.js is loaded)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if (typeof EXPLORATION_ZONES !== 'undefined') {
    // Merge new zones while keeping custom zones
    Object.assign(LOCATIONS, EXPLORATION_ZONES);
    console.log('âœ… Loaded expanded exploration zones');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MERGE ZONE MONSTERS (if exploration-zones.js is loaded)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if (typeof ZONE_MONSTERS !== 'undefined') {
    Object.assign(ENEMIES, ZONE_MONSTERS);
    console.log('âœ… Loaded zone-specific monsters');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MERGE ADVENTURE ENEMIES (if adventures.js is loaded)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if (typeof ADVENTURE_ENEMIES !== 'undefined') {
    Object.assign(ENEMIES, ADVENTURE_ENEMIES);
    console.log('âœ… Loaded adventure enemies');
}



        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MODEM SPEED SIMULATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const MODEM_SPEEDS = {
            '56k': 7,      // ~7 characters per frame (56k modem - fast)
            '28.8k': 4,    // ~4 characters per frame (28.8k modem - medium)
            '14.4k': 2,    // ~2 characters per frame (14.4k modem - slow)
            '9600': 1,     // ~1 character per frame (9600 baud - very slow)
            '4800': 0.5,   // ~0.5 characters per frame (4800 baud - ultra slow)
            'instant': -1  // No delay
        };
        
        let currentModemSpeed = '14.4k'; // Default to 14.4k modem (authentic BBS experience)
        let isStreaming = false;
        let streamCancelled = false;
        
        function streamText(element, html, callback) {
           if (currentModemSpeed === 'instant') {
    line.innerHTML = html;

    // âœ… STEP 3A: scroll AFTER line is fully rendered
    if (shouldAutoScroll) {
        tw.scrollTop = tw.scrollHeight;
    }

line.innerHTML =
    sliceToVisible(html, visibleCount) +
    '<span style="animation:blink 1s infinite;">_</span>';


    if (onDone) onDone();
    termDrain();
    return;
}

            
            isStreaming = true;
            streamCancelled = false;
            
            // Strip HTML tags for character counting but keep them for display
            const charsPerFrame = MODEM_SPEEDS[currentModemSpeed];
            let currentIndex = 0;
            
            const interval = setInterval(() => {
                if (streamCancelled) {
                    clearInterval(interval);
                    element.innerHTML = html;
                    isStreaming = false;
                    if (callback) callback();
                    return;
                }
                
                currentIndex += charsPerFrame;
                
                if (currentIndex >= html.length) {
                    clearInterval(interval);
                    element.innerHTML = html;
                    isStreaming = false;
                    if (callback) callback();
                } else {
                    // Display partial HTML up to current index
                    element.innerHTML = html.substring(0, currentIndex) + '<span style="animation: blink 1s infinite;">_</span>';
                }
            }, 16); // ~60fps
        }
        
        function cancelStream() {
            streamCancelled = true;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SAVE FILE ENCRYPTION (Anti-Cheat)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // Simple but effective encryption key (obfuscated in code)
        const SAVE_KEY = 'DQ_' + btoa('DUNGEON_QUEST_2026').split('').reverse().join('');
        
        function encryptSave(data) {
            try {
                const jsonStr = JSON.stringify(data);
                const encoded = btoa(encodeURIComponent(jsonStr));
                
                // Add checksum to detect tampering
                const checksum = generateChecksum(jsonStr);
                
                // XOR cipher with key
                let encrypted = '';
                for (let i = 0; i < encoded.length; i++) {
                    encrypted += String.fromCharCode(
                        encoded.charCodeAt(i) ^ SAVE_KEY.charCodeAt(i % SAVE_KEY.length)
                    );
                }
                
                return btoa(JSON.stringify({
                    v: 1, // version
                    d: btoa(encrypted), // data
                    c: checksum // checksum
                }));
            } catch (e) {
                console.error('Encryption failed:', e);
                return null;
            }
        }
        
        function decryptSave(encryptedData) {
            try {
                const wrapper = JSON.parse(atob(encryptedData));
                
                if (wrapper.v !== 1) {
                    throw new Error('Invalid save version');
                }
                
                const encrypted = atob(wrapper.d);
                
                // XOR decipher
                let decoded = '';
                for (let i = 0; i < encrypted.length; i++) {
                    decoded += String.fromCharCode(
                        encrypted.charCodeAt(i) ^ SAVE_KEY.charCodeAt(i % SAVE_KEY.length)
                    );
                }
                
                const jsonStr = decodeURIComponent(atob(decoded));
                
                // Verify checksum
                const calculatedChecksum = generateChecksum(jsonStr);
                if (calculatedChecksum !== wrapper.c) {
                    throw new Error('Save file has been tampered with!');
                }
                
                return JSON.parse(jsonStr);
            } catch (e) {
                console.error('Decryption failed:', e);
                throw new Error('Invalid or corrupted save file');
            }
        }
        
        function generateChecksum(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return hash.toString(36);
        }
        
        function downloadSaveFile() {
            try {
                const snapshot = buildSaveSnapshot();
                if (!snapshot) {
                    alert('No character data to save!');
                    return;
                }
                
                const encrypted = encryptSave(snapshot);
                if (!encrypted) {
                    alert('Failed to encrypt save file!');
                    return;
                }
                
                // Create filename with character name and timestamp
                const timestamp = new Date().toISOString().slice(0, 10);
                const filename = `DungeonQuest_${snapshot.characterName}_${timestamp}.dqsave`;
                
                // Create blob and download
                const blob = new Blob([encrypted], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert(`âœ… Save file downloaded: ${filename}`);
            } catch (e) {
                console.error('Download failed:', e);
                alert('Failed to download save file!');
            }
        }
        
        function loadFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.dqsave';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const encryptedData = event.target.result;
                        const data = decryptSave(encryptedData);
                        
                        // Validate the save data
                        if (!data.player || !data.characterId) {
                            throw new Error('Invalid save file structure');
                        }
                        
                        // Save to localStorage
                        const key = `dq_save_${data.characterId}`;
                        localStorage.setItem(key, JSON.stringify(data));
                        
                        // Update character list
                        updateCharacterList(data);
                        
                        alert(`âœ… Character "${data.characterName}" loaded successfully!`);
                        
                        // Load the character
                        loadCharacter(data.characterId);
                    } catch (e) {
                        console.error('Load failed:', e);
                        alert('âŒ Failed to load save file: ' + e.message);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        // â”€â”€ Version check and revision history live in gameversion.js â”€â”€
        // GAME_VERSION and REVISION_HISTORY are loaded from that file.
        // checkGameVersion() is also defined there.

        // Game State
        let gameState = {
            player: null,
            currentLocation: 'town',
            currentTown: 'town1',   // which town hub the player is in
            combatState: null,
            combatTimer: null,
            lastAction: null,
            restState: {
                hpRegenTimer: null,    // ticks HP outside combat
                mpRegenTimer: null,    // ticks MP after 15s inactivity
                mpLastAction: 0        // timestamp of last attack/spell; 0 = never
            },
            sysop: {
                authenticated: false,
                username: null,
                terminalActive: false,
                commandHistory: []
            }
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PASSIVE REGENERATION SYSTEM
        //
        // HP REGEN  â€” ticks every 8s when NOT in combat.
        //             Restores 5% maxHP per tick (min 1).
        //             Stops when combat begins; resumes when it ends.
        //
        // MP REGEN  â€” single long-running interval (3s tick).
        //             In town:  ticks immediately, no inactivity wait.
        //             In field: waits 15s of no attacks/spells first.
        //             5% maxMP per tick (min 1).
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // â”€â”€ Called whenever the player fires an attack or casts a spell â”€
        function markMpAction() {
            gameState.restState.mpLastAction = Date.now();
        }

        // â”€â”€ HP regen: (re)start ticking. Safe to call multiple times â”€â”€â”€â”€
        function startHpRegen(isTown = false) {
            // Always clear and restart so rate can change (town vs field)
            if (gameState.restState.hpRegenTimer) {
                clearInterval(gameState.restState.hpRegenTimer);
                gameState.restState.hpRegenTimer = null;
            }

            const TICK_MS = isTown ? 6000 : 8000;  // town: 6s, field: 8s

            gameState.restState.hpRegenTimer = setInterval(() => {
                const p = gameState.player;
                if (!p) return;

                // Pause if in active combat
                if (gameState.combatState) return;

                // Already full
                if (p.hp >= p.maxHp) {
                    p.hp = p.maxHp;
                    updateHud();
                    _refreshTownStats();
                    return;
                }

                // 5% maxHP per tick, minimum 1
                const restore = Math.max(1, Math.ceil(p.maxHp * 0.05));
                p.hp = Math.min(p.maxHp, p.hp + restore);
                updateHud();
                _refreshTownStats();
            }, TICK_MS);
        }

        // â”€â”€ MP regen: (re)start. isTown = tick immediately, no cooldown â”€
        function startMpRegen(isTown = false) {
            // Always restart so town/field rate can differ
            if (gameState.restState.mpRegenTimer) {
                clearInterval(gameState.restState.mpRegenTimer);
                gameState.restState.mpRegenTimer = null;
            }

            // In town: reset action clock so MP ticks right away
            if (isTown) {
                gameState.restState.mpLastAction = 0;
            }

            const MP_COOLDOWN = isTown ? 0      : 15000;  // town: instant, field: 15s
            const MP_TICK_MS  = isTown ? 4000   : 3000;   // town: 4s tick, field: 3s

            gameState.restState.mpRegenTimer = setInterval(() => {
                const p = gameState.player;
                if (!p) return;
                if (p.mp >= p.maxMp) return;

                const idle = Date.now() - (gameState.restState.mpLastAction || 0);
                if (idle < MP_COOLDOWN) return;

                const restore = Math.max(1, Math.ceil(p.maxMp * 0.05));
                p.mp = Math.min(p.maxMp, p.mp + restore);
                updateHud();
                _refreshTownStats();
            }, MP_TICK_MS);
        }

        // â”€â”€ Refresh HP/MP display in the town screen (static HTML panel) â”€
        function _refreshTownStats() {
            // Only relevant when on the town screen (no terminal-mode)
            if (document.body.classList.contains('terminal-mode')) return;
            const p = gameState.player;
            if (!p) return;
            const hpEl = document.getElementById('townHp');
            const mpEl = document.getElementById('townMp');
            if (hpEl) hpEl.textContent = `${p.hp}/${p.maxHp}`;
            if (mpEl) mpEl.textContent = `${p.mp}/${p.maxMp}`;
        }

        // â”€â”€ Legacy shim â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function startResting(isTown = false) {
            startHpRegen(isTown);
        }

        // â”€â”€ Stop HP regen only (called when combat starts) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function stopResting() {
            if (gameState.restState.hpRegenTimer) {
                clearInterval(gameState.restState.hpRegenTimer);
                gameState.restState.hpRegenTimer = null;
            }
        }

        // â”€â”€ Stop both timers entirely (logout, new character, etc.) â”€â”€â”€â”€â”€
        function stopAllRegen() {
            stopResting();
            if (gameState.restState.mpRegenTimer) {
                clearInterval(gameState.restState.mpRegenTimer);
                gameState.restState.mpRegenTimer = null;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // END REGENERATION SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // ğŸ”‘ Prevent UI reset after restore (mobile fix)
gameState.hasRestoredGame = false;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SYSOP TERMINAL SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Credentials are NOT stored in plaintext.
        // Username is stored as a base64 label only.
        // Password is verified by comparing SHA-256 hashes â€” the actual
        // password never appears anywhere in this source file.
        // SHA-256 cannot be reversed without brute-force.
        const _SYS = {
            // atob('U3lzb3A=') â†’ 'Sysop'
            u: 'U3lzb3A=',
            // SHA-256 of the real password (not the password itself)
            h: '708bdb7228d3bc89a59db53a36d686bac51fba5126229428f9ea532b821e77ea'
        };

        async function _hashPassword(pw) {
            const buf  = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(pw));
            return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2,'0')).join('');
        }

        async function _checkCredentials(u, p) {
            const expectedUser = atob(_SYS.u);
            if (u !== expectedUser) return false;
            const hashed = await _hashPassword(p);
            return hashed === _SYS.h;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // FULLSCREEN + iOS INSTALL BANNER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INSTALL APP MODAL  â€” detects platform, shows tailored steps
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Detect platform
        function _getPlatform() {
            const ua = navigator.userAgent || '';
            const isStandalone = window.navigator.standalone === true ||
                                 window.matchMedia('(display-mode: standalone)').matches;
            if (isStandalone) return 'standalone';
            if (/iphone|ipad|ipod/i.test(ua)) return 'ios';
            if (/android/i.test(ua)) return 'android';
            if (/macintosh|windows|linux/i.test(ua)) return 'desktop';
            return 'unknown';
        }

        // Content for each platform
        const _installContent = {
            standalone: {
                title: 'âœ… Already Installed!',
                steps: [
                    { icon: 'ğŸ®', text: 'You\'re already running Dungeon Quest as an installed app.' },
                    { icon: 'âœ¨', text: 'Full-screen mode is active â€” enjoy your adventure!' }
                ]
            },
            ios: {
                title: 'ğŸ“± Install on iPhone / iPad',
                steps: [
                    { icon: '1ï¸âƒ£', text: 'Tap the <span class="install-highlight">â™ Share</span> button at the bottom of Safari' },
                    { icon: '2ï¸âƒ£', text: 'Scroll down and tap <span class="install-highlight">Add to Home Screen</span>' },
                    { icon: '3ï¸âƒ£', text: 'Tap <span class="install-highlight">Add</span> in the top-right corner' },
                    { icon: '4ï¸âƒ£', text: 'Open <span class="install-highlight">Dungeon Quest</span> from your home screen â€” full-screen, no browser chrome!' }
                ]
            },
            android: {
                title: 'ğŸ“± Install on Android',
                steps: [
                    { icon: '1ï¸âƒ£', text: 'Tap the <span class="install-highlight">â‹® menu</span> in the top-right of Chrome' },
                    { icon: '2ï¸âƒ£', text: 'Tap <span class="install-highlight">Add to Home screen</span> (or look for an install banner at the bottom)' },
                    { icon: '3ï¸âƒ£', text: 'Tap <span class="install-highlight">Install</span> when prompted' },
                    { icon: '4ï¸âƒ£', text: 'Open <span class="install-highlight">Dungeon Quest</span> from your home screen for full-screen play!' }
                ]
            },
            desktop: {
                title: 'ğŸ–¥ï¸ Install on Desktop',
                steps: [
                    { icon: 'ğŸŒ', text: 'In <span class="install-highlight">Chrome or Edge</span>, look for the install icon (âŠ•) in the address bar' },
                    { icon: '2ï¸âƒ£', text: 'Click <span class="install-highlight">Install</span> when prompted, or go to <span class="install-highlight">â‹® menu â†’ Install Dungeon Quest</span>' },
                    { icon: '3ï¸âƒ£', text: 'Once installed it opens in its own window without browser chrome' },
                    { icon: 'â„¹ï¸', text: 'Firefox and Safari desktop do <span class="install-highlight">not</span> support PWA install' }
                ]
            },
            unknown: {
                title: 'ğŸ“± Install Dungeon Quest',
                steps: [
                    { icon: 'ğŸ“–', text: 'Are you on <span class="install-highlight">iPhone/iPad</span>? Tap â™ Share â†’ Add to Home Screen' },
                    { icon: 'ğŸ“–', text: 'Are you on <span class="install-highlight">Android</span>? Tap â‹® menu â†’ Add to Home Screen' },
                    { icon: 'ğŸ“–', text: 'Are you on <span class="install-highlight">Desktop</span>? Look for the âŠ• install icon in your address bar' }
                ]
            }
        };

        function openInstallModal() {
            const platform = _getPlatform();
            const content  = _installContent[platform] || _installContent.unknown;

            const stepsHtml = content.steps.map(s =>
                `<div class="install-step">
                    <span class="install-icon">${s.icon}</span>${s.text}
                </div>`
            ).join('');

            document.getElementById('installModalBody').innerHTML = `
                <div style="font-size:19px;color:var(--highlight-color);margin-bottom:10px;">
                    ${content.title}
                </div>
                ${stepsHtml}
                ${platform === 'unknown' ? `
                <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;">
                    <button onclick="_showInstallFor('ios')"    style="flex:1;font-size:14px;padding:6px;">ğŸ iPhone</button>
                    <button onclick="_showInstallFor('android')" style="flex:1;font-size:14px;padding:6px;">ğŸ¤– Android</button>
                    <button onclick="_showInstallFor('desktop')" style="flex:1;font-size:14px;padding:6px;">ğŸ–¥ï¸ Desktop</button>
                </div>` : ''}
            `;

            document.getElementById('installModal').classList.add('open');
        }

        function _showInstallFor(platform) {
            const content = _installContent[platform] || _installContent.unknown;
            const stepsHtml = content.steps.map(s =>
                `<div class="install-step">
                    <span class="install-icon">${s.icon}</span>${s.text}
                </div>`
            ).join('');
            document.getElementById('installModalBody').innerHTML = `
                <div style="font-size:19px;color:var(--highlight-color);margin-bottom:10px;">
                    ${content.title}
                </div>
                ${stepsHtml}
                <button onclick="openInstallModal()" style="margin-top:10px;font-size:14px;padding:5px 10px;border-color:#555;">â† Back</button>
            `;
        }

        function closeInstallModal() {
            document.getElementById('installModal').classList.remove('open');
        }

        // Close on backdrop click
        document.getElementById('installModal').addEventListener('click', function(e) {
            if (e.target === this) closeInstallModal();
        });

        // â”€â”€ Fullscreen toggle button (â›¶) still triggers modal on iOS â”€â”€â”€â”€
        function toggleFullscreen() {
           const el = document.documentElement;
            if (!document.fullscreenElement && !document.webkitFullscreenElement &&
               !document.mozFullScreenElement) {
                const req = el.requestFullscreen || el.webkitRequestFullscreen ||
                            el.mozRequestFullScreen || el.msRequestFullscreen;
                if (req) {
                    req.call(el).catch(() => {});
                } else {
                    // iOS â€” can't programmatic fullscreen, show install modal
                    openInstallModal();
                }
            } else {
                const exit = document.exitFullscreen || document.webkitExitFullscreen ||
                             document.mozCancelFullScreen || document.msExitFullscreen;
                if (exit) exit.call(document);
            }
        }

        document.addEventListener('fullscreenchange',       _onFsChange);
        document.addEventListener('webkitfullscreenchange', _onFsChange);
        function _onFsChange() {
            const inFs = !!(document.fullscreenElement || document.webkitFullscreenElement);
            const btn = document.getElementById('fsBtn');
            if (btn) btn.textContent = inFs ? 'âŠ ' : 'â›¶';
        }

        // Toggle terminal with ~ key
        document.addEventListener('keydown', (e) => {
            if (e.key === '~' || e.key === '`') {
                e.preventDefault();
                toggleTerminal();
            }
            if (e.key === 'Escape' && gameState.sysop.terminalActive) {
                toggleTerminal();
            }
            // â”€â”€ Dungeon keyboard navigation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (gameState.dungeon && !gameState.sysop.terminalActive) {
                const tag = document.activeElement?.tagName;
                const inInput = tag === 'INPUT' || tag === 'TEXTAREA';
                if (!inInput) {
                    const arrowMap = {
                        'ArrowUp':   'n',
                        'ArrowDown': 's',
                        'ArrowLeft': 'w',
                        'ArrowRight':'e'
                    };
                    if (arrowMap[e.key]) {
                        e.preventDefault();
                        dungeonNav(arrowMap[e.key]);
                    }
                }
            }
            // â”€â”€ Combat / Explore keyboard shortcuts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Only on desktop (pointer:fine) and not in any input field
            // 1=Attack  2=Spell  3=Potion  4=Defend  5=Flee  6=Stats
            // Esc=Cancel/Back
            if (!gameState.sysop.terminalActive && gameState.combatState !== undefined) {
                const tag = document.activeElement?.tagName;
                if (tag === 'INPUT' || tag === 'TEXTAREA') return;
                const cs = gameState.combatState;
                const mode = cs ? (cs.actionMode || 'main') : null;
                // Number keys 1-9 â€” context-sensitive across all menu layers
                const numKey = parseInt(e.key, 10);   // 1-9, or NaN
                if (!isNaN(numKey) && numKey >= 1) {
                    // â”€â”€ Target selection (attack or spell aimed at a monster) â”€â”€
                    if (cs && (mode === 'target_attack' || mode === 'target_spell' || mode === 'target_staff_melee')) {
                        const idx = numKey - 1;
                        if (idx < cs.monsters.length) { e.preventDefault(); executeTargetedAction(idx); }
                        return;
                    }
                    // â”€â”€ Spell list â”€â”€
                    if (cs && mode === 'spell_list') {
                        const validSpells = (gameState.player.knownSpells || []).map(sk => ensureSpellExists(sk) || SPELLS[sk]).filter(Boolean);
                        const weapon   = WEAPONS[gameState.player.weapon];
                        const hasStaff = weapon && (weapon.name.toLowerCase().includes('staff') || weapon.baseMagicDamage > 0);
                        const idx = numKey - 1;
                        if (idx < validSpells.length) {
                            e.preventDefault();
                            selectSpell(gameState.player.knownSpells.filter(sk => (ensureSpellExists(sk)||SPELLS[sk]))[idx]);
                        } else if (hasStaff && idx === validSpells.length) {
                            e.preventDefault(); staffMeleeAttack();
                        }
                        return;
                    }
                    // â”€â”€ Attack type sub-menu â”€â”€
                    if (cs && mode === 'attack_type') {
                        if (numKey === 1) { e.preventDefault(); selectAttackType('normal'); }
                        else if (numKey === 2) { e.preventDefault(); selectAttackType('heavy'); }
                        else if (numKey === 3) {
                            const hl = cs.pipAvailable ? cs.pipAvailable.filter(x=>x).length : 0;
                            if (hl >= 3) { e.preventDefault(); selectAttackType('special'); }
                        }
                        return;
                    }
                    // â”€â”€ Main combat menu â”€â”€
                    if (cs && mode === 'main') {
                        e.preventDefault();
                        if (numKey === 1) showAttackMenu();
                        else if (numKey === 2) showSpellMenu();
                        else if (numKey === 3) showPotionMenu();
                        else if (numKey === 4) playerDefend();
                        else if (numKey === 5) attemptFlee();
                        else if (numKey === 6) printStatsToTerminal();
                        return;
                    }
                    // â”€â”€ Explore (no combat) â”€â”€
                    if (!cs) {
                        e.preventDefault();
                        if (numKey === 1) exploreLocation(gameState.currentLocation);
                        else if (numKey === 3) showPotionMenuExplore();
                        else if (numKey === 4) printStatsToTerminal();
                        else if (numKey === 5) leaveExploreToTown();
                        return;
                    }
                }
                switch (e.key) {
                    case 'Escape':
                        if (cs && mode !== 'main')          { e.preventDefault(); cancelAction(); }
                        break;
                    // Trap shortcut for hunters
                    case 't': case 'T':
                        if (cs && mode === 'main' && (gameState.player.baseClass || gameState.player.class) === 'hunter') {
                            e.preventDefault();
                            castTrap();
                        }
                        break;
                    // Attack sub-menu letter shortcuts (legacy, still work)
                    case 'n': case 'N':
                        if (cs && mode === 'attack_type')   { e.preventDefault(); selectAttackType('normal'); }
                        return;
                    case 'h': case 'H':
                        if (cs && mode === 'attack_type')   { e.preventDefault(); selectAttackType('heavy'); }
                        break;
                    case 's': case 'S':
                        if (cs && mode === 'attack_type') {
                            const hl = cs.pipAvailable ? cs.pipAvailable.filter(x=>x).length : 0;
                            if (hl >= 3) { e.preventDefault(); selectAttackType('special'); }
                        }
                        return;
                }
            }
        });

function showActionBar() {
    // No-op: body.terminal-mode CSS handles actionBar visibility
}

function hideActionBar() {
    // No-op: body.terminal-mode CSS handles actionBar visibility
}


function buildSaveSnapshot() {
    if (!gameState.player) {
        console.warn('No player state to save');
        return null;
    }

    const p = gameState.player;
    
    const snapshot = {
        version: 1,
        characterId: p.id || 'default',
        characterName: p.name,
        timestamp: Date.now(),
        lastSaved: new Date().toLocaleString(),

        player: {
            // Identity
            id: p.id || 'default',
            name: p.name,
            class: p.class,
            
            // Core stats
            level: p.level,
            xp: p.xp,
            xpToNext: p.xpToNext,
            
            // Resources
            hp: p.hp,
            maxHp: p.maxHp,
            mp: p.mp,
            maxMp: p.maxMp,
            gold: p.gold,
            bankGold: p.bankGold || 0,  // Bank storage
            
            // Legacy base stats
            strength: p.strength,
            defense: p.defense,
            magic: p.magic,
            speed: p.speed,
            
            // New stat block (if exists)
            str: p.str,
            dex: p.dex,
            con: p.con,
            wis: p.wis,
            cha: p.cha,
            lck: p.lck,
            
            // Equipment
            weapon: p.weapon,
            armor: p.armor,
            activePet: p.activePet || null,
            
            // Inventory & spells
            inventory: [...(p.inventory || [])],
            knownSpells: [...(p.knownSpells || [])],
            
            // Stat points
            statPoints: p.statPoints || 0,

            // Defeated Masters/unlocked areas
            defeatedMasters: [...(p.defeatedMasters || [])],  // Explicit copy
            unlockedAreas: [...(p.unlockedAreas || [])],
            
            // Base class (for evolution tracking)
            baseClass: p.baseClass,
            className: p.className,
            hasEvolved: p.hasEvolved,
            
            // Progression
            defeatedMasters: [...(p.defeatedMasters || [])],
            unlockedAreas: [...(p.unlockedAreas || [])],
            
            // Special flags
            godMode: p.godMode || false,

            // Portal unlock flag â€” set when player first uses town2â†’town1 portal
            portalUnlocked: p.portalUnlocked || false,

            // Achievements & runestones
            achievements: [...(p.achievements || [])],
            runestones: [...(p.runestones || [])],
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PERSISTENT DUNGEON MAPS â€” discovered rooms for all dungeons/floors
            // Structure: { dungeonKey: { floorNum: [roomIds...] } }
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            dungeonMaps: (() => {
                const maps = {};
                for (const dungeonKey in (p.dungeonMaps || {})) {
                    maps[dungeonKey] = {};
                    for (const floorNum in p.dungeonMaps[dungeonKey]) {
                        maps[dungeonKey][floorNum] = [...p.dungeonMaps[dungeonKey][floorNum]];
                    }
                }
                return maps;
            })(),

            // Persistent enemy respawn timers (survive town visits)
            dungeonTimers: (() => {
                const timers = {};
                const now = Date.now();
                for (const dk in (p.dungeonTimers || {})) {
                    const valid = (p.dungeonTimers[dk] || []).filter(e => now < e.respawnTime);
                    if (valid.length > 0) timers[dk] = valid;
                }
                return timers;
            })()
        },
        
        // Town hub the player is in
        currentTown: gameState.currentTown || 'town1',
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GENERATED WEAPONS - Save all dynamically created weapon drops
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        generatedWeapons: (() => {
            const generated = {};
            // Find all weapons in inventory that have .isDropped flag
            (p.inventory || []).forEach(itemKey => {
                const weapon = WEAPONS[itemKey];
                if (weapon && weapon.isDropped) {
                    generated[itemKey] = weapon;
                }
            });
            // Also save equipped weapon if it's generated
            if (p.weapon && WEAPONS[p.weapon]?.isDropped) {
                generated[p.weapon] = WEAPONS[p.weapon];
            }
            return generated;
        })(),
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GENERATED ARMOR - Save all dynamically created armor drops
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        generatedArmor: (() => {
            const generated = {};
            // Find all armor in inventory that have .isDropped flag
            (p.inventory || []).forEach(itemKey => {
                const armor = ARMOR[itemKey];
                if (armor && armor.isDropped) {
                    generated[itemKey] = armor;
                }
            });
            // Also save equipped armor if it's generated
            if (p.armor && ARMOR[p.armor]?.isDropped) {
                generated[p.armor] = ARMOR[p.armor];
            }
            return generated;
        })(),

        // Current location/state
        currentLocation: gameState.currentLocation,

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ACTIVE COMBAT - Save mid-fight state so enemies persist on reload
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        activeCombat: (() => {
            const cs = gameState.combatState;
            if (!cs || gameState.dungeon) return null; // Only for world exploration combat
            return {
                location: gameState.currentLocation,
                monsters: cs.monsters.map(m => ({
                    // All fields needed to fully reconstruct the enemy
                    key:         m.key,
                    name:        m.name,
                    rarity:      m.rarity,
                    rarityColor: m.rarityColor,
                    hp:          m.hp,
                    maxHp:       m.maxHp,
                    damage:      m.damage,
                    defense:     m.defense,
                    xp:          m.xp,
                    gold:        m.gold,
                    level:       m.level,
                    possibleDrops: m.possibleDrops,
                    dropRates:   m.dropRates,
                    index:       m.index
                })),
                currentTarget:   cs.currentTarget,
                enemyDelay:      cs.enemyDelay,
                enemyHits:       cs.enemyHits,
                enemyHitsLeft:   cs.enemyHitsLeft,
                // Save pip state (how many pips are ready vs cooling down)
                pipCount:        cs.pipAvailable.length,
                pipsReady:       cs.pipAvailable.map(x => x),
            };
        })(),

        // Dungeon state (if in dungeon)
        dungeon: gameState.dungeon ? {
            dungeonKey: gameState.dungeon.dungeonKey,
            floor: gameState.dungeon.floor,
            currentRoom: gameState.dungeon.currentRoom,
            discoveredRooms: [...gameState.dungeon.discoveredRooms],
            spawnedRooms: [...(gameState.dungeon.spawnedRooms || [])],
            activeEnemies: gameState.dungeon.activeEnemies.map(e => ({
                id: e.id,
                monsterId: e.monsterId,
                name: e.name,
                hp: e.hp,
                maxHp: e.maxHp,
                currentRoom: e.currentRoom,
                leash: e.leash,
                drop: e.drop || null
            })),
            defeatedEnemies: (gameState.dungeon.defeatedEnemies || []).map(e => ({
                id: e.id,
                monsterId: e.monsterId,
                name: e.name,
                currentRoom: e.currentRoom,
                leash: e.leash,
                drop: e.drop || null,
                deathTime: e.deathTime,
                respawnTime: e.respawnTime
            }))
        } : null,

        meta: {
            inDungeon: !!gameState.dungeon
        }
    };

    return snapshot;
}


function saveGame() {
    try {
        const snapshot = buildSaveSnapshot();
        if (!snapshot) return;

        const key = `dq_save_${snapshot.characterId}`;
        localStorage.setItem(key, JSON.stringify(snapshot));
        
        // Also update character list
        updateCharacterList(snapshot);

        console.log(`âœ… Game saved: ${snapshot.characterName} (${snapshot.lastSaved})`);
        
        // Show brief save confirmation
        const hud = document.getElementById('hud');
        if (hud && hud.style.display !== 'none') {
            const saveMsg = document.createElement('div');
            saveMsg.style.cssText = 'position:fixed;top:10px;right:10px;background:#0a0a0a;border:2px solid var(--text-color);padding:8px 12px;color:var(--text-color);font-size:14px;z-index:9999;';
            saveMsg.textContent = 'ğŸ’¾ Game Saved';
            document.body.appendChild(saveMsg);
            setTimeout(() => saveMsg.remove(), 2000);
        }
    } catch (e) {
        console.error('Error saving game:', e);
    }
}

function updateCharacterList(snapshot) {
    try {
        let charList = JSON.parse(localStorage.getItem('dq_character_list') || '[]');
        
        // Remove old entry for this character if exists
        charList = charList.filter(c => c.id !== snapshot.characterId);
        
        // Add new entry
        charList.push({
            id: snapshot.characterId,
            name: snapshot.characterName,
            level: snapshot.player.level,
            class: snapshot.player.class,
            timestamp: snapshot.timestamp,
            lastSaved: snapshot.lastSaved
        });
        
        // Sort by most recent
        charList.sort((a, b) => b.timestamp - a.timestamp);
        
        localStorage.setItem('dq_character_list', JSON.stringify(charList));
    } catch (e) {
        console.error('Error updating character list:', e);
    }
}

function getAllCharacters() {
    try {
        return JSON.parse(localStorage.getItem('dq_character_list') || '[]');
    } catch (e) {
        console.error('Error getting character list:', e);
        return [];
    }
}

function deleteCharacter(characterId) {
    try {
        // Remove save data
        localStorage.removeItem(`dq_save_${characterId}`);
        
        // Remove from character list
        let charList = getAllCharacters();
        charList = charList.filter(c => c.id !== characterId);
        localStorage.setItem('dq_character_list', JSON.stringify(charList));
        
        console.log(`ğŸ—‘ï¸ Deleted character: ${characterId}`);
        return true;
    } catch (e) {
        console.error('Error deleting character:', e);
        return false;
    }
}

// Auto-save on page unload
window.addEventListener('beforeunload', () => {
    saveGame();
});



        function toggleTerminal() {
            const terminal = document.getElementById('terminalContainer');
            const input = document.getElementById('terminalInput');
            
            gameState.sysop.terminalActive = !gameState.sysop.terminalActive;
            
            if (gameState.sysop.terminalActive) {
                terminal.classList.add('active');
                input.focus();
                if (!gameState.sysop.authenticated) {
                    terminalPrint('Terminal activated. Type /login <username> <password> to authenticate.', 'warning');
                }
            } else {
                terminal.classList.remove('active');
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ’ INVENTORY BUTTON LONG-PRESS â†’ SYSOP (3 seconds)
        // Works in both dungeon action bar and town menu
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let _invMenuHoldTimer = null, _invMenuFired = false;
        function _invMenuDown(e) {
            if (e.cancelable) e.preventDefault();
            _invMenuFired = false;
            _invMenuHoldTimer = setTimeout(() => {
                _invMenuHoldTimer = null;
                _invMenuFired = true;
                openSysopOverlay();
            }, POT_HOLD_MS);
        }
        function _invMenuUp() {
            if (_invMenuHoldTimer) { clearTimeout(_invMenuHoldTimer); _invMenuHoldTimer = null; }
            if (!_invMenuFired) showInventory();
            _invMenuFired = false;
        }
        function _invMenuCancel() {
            if (_invMenuHoldTimer) { clearTimeout(_invMenuHoldTimer); _invMenuHoldTimer = null; }
            _invMenuFired = false;
        }
        let _potHoldTimer  = null;
        let _potFired      = false;
        const POT_HOLD_MS  = 3000;

        function potBtnDown(e, normalFn) {
            e.preventDefault();
            _potFired = false;
            _potHoldTimer = setTimeout(() => {
                _potHoldTimer = null;
                _potFired     = true;
                openSysopOverlay();
            }, POT_HOLD_MS);
        }
        function potBtnUp(e, normalFn) {
            if (_potHoldTimer) {
                clearTimeout(_potHoldTimer);
                _potHoldTimer = null;
            }
            if (!_potFired) {
                // Normal short tap â€” call the potion menu
                if (typeof window[normalFn] === 'function') window[normalFn]();
            }
            _potFired = false;
        }
        function potBtnCancel() {
            if (_potHoldTimer) { clearTimeout(_potHoldTimer); _potHoldTimer = null; }
            _potFired = false;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ“Š PRINT STATS TO TERMINAL
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function printStatsToTerminal() {
            const p = gameState.player;
            if (!p) { termAppend('No character loaded.', 'term-error'); return; }
            termAppend('', 'term-separator');
            termAppend(`ğŸ“Š <span style="color:var(--highlight-color);">${p.name}${getRunestonePip(p)}</span> Â· Lv ${p.level} ${p.className}`, 'term-highlight');
            termAppend(`â¤ï¸ HP: <span style="color:#ff6666;">${p.hp}/${p.maxHp}</span>  âœ¨ MP: <span style="color:#4488ff;">${p.mp}/${p.maxMp}</span>`);
            termAppend(`â­ XP: ${p.xp}/${p.xpToNext}  ğŸ’° Gold: ${p.gold}g`);
            termAppend(`STR:${p.str} DEX:${p.dex} CON:${p.con} WIS:${p.wis} CHA:${p.cha} LCK:${p.lck}`, 'term-dim');
            termAppend('', 'term-separator');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â”€â”€ Quit to menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function confirmQuitToMenu() {
            if (confirm('Quit to main menu?\nUnsaved progress will be lost.')) {
                stopAllRegen();
                if (gameState.combatTimer) {
                    clearInterval(gameState.combatTimer);
                    gameState.combatTimer = null;
                }
                gameState.combatState = null;
                gameState.dungeon     = null;
                document.body.classList.remove('terminal-mode');
                showMainMenu();
            }
        }

        // â”€â”€ SYSOP overlay open / close â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function openSysopOverlay() {
            document.getElementById('sysopOverlay').classList.add('open');
            renderSysopOverlay();
        }
        function closeSysopOverlay() {
            document.getElementById('sysopOverlay').classList.remove('open');
        }

        // â”€â”€ Output log (shared with desktop terminal) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window._sysoLog = [];
        function sysoLog(msg, type = 'normal') {
            const colors = { normal:'#00FF41', error:'#ff4444', success:'#88ff88', warning:'#ff8c00' };
            window._sysoLog.push({ msg, color: colors[type] || '#00FF41' });
            if (window._sysoLog.length > 50) window._sysoLog.shift();
            terminalPrint(msg, type);   // mirror to desktop terminal
            _refreshSysoLog();
        }
        function _refreshSysoLog() {
            const el = document.getElementById('sysoLog');
            if (!el) return;
            el.innerHTML = window._sysoLog.slice(-25).map(e =>
                `<div style="color:${e.color};">${e.msg.replace(/</g,'&lt;')}</div>`
            ).join('');
            el.scrollTop = el.scrollHeight;
        }
        // Wrap executeCommand to capture output into sysoLog
        function sysoExec(cmd) {
            sysoLog(`> ${cmd}`);
            executeCommand(cmd);
            setTimeout(_refreshSysoLog, 100);
        }

        // â”€â”€ Main overlay renderer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function renderSysopOverlay() {
            const content = document.getElementById('sysopOverlayContent');
            const auth = gameState.sysop.authenticated;
            let html = `<div class="syo-log" id="sysoLog"></div>`;

            if (!auth) {
                // LOGIN SCREEN
                html += `
                <div class="syo-login-art">
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—<br>
â•‘   SYSOP  TERMINAL    â•‘<br>
â•‘   AUTHENTICATION     â•‘<br>
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                </div>
                <div class="syo-section">
                    <div class="syo-label">USERNAME</div>
                    <input class="syo-input" id="sysoUser" placeholder="sysop" autocomplete="off" autocorrect="off" spellcheck="false">
                    <div class="syo-label">PASSWORD</div>
                    <input class="syo-input" id="sysoPass" type="password" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢" autocomplete="off">
                    <div id="sysoLoginErr" style="display:none;color:#ff4444;font-family:'VT323',monospace;font-size:18px;margin:4px 0 8px;"></div>
                    <div class="syo-grid" style="margin-top:8px;">
                        <button class="syo-btn full" style="border-color:#00FF41;color:#00FF41;font-size:22px;padding:14px;"
                            onclick="sysoLogin()">âš¡ LOGIN</button>
                    </div>
                </div>`;
            } else {
                // COMMAND GRID
                const isGod = gameState.player?._godMode;
                html += `
                <div class="syo-section">
                    <div class="syo-section-title">âŒ¨ï¸ COMMAND</div>
                    <div style="display:flex;gap:6px;">
                        <input class="syo-input" id="sysocmdInput" placeholder="/help â€” type a command..." 
                            autocomplete="off" autocorrect="off" spellcheck="false" style="margin-bottom:0;font-size:18px;"
                            oninput="_sysoLiveHelp(this.value)"
                            onkeydown="if(event.key==='Enter'){const v=this.value.trim();if(v){sysoExec(v);this.value='';_sysoLiveHelp('');}}">
                        <button class="syo-btn" style="white-space:nowrap;padding:6px 10px;"
                            onclick="(function(){const v=document.getElementById('sysocmdInput')?.value?.trim();if(v){sysoExec(v);document.getElementById('sysocmdInput').value='';_sysoLiveHelp('');}})()">â–¶ RUN</button>
                    </div>
                    <div id="sysoCmdHints" style="font-family:'VT323',monospace;font-size:14px;color:#3a6a3a;padding:3px 4px 0;min-height:16px;"></div>
                </div>
                <div class="syo-section">
                    <div class="syo-section-title">ğŸ‘¤ PLAYER</div>
                    <div class="syo-grid">
                        <button class="syo-btn" onclick="sysoExec('/heal');_refreshSysoLog();">â¤ï¸ FULL HEAL</button>
                        <button class="syo-btn ${isGod?'orange':''}" onclick="sysoShowGodmode()">âš¡ GOD MODE ${isGod?'[ON]':'[OFF]'}</button>
                        <button class="syo-btn" onclick="sysoShowSub('level')">ğŸ“ˆ SET LEVEL</button>
                        <button class="syo-btn" onclick="sysoShowSub('gold')">ğŸ’° SET GOLD</button>
                    </div>
                </div>

                <div class="syo-section">
                    <div class="syo-section-title">ğŸ GIVE</div>
                    <div class="syo-grid cols3">
                        <button class="syo-btn" onclick="sysoShowGive('weapon')">âš”ï¸<br>Weapon</button>
                        <button class="syo-btn" onclick="sysoShowGive('armor')">ğŸ›¡ï¸<br>Armor</button>
                        <button class="syo-btn" onclick="sysoShowGive('item')">ğŸ§ª<br>Item</button>
                        <button class="syo-btn" onclick="sysoShowGive('spell')">ğŸ”®<br>Spell</button>
                    </div>
                </div>

                <div class="syo-section">
                    <div class="syo-section-title">ğŸ“‹ LISTS</div>
                    <div class="syo-grid">
                        <button class="syo-btn" onclick="_sysoShowListPanel('weapons')">âš”ï¸ Weapons</button>
                        <button class="syo-btn" onclick="_sysoShowListPanel('armor')">ğŸ›¡ï¸ Armor</button>
                        <button class="syo-btn" onclick="_sysoShowListPanel('monsters')">ğŸ‘¹ Monsters</button>
                        <button class="syo-btn" onclick="_sysoShowListPanel('items')">ğŸ’ Items</button>
                    </div>
                </div>

                <div class="syo-section">
                    <div class="syo-section-title">ğŸ° DUNGEON</div>
                    <div class="syo-grid">
                        <button class="syo-btn orange" onclick="sysoExec('/killmonster')">ğŸ’€ Kill Enemy</button>
                        <button class="syo-btn" onclick="sysoShowSub('teleport')">ğŸš€ Teleport</button>
                    </div>
                </div>

                <div class="syo-section">
                    <div class="syo-section-title">ğŸ› ï¸ SYSTEM</div>
                    <div class="syo-grid">
                        <button class="syo-btn" onclick="window._sysoLog=[];clearTerminal();_refreshSysoLog();">ğŸ§¹ Clear Log</button>
                        <button class="syo-btn" onclick="sysoShowSub('export')">ğŸ“¤ Export</button>
                        <button class="syo-btn" onclick="sysoExec('/help')">â“ Help</button>
                        <button class="syo-btn red" onclick="sysoLogout()">ğŸ”’ Logout</button>
                    </div>
                </div>

                <div id="sysoSub"></div>`;
            }

            content.innerHTML = html;
            _refreshSysoLog();
        }

        // â”€â”€ Login / Logout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function sysoLogin() {
            const u = (document.getElementById('sysoUser')?.value || '').trim();
            const p = (document.getElementById('sysoPass')?.value || '').trim();
            _checkCredentials(u, p).then(valid => {
                if (valid) {
                    gameState.sysop.authenticated = true;
                    gameState.sysop.username = atob(_SYS.u);
                    document.getElementById('sysopBadge')?.classList.add('active');
                    sysoLog('Authentication successful. Welcome, ' + atob(_SYS.u));
                    renderSysopOverlay();
                } else {
                    const errEl = document.getElementById('sysoLoginErr');
                    if (errEl) {
                        errEl.textContent = 'âœ— Invalid credentials';
                        errEl.style.display = 'block';
                    }
                    sysoLog('Authentication failed.', 'error');
                }
            });
        }
        function sysoLogout() {
            handleLogout();
            renderSysopOverlay();
        }

        // â”€â”€ Godmode sub-panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function sysoShowGodmode() {
            document.getElementById('sysoSub').innerHTML = `
            <div class="syo-sub">
                <div class="syo-sub-title">âš¡ GOD MODE</div>
                <div class="syo-grid">
                    <button class="syo-btn" style="border-color:#00FF41;color:#00FF41;"
                        onclick="sysoExec('/godmode on');renderSysopOverlay();">âš¡ ON</button>
                    <button class="syo-btn red"
                        onclick="sysoExec('/godmode off');renderSysopOverlay();">â›” OFF</button>
                </div>
            </div>`;
        }

        // â”€â”€ Generic sub-panel dispatcher â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function sysoShowSub(type) {
            const sub = document.getElementById('sysoSub');
            if (!sub) return;

            if (type === 'level') {
                sub.innerHTML = `
                <div class="syo-sub">
                    <div class="syo-sub-title">ğŸ“ˆ SET LEVEL (1â€“25)</div>
                    <input class="syo-input" id="sysoLvl" type="number" min="1" max="25"
                        inputmode="numeric" placeholder="e.g. 10">
                    <button class="syo-btn full" style="margin-top:4px;"
                        onclick="sysoExec('/setlevel '+document.getElementById('sysoLvl').value.trim());">âœ” CONFIRM</button>
                </div>`;
                setTimeout(() => document.getElementById('sysoLvl')?.focus(), 50);
            }

            else if (type === 'gold') {
                sub.innerHTML = `
                <div class="syo-sub">
                    <div class="syo-sub-title">ğŸ’° SET GOLD</div>
                    <input class="syo-input" id="sysoGold" type="number" min="0"
                        inputmode="numeric" placeholder="e.g. 9999">
                    <button class="syo-btn full" style="margin-top:4px;"
                        onclick="sysoExec('/setgold '+document.getElementById('sysoGold').value.trim());">âœ” CONFIRM</button>
                </div>`;
                setTimeout(() => document.getElementById('sysoGold')?.focus(), 50);
            }

            else if (type === 'teleport') {
                // List available dungeons for the dropdown
                const dungeonOptions = (typeof DUNGEONS !== 'undefined')
                    ? Object.keys(DUNGEONS).map(k => `<option value="${k}">${k}</option>`).join('')
                    : '<option value="Dungeon1">Dungeon1</option>';

                sub.innerHTML = `
                <div class="syo-sub">
                    <div class="syo-sub-title">ğŸš€ TELEPORT</div>
                    <div class="syo-grid" style="margin-bottom:8px;">
                        <button class="syo-btn" onclick="sysoExec('/teleport town1')">ğŸ˜ Silverdale</button>
                        <button class="syo-btn" onclick="sysoExec('/teleport town2')">ğŸŒ‹ Ashen Harbor</button>
                        <button class="syo-btn" onclick="sysoExec('/teleport town3')">ğŸ™ Town 3</button>
                    </div>
                    <div class="syo-label">Dungeon</div>
                    <select class="syo-input" id="sysoTpDungeon" style="font-size:18px;padding:6px;">
                        ${dungeonOptions}
                    </select>
                    <div class="syo-label">Floor (e.g. 1, 2, 3)</div>
                    <input class="syo-input" id="sysoTpF" type="number" min="1" inputmode="numeric" value="1">
                    <div class="syo-label">Room ID (e.g. R1, R57) â€” leave blank for floor start</div>
                    <input class="syo-input" id="sysoTpR" placeholder="R1" autocorrect="off" spellcheck="false"
                           style="text-transform:uppercase;">
                    <button class="syo-btn full" style="margin-top:8px;"
                        onclick="(function(){
                            const d=document.getElementById('sysoTpDungeon').value.trim();
                            const f=document.getElementById('sysoTpF').value.trim();
                            const r=document.getElementById('sysoTpR').value.trim();
                            const cmd='/teleport '+d+' f'+f+(r?' '+r.toUpperCase():'');
                            sysoExec(cmd);
                        })();">ğŸš€ GO</button>
                </div>`;
            }

            else if (type === 'export') {
                sub.innerHTML = `
                <div class="syo-sub">
                    <div class="syo-sub-title">ğŸ“¤ EXPORT</div>
                    <div class="syo-grid">
                        <button class="syo-btn" onclick="sysoExec('/export save');">ğŸ’¾ Save File</button>
                        <button class="syo-btn" onclick="sysoExec('/export stats');">ğŸ“Š Stats</button>
                    </div>
                </div>`;
            }

            sub.scrollIntoView({ behavior:'smooth', block:'nearest' });
        }

        // â”€â”€ Give item sub-panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function sysoShowGive(type) {
            if (!document.getElementById('sysopOverlay')?.classList.contains('open')) {
                openSysopOverlay();
            }
            let sub = document.getElementById('sysoSub');
            if (!sub) {
                setTimeout(() => sysoShowGive(type), 80);
                return;
            }

            let allKeys = [];
            if (type === 'weapon') allKeys = Object.keys(WEAPONS).filter(k => !WEAPONS[k].unarmed && !WEAPONS[k].isDropped);
            else if (type === 'armor')  allKeys = Object.keys(ARMOR).filter(k => !ARMOR[k].unarmored && !ARMOR[k].isDropped);
            else if (type === 'item')   allKeys = typeof ITEMS  !== 'undefined' ? Object.keys(ITEMS)  : [];
            else if (type === 'spell')  allKeys = typeof SPELLS !== 'undefined' ? Object.keys(SPELLS) : [];

            const needsQuality = type === 'weapon' || type === 'armor';
            const qualities = ['poor','normal','rare','epic','legendary','godly'];
            const db = type==='weapon' ? WEAPONS : type==='armor' ? ARMOR : type==='item' ? ITEMS : SPELLS;

            // Store for autocomplete handler
            window._sysoGiveKeys = allKeys;
            window._sysoGiveDb = db;

            const qualityHtml = needsQuality ? `
                <div class="syo-label">Quality</div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:4px;margin-bottom:6px;">
                    ${qualities.map(q => `<button class="syo-btn" id="sysoGiveQ_${q}"
                        onclick="window._sysoGiveQuality='${q}';document.querySelectorAll('[id^=sysoGiveQ_]').forEach(b=>b.style.borderColor='');this.style.borderColor='#00FF41';"
                        style="${q==='normal'?'border-color:#00FF41;':''}">${q}</button>`).join('')}
                </div>` : '';

            sub.innerHTML = `
            <div class="syo-sub">
                <div class="syo-sub-title">ğŸ GIVE ${type.toUpperCase()}</div>
                <div class="syo-label">Search (type to filter)</div>
                <input class="syo-input" id="sysoGiveSearch" placeholder="Type name or key..."
                    autocorrect="off" spellcheck="false"
                    oninput="(function(v){
                        const q=v.toLowerCase();
                        const keys=window._sysoGiveKeys||[];
                        const db=window._sysoGiveDb||{};
                        const matches=keys.filter(k=>!q||k.toLowerCase().includes(q)||(db[k]?.name||'').toLowerCase().includes(q));
                        const sel=document.getElementById('sysoGiveId');
                        if(!sel) return;
                        sel.innerHTML=matches.length===0
                            ? '<option value=\"\">No matches</option>'
                            : matches.map(k=>'<option value=\"'+k+'\">'+(db[k]?.name||k)+' ['+k+']</option>').join('');
                        document.getElementById('sysoGiveCount').textContent=matches.length+' / '+keys.length;
                    })(this.value)">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                    <div class="syo-label">Select</div>
                    <span id="sysoGiveCount" style="color:#5a8a5a;font-family:'VT323',monospace;font-size:13px;">${allKeys.length} / ${allKeys.length}</span>
                </div>
                <select class="syo-input" id="sysoGiveId" size="6" style="height:auto;">
                    ${allKeys.map(k => `<option value="${k}">${db[k]?.name||k} [${k}]</option>`).join('')}
                </select>
                ${qualityHtml}
                <button class="syo-btn full" style="margin-top:6px;" onclick="sysoExecGive('${type}');">âœ” GIVE</button>
            </div>`;

            // Default quality
            window._sysoGiveQuality = 'normal';

            sub.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            setTimeout(() => document.getElementById('sysoGiveSearch')?.focus(), 100);
        }

        function sysoExecGive(type) {
            const id  = document.getElementById('sysoGiveId')?.value;
            if (!id) { sysoLog('No item selected', 'error'); return; }
            const needsQuality = type === 'weapon' || type === 'armor';
            const q = needsQuality ? (window._sysoGiveQuality || 'normal') : '';
            const cmd = q ? `/give ${type} ${id} ${q}` : `/give ${type} ${id}`;
            sysoExec(cmd);
        }

        // â”€â”€ Live command help / autocomplete â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function _sysoLiveHelp(raw) {
            const hintsEl = document.getElementById('sysoCmdHints');
            if (!hintsEl) return;

            const input = raw.trim().toLowerCase();
            if (!input) { hintsEl.innerHTML = ''; return; }

            // â”€â”€ All available commands with signatures â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const COMMANDS = [
                { cmd: '/help',           sig: '',                            desc: 'Show all commands' },
                { cmd: '/heal',           sig: '',                            desc: 'Full heal player' },
                { cmd: '/godmode',        sig: 'on|off',                      desc: 'Toggle god mode' },
                { cmd: '/setlevel',       sig: '<1-25>',                      desc: 'Set player level' },
                { cmd: '/setgold',        sig: '<amount>',                    desc: 'Set gold amount' },
                { cmd: '/give',           sig: 'weapon|armor|item|spell <id> [quality]', desc: 'Give item to player' },
                { cmd: '/giveweapon',     sig: '<id> [quality]',              desc: 'Give weapon â€” type name to search' },
                { cmd: '/givearmor',      sig: '<id> [quality]',              desc: 'Give armor â€” type name to search' },
                { cmd: '/giveitem',       sig: '<id>',                        desc: 'Give item â€” type name to search' },
                { cmd: '/givespell',      sig: '<id>',                        desc: 'Give spell â€” type name to search' },
                { cmd: '/listweapons',    sig: '',                            desc: 'Browse all weapons' },
                { cmd: '/listarmor',      sig: '',                            desc: 'Browse all armor' },
                { cmd: '/listitems',      sig: '',                            desc: 'Browse all items' },
                { cmd: '/listmonsters',   sig: '',                            desc: 'Browse all monsters' },
                { cmd: '/teleport',       sig: 'town1|town2|town3|<dungeon> [fN] [roomId]', desc: 'Teleport anywhere' },
                { cmd: '/killmonster',    sig: '',                            desc: 'Kill current enemy' },
                { cmd: '/revealmap',      sig: '[dungeonKey]',                desc: 'Reveal dungeon map' },
                { cmd: '/unlockmaster',   sig: '<masterId>',                  desc: 'Unlock class master' },
                { cmd: '/export',         sig: 'save|stats',                  desc: 'Export data' },
            ];

            const parts = input.split(/\s+/);
            const cmdPart = parts[0];
            const argPart = parts.slice(1).join(' ');

            // â”€â”€ If first token matches a full command, show arg hints â”€â”€
            const exact = COMMANDS.find(c => c.cmd === cmdPart);
            if (exact) {
                let extraHints = '';

                // Context-aware arg autocomplete
                if ((cmdPart === '/giveweapon' || cmdPart === '/give weapon') && argPart) {
                    const q = argPart.split(' ')[0].toLowerCase();
                    const matches = Object.keys(WEAPONS).filter(k => !WEAPONS[k].unarmed && !WEAPONS[k].isDropped &&
                        (k.includes(q) || (WEAPONS[k].name||'').toLowerCase().includes(q))).slice(0,5);
                    if (matches.length) extraHints = ' â†’ ' + matches.map(k=>`<span style="color:#00FF41;cursor:pointer;" onclick="document.getElementById('sysocmdInput').value='/give weapon ${k} normal';_sysoLiveHelp('/give weapon ${k} normal');">${k}</span>`).join('  ');
                } else if ((cmdPart === '/givearmor' || cmdPart === '/give armor') && argPart) {
                    const q = argPart.split(' ')[0].toLowerCase();
                    const matches = Object.keys(ARMOR).filter(k => !ARMOR[k].unarmored && !ARMOR[k].isDropped &&
                        (k.includes(q) || (ARMOR[k].name||'').toLowerCase().includes(q))).slice(0,5);
                    if (matches.length) extraHints = ' â†’ ' + matches.map(k=>`<span style="color:#00FF41;cursor:pointer;" onclick="document.getElementById('sysocmdInput').value='/give armor ${k} normal';_sysoLiveHelp('/give armor ${k} normal');">${k}</span>`).join('  ');
                } else if ((cmdPart === '/giveitem' || cmdPart === '/give item') && argPart) {
                    const q = argPart.split(' ')[0].toLowerCase();
                    const matches = Object.keys(ITEMS||{}).filter(k => k.includes(q) || (ITEMS[k].name||'').toLowerCase().includes(q)).slice(0,5);
                    if (matches.length) extraHints = ' â†’ ' + matches.map(k=>`<span style="color:#00FF41;cursor:pointer;" onclick="document.getElementById('sysocmdInput').value='/give item ${k}';_sysoLiveHelp('/give item ${k}');">${k}</span>`).join('  ');
                } else if (cmdPart === '/teleport' && argPart) {
                    const q = argPart.toLowerCase();
                    const towns = ['town1','town2','town3'].filter(t => t.includes(q));
                    const dungeons = typeof DUNGEONS !== 'undefined' ? Object.keys(DUNGEONS).filter(k => k.toLowerCase().includes(q)) : [];
                    const all = [...towns, ...dungeons].slice(0, 6);
                    if (all.length) extraHints = ' â†’ ' + all.map(d=>`<span style="color:#00FF41;cursor:pointer;" onclick="document.getElementById('sysocmdInput').value='/teleport ${d}';_sysoLiveHelp('/teleport ${d}');">${d}</span>`).join('  ');
                } else if (cmdPart === '/setlevel' && argPart) {
                    const lvl = parseInt(argPart);
                    if (!isNaN(lvl)) extraHints = lvl < 1 || lvl > 25 ? ' <span style="color:#ff4444;">âš  Level must be 1â€“25</span>' : ` <span style="color:#00FF41;">â†’ Set level to ${lvl}</span>`;
                }

                hintsEl.innerHTML = `<span style="color:#ff8c00;">${exact.cmd}</span> <span style="color:#5a8a5a;">${exact.sig}</span>  <span style="color:#3a6a3a;">${exact.desc}</span>${extraHints}`;
                return;
            }

            // â”€â”€ Partial match â€” show suggestions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const suggestions = COMMANDS.filter(c => c.cmd.startsWith(cmdPart) || c.cmd.includes(cmdPart)).slice(0, 6);
            if (suggestions.length === 0) {
                hintsEl.innerHTML = `<span style="color:#ff4444;">Unknown command. Try /help</span>`;
                return;
            }
            hintsEl.innerHTML = suggestions.map(c =>
                `<span style="color:#ff8c00;cursor:pointer;" onclick="document.getElementById('sysocmdInput').value='${c.cmd} ';document.getElementById('sysocmdInput').focus();_sysoLiveHelp('${c.cmd} ');">${c.cmd}</span> <span style="color:#3a6a3a;">${c.desc}</span>`
            ).join('  <span style="color:#1a3a1a;">|</span>  ');
        }
        function toggleMobileSysop()   { openSysopOverlay(); }
        function renderMobileSysop()   { renderSysopOverlay(); }
        function msysopLog(msg, type)  { sysoLog(msg, type); }
        function refreshMsysopOutput() { _refreshSysoLog(); }

        function terminalPrint(message, type = 'normal') {
            const output = document.getElementById('terminalOutput');
            const line = document.createElement('div');
            line.className = `terminal-line ${type === 'error' ? 'terminal-error' : ''} ${type === 'success' ? 'terminal-success' : ''} ${type === 'warning' ? 'terminal-warning' : ''}`;
            line.textContent = message;
            output.appendChild(line);
            
            // Auto-scroll to bottom
            output.scrollTop = output.scrollHeight;
        }

        function clearTerminal() {
            document.getElementById('terminalOutput').innerHTML = '';
        }

        // Terminal input handler
        // â”€â”€ Detect touch/mobile device â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const _isMobile = () => navigator.maxTouchPoints > 0 || /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);

        // â”€â”€ Terminal command history â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let _termHistIdx = -1;

        // â”€â”€ Inline hint engine (PC only) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function _termHint(raw) {
            const hintsEl = document.getElementById('termHints');
            if (!hintsEl || _isMobile()) { if (hintsEl) hintsEl.style.display = 'none'; return; }

            const input = raw.trim();
            if (!input || !input.startsWith('/')) { hintsEl.style.display = 'none'; return; }

            const parts  = input.split(/\s+/);
            const cmd    = parts[0].toLowerCase();
            const args   = parts.slice(1);
            const argStr = args.join(' ').toLowerCase();

            const CMDS = [
                { c:'/help',          s:'',                                   d:'List all commands' },
                { c:'/heal',          s:'',                                   d:'Full heal player' },
                { c:'/godmode',       s:'on | off',                           d:'Toggle god mode' },
                { c:'/setlevel',      s:'<1â€“25>',                             d:'Set player level' },
                { c:'/setgold',       s:'<amount>',                           d:'Set gold' },
                { c:'/give',          s:'weapon|armor|item|spell <id> [quality]', d:'Give item' },
                { c:'/listweapons',   s:'',                                   d:'List all weapons' },
                { c:'/listarmor',     s:'',                                   d:'List all armor' },
                { c:'/listitems',     s:'',                                   d:'List all items' },
                { c:'/listmonsters',  s:'',                                   d:'List all monsters' },
                { c:'/teleport',      s:'town1|town2|town3|<dungeon> [fN] [roomId]', d:'Teleport anywhere' },
                { c:'/killmonster',   s:'',                                   d:'Kill current enemy' },
                { c:'/revealmap',     s:'[dungeonKey]',                       d:'Reveal dungeon map' },
                { c:'/unlockmaster',  s:'<masterId>',                         d:'Unlock class master' },
                { c:'/export',        s:'save | stats',                       d:'Export data' },
                { c:'/clear',         s:'',                                   d:'Clear terminal' },
                { c:'/logout',        s:'',                                   d:'Logout of sysop' },
            ];

            let html = '';

            // â”€â”€ Exact command match â€” show arg hints + live suggestions â”€â”€
            const exact = CMDS.find(x => x.c === cmd);
            if (exact) {
                html += `<span style="color:#ff8c00;">${exact.c}</span> <span style="color:#5a8a5a;">${exact.s}</span>  <span style="color:#3a6a3a;">${exact.d}</span>`;

                // Arg-level autocomplete
                const q = (args[0] || '').toLowerCase();
                let suggestions = [];

                if (cmd === '/give') {
                    const sub = (args[0]||'').toLowerCase();
                    const id  = (args[1]||'').toLowerCase();
                    const qual= (args[2]||'').toLowerCase();
                    if (!sub || ['weapon','armor','item','spell'].some(x=>x.startsWith(sub) && x!==sub)) {
                        suggestions = ['weapon','armor','item','spell'].filter(x=>x.startsWith(sub));
                        html += _hintRow('Subtype:', suggestions, s => `/give ${s} `);
                    } else if (sub === 'weapon' && id !== undefined) {
                        const db = Object.keys(WEAPONS).filter(k=>!WEAPONS[k].unarmed && !WEAPONS[k].isDropped);
                        suggestions = db.filter(k=>k.includes(id)||(WEAPONS[k].name||'').toLowerCase().includes(id)).slice(0,5);
                        if (suggestions.length) html += _hintRow('Weapons:', suggestions, s=>`/give weapon ${s} `, k=>WEAPONS[k]?.name);
                        if (qual !== undefined && args.length >= 3) {
                            const qs = ['poor','normal','rare','epic','legendary','godly'].filter(x=>x.startsWith(qual));
                            if (qs.length) html += _hintRow('Quality:', qs, q=>`/give weapon ${args[1]} ${q}`);
                        }
                    } else if (sub === 'armor' && id !== undefined) {
                        const db = Object.keys(ARMOR).filter(k=>!ARMOR[k].unarmored && !ARMOR[k].isDropped);
                        suggestions = db.filter(k=>k.includes(id)||(ARMOR[k].name||'').toLowerCase().includes(id)).slice(0,5);
                        if (suggestions.length) html += _hintRow('Armor:', suggestions, s=>`/give armor ${s} `, k=>ARMOR[k]?.name);
                        if (qual !== undefined && args.length >= 3) {
                            const qs = ['poor','normal','rare','epic','legendary','godly'].filter(x=>x.startsWith(qual));
                            if (qs.length) html += _hintRow('Quality:', qs, q=>`/give armor ${args[1]} ${q}`);
                        }
                    } else if (sub === 'item' && id !== undefined) {
                        const db = typeof ITEMS!=='undefined' ? Object.keys(ITEMS) : [];
                        suggestions = db.filter(k=>k.includes(id)||(ITEMS[k]?.name||'').toLowerCase().includes(id)).slice(0,5);
                        if (suggestions.length) html += _hintRow('Items:', suggestions, s=>`/give item ${s}`, k=>ITEMS[k]?.name);
                    } else if (sub === 'spell' && id !== undefined) {
                        const db = typeof SPELLS!=='undefined' ? Object.keys(SPELLS) : [];
                        suggestions = db.filter(k=>k.includes(id)||(SPELLS[k]?.name||'').toLowerCase().includes(id)).slice(0,5);
                        if (suggestions.length) html += _hintRow('Spells:', suggestions, s=>`/give spell ${s}`, k=>SPELLS[k]?.name);
                    }
                } else if (cmd === '/teleport') {
                    const towns = ['town1','town2','town3'].filter(t=>t.startsWith(q)||!q);
                    const dungeons = typeof DUNGEONS!=='undefined' ? Object.keys(DUNGEONS).filter(k=>k.toLowerCase().startsWith(q)||!q) : [];
                    const dest = [...towns, ...dungeons].slice(0,8);
                    if (dest.length && args.length <= 1) html += _hintRow('Destinations:', dest, d=>`/teleport ${d}`);
                } else if (cmd === '/setlevel' && q) {
                    const n = parseInt(q);
                    if (!isNaN(n)) html += (n<1||n>25) ? `  <span style="color:#ff4444;">âš  must be 1â€“25</span>` : `  <span style="color:#88ff88;">â†’ set to level ${n}</span>`;
                } else if (cmd === '/godmode' && q) {
                    ['on','off'].filter(x=>x.startsWith(q)).forEach(x=>{ html += `  <span class="_termFill" data-fill="/godmode ${x}" style="color:#00FF41;cursor:pointer;text-decoration:underline;">${x}</span>`; });
                } else if (cmd === '/export' && q) {
                    ['save','stats'].filter(x=>x.startsWith(q)).forEach(x=>{ html += `  <span class="_termFill" data-fill="/export ${x}" style="color:#00FF41;cursor:pointer;text-decoration:underline;">${x}</span>`; });
                }

                hintsEl.innerHTML = html;
                hintsEl.style.display = 'block';
                _bindTermFill();
                return;
            }

            // â”€â”€ Partial command â€” show matching commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const matches = CMDS.filter(x => x.c.startsWith(cmd) || (cmd.length > 1 && x.c.includes(cmd)));
            if (!matches.length) {
                hintsEl.innerHTML = `<span style="color:#ff4444;">Unknown command â€” try /help</span>`;
                hintsEl.style.display = 'block';
                return;
            }
            html = matches.map(x =>
                `<span class="_termFill" data-fill="${x.c} " style="color:#ff8c00;cursor:pointer;text-decoration:underline;">${x.c}</span><span style="color:#3a6a3a;"> ${x.d}</span>`
            ).join('  <span style="color:#1a2a1a;">Â·</span>  ');
            hintsEl.innerHTML = html;
            hintsEl.style.display = 'block';
            _bindTermFill();
        }

        function _hintRow(label, keys, fillFn, nameFn) {
            if (!keys.length) return '';
            const items = keys.map(k => {
                const name = nameFn ? nameFn(k) : null;
                const display = name ? `${k}<span style="color:#3a6a3a;"> ${name}</span>` : k;
                const fill = fillFn(k);
                return `<span class="_termFill" data-fill="${fill}" style="color:#00FF41;cursor:pointer;text-decoration:underline;white-space:nowrap;margin-right:12px;">${display}</span>`;
            }).join('');
            return `<br><span style="color:#5a8a5a;">${label}</span> ${items}`;
        }

        function _bindTermFill() {
            document.querySelectorAll('._termFill').forEach(el => {
                el.onclick = () => {
                    const inp = document.getElementById('terminalInput');
                    inp.value = el.dataset.fill;
                    inp.focus();
                    _termHint(inp.value);
                };
            });
        }

        // â”€â”€ List/Give routing: overlay on mobile, terminal print on PC â”€
        function _routeList(type) {
            if (_isMobile()) {
                _sysoShowListPanel(type);
            } else {
                // Print to terminal in a compact readable format
                const configs = {
                    weapons:  { db: WEAPONS,  filter: k=>!WEAPONS[k].unarmed&&!WEAPONS[k].isDropped, meta: (k,v)=>`Lv${v.level||'?'} DMG:${v.baseDamage||'?'}` },
                    armor:    { db: ARMOR,    filter: k=>!ARMOR[k].unarmored&&!ARMOR[k].isDropped,   meta: (k,v)=>`Lv${v.level||'?'} DEF:${v.baseDefense||'?'}` },
                    items:    { db: typeof ITEMS!=='undefined'?ITEMS:{}, filter:()=>true, meta:(k,v)=>v.type||'' },
                    monsters: { db: ENEMIES,  filter: ()=>true, meta: (k,v)=>`Lv${v.level||'?'} HP:${v.baseHp||'?'}` },
                };
                const cfg = configs[type];
                if (!cfg) return;
                const keys = Object.keys(cfg.db).filter(cfg.filter);
                terminalPrint(`â•â•â• ${type.toUpperCase()} (${keys.length}) â•â•â•`, 'warning');
                keys.forEach(k => {
                    const v = cfg.db[k];
                    terminalPrint(`  ${k.padEnd(28)} ${(v.name||k).padEnd(28)} ${cfg.meta(k,v)}`);
                });
                terminalPrint(`â•â•â• END ${type.toUpperCase()} â•â•â•`, 'warning');
            }
        }

        document.getElementById('terminalInput').addEventListener('keydown', (e) => {
            const inp = e.target;
            const hist = gameState.sysop.commandHistory || [];

            // â”€â”€ Up/Down arrow: command history â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (_termHistIdx < hist.length - 1) _termHistIdx++;
                inp.value = hist[hist.length - 1 - _termHistIdx] || '';
                _termHint(inp.value);
                return;
            }
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (_termHistIdx > 0) { _termHistIdx--; inp.value = hist[hist.length - 1 - _termHistIdx] || ''; }
                else { _termHistIdx = -1; inp.value = ''; }
                _termHint(inp.value);
                return;
            }

            // â”€â”€ Tab: autocomplete first suggestion â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (e.key === 'Tab') {
                e.preventDefault();
                const first = document.querySelector('._termFill');
                if (first) { inp.value = first.dataset.fill; _termHint(inp.value); }
                return;
            }

            // â”€â”€ Enter: execute â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (e.key === 'Enter') {
                const val = inp.value.trim();
                inp.value = '';
                _termHistIdx = -1;
                document.getElementById('termHints').style.display = 'none';
                if (val) {
                    terminalPrint(`root@dungeon:~# ${val}`, 'normal');
                    gameState.sysop.commandHistory.push(val);
                    executeCommand(val);
                }
            }
        });

        document.getElementById('terminalInput').addEventListener('input', (e) => {
            _termHistIdx = -1;
            _termHint(e.target.value);
        });

        function executeCommand(input) {
            const parts = input.split(' ');
            const command = parts[0].toLowerCase();
            const args = parts.slice(1);

            // Login command (always available)
            if (command === '/login') {
                handleLogin(args);
                return;
            }

            // Check authentication for all other commands
            if (!gameState.sysop.authenticated) {
                terminalPrint('ERROR: Authentication required. Use /login <username> <password>', 'error');
                return;
            }

            // Execute authenticated commands
            switch(command) {
                case '/help':
                    showHelp();
                    break;
                case '/logout':
                    handleLogout();
                    break;
                case '/clear':
                    clearTerminal();
                    break;
                case '/give':
                    handleGive(args);
                    break;
                case '/addmonster':
                    openAddMonsterForm();
                    break;
                case '/addweapon':
                    openAddWeaponForm();
                    break;
                case '/addarmor':
                    openAddArmorForm();
                    break;
                case '/additem':
                    openAddItemForm();
                    break;
                case '/listmonsters':
                    listMonsters();
                    break;
                case '/listweapons':
                    listWeapons();
                    break;
                case '/listarmor':
                    listArmor();
                    break;
                case '/listitems':
                    listItems();
                    break;
                case '/setlevel':
                    handleSetLevel(args);
                    break;
                case '/setgold':
                    handleSetGold(args);
                    break;
                case '/heal':
                    handleHeal();
                    break;
                case '/godmode':
                    handleGodMode(args);
                    break;
                case '/teleport':
                    handleTeleport(args);
                    break;
                case '/killmonster':
                    handleKillMonster();
                    break;
                case '/export':
                    handleExport(args);
                    break;
                case '/revealmap':
                    handleRevealMap(args);
                    break;
                case '/unlockmaster':
                    handleUnlockMaster(args);
                    break;
                default:
                    terminalPrint(`ERROR: Unknown command '${command}'. Type /help for available commands.`, 'error');
            }
        }

        function handleLogin(args) {
            if (args.length < 2) {
                terminalPrint('ERROR: Usage: /login <username> <password>', 'error');
                return;
            }
            const username = args[0];
            const password = args[1];
            const displayName = atob(_SYS.u);
            _checkCredentials(username, password).then(valid => {
                if (valid) {
                    gameState.sysop.authenticated = true;
                    gameState.sysop.username = displayName;
                    document.getElementById('sysopBadge').classList.add('active');
                    terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
                    terminalPrint('  AUTHENTICATION SUCCESSFUL', 'success');
                    terminalPrint('  Welcome, ' + displayName, 'success');
                    terminalPrint('  Type /help for available commands', 'success');
                    terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
                } else {
                    terminalPrint('ERROR: Authentication failed. Invalid credentials.', 'error');
                }
            });
        }

        function handleLogout() {
            gameState.sysop.authenticated = false;
            gameState.sysop.username = null;
            document.getElementById('sysopBadge').classList.remove('active');
            terminalPrint('Logged out. Terminal locked.', 'warning');
        }

        function showHelp() {
            terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
            terminalPrint('SYSOP COMMANDS:', 'warning');
            terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
            terminalPrint('');
            terminalPrint('AUTHENTICATION:');
            terminalPrint('  /login <user> <pass>  - Authenticate as sysop');
            terminalPrint('  /logout               - End sysop session');
            terminalPrint('');
            terminalPrint('PLAYER COMMANDS:');
            terminalPrint('  /give <type> <id> [quality]  - Give item to player');
            terminalPrint('                                 Types: weapon, armor, item, spell, runestone');
            terminalPrint('                                 Quality (optional): poor, normal, rare,');
            terminalPrint('                                           epic, legendary, godly');
            terminalPrint('                                 Examples:');
            terminalPrint('                                   /give weapon iron_sword legendary');
            terminalPrint('                                   /give armor leather_armor godly');
            terminalPrint('                                   /give runestone white');
            terminalPrint('                                   /give runestone yellow');
            terminalPrint('                                   /give runestone none  (removes all)');
            terminalPrint('                                 Runestone colors:');
            terminalPrint('                                   white, yellow, green, blue,');
            terminalPrint('                                   purple, brown, black, red');
            terminalPrint('  /setlevel <level>     - Set player level (1-25)');
            terminalPrint('                          âš¡ Level 20 triggers class evolution!');
            terminalPrint('  /setgold <amount>     - Set gold amount');
            terminalPrint('  /heal                 - Fully heal player');
            terminalPrint('  /godmode <on/off>     - Toggle invincibility');
            terminalPrint('');
            terminalPrint('GAME CONTENT:');
            terminalPrint('  /addmonster           - Add new monster (opens form)');
            terminalPrint('  /addweapon            - Add new weapon (opens form)');
            terminalPrint('  /addarmor             - Add new armor (opens form)');
            terminalPrint('  /additem              - Add new item (opens form)');
            terminalPrint('');
            terminalPrint('LISTING:');
            terminalPrint('  /listmonsters         - Show all monsters');
            terminalPrint('  /listweapons          - Show all weapons');
            terminalPrint('  /listarmor            - Show all armor');
            terminalPrint('  /listitems            - Show all items');
            terminalPrint('');
            terminalPrint('UTILITIES:');
            terminalPrint('  /teleport <dest>               - Teleport anywhere');
            terminalPrint('    /teleport town1              - Go to Silverdale');
            terminalPrint('    /teleport town2              - Go to Ashen Harbor');
            terminalPrint('    /teleport town3              - Go to Town 3');
            terminalPrint('    /teleport dungeon1           - Dungeon1 Floor 1 start');
            terminalPrint('    /teleport dungeon1 f2        - Dungeon1 Floor 2 start');
            terminalPrint('    /teleport dungeon1 f1 R57    - Dungeon1 Floor 1 Room R57');
            terminalPrint('    /teleport forest             - Any explore zone key');
            terminalPrint('  /revealmap [dungeon]     - Reveal entire dungeon map');
            terminalPrint('                             No arg = all dungeons');
            terminalPrint('                             /revealmap dungeon1');
            terminalPrint('  /unlockmaster [area|all] - Mark class master(s) as defeated');
            terminalPrint('                             and unlock the zone they guard');
            terminalPrint('                             /unlockmaster all');
            terminalPrint('                             /unlockmaster plains');
            terminalPrint('  /killmonster             - Instantly kill current enemy');
            terminalPrint('  /export <type>           - Export data (monsters/weapons/armor/items)');
            terminalPrint('  /clear                   - Clear terminal output');
            terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
        }

        function handleGive(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            if (args.length < 2) {
                terminalPrint('ERROR: Usage: /give <type> <id> [quality]', 'error');
                terminalPrint('Types: weapon, armor, item, spell', 'error');
                terminalPrint('Quality (optional, for weapons): poor, normal, rare, epic, legendary, godly', 'error');
                return;
            }

            const type = args[0].toLowerCase();
            const id = args[1].toLowerCase();
            const quality = args[2] ? args[2].toLowerCase() : null;

            switch(type) {
                case 'weapon':
                    if (WEAPONS[id]) {
                        // Check if quality was specified and is valid
                        if (quality && QUALITY_CONFIG[quality]) {
                            // Generate a weapon drop with specified quality
                            const baseWeapon = WEAPONS[id];
                            const weaponLevel = baseWeapon.level || gameState.player.level;
                            
                            // Create unique weapon ID with quality
                            const weaponId = `${id}_${quality}_sysop_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
                            
                            // Apply quality bonus (percentage-based)
                            const bonusPct = QUALITY_CONFIG[quality].bonusPct || 0;
                            const bonusDmg = Math.floor(baseWeapon.baseDamage * bonusPct);
                            const bonusMax = Math.floor((baseWeapon.maxDamage || baseWeapon.baseDamage) * bonusPct);
                            
                            // Create the quality weapon
                            const qualityWeapon = {
                                id: weaponId,
                                name: `${QUALITY_CONFIG[quality].name} ${baseWeapon.name}`,
                                baseDamage: baseWeapon.baseDamage + bonusDmg,
                                maxDamage: (baseWeapon.maxDamage || baseWeapon.baseDamage) + bonusMax,
                                baseMagicDamage: baseWeapon.baseMagicDamage || 0,
                                level: weaponLevel,
                                quality: quality,
                                modifiers: [],
                                cost: baseWeapon.cost * (QUALITY_CONFIG[quality].bonusPct + 1),
                                description: `A ${quality} quality ${baseWeapon.name}`,
                                slot: 'weapon',
                                isDropped: true, // Mark as generated
                                classRestriction: baseWeapon.classRestriction
                            };
                            
                            // Register in WEAPONS
                            WEAPONS[weaponId] = qualityWeapon;
                            
                            // Add to inventory
                            gameState.player.inventory.push(weaponId);
                            
                            terminalPrint(`SUCCESS: Gave ${quality} ${baseWeapon.name} (${qualityWeapon.baseDamage}-${qualityWeapon.maxDamage} dmg)`, 'success');
                        } else {
                            // Give base weapon without quality
                            if (!gameState.player.inventory.includes(id)) {
                                gameState.player.inventory.push(id);
                            }
                            terminalPrint(`SUCCESS: Gave weapon '${WEAPONS[id].name}' to player`, 'success');
                        }
                    } else {
                        terminalPrint(`ERROR: Weapon '${id}' not found`, 'error');
                        terminalPrint('Use /listweapons to see available weapons', 'error');
                    }
                    break;
                case 'armor':
                    if (ARMOR[id]) {
                        // Check if quality was specified and is valid
                        if (quality && QUALITY_CONFIG[quality]) {
                            // Generate armor with specified quality
                            const baseArmor = ARMOR[id];
                            const armorLevel = baseArmor.level || gameState.player.level;
                            
                            // Create unique armor ID with quality
                            const armorId = `${id}_${quality}_sysop_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
                            
                            // Apply quality bonus (percentage-based)
                            const bonusPct = QUALITY_CONFIG[quality].bonusPct || 0;
                            const bonusDef = Math.floor(baseArmor.baseDefense * bonusPct);
                            const bonusMag = Math.floor((baseArmor.baseMagicBonus || 0) * bonusPct);
                            
                            // Create the quality armor
                            const qualityArmor = {
                                id: armorId,
                                name: `${QUALITY_CONFIG[quality].name} ${baseArmor.name}`,
                                baseDefense: baseArmor.baseDefense + bonusDef,
                                baseMagicBonus: (baseArmor.baseMagicBonus || 0) + bonusMag,
                                level: armorLevel,
                                quality: quality,
                                cost: baseArmor.cost * (QUALITY_CONFIG[quality].bonusPct + 1),
                                description: `A ${quality} quality ${baseArmor.name}`,
                                slot: 'armor',
                                isDropped: true, // Mark as generated
                                classRestriction: baseArmor.classRestriction
                            };
                            
                            // Register in ARMOR
                            ARMOR[armorId] = qualityArmor;
                            
                            // Add to inventory
                            gameState.player.inventory.push(armorId);
                            
                            terminalPrint(`SUCCESS: Gave ${quality} ${baseArmor.name} (${qualityArmor.baseDefense} DEF${qualityArmor.baseMagicBonus > 0 ? `, +${qualityArmor.baseMagicBonus} MAG` : ''})`, 'success');
                        } else {
                            // Give base armor without quality
                            if (!gameState.player.inventory.includes(id)) {
                                gameState.player.inventory.push(id);
                            }
                            terminalPrint(`SUCCESS: Gave armor '${ARMOR[id].name}' to player`, 'success');
                        }
                    } else {
                        terminalPrint(`ERROR: Armor '${id}' not found`, 'error');
                        terminalPrint('Use /listarmor to see available armor', 'error');
                    }
                    break;
                case 'item':
                    if (ITEMS[id]) {
                        gameState.player.inventory.push(id); // Items can stack, so always push
                        terminalPrint(`SUCCESS: Gave item '${ITEMS[id].name}' to player`, 'success');
                    } else {
                        terminalPrint(`ERROR: Item '${id}' not found`, 'error');
                    }
                    break;
                case 'spell':
                    if (SPELLS[id]) {
                        if (!gameState.player.knownSpells.includes(id)) {
                            gameState.player.knownSpells.push(id);
                        }
                        terminalPrint(`SUCCESS: Taught spell '${SPELLS[id].name}' to player`, 'success');
                    } else {
                        terminalPrint(`ERROR: Spell '${id}' not found`, 'error');
                    }
                    break;
                case 'runestone': {
                    // Special: /give runestone none â€” clears all runestones
                    if (id === 'none' || id === 'clear' || id === 'reset') {
                        if (!gameState.player.runestones || gameState.player.runestones.length === 0) {
                            terminalPrint('Player has no runestones to remove.', 'warning');
                        } else {
                            const removed = [...gameState.player.runestones];
                            gameState.player.runestones = [];
                            // Also clear portalUnlocked since it ties to runestone travel
                            gameState.player.portalUnlocked = false;
                            saveGame();
                            terminalPrint(`SUCCESS: Removed ${removed.length} runestone(s): ${removed.join(', ')}`, 'success');
                            terminalPrint('  â†’ Portal access reset.', 'info');
                        }
                        break;
                    }
                    // Accept 'white' or 'white_runestone' â€” normalize to full key
                    const rsId = id.includes('_runestone') ? id : `${id}_runestone`;
                    if (RUNESTONES[rsId]) {
                        const rs = RUNESTONES[rsId];
                        if (!gameState.player.runestones) gameState.player.runestones = [];
                        if (!gameState.player.runestones.includes(rsId)) {
                            gameState.player.runestones.push(rsId);
                            if (!gameState.player.achievements) gameState.player.achievements = [];
                            gameState.player.achievements.push({ id: rsId, name: rs.name, earned: Date.now() });
                            terminalPrint(`SUCCESS: Gave <span style="color:${rs.color};">${rs.name}</span> to player`, 'success');
                            terminalPrint(`  â†’ "${rs.description}"`, 'info');
                            if (rs.unlocksPortal) {
                                terminalPrint(`  â†’ Portal unlocked: ${rs.unlocksPortal.from} â†” ${rs.unlocksPortal.to}`, 'success');
                            }
                            saveGame();
                        } else {
                            terminalPrint(`Player already has the ${rs.name}`, 'warning');
                        }
                    } else {
                        terminalPrint(`ERROR: Unknown runestone color '${id}'`, 'error');
                        terminalPrint('Valid colors: white, yellow, green, blue, purple, brown, black, red', 'error');
                        terminalPrint('Usage: /give runestone white   OR   /give runestone white_runestone', 'error');
                        terminalPrint('       /give runestone none    â€” removes all runestones', 'error');
                    }
                    break;
                }
                default:
                    terminalPrint(`ERROR: Invalid type '${type}'`, 'error');
            }
        }

        function handleSetLevel(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const targetLevel = parseInt(args[0]);
            if (isNaN(targetLevel) || targetLevel < 1 || targetLevel > 25) {
                terminalPrint('ERROR: Invalid level. Use 1-25', 'error');
                return;
            }

            const p = gameState.player;
            const currentLevel = p.level;
            
            // Calculate how many levels to add
            const levelsToAdd = targetLevel - currentLevel;
            
            if (levelsToAdd === 0) {
                terminalPrint(`Player is already level ${targetLevel}`, 'info');
                return;
            }
            
            // Apply level-ups manually
            for (let i = 0; i < Math.abs(levelsToAdd); i++) {
                if (levelsToAdd > 0) {
                    // Level up
                    p.level++;
                    p.maxHp += 15 + (p.con || 0);
                    p.hp = p.maxHp;
                    p.maxMp += 10;
                    p.mp = p.maxMp;
                    p.strength += 2;
                    p.defense += 2;
                    p.magic += 2;
                    p.speed += 1;
                    
                    if (p.str !== undefined) {
                        p.str++; p.dex++; p.wis++; p.cha++; p.con++; p.lck++;
                        if (p.class === 'paladin' || p.baseClass === 'paladin') { 
                            p.str++; p.wis++; 
                        }
                    }
                    
                    // Check for class evolution at 20
                    if (p.level === 20 && evolveClass(p)) {
                        const evolution = ADVANCED_CLASSES[p.baseClass];
                        terminalPrint(`âš¡ CLASS EVOLUTION! ${evolution.announcement}`, 'success');
                    }
                } else {
                    // Level down
                    p.level--;
                    p.maxHp = Math.max(20, p.maxHp - 15 - (p.con || 0));
                    p.hp = Math.min(p.hp, p.maxHp);
                    p.maxMp = Math.max(10, p.maxMp - 10);
                    p.mp = Math.min(p.mp, p.maxMp);
                    p.strength = Math.max(1, p.strength - 2);
                    p.defense = Math.max(1, p.defense - 2);
                    p.magic = Math.max(1, p.magic - 2);
                    p.speed = Math.max(1, p.speed - 1);
                    
                    if (p.str !== undefined) {
                        p.str = Math.max(1, p.str - 1);
                        p.dex = Math.max(1, p.dex - 1);
                        p.wis = Math.max(1, p.wis - 1);
                        p.cha = Math.max(1, p.cha - 1);
                        p.con = Math.max(1, p.con - 1);
                        p.lck = Math.max(1, p.lck - 1);
                    }
                }
            }
            
            // Update XP to next
            p.xpToNext = getXpToNextLevel(p.baseClass || p.class, p.level);
            p.xp = getXpForLevel(p.baseClass || p.class, p.level); // Set to start of this level
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // AUTO-UNLOCK EXPLORE ZONES (same logic as showTown)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof LOCATIONS !== 'undefined') {
                Object.keys(LOCATIONS).forEach(key => {
                    const loc = LOCATIONS[key];
                    if (key === 'town') return;
                    if (!loc.locked && loc.requiredLevel && p.level >= loc.requiredLevel) {
                        if (!p.unlockedAreas.includes(key)) {
                            p.unlockedAreas.push(key);
                            terminalPrint(`âœ“ Unlocked zone: ${loc.name}`, 'success');
                        }
                    }
                });
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // AUTO-DEFEAT CLASS MASTERS for skipped levels
            // Locked zones require a master fight â€” when /setlevel skips past
            // a master's requiredLevel, mark that master as defeated and unlock
            // the zone it guards so the player isn't permanently soft-locked.
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof CLASS_MASTERS !== 'undefined') {
                const areaOrder = ['forest', 'riverside', 'plains', 'cave', 'crypt', 'volcano'];
                Object.keys(CLASS_MASTERS).forEach(masterKey => {
                    const master = CLASS_MASTERS[masterKey];
                    // Only process masters for this player's class
                    const playerClass = p.baseClass || p.class;
                    if (!masterKey.startsWith(playerClass + '_master_')) return;
                    // If player meets or exceeds the master's required level, auto-defeat
                    if (p.level >= master.requiredLevel && !p.defeatedMasters.includes(masterKey)) {
                        p.defeatedMasters.push(masterKey);
                        terminalPrint(`âœ“ Auto-defeated master: ${master.name}`, 'success');
                        // Unlock the zone this master guards
                        if (master.unlocks && typeof LOCATIONS !== 'undefined' && LOCATIONS[master.unlocks]) {
                            if (!p.unlockedAreas.includes(master.unlocks)) {
                                p.unlockedAreas.push(master.unlocks);
                                terminalPrint(`âœ“ Unlocked zone: ${LOCATIONS[master.unlocks].name}`, 'success');
                            }
                        }
                    }
                });
            }
            
            updateHud();
            saveGame();
            terminalPrint(`SUCCESS: Set player level to ${targetLevel}`, 'success');
            
            if (p.hasEvolved) {
                terminalPrint(`Player is now a ${getAdvancedClassName(p)} with ${getClassDamageMultiplier(p)}x damage!`, 'info');
            }
        }

        function handleSetGold(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const gold = parseInt(args[0]);
            if (isNaN(gold) || gold < 0) {
                terminalPrint('ERROR: Invalid gold amount', 'error');
                return;
            }

            gameState.player.gold = gold;
            terminalPrint(`SUCCESS: Set gold to ${gold}`, 'success');
        }

        function handleHeal() {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            gameState.player.hp = gameState.player.maxHp;
            gameState.player.mp = gameState.player.maxMp;
            terminalPrint('SUCCESS: Player fully healed', 'success');
        }

        function handleGodMode(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const mode = args[0]?.toLowerCase();
            if (mode === 'on') {
                gameState.player.godMode = true;
                terminalPrint('SUCCESS: God Mode ENABLED - Player is invincible', 'success');
            } else if (mode === 'off') {
                gameState.player.godMode = false;
                terminalPrint('SUCCESS: God Mode DISABLED', 'success');
            } else {
                terminalPrint('ERROR: Usage: /godmode <on/off>', 'error');
            }
        }

        function handleTeleport(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }
            if (!args || args.length === 0) {
                terminalPrint('ERROR: Usage: /teleport <destination>', 'error');
                terminalPrint('  /teleport town1               â€” Silverdale', 'warning');
                terminalPrint('  /teleport town2               â€” Ashen Harbor', 'warning');
                terminalPrint('  /teleport town3               â€” Town 3', 'warning');
                terminalPrint('  /teleport dungeon1            â€” Dungeon1 Floor 1 start', 'warning');
                terminalPrint('  /teleport dungeon1 f2         â€” Dungeon1 Floor 2 start', 'warning');
                terminalPrint('  /teleport dungeon1 f3         â€” Dungeon1 Floor 3 start', 'warning');
                terminalPrint('  /teleport dungeon1 f1 R57     â€” Dungeon1 Floor 1 Room R57', 'warning');
                terminalPrint('  /teleport <zone>              â€” Any explore zone key', 'warning');
                return;
            }

            const dest = args[0].toLowerCase();

            // â”€â”€ Town teleport â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (dest === 'town1' || dest === 'town2' || dest === 'town3') {
                // Clear any dungeon/combat state
                gameState.dungeon = null;
                gameState.combatState = null;
                if (gameState.combatTimer) { clearInterval(gameState.combatTimer); gameState.combatTimer = null; }
                document.body.classList.remove("terminal-mode");
                document.getElementById('actionBar').innerHTML = '';
                gameState._terminalOpen = false;
                gameState._currentExploreArea = null;
                gameState.currentTown = dest;
                saveGame();
                showTown(dest);
                const tname = (typeof TOWNS !== 'undefined' && TOWNS[dest]) ? TOWNS[dest].name : dest;
                terminalPrint(`SUCCESS: Teleported to ${tname}`, 'success');
                return;
            }

            // â”€â”€ Dungeon teleport: /teleport dungeon1 [fN] [RoomId] â”€â”€â”€â”€â”€â”€â”€â”€
            // Match dungeon key case-insensitively
            const dungeonKey = (() => {
                if (typeof DUNGEONS === 'undefined') return null;
                for (const k in DUNGEONS) {
                    if (k.toLowerCase() === dest) return k;
                }
                return null;
            })();

            if (dungeonKey) {
                if (typeof DUNGEONS === 'undefined' || !DUNGEONS[dungeonKey]) {
                    terminalPrint(`ERROR: Dungeon "${dungeonKey}" not loaded`, 'error');
                    return;
                }
                const dungeonData = DUNGEONS[dungeonKey];

                // Parse floor: second arg like "f2" or "2"
                let targetFloor = 1;
                if (args[1]) {
                    const floorStr = args[1].replace(/^f/i, '');
                    const parsed = parseInt(floorStr);
                    if (!isNaN(parsed) && dungeonData.floors[parsed]) {
                        targetFloor = parsed;
                    } else {
                        terminalPrint(`ERROR: Floor "${args[1]}" not found in ${dungeonKey}`, 'error');
                        terminalPrint(`Available floors: ${Object.keys(dungeonData.floors).map(f=>'F'+f).join(', ')}`, 'warning');
                        return;
                    }
                }

                const floorData = dungeonData.floors[targetFloor];

                // Parse room: third arg like "R57"
                let targetRoom = floorData.startRoom;
                if (args[2]) {
                    const roomId = args[2].toUpperCase();
                    if (floorData.rooms[roomId]) {
                        targetRoom = roomId;
                    } else {
                        // Try lowercase
                        const found = Object.keys(floorData.rooms).find(k => k.toUpperCase() === roomId);
                        if (found) {
                            targetRoom = found;
                        } else {
                            terminalPrint(`ERROR: Room "${args[2]}" not found on Floor ${targetFloor}`, 'error');
                            const roomList = Object.keys(floorData.rooms).join(', ');
                            terminalPrint(`Floor ${targetFloor} rooms: ${roomList}`, 'warning');
                            return;
                        }
                    }
                }

                // â”€â”€ Actually teleport into dungeon â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // Clear any current dungeon/combat/explore state
                gameState.combatState = null;
                if (gameState.combatTimer) { clearInterval(gameState.combatTimer); gameState.combatTimer = null; }
                gameState._terminalOpen = false;
                gameState._currentExploreArea = null;

                // Mark room as discovered
                const destRoom = floorData.rooms[targetRoom];
                destRoom.flags = destRoom.flags || {};
                destRoom.flags.discovered = true;

                // Load persistent map and add target room
                const persistentMap = loadDungeonMap(gameState.player, dungeonKey, targetFloor);
                const scopedTargetRoom = `${targetFloor}:${targetRoom}`;
                persistentMap.add(scopedTargetRoom);
                saveRoomDiscovery(gameState.player, dungeonKey, targetFloor, targetRoom);

                gameState.dungeon = {
                    dungeonKey,
                    floor:          targetFloor,
                    currentRoom:    targetRoom,
                    discoveredRooms: persistentMap, // Load from persistent map
                    activeEnemies: []
                };

                // Show terminal
                /* mainScreen hidden by terminal-mode CSS class */
                openTerminalView(dungeonKey);
                startMpRegen(false);
                startResting(false);

                termAppend('', 'term-separator');
                termAppend(`ğŸ”® <span style="color:#AA88FF;">[SYSOP TELEPORT]</span> Floor ${targetFloor} â€” ${targetRoom}`, 'term-highlight');
                termAppend(`<strong>${destRoom.name || targetRoom}</strong>`);
                termAppend(destRoom.description || '', 'term-dim');
                const exitList = buildExitList(destRoom);
                termAppend(`You see exits: ${exitList}.`, 'term-dim');
                checkTownExit(destRoom);

                saveGame();
                renderDungeonActionBar();

                terminalPrint(`SUCCESS: Teleported to ${dungeonKey} Floor ${targetFloor} Room ${targetRoom}`, 'success');
                return;
            }

            // â”€â”€ Exploration zone teleport â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (typeof LOCATIONS !== 'undefined' && LOCATIONS[dest]) {
                gameState.dungeon = null;
                gameState.combatState = null;
                if (gameState.combatTimer) { clearInterval(gameState.combatTimer); gameState.combatTimer = null; }
                gameState.currentLocation = dest;
                gameState._terminalOpen = false;
                exploreLocation(dest);
                terminalPrint(`SUCCESS: Teleported to ${LOCATIONS[dest].name}`, 'success');
                return;
            }

            // â”€â”€ Nothing matched â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            terminalPrint(`ERROR: Unknown destination "${dest}"`, 'error');
            terminalPrint('Valid towns: town1, town2', 'warning');
            if (typeof DUNGEONS !== 'undefined') {
                terminalPrint('Valid dungeons: ' + Object.keys(DUNGEONS).map(k=>k.toLowerCase()).join(', '), 'warning');
            }
            if (typeof LOCATIONS !== 'undefined') {
                terminalPrint('Valid zones: ' + Object.keys(LOCATIONS).filter(k=>k!=='town').join(', '), 'warning');
            }
        }

        function handleKillMonster() {
            if (!gameState.combatState) {
                terminalPrint('ERROR: Not in combat', 'error');
                return;
            }

            gameState.combatState.enemy.hp = 0;
            terminalPrint('SUCCESS: Enemy eliminated', 'success');
            checkCombatEnd();
        }

        function handleRevealMap(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }
            
            if (typeof DUNGEONS === 'undefined') {
                terminalPrint('ERROR: DUNGEONS not loaded', 'error');
                return;
            }
            
            const p = gameState.player;
            let targetDungeons = [];
            
            // If dungeon specified, reveal only that one
            if (args && args.length > 0) {
                const dungeonKey = args[0];
                // Match case-insensitively
                const matched = Object.keys(DUNGEONS).find(k => k.toLowerCase() === dungeonKey.toLowerCase());
                if (!matched) {
                    terminalPrint(`ERROR: Dungeon "${dungeonKey}" not found`, 'error');
                    terminalPrint(`Available dungeons: ${Object.keys(DUNGEONS).join(', ')}`, 'warning');
                    return;
                }
                targetDungeons = [matched];
            } else {
                // No arg = reveal ALL dungeons
                targetDungeons = Object.keys(DUNGEONS);
            }
            
            let totalRooms = 0;
            let totalFloors = 0;
            
            targetDungeons.forEach(dungeonKey => {
                const dungeon = DUNGEONS[dungeonKey];
                
                Object.keys(dungeon.floors).forEach(floorNum => {
                    const floor = dungeon.floors[floorNum];
                    totalFloors++;
                    
                    // Reveal all rooms on this floor
                    Object.keys(floor.rooms).forEach(roomId => {
                        const room = floor.rooms[roomId];
                        if (room.map) { // Only rooms with map coordinates
                            saveRoomDiscovery(p, dungeonKey, parseInt(floorNum), roomId);
                            totalRooms++;
                        }
                    });
                });
            });
            
            // If currently in a dungeon, reload the persistent map for active floor
            if (gameState.dungeon) {
                const ds = gameState.dungeon;
                ds.discoveredRooms = loadDungeonMap(p, ds.dungeonKey, ds.floor);
            }
            
            saveGame();
            
            terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
            terminalPrint('  MAP REVEAL COMPLETE', 'success');
            terminalPrint(`  Dungeons: ${targetDungeons.join(', ')}`, 'success');
            terminalPrint(`  Floors revealed: ${totalFloors}`, 'success');
            terminalPrint(`  Rooms revealed: ${totalRooms}`, 'success');
            terminalPrint('  Open dungeon map to see all rooms', 'success');
            terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // /unlockmaster [area|all]
        // Marks class masters as defeated and unlocks the zones they guard.
        // Usage:
        //   /unlockmaster all        â€” unlock every master for this class
        //   /unlockmaster forest     â€” unlock the master tied to "forest"
        //   /unlockmaster plains     â€” unlock the master tied to "plains"
        //   (etc. for cave, crypt, volcano, riverside)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function handleUnlockMaster(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }
            if (typeof CLASS_MASTERS === 'undefined') {
                terminalPrint('ERROR: CLASS_MASTERS not loaded', 'error');
                return;
            }

            const p = gameState.player;
            const playerClass = p.baseClass || p.class;
            const target = args[0] ? args[0].toLowerCase() : 'all';

            let unlocked = 0;

            Object.keys(CLASS_MASTERS).forEach(masterKey => {
                // Only this class's masters
                if (!masterKey.startsWith(playerClass + '_master_')) return;

                // Filter by specific area if requested
                if (target !== 'all') {
                    if (!masterKey.endsWith('_' + target)) return;
                }

                const master = CLASS_MASTERS[masterKey];

                if (p.defeatedMasters.includes(masterKey)) {
                    terminalPrint(`  (already defeated: ${master.name})`, 'info');
                    return;
                }

                p.defeatedMasters.push(masterKey);
                terminalPrint(`âœ“ Defeated master: ${master.name}`, 'success');
                unlocked++;

                // Unlock the zone this master guards
                if (master.unlocks && typeof LOCATIONS !== 'undefined' && LOCATIONS[master.unlocks]) {
                    if (!p.unlockedAreas.includes(master.unlocks)) {
                        p.unlockedAreas.push(master.unlocks);
                        terminalPrint(`âœ“ Unlocked zone: ${LOCATIONS[master.unlocks].name}`, 'success');
                    } else {
                        terminalPrint(`  (zone already unlocked: ${LOCATIONS[master.unlocks].name})`, 'info');
                    }
                }
            });

            if (unlocked === 0 && target !== 'all') {
                terminalPrint(`ERROR: No undefeated master found for area "${target}" and class "${playerClass}"`, 'error');
                terminalPrint(`Valid areas: forest, riverside, plains, cave, crypt, volcano`, 'warning');
                return;
            }

            saveGame();
            terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
            terminalPrint(`  ${unlocked} master(s) unlocked. Re-open Explore to see zones.`, 'success');
            terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
        }

        function listMonsters() { _routeList('monsters'); }
        function listWeapons()  { _routeList('weapons');  }
        function listArmor()    { _routeList('armor');    }
        function listItems()    { _routeList('items');    }

        function _sysoShowListPanel(type) {
            // Ensure the sysop overlay is open and rendered
            if (!document.getElementById('sysopOverlay')?.classList.contains('open')) {
                openSysopOverlay();
            }
            // sysoSub may not exist yet if overlay just opened â€” give it a tick
            let sub = document.getElementById('sysoSub');
            if (!sub) {
                setTimeout(() => _sysoShowListPanel(type), 80);
                return;
            }

            const configs = {
                weapons:  { title: 'âš”ï¸ WEAPONS',  icon: 'âš”ï¸', db: () => WEAPONS, filter: k => !WEAPONS[k].unarmed && !WEAPONS[k].isDropped,
                            meta: (k,v) => `Lv${v.level||'?'} | DMG:${v.baseDamage||v.damage||'?'}`, desc: (k,v) => v.description||'' },
                armor:    { title: 'ğŸ›¡ï¸ ARMOR',    icon: 'ğŸ›¡ï¸', db: () => ARMOR,   filter: k => !ARMOR[k].unarmored && !ARMOR[k].isDropped,
                            meta: (k,v) => `Lv${v.level||'?'} | DEF:${v.baseDefense||v.defense||'?'}`, desc: (k,v) => v.description||'' },
                items:    { title: 'ğŸ’ ITEMS',    icon: 'ğŸ’', db: () => (typeof ITEMS!=='undefined'?ITEMS:{}), filter: ()=>true,
                            meta: (k,v) => v.type||'', desc: (k,v) => v.description||'' },
                monsters: { title: 'ğŸ‘¹ MONSTERS', icon: 'ğŸ‘¹', db: () => ENEMIES,  filter: ()=>true,
                            meta: (k,v) => `Lv${v.level||'?'} | HP:${v.baseHp||v.hp||'?'}`, desc: (k,v) => v.description||'' },
            };
            const cfg = configs[type];
            if (!cfg) return;

            const db = cfg.db();
            const allKeys = Object.keys(db).filter(cfg.filter);

            const renderRows = (filter) => {
                const q = filter.toLowerCase();
                const matches = allKeys.filter(k => {
                    if (!q) return true;
                    const v = db[k];
                    return k.toLowerCase().includes(q) || (v.name||'').toLowerCase().includes(q) || (v.description||'').toLowerCase().includes(q);
                });
                const countEl = document.getElementById('sysoListCount');
                if (countEl) countEl.textContent = `${matches.length} / ${allKeys.length} entries`;
                const body = document.getElementById('sysoListBody');
                if (!body) return;
                if (matches.length === 0) {
                    body.innerHTML = `<div style="color:#5a8a5a;font-family:'VT323',monospace;padding:10px;">No matches for "${filter}"</div>`;
                    return;
                }
                body.innerHTML = matches.map(k => {
                    const v = db[k];
                    const name = v.name || k;
                    const meta = cfg.meta(k, v);
                    const desc = cfg.desc(k, v);
                    // Clicking a list row copies the key into the give panel or fills the search
                    const clickable = (type !== 'monsters')
                        ? `onclick="document.getElementById('sysoListSearch').value='${k}';document.getElementById('sysoListSearch').dispatchEvent(new Event('input'));"`
                        : '';
                    return `<div class="syo-list-row" ${clickable}>
                        <div class="syo-list-key">${k}</div>
                        <div class="syo-list-name">${name}${desc ? `<br><span style="color:#3a6a3a;font-size:13px;">${desc}</span>` : ''}</div>
                        <div class="syo-list-meta">${meta}</div>
                    </div>`;
                }).join('');
            };

            sub.innerHTML = `
            <div class="syo-list-panel">
                <div style="padding:8px 8px 0;display:flex;justify-content:space-between;align-items:center;">
                    <span style="color:#ff8c00;font-family:'VT323',monospace;font-size:18px;">${cfg.title}</span>
                    <span class="syo-list-count" id="sysoListCount">${allKeys.length} entries</span>
                </div>
                <div class="syo-list-search">
                    <input id="sysoListSearch" placeholder="ğŸ” Filter by name, key, or description..." autocorrect="off" spellcheck="false"
                        oninput="(function(v){
                            const db=window._sysoListDb; const cfg=window._sysoListCfg;
                            if(!db||!cfg) return;
                            const q=v.toLowerCase();
                            const allKeys=Object.keys(db).filter(cfg.filter);
                            const matches=allKeys.filter(k=>!q||k.toLowerCase().includes(q)||(db[k].name||'').toLowerCase().includes(q)||(db[k].description||'').toLowerCase().includes(q));
                            document.getElementById('sysoListCount').textContent=matches.length+' / '+allKeys.length+' entries';
                            document.getElementById('sysoListBody').innerHTML=matches.length===0
                                ? '<div style=\"color:#5a8a5a;font-family:VT323,monospace;padding:10px;\">No matches</div>'
                                : matches.map(k=>{
                                    const v=db[k];
                                    return '<div class=\"syo-list-row\"><div class=\"syo-list-key\">'+k+'</div><div class=\"syo-list-name\">'+(v.name||k)+(v.description?'<br><span style=\"color:#3a6a3a;font-size:13px;\">'+v.description+'</span>':'')+'</div><div class=\"syo-list-meta\">'+cfg.meta(k,v)+'</div></div>';
                                }).join('');
                        })(this.value)">
                </div>
                <div class="syo-list-body" id="sysoListBody"></div>
            </div>`;

            // Store db and cfg on window for the inline oninput handler
            window._sysoListDb = db;
            window._sysoListCfg = cfg;

            renderRows('');
            sub.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            setTimeout(() => document.getElementById('sysoListSearch')?.focus(), 100);
        }

        function openAddMonsterForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW MONSTER</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Monster ID (lowercase, underscores):</label>
                    <input type="text" id="monsterId" placeholder="fire_dragon">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="monsterName" placeholder="Fire Dragon">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">HP:</label>
                    <input type="number" id="monsterHp" value="100">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Damage:</label>
                    <input type="number" id="monsterDamage" value="20">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Defense:</label>
                    <input type="number" id="monsterDefense" value="10">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">XP Reward:</label>
                    <input type="number" id="monsterXp" value="100">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Gold Reward:</label>
                    <input type="number" id="monsterGold" value="80">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level:</label>
                    <input type="number" id="monsterLevel" value="5">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="monsterDesc" placeholder="A fearsome creature">
                </div>
                <button onclick="submitAddMonster()">ADD MONSTER</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddMonster() {
            const id = document.getElementById('monsterId').value.trim().toLowerCase();
            const name = document.getElementById('monsterName').value.trim();
            const hp = parseInt(document.getElementById('monsterHp').value);
            const damage = parseInt(document.getElementById('monsterDamage').value);
            const defense = parseInt(document.getElementById('monsterDefense').value);
            const xp = parseInt(document.getElementById('monsterXp').value);
            const gold = parseInt(document.getElementById('monsterGold').value);
            const level = parseInt(document.getElementById('monsterLevel').value);
            const description = document.getElementById('monsterDesc').value.trim();

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            ENEMIES[id] = {
                name: name,
                hp: hp,
                damage: damage,
                defense: defense,
                xp: xp,
                gold: gold,
                level: level,
                description: description
            };

            closeModal();
            terminalPrint(`SUCCESS: Added monster '${name}' with ID '${id}'`, 'success');
            terminalPrint('Remember to add it to a location\'s encounter list!', 'warning');
        }

        function openAddWeaponForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW WEAPON</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Weapon ID:</label>
                    <input type="text" id="weaponId" placeholder="flame_sword">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="weaponName" placeholder="Flame Sword">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Damage:</label>
                    <input type="number" id="weaponDamage" value="30">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Magic Damage:</label>
                    <input type="number" id="weaponMagic" value="10">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Cost:</label>
                    <input type="number" id="weaponCost" value="200">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level Requirement:</label>
                    <input type="number" id="weaponLevel" value="5">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="weaponDesc" placeholder="A blazing weapon">
                </div>
                <button onclick="submitAddWeapon()">ADD WEAPON</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddWeapon() {
            const id = document.getElementById('weaponId').value.trim().toLowerCase();
            const name = document.getElementById('weaponName').value.trim();
            const damage = parseInt(document.getElementById('weaponDamage').value);
            const magicDamage = parseInt(document.getElementById('weaponMagic').value);
            const cost = parseInt(document.getElementById('weaponCost').value);
            const level = parseInt(document.getElementById('weaponLevel').value);
            const description = document.getElementById('weaponDesc').value.trim();

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            WEAPONS[id] = {
                name: name,
                damage: damage,
                magicDamage: magicDamage,
                cost: cost,
                level: level,
                description: description
            };

            closeModal();
            terminalPrint(`SUCCESS: Added weapon '${name}' with ID '${id}'`, 'success');
        }

        function openAddArmorForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW ARMOR</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Armor ID:</label>
                    <input type="text" id="armorId" placeholder="dragon_mail">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="armorName" placeholder="Dragon Mail">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Defense:</label>
                    <input type="number" id="armorDefense" value="25">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Magic Bonus:</label>
                    <input type="number" id="armorMagic" value="0">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Cost:</label>
                    <input type="number" id="armorCost" value="300">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level Requirement:</label>
                    <input type="number" id="armorLevel" value="6">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="armorDesc" placeholder="Strong protective armor">
                </div>
                <button onclick="submitAddArmor()">ADD ARMOR</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddArmor() {
            const id = document.getElementById('armorId').value.trim().toLowerCase();
            const name = document.getElementById('armorName').value.trim();
            const defense = parseInt(document.getElementById('armorDefense').value);
            const magicBonus = parseInt(document.getElementById('armorMagic').value);
            const cost = parseInt(document.getElementById('armorCost').value);
            const level = parseInt(document.getElementById('armorLevel').value);
            const description = document.getElementById('armorDesc').value.trim();

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            ARMOR[id] = {
                name: name,
                defense: defense,
                magicBonus: magicBonus,
                cost: cost,
                level: level,
                description: description
            };

            closeModal();
            terminalPrint(`SUCCESS: Added armor '${name}' with ID '${id}'`, 'success');
        }

        function openAddItemForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW ITEM</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Item ID:</label>
                    <input type="text" id="itemId" placeholder="super_potion">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="itemName" placeholder="Super Potion">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Type:</label>
                    <select id="itemType" style="width: 100%; background: var(--secondary-bg); color: var(--text-color); border: 2px solid var(--border-color); padding: 10px; font-family: 'VT323', monospace; font-size: 18px;">
                        <option value="consumable">Consumable</option>
                        <option value="quest">Quest</option>
                        <option value="permanent">Permanent</option>
                        <option value="utility">Utility</option>
                        <option value="passive">Passive</option>
                    </select>
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Subtype:</label>
                    <input type="text" id="itemSubtype" placeholder="heal_hp">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Power:</label>
                    <input type="number" id="itemPower" value="50">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Cost:</label>
                    <input type="number" id="itemCost" value="30">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level:</label>
                    <input type="number" id="itemLevel" value="1">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="itemDesc" placeholder="Restores HP">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">
                        <input type="checkbox" id="itemStackable" checked> Stackable
                    </label>
                </div>
                <button onclick="submitAddItem()">ADD ITEM</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddItem() {
            const id = document.getElementById('itemId').value.trim().toLowerCase();
            const name = document.getElementById('itemName').value.trim();
            const type = document.getElementById('itemType').value;
            const subtype = document.getElementById('itemSubtype').value.trim();
            const power = parseInt(document.getElementById('itemPower').value);
            const cost = parseInt(document.getElementById('itemCost').value);
            const level = parseInt(document.getElementById('itemLevel').value);
            const description = document.getElementById('itemDesc').value.trim();
            const stackable = document.getElementById('itemStackable').checked;

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            ITEMS[id] = {
                name: name,
                type: type,
                subtype: subtype,
                power: power,
                cost: cost,
                level: level,
                description: description,
                stackable: stackable
            };

            closeModal();
            terminalPrint(`SUCCESS: Added item '${name}' with ID '${id}'`, 'success');
        }

        function closeModal() {
            document.getElementById('modalOverlay').classList.remove('active');
        }

        function handleExport(args) {
            const type = args[0]?.toLowerCase();
            let data;
            let filename;

            switch(type) {
                case 'monsters':
                    data = JSON.stringify(ENEMIES, null, 2);
                    filename = 'monsters.json';
                    break;
                case 'weapons':
                    data = JSON.stringify(WEAPONS, null, 2);
                    filename = 'weapons.json';
                    break;
                case 'armor':
                    data = JSON.stringify(ARMOR, null, 2);
                    filename = 'armor.json';
                    break;
                case 'items':
                    data = JSON.stringify(ITEMS, null, 2);
                    filename = 'items.json';
                    break;
                default:
                    terminalPrint('ERROR: Usage: /export <monsters/weapons/armor/items>', 'error');
                    return;
            }

            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);

            terminalPrint(`SUCCESS: Exported ${type} to ${filename}`, 'success');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CLASS-SPECIFIC XP TABLES (Levels 1-25)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â”€â”€ XP TABLES (levels 1-25) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Calibrated against actual monster XP output per zone:
        //   Zone1 (Lv1-2 mobs, ~22 xp avg) â†’ Lv1-3: ~50-80 kills each
        //   Zone2 unlocks Lv4 (~62 xp avg) â†’ Lv4-5: ~80 kills each
        //   Zone3 unlocks Lv6 (~105 xp avg) â†’ Lv6-9: ~80-85 kills each
        //   Zone4 unlocks Lv10 (~211 xp avg) â†’ Lv10-15: ~85 kills each
        //   Zone5 unlocks Lv13, Zone6 Lv16, Zone7 Lv19, Zone8 Lv22
        // Lv1â†’2 and Lv2â†’3 kept at original values (already fair).
        // Lv3 onward: cut to match real kill counts (old table was 8-10x too high).

        // Base table (warrior/paladin/archer/hunter â€” standard speed)
        const _BASE_XP = [
              0,    1125,    3240,    5000,    9960,
          15720,   24120,   33400,   45320,   57985,
          75920,   98275,  123350,  153100,  187100,
         226520,  290150,  355940,  466190,  561950,
         699700,  817500,  975200, 1160100, 1370300
        ];

        // Class XP multipliers (higher = needs more XP per level = slower)
        // Applied to every threshold from Lv3 onward (Lv1-2 stay identical)
        const _XP_MULT = {
            warrior:  1.00,
            paladin:  1.00,
            archer:   1.00,
            hunter:   1.00,
            ranger:   1.00,
            rogue:    0.93,   // rogues level slightly faster
            acolyte:  1.08,   // casters slightly slower (AOE advantage)
            necrolyte:1.08,
            druid:    1.08,
            sorceror: 1.08,
            mage:     1.05,
            cleric:   1.00,
            warlock:  1.05,
            runesmith:1.02,
        };

        function _buildXpTable(cls) {
            const mult = _XP_MULT[cls] || 1.00;
            return _BASE_XP.map((v, i) => {
                if (i <= 2) return v;          // Lv1-3 thresholds unchanged
                return Math.round(v * mult);
            });
        }

        const XP_TABLES = {
            warrior:   _buildXpTable('warrior'),
            paladin:   _buildXpTable('paladin'),
            archer:    _buildXpTable('archer'),
            hunter:    _buildXpTable('hunter'),
            ranger:    _buildXpTable('ranger'),
            rogue:     _buildXpTable('rogue'),
            acolyte:   _buildXpTable('acolyte'),
            necrolyte: _buildXpTable('necrolyte'),
            druid:     _buildXpTable('druid'),
            sorceror:  _buildXpTable('sorceror'),
            mage:      _buildXpTable('mage'),
            cleric:    _buildXpTable('cleric'),
            warlock:   _buildXpTable('warlock'),
            runesmith: _buildXpTable('runesmith'),
        };
        
        function getXpForLevel(playerClass, level) {
            const table = XP_TABLES[playerClass] || XP_TABLES.warrior;
            if (level < 1) return 0;
            if (level > 25) return table[24]; // Max at level 25
            return table[level - 1];
        }
        
        function getXpToNextLevel(playerClass, currentLevel) {
            if (currentLevel >= 25) return 999999999; // Max level
            return getXpForLevel(playerClass, currentLevel + 1);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // END XP TABLES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        window.submitAddMonster = submitAddMonster;
        window.submitAddWeapon = submitAddWeapon;
        window.submitAddArmor = submitAddArmor;
        window.submitAddItem = submitAddItem;
        window.closeModal = closeModal;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // END SYSOP TERMINAL SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•





        // Initialize Game
        function initGame() {
            try {
                // Try to auto-restore character (especially important for dungeons!)
                const characters = getAllCharacters();
                
                if (characters.length > 0) {
                    // Check if any character is currently in a dungeon
                    let dungeonChar = null;
                    try {
                        dungeonChar = characters.find(char => {
                            try {
                                const saveData = localStorage.getItem(`dq_save_${char.id}`);
                                if (saveData) {
                                    const data = JSON.parse(saveData);
                                    return data.meta?.inDungeon === true;
                                }
                            } catch (e) {
                                console.error(`Corrupted save for ${char.id}:`, e);
                                // Delete corrupted save
                                localStorage.removeItem(`dq_save_${char.id}`);
                            }
                            return false;
                        });
                    } catch (e) {
                        console.error('Error checking for dungeon characters:', e);
                    }
                    
                    if (dungeonChar) {
                        // Auto-load character that was in a dungeon (prevent cheating!)
                        console.log('ğŸ° Auto-restoring dungeon session:', dungeonChar.name);
                        try {
                            loadCharacter(dungeonChar.id);
                            return;
                        } catch (e) {
                            console.error('Failed to load dungeon character:', e);
                            alert('âš ï¸ Your dungeon save was corrupted. Returning to main menu.');
                            // Delete corrupted save and continue to main menu
                            deleteCharacter(dungeonChar.id);
                        }
                    }
                    
                    // If single character and not in dungeon, auto-load for convenience
                    if (characters.length === 1) {
                        console.log('Auto-loading single character:', characters[0].name);
                        try {
                            loadCharacter(characters[0].id);
                            return;
                        } catch (e) {
                            console.error('Failed to load character:', e);
                            alert('âš ï¸ Your save was corrupted. Returning to main menu.');
                            // Delete corrupted save and continue to main menu
                            deleteCharacter(characters[0].id);
                        }
                    }
                }
            } catch (e) {
                console.error('Critical error in initGame:', e);
                // Clear potentially corrupted data
                try {
                    localStorage.removeItem('dq_character_list');
                } catch (clearError) {
                    console.error('Could not clear character list:', clearError);
                }
            }
            
            // Always fall back to main menu if anything goes wrong
            showMainMenu();
            
            // Warn before leaving page without saving
            window.addEventListener('beforeunload', function(e) {
                // Only warn if player exists and has made progress
                if (gameState.player && gameState.player.level >= 1) {
                    const message = 'You have unsaved progress! Are you sure you want to leave?';
                    e.preventDefault();
                    e.returnValue = message;  // Chrome requires returnValue
                    return message;           // Some browsers use return value
                }
            });
        }

        function showMainMenu() {
            checkGameVersion();
            const screen = document.getElementById('mainScreen');
            const characters = getAllCharacters();
            const hasCharacters = characters.length > 0;

            // Only show install option if not already a standalone PWA
            const isStandalone = window.navigator.standalone === true ||
                                 window.matchMedia('(display-mode: standalone)').matches;
            const installOption = isStandalone ? '' : `
                    <div class="menu-option" onclick="openInstallModal()"
                         style="border-color:#2a5a2a;color:#4a9a4a;margin-top:12px;">
                        ğŸ“± INSTALL APP
                        <span style="font-size:13px;color:#336633;"> â€” play fullscreen</span>
                    </div>`;

            screen.innerHTML = `
                <div class="location-header">MAIN MENU</div>
                <div style="text-align:center; margin: 30px 0;">
                    <div style="display:inline-block; border:2px solid var(--highlight-color); padding:10px 28px; color:var(--highlight-color); font-family:'VT323',monospace; font-size:22px; letter-spacing:2px; box-shadow:0 0 12px rgba(255,200,0,0.3);">
                        DUNGEON QUEST AWAITS!
                    </div>
                    <div style="color:var(--highlight-color); font-size:18px; margin-top:8px; letter-spacing:3px;">âš”ï¸ â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” âš”ï¸</div>
                </div>
                <div style="max-width: 400px; margin: 0 auto;">
                    <div class="menu-option" onclick="newGame()">â–º NEW GAME</div>
                    <div class="menu-option ${!hasCharacters?'disabled':''}" onclick="${hasCharacters?'showCharacterSelect()':''}">
                        â–º CONTINUE ${hasCharacters?`(${characters.length} local save${characters.length>1?'s':''})`:' (No saves)'}
                    </div>
                    <div class="menu-option" onclick="loadFromFile()">ğŸ“ LOAD FROM FILE (.dqsave)</div>
                    <div class="menu-option" onclick="showInstructions()">â–º INSTRUCTIONS</div>
                    <div class="menu-option" onclick="showRevisionHistory()" style="border-color:#4a7a4a;color:#8aaa8a;">â–º ğŸ“‹ REVISION HISTORY</div>
                    ${installOption}
                </div>
                <div style="position:fixed;bottom:6px;right:10px;font-family:'VT323',monospace;font-size:13px;color:#1a3a1a;pointer-events:none;user-select:none;">
                    v${GAME_VERSION}
                </div>
            `;
        }

        function showCharacterSelect() {
            checkGameVersion();
            const characters = getAllCharacters();
            if (characters.length === 0) {
                alert('No saved characters found!');
                return;
            }
            
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">SELECT CHARACTER</div>
                <div id="characterList" style="max-width: 600px; margin: 20px auto; padding: 0 10px;"></div>
                <div style="padding: 0 10px 20px;">
                    <button onclick="showMainMenu()" style="width:100%;max-width:600px;display:block;margin:0 auto;">â† BACK TO MENU</button>
                </div>
            `;
            
            const charList = document.getElementById('characterList');
            
            characters.forEach(char => {
                const card = document.createElement('div');
                card.className = 'character-card';
                card.style.cssText = `
                    background: var(--secondary-bg);
                    border: 2px solid var(--border-color);
                    padding: 15px;
                    margin-bottom: 15px;
                    box-sizing: border-box;
                    width: 100%;
                `;
                
                card.innerHTML = `
                    <div style="margin-bottom: 12px;">
                        <div style="color: var(--highlight-color); font-size: 22px; margin-bottom: 4px; word-break: break-word;">
                            ${char.name}
                        </div>
                        <div style="color: var(--text-color); font-size: 16px;">
                            Level ${char.level} ${char.class || 'Adventurer'}
                        </div>
                        <div style="color: #8aaa8a; font-size: 14px; margin-top: 4px;">
                            Last played: ${char.lastSaved}
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; width: 100%;">
                        <button onclick="event.stopPropagation(); loadCharacter('${char.id}')"
                                style="flex: 1; padding: 12px 8px; background: #0a3a0a; border: 2px solid var(--text-color); font-size: 18px; min-width: 0;">
                            â–¶ PLAY
                        </button>
                        <button onclick="event.stopPropagation(); confirmDeleteCharacter('${char.id}', '${char.name}')"
                                style="flex: 1; padding: 12px 8px; background: #3a0a0a; border: 2px solid var(--error-color); color: var(--error-color); font-size: 18px; min-width: 0;">
                            ğŸ—‘ï¸ DELETE
                        </button>
                    </div>
                `;
                
                card.addEventListener('mouseenter', () => {
                    card.style.background = 'var(--primary-bg)';
                    card.style.borderColor = 'var(--highlight-color)';
                });
                
                card.addEventListener('mouseleave', () => {
                    card.style.background = 'var(--secondary-bg)';
                    card.style.borderColor = 'var(--border-color)';
                });
                
                charList.appendChild(card);
            });
        }

        function confirmDeleteCharacter(charId, charName) {
            if (confirm(`Are you sure you want to DELETE ${charName}? This cannot be undone!`)) {
                if (deleteCharacter(charId)) {
                    showCharacterSelect(); // Refresh the list
                } else {
                    alert('Error deleting character!');
                }
            }
        }

        function loadCharacter(characterId) {
            try {
                const saveData = localStorage.getItem(`dq_save_${characterId}`);
                if (!saveData) {
                    console.error('Save file not found:', characterId);
                    alert('âš ï¸ Save file not found!');
                    showMainMenu();
                    return;
                }

                const data = JSON.parse(saveData);
                
                // Validate save data structure
                if (!data.player) {
                    throw new Error('Invalid save data: missing player data');
                }
                
                // Restore complete player state
                gameState.player = {
                    ...data.player,
                    // Ensure all arrays are properly restored
                    inventory: data.player.inventory || [],
                    knownSpells: data.player.knownSpells || [],
                    defeatedMasters: data.player.defeatedMasters || [],
                    unlockedAreas: data.player.unlockedAreas || [],
                    // Ensure bankGold exists (for old saves)
                    bankGold: data.player.bankGold || 0,
                    achievements: data.player.achievements || [],
                    runestones: data.player.runestones || [],
                    // Portal unlock â€” false for old saves that predate this flag
                    portalUnlocked: data.player.portalUnlocked || false,
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // PERSISTENT DUNGEON MAPS - Restore and convert arrays back to Sets
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    dungeonMaps: (() => {
                        const maps = {};
                        if (data.player.dungeonMaps) {
                            for (const dungeonKey in data.player.dungeonMaps) {
                                maps[dungeonKey] = {};
                                for (const floorNum in data.player.dungeonMaps[dungeonKey]) {
                                    // Convert arrays back to Sets
                                    maps[dungeonKey][floorNum] = new Set(data.player.dungeonMaps[dungeonKey][floorNum]);
                                }
                            }
                        }
                        return maps;
                    })(),

                    // Restore enemy respawn timers (prune any that expired while offline)
                    dungeonTimers: (() => {
                        const timers = {};
                        const now = Date.now();
                        if (data.player.dungeonTimers) {
                            for (const dk in data.player.dungeonTimers) {
                                const valid = (data.player.dungeonTimers[dk] || []).filter(e => now < e.respawnTime);
                                if (valid.length > 0) timers[dk] = valid;
                            }
                        }
                        return timers;
                    })()
                };
                
                // Restore current town
                gameState.currentTown = data.currentTown || 'town1';

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // MIGRATIONS â€” patch existing saves when base values change
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                const _p = gameState.player;
                const _class = _p.baseClass || _p.class;

                // Cleric MP raised from 70 â†’ 100 starting (same as mage).
                // Each level gains +10 MP, so expected maxMp = 100 + (level-1)*10.
                // If their maxMp is below that, they were created before the change.
                if (_class === 'cleric') {
                    const expectedMaxMp = 100 + (_p.level - 1) * 10;
                    if (_p.maxMp < expectedMaxMp) {
                        const diff = expectedMaxMp - _p.maxMp;
                        _p.maxMp += diff;
                        _p.mp = Math.min(_p.mp + diff, _p.maxMp);
                        console.log(`ğŸ”§ Cleric MP migration: +${diff} MP (now ${_p.mp}/${_p.maxMp})`);
                    }
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // RESTORE GENERATED WEAPONS - Must happen BEFORE equipment check!
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if (data.generatedWeapons) {
                    Object.keys(data.generatedWeapons).forEach(weaponId => {
                        WEAPONS[weaponId] = data.generatedWeapons[weaponId];
                    });
                    console.log(`âœ… Restored ${Object.keys(data.generatedWeapons).length} generated weapons`);
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // RESTORE GENERATED ARMOR - Must happen BEFORE equipment check!
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if (data.generatedArmor) {
                    Object.keys(data.generatedArmor).forEach(armorId => {
                        ARMOR[armorId] = data.generatedArmor[armorId];
                    });
                    console.log(`âœ… Restored ${Object.keys(data.generatedArmor).length} generated armor pieces`);
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // EQUIPMENT MIGRATION (fix old save data with missing weapons/armor)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                const p = gameState.player;
                
                // Check if weapon exists (null/undefined = intentionally unarmed)
                if (p.weapon && !WEAPONS[p.weapon]) {
                    console.warn(`âš ï¸ Weapon '${p.weapon}' not found. Migrating to bare_fists...`);
                    p.weapon = 'bare_fists';
                    console.log(`âœ… Migrated weapon to: bare_fists`);
                }
                if (!p.weapon) p.weapon = 'bare_fists';
                
                // Check if armor exists (null/undefined = intentionally unarmored)
                if (p.armor && !ARMOR[p.armor]) {
                    console.warn(`âš ï¸ Armor '${p.armor}' not found. Migrating to no_armor...`);
                    p.armor = 'no_armor';
                    console.log(`âœ… Migrated armor to: no_armor`);
                }
                if (!p.armor) p.armor = 'no_armor';
                
                // Ensure className exists (for old saves)
                if (!p.className && p.class && CLASSES[p.class]) {
                    p.className = CLASSES[p.class].name;
                    console.log(`âœ… Added className: ${p.className}`);
                }

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // ROGUE WEAPON MIGRATION â€” daggers only (force old rogues to comply)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                const baseClassCheck = p.baseClass || p.class;
                if (baseClassCheck === 'rogue' && p.weapon && WEAPONS[p.weapon]) {
                    const wpn = WEAPONS[p.weapon];
                    const isDagger = wpn.classRestriction === 'rogue'
                        || (wpn.name && (wpn.name.toLowerCase().includes('dagger') || wpn.name.toLowerCase().includes('shiv')))
                        || (p.weapon && (p.weapon.toLowerCase().includes('dagger') || p.weapon.toLowerCase().includes('shiv')));
                    if (!isDagger) {
                        console.warn(`âš ï¸ Rogue has non-dagger weapon '${p.weapon}'. Migrating to rusty_shiv...`);
                        // Strip the non-dagger from inventory if present
                        const idx = p.inventory.indexOf(p.weapon);
                        if (idx !== -1) p.inventory.splice(idx, 1);
                        // Equip rusty_shiv
                        p.weapon = 'rusty_shiv';
                        if (!p.inventory.includes('rusty_shiv')) p.inventory.push('rusty_shiv');
                        console.log(`âœ… Rogue weapon migrated to rusty_shiv`);
                    }
                }

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // XP SYSTEM MIGRATION â€” running total (v2) vs per-level (v1)
                // Old saves store p.xp as XP earned within the current level
                // (always < xpToNext). New system stores p.xp as a cumulative
                // running total (always >= getXpForLevel(cls, level)).
                // We detect old saves and convert them automatically.
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                (function migrateXp(p) {
                    if (p.level <= 1) return; // Level 1 needs no migration
                    const cls = p.baseClass || p.class;
                    const levelFloor = getXpForLevel(cls, p.level);
                    if (p.xp < levelFloor) {
                        // Old-style save: p.xp is within-level XP.
                        // Convert to running total by adding the level's base threshold.
                        const oldXp = p.xp;
                        p.xp = levelFloor + oldXp;
                        console.log(`âœ… XP migration: level ${p.level} ${cls} | ${oldXp} within-level â†’ ${p.xp} running total`);
                    }
                    // Also ensure xpToNext matches the cumulative table value
                    p.xpToNext = getXpToNextLevel(cls, p.level);
                })(p);
                
                gameState.currentLocation = data.currentLocation || 'silverdale';
                
                // Restore dungeon state if applicable
                if (data.meta?.inDungeon && data.dungeon) {
                    // Check if DUNGEONS is loaded
                    if (typeof DUNGEONS === 'undefined') {
                        console.error('âš ï¸ DUNGEONS not loaded! Check dungeon-data.js for syntax errors.');
                        alert('âš ï¸ Dungeon data failed to load. Returning to town.');
                        gameState.dungeon = null;
                        showTown();
                        return;
                    }
                    
                    console.log('ğŸ” Loading dungeon:', data.dungeon.dungeonKey);
                    console.log('ğŸ“¦ Available dungeons:', Object.keys(DUNGEONS));
                    
                    let dungeonKey = data.dungeon.dungeonKey;
                    
                    // Migrate old dungeon keys if needed
                    if (!DUNGEONS[dungeonKey]) {
                        console.warn(`âš ï¸ Dungeon "${dungeonKey}" not found. Attempting migration...`);
                        const availableDungeons = Object.keys(DUNGEONS);
                        if (availableDungeons.length > 0) {
                            dungeonKey = availableDungeons[0];
                            console.log(`âœ… Migrated to dungeon: ${dungeonKey}`);
                        } else {
                            console.error('âŒ No dungeons available!');
                            alert('âš ï¸ Dungeon not found. Returning to town.');
                            gameState.dungeon = null;
                            showTown();
                            return;
                        }
                    }
                    
                    const dungeon = DUNGEONS[dungeonKey];
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // MERGE: Load persistent map + current session discovered rooms
                    // Only merge rooms that belong to the current floor to prevent
                    // cross-floor contamination when room IDs are shared across floors.
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    const floorNum = data.dungeon.floor;
                    const persistentMap = loadDungeonMap(p, dungeonKey, floorNum);
                    const sessionRooms = new Set(data.dungeon.discoveredRooms || []);
                    
                    // Merge session rooms into persistent map â€” current floor only
                    sessionRooms.forEach(roomKey => {
                        if (roomKey.includes(':')) {
                            const [floor, roomId] = roomKey.split(':');
                            const roomFloor = parseInt(floor);
                            // Only merge rooms belonging to the current floor
                            if (roomFloor === floorNum) {
                                persistentMap.add(roomKey);
                                saveRoomDiscovery(p, dungeonKey, roomFloor, roomId);
                            } else {
                                // Save other floors to their own persistent maps but don't pollute current
                                saveRoomDiscovery(p, dungeonKey, roomFloor, roomId);
                            }
                        } else {
                            // Old unscoped format â€” scope to current floor
                            persistentMap.add(`${floorNum}:${roomKey}`);
                            saveRoomDiscovery(p, dungeonKey, floorNum, roomKey);
                        }
                    });
                    
                    gameState.dungeon = {
                        dungeonKey: dungeonKey,
                        floor: floorNum,
                        currentRoom: data.dungeon.currentRoom,
                        discoveredRooms: persistentMap, // Use merged map
                        spawnedRooms: new Set(data.dungeon.spawnedRooms || []),
                        activeEnemies: (data.dungeon.activeEnemies || []).map(e => ({
                            ...e,
                            isChasing: false,
                            roomsFollowed: 0
                        })),
                        defeatedEnemies: (data.dungeon.defeatedEnemies || []).map(e => ({
                            ...e
                        }))
                    };
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // MIGRATION: Ensure discoveredRooms only contains current-floor keys
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    const ds = gameState.dungeon;
                    const migratedSet = new Set();
                    ds.discoveredRooms.forEach(entry => {
                        if (entry.includes(':')) {
                            const [floor] = entry.split(':');
                            // Only keep entries for the current floor
                            if (parseInt(floor) === ds.floor) {
                                migratedSet.add(entry);
                            }
                        } else {
                            // Old format (just roomId) â€” scope to current floor
                            migratedSet.add(`${ds.floor}:${entry}`);
                        }
                    });
                    ds.discoveredRooms = migratedSet;
                    
                    // Open dungeon UI
                    openTerminalView(dungeonKey);
                    
                    const floor = dungeon.floors[data.dungeon.floor];
                    if (!floor) {
                        console.error(`âš ï¸ Floor ${data.dungeon.floor} not found!`);
                        alert('âš ï¸ Invalid dungeon floor. Returning to town.');
                        gameState.dungeon = null;
                        showTown();
                        return;
                    }
                    
                    const room = floor.rooms[data.dungeon.currentRoom];
                    if (!room) {
                        console.error(`âš ï¸ Room ${data.dungeon.currentRoom} not found!`);
                        alert('âš ï¸ Invalid dungeon room. Returning to town.');
                        gameState.dungeon = null;
                        showTown();
                        return;
                    }
                    
                    termAppend('', 'term-separator');
                    termAppend(`<strong>${room.name}</strong>`);
                    termAppend(room.description, 'term-dim');
                    
                    const exits = Object.keys(room.exits).map(d => d.toUpperCase()).join(', ');
                    termAppend(`You see exits: ${exits}.`, 'term-dim');
                    
                    checkEnemiesInRoom(data.dungeon.currentRoom);
                    renderDungeonActionBar();
                    
                    // Start regeneration in dungeon (normal speed)
                    startMpRegen(false);
                    startResting(false);
                } else if (data.activeCombat && data.activeCombat.monsters && data.activeCombat.monsters.length > 0) {
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // RESTORE MID-COMBAT STATE - enemies still waiting from last session
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    const ac = data.activeCombat;
                    const p  = gameState.player;
                    
                    // Restore pip array
                    const pipCount  = ac.pipCount || calcPlayerHits(p);
                    const pipTimers = Array(pipCount).fill(10);
                    const pipReady  = ac.pipsReady || Array(pipCount).fill(true);
                    
                    gameState.combatState = {
    monsters:           ac.monsters,
    currentTarget:      ac.currentTarget || 0,
    messages:           [],
    defeatedMonsters:   [],
    pipTimers:          pipTimers,
    pipAvailable:       pipReady,
    enemyTimer:         ac.enemyDelay || 15,
    enemyDelay:         ac.enemyDelay || 15,
    enemyHits:          ac.enemyHits  || 1,
    enemyHitsLeft:      ac.enemyHitsLeft || 1,
    playerStatusEffects:  [],
    monsterStatusEffects: {},
    dotTimers:            {},
    actionMode:           'main',
    shieldActive:         false  // Warrior shield starts inactive
};
                    
                    // Open the terminal view for the saved location
                    const loc = ac.location || gameState.currentLocation;
                    gameState.currentLocation = loc;
                    gameState._terminalOpen = false;
                    openTerminalView(loc);
                    
                    // Print restoration message
                    termAppend('', 'term-separator');
                    termAppend(`<span style="color:#FF8800;">âš ï¸ You were mid-combat when you left!</span>`, 'term-enemy');
                    
                    const names = ac.monsters.map(m =>
                        `<span style="color:${m.rarityColor};">${m.name}</span> (${m.hp}/${m.maxHp} HP)`
                    ).join(', ');
                    termAppend(`Still fighting: ${names}`, 'term-enemy');
                    
                    // Start regen, render UI
                    startMpRegen(false);
                    startResting(false);
                    renderEnemyCards();
                    renderActionBar();
                    startCombatTimer();
                    
                    console.log(`âš”ï¸ Restored combat: ${ac.monsters.length} enemies waiting`);
                } else {
                    showTown();
                }
                
                console.log(`âœ… Character loaded: ${data.characterName}`);
                console.log(`   Weapon: ${gameState.player.weapon} | Armor: ${gameState.player.armor}`);
            } catch (e) {
                console.error('Error loading character:', e);
                alert('âš ï¸ Failed to load save file. The data may be corrupted. Returning to main menu.');
                
                // Clean up corrupted state
                gameState.player = null;
                gameState.dungeon = null;
                gameState.combatState = null;
                
                // Try to delete corrupted save
                try {
                    deleteCharacter(characterId);
                } catch (deleteError) {
                    console.error('Could not delete corrupted save:', deleteError);
                }
                
                // Always return to main menu on error
                showMainMenu();
            }
        }

        function showInstructions() {
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">INSTRUCTIONS</div>
                <button onclick="showMainMenu()" style="margin-bottom:10px;">BACK TO MENU</button>

                <div class="message">
                    <p><span class="stat-label">OBJECTIVE:</span> Explore dungeons, defeat monsters, collect loot, level up, and become legendary!</p>
                </div>

                <div class="message">
                    <p><span class="stat-label">COMBAT:</span> Turn-based with a pip timer. Each pip takes ~10 seconds to recharge. Use Attack, Spell, or Potion each turn. The enemy attacks on its own timer â€” watch for telegraphed moves! You must have full pips restored to move to a new room.</p>
                </div>

                <div class="message">
                    <p><span class="stat-label">EXPLORATION:</span> Travel to different locations from the world map. Stronger zones have tougher enemies but better loot. You must defeat zone bosses to unlock further areas.</p>
                </div>

                <div class="message">
                    <p><span class="stat-label">PROGRESSION:</span> Gain XP and Gold from combat. Level up to increase stats, unlock new spells, and equip higher-tier gear. Visit the Temple to learn spells. Check the Shop for weapons and armor.</p>
                </div>

                <div class="message">
                    <p><span class="stat-label">SAVING:</span> The game auto-saves after most actions. Use Quick Save or Download Save File from the town menu to keep a backup.</p>
                </div>

                <div class="message" style="border-color:#FF4444;">
                    <p><span class="stat-label" style="color:#FF4444;">âš  DUNGEON WARNING:</span></p>
                    <p>Dungeons are persistent â€” enemies remember where you are. If you run from a fight, <strong>enemies will follow you</strong> into the next room and immediately join any existing combat. Pulling multiple enemies is intentional â€” use AOE spells to handle groups!</p>
                    <p style="margin-top:6px;">You cannot move while your pips are recharging. Plan your retreat carefully â€” a cornered adventurer with empty pips is a dead one.</p>
                    <p style="margin-top:6px;">Dungeon keys are <strong>permanent collectibles</strong> â€” they never leave your inventory and are not consumed when unlocking doors. Collect them all to access deeper areas.</p>
                </div>

                <div class="message" style="border-color:#9933FF;">
                    <p><span class="stat-label" style="color:#9933FF;">ğŸ¨ ENEMY RARITY COLORS:</span></p>
                    <p>Enemy names are colored by rarity tier. Higher rarity = more HP, damage, and better drop chance:</p>
                    <p style="margin-top:6px;">
                        <span style="color:#FFFFFF;">â–  Common</span> â€” Standard encounter, normal drops<br>
                        <span style="color:#00FF00;">â–  Uncommon</span> â€” 30% stronger, improved drops<br>
                        <span style="color:#0099FF;">â–  Rare</span> â€” 60% stronger, can double-attack<br>
                        <span style="color:#9933FF;">â–  Epic</span> â€” 2Ã— stats, multi-attacks, good loot<br>
                        <span style="color:#FF9900;">â–  Legendary</span> â€” 2.5Ã— stats, dangerous, rare drops<br>
                        <span style="color:#FF0000;">â–  Mythic</span> â€” 3.5Ã— stats, extremely deadly, best loot
                    </p>
                </div>

                <div class="message" style="border-color:#FF9900;">
                    <p><span class="stat-label" style="color:#FF9900;">ğŸ—¡ï¸ WEAPON &amp; ARMOR QUALITY:</span></p>
                    <p>Equipment has a quality tier that boosts its base stats by a percentage. Quality is shown by the item's name color:</p>
                    <p style="margin-top:6px;">
                        <span style="color:#808080;">â–  Poor</span> â€” No bonus (base stats only)<br>
                        <span style="color:#00FF00;">â–  Normal</span> â€” +10% stats<br>
                        <span style="color:#0099FF;">â–  Rare</span> â€” +25% stats<br>
                        <span style="color:#9933FF;">â–  Epic</span> â€” +40% stats<br>
                        <span style="color:#FF9900;">â–  Legendary</span> â€” +60% stats<br>
                        <span style="color:#FF0000;">â–  Godly</span> â€” +85% stats (extremely rare)
                    </p>
                </div>

                <div class="message" style="border-color:#00FF88;">
                    <p><span class="stat-label" style="color:#00FF88;">ğŸ“¦ WEAPON &amp; ARMOR DROPS:</span></p>
                    <p>Every enemy you defeat has a chance to drop a weapon or armor piece. Drop quality scales with the enemy's rarity and your current level â€” so a Legendary enemy killed at level 10 will drop much better gear than the same enemy at level 1.</p>
                    <p style="margin-top:6px;">Dungeon enemies with a <span style="color:#e8b84a;">ğŸ”‘ key</span> always drop their key on death. Other special drops (like rare crafting materials) show up as loot in the combat results screen.</p>
                    <p style="margin-top:6px;">New drops go directly into your inventory. Use the <strong>ğŸ’ Inventory</strong> button in the dungeon or visit Inventory from town to equip them.</p>
                </div>

                <button onclick="showMainMenu()">BACK TO MENU</button>
            `;
        }

        function showRevisionHistory() {
            const screen = document.getElementById('mainScreen');
            let html = `<div class="location-header">ğŸ“‹ REVISION HISTORY</div>`;
            html += `<button onclick="showMainMenu()" style="margin-bottom:10px;">BACK TO MENU</button>`;

            if (typeof REVISION_HISTORY === 'undefined' || REVISION_HISTORY.length === 0) {
                html += `<div class="message"><p style="color:#888;">No revision history available.</p></div>`;
            } else {
                REVISION_HISTORY.forEach((rev, idx) => {
                    const isLatest = idx === 0;
                    const borderCol = isLatest ? '#00FF88' : '#2a4a2a';
                    const labelHtml = isLatest
                        ? `<span style="color:#00FF88;font-size:13px;margin-left:8px;">â† CURRENT</span>`
                        : '';
                    html += `
                    <div class="message" style="border-color:${borderCol};margin-bottom:10px;">
                        <div style="display:flex;align-items:baseline;flex-wrap:wrap;gap:4px;margin-bottom:6px;">
                            <span style="color:${isLatest?'#00FF88':'var(--highlight-color)'};font-size:16px;font-weight:bold;">v${rev.version}</span>
                            ${labelHtml}
                            <span style="color:#666;font-size:13px;margin-left:6px;">${rev.date}</span>
                        </div>
                        <div style="color:#aaa;font-size:14px;margin-bottom:6px;font-style:italic;">${rev.summary}</div>
                        <ul style="margin:0;padding-left:18px;font-size:13px;color:#8aaa8a;line-height:1.7;">
                            ${rev.changes.map(c => `<li>${c}</li>`).join('')}
                        </ul>
                    </div>`;
                });
            }

            html += `<button onclick="showMainMenu()">BACK TO MENU</button>`;
            screen.innerHTML = html;
        }

        function newGame() {
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">CHARACTER CREATION</div>
                <div class="message">
                    <p>Enter your character name:</p>
                    <input type="text" id="playerName" maxlength="20" placeholder="Hero Name">
                </div>
                <div class="message">
                    <p><span class="stat-label">Choose your class:</span></p>
                </div>
                <div class="character-select" id="classSelect"></div>
                <button onclick="goToStatAlloc()" id="createBtn" disabled>ALLOCATE STATS â†’</button>
                <button onclick="showMainMenu()">CANCEL</button>
            `;

            const classSelect = document.getElementById('classSelect');
            window._selectedClass = null;

            Object.keys(CLASSES).forEach(classKey => {
                const cd   = CLASSES[classKey];
                const card = document.createElement('div');
                card.className = 'class-card';
                card.innerHTML = `
                    <div style="color:var(--highlight-color);font-size:22px;margin-bottom:8px;">${cd.name}</div>
                    <div style="font-size:16px;margin-bottom:8px;">${cd.description}</div>
                    <div class="stat">HP: ${cd.hp} | MP: ${cd.mp}</div>
                    <div class="stat" style="color:#8aaa8a;">STR/DEF/MAG/SPD set at creation</div>
                `;
                card.onclick = () => {
                    document.querySelectorAll('.class-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    window._selectedClass = classKey;
                    document.getElementById('createBtn').disabled = false;
                };
                classSelect.appendChild(card);
            });
        }

        // â”€â”€ stat allocation screen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window._pendingStats = null;
        window._pendingName  = '';

        function goToStatAlloc() {
            const name = document.getElementById('playerName').value.trim();
            if (!name)                { alert('Please enter a character name!'); return; }
            if (!window._selectedClass) { alert('Please select a class!');       return; }
            window._pendingName  = name;
            window._pendingStats = Object.assign({}, CLASS_STAT_PRESETS[window._selectedClass]);
            renderStatAllocScreen();
        }

        function renderStatAllocScreen() {
            const classKey   = window._selectedClass;
            const classData  = CLASSES[classKey];
            const stats      = window._pendingStats;
            const spent      = STAT_NAMES.reduce((a,k) => a + stats[k], 0);
            const remaining  = STAT_BUDGET - spent;
            const affinities = CLASS_AFFINITIES[classKey];
            const screen     = document.getElementById('mainScreen');

            // preview derived values
            const previewHp   = classData.hp + stats.con * 5;
            const previewHits = (function(){
                let h=1;
                if(classKey==='rogue') h++;
                h += Math.floor(Math.max(0, stats.str-8)/6);
                return h;
            })();

            let rows = '';
            STAT_NAMES.forEach(s => {
                const isAff   = affinities.includes(s);
                const canUp   = remaining > 0 && stats[s] < 15;
                const canDown = stats[s] > 0;
                rows += `
                <div style="display:flex;align-items:center;gap:6px;padding:5px 0;border-bottom:1px solid #1a4a1a;flex-wrap:wrap;">
                    <span style="min-width:36px;color:${isAff?'var(--highlight-color)':'var(--text-color)'};font-weight:bold;">${STAT_LABELS[s]}</span>
                    <span style="flex:1;min-width:120px;font-size:16px;color:#8aaa8a;">${STAT_DESCS[s]}${isAff?' â˜…':''}</span>
                    <button onclick="statAdj('${s}',-1)" ${canDown?'':'disabled'} style="width:32px;padding:4px 0;margin:0;font-size:20px;">âˆ’</button>
                    <span style="min-width:28px;text-align:center;color:var(--highlight-color);font-size:22px;">${stats[s]}</span>
                    <button onclick="statAdj('${s}',+1)" ${canUp ?'':'disabled'} style="width:32px;padding:4px 0;margin:0;font-size:20px;">+</button>
                </div>`;
            });

            screen.innerHTML = `
                <div class="location-header">ALLOCATE STATS â€“ ${classData.name}</div>
                <div class="message" style="border-color:var(--highlight-color);">
                    <span style="color:var(--highlight-color);">Points remaining: </span>
                    <span style="color:${remaining>0?'var(--text-color)':'var(--error-color)'};font-size:22px;">${remaining}</span>
                    <span style="color:#8aaa8a;font-size:15px;"> (â˜… = class affinity)</span>
                </div>
                <div style="max-width:520px;margin:0 auto;">${rows}</div>
                <div class="message" style="border-color:#005500;margin-top:12px;font-size:15px;">
                    <span style="color:#8aaa8a;">PREVIEW:</span><br>
                    <span style="color:var(--highlight-color);">HP ${previewHp}</span>
                    <span style="color:var(--border-color);"> | ATK/rd: ${previewHits}</span><br>
                    <span style="color:#8aaa8a;">Crit ${calcCritChance(stats.lck)}% | Dodge ${calcDodgeChance(stats.dex)}%</span>
                </div>
                <div style="margin-top:14px;display:flex;flex-wrap:wrap;gap:8px;">
                    <button onclick="window._pendingStats=Object.assign({},CLASS_STAT_PRESETS['${classKey}']);renderStatAllocScreen();">ğŸ“‹ CLASS PRESET</button>
                    <button onclick="window._pendingStats=rerollStats('${classKey}');renderStatAllocScreen();">ğŸ² REROLL</button>
                    <button onclick="STAT_NAMES.forEach(s=>window._pendingStats[s]=0);renderStatAllocScreen();" style="border-color:#ff4444;color:#ff4444;">ğŸ—‘ RESET ALL</button>
                </div>
                <div style="margin-top:14px;">
                    <button onclick="finaliseCharacter()" ${remaining===0?'':'disabled'} style="font-size:20px;">âš”ï¸ BEGIN ADVENTURE âš”ï¸</button>
                    <button onclick="newGame()">â† BACK</button>
                </div>
            `;
        }

        window.statAdj = function(stat, dir) {
            const stats = window._pendingStats;
            const spent = STAT_NAMES.reduce((a,k) => a + stats[k], 0);
            if (dir > 0 && spent >= STAT_BUDGET) return;
            if (dir < 0 && stats[stat] <= 0)     return;  // can go to 0
            stats[stat] += dir;
            renderStatAllocScreen();
        };

        function finaliseCharacter() {
            const classKey  = window._selectedClass;
            const classData = CLASSES[classKey];
            const stats     = window._pendingStats;

            // Generate unique character ID
            const charId = 'char_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

            gameState.player = {
                id: charId,  // Unique character ID
                name: window._pendingName,
                class: classKey,  className: classData.name,
                level: 1,  xp: 0,  xpToNext: getXpToNextLevel(classKey, 1),
                hp: classData.hp + stats.con * 5,
                maxHp: classData.hp + stats.con * 5,
                mp: classData.mp,  maxMp: classData.mp,
                strength: classData.strength,   // legacy weapon-calc field
                defense:  classData.defense,
                magic:    classData.magic,
                speed:    classData.speed,
                gold: 100,
                bankGold: 0,  // Bank storage starts empty
                weapon: classData.startWeapon,
                armor:  classData.startArmor,
                inventory:  [classData.startWeapon, classData.startArmor],
                knownSpells: getStartingSpells(classKey),
                defeatedMasters: [],
                unlockedAreas:  ['forest'],
                // â”€â”€ new stat block â”€â”€
                str: stats.str,  dex: stats.dex,  wis: stats.wis,
                cha: stats.cha,  con: stats.con,  lck: stats.lck,
                // â”€â”€ stat point allocation â”€â”€
                statPoints: 0,   // earned 3 per level-up, spent in Character Stats
                // â”€â”€ store base class so evolution doesn't lose class identity â”€â”€
                baseClass: classKey,
                // â”€â”€ hunter pet system â”€â”€
                activePet: classKey === 'hunter' ? null : undefined,  // hunters start with no pet, others don't use this
                runeOverloadPips: classKey === 'runesmith' ? 0 : undefined  // runesmith overload charge tracker
                
            };
            gameState.currentLocation = 'town';
            
            // Auto-save new character
            saveGame();
            
            showTown();
        }

        function getStartingSpells(classKey) {
            // Use CLASS_SPELL_TREES to get starting spell
            if (typeof CLASS_SPELL_TREES !== 'undefined' && CLASS_SPELL_TREES[classKey]) {
                const startingSpell = CLASS_SPELL_TREES[classKey].startingSpell;
                return startingSpell ? [startingSpell] : [];
            }
            
            // Fallback for classes without spell trees (warriors, rogues, etc.)
            return [];
        }

        function showTown(townId) {
            checkGameVersion();
            document.body.classList.remove("terminal-mode");
            
            // Update current town if specified
            if (townId) gameState.currentTown = townId;
            const tid = gameState.currentTown || 'town1';
            
            // Get town definition (fall back to inline data if TOWNS not loaded yet)
            const townDef = (typeof TOWNS !== 'undefined' && TOWNS[tid]) ? TOWNS[tid] : null;
            const townName = townDef ? townDef.name : 'Silverdale';
            const townDesc = townDef ? townDef.description : 'A peaceful starting town.';

            // Apply town color theme
            if (townDef && townDef.theme) {
                document.documentElement.style.setProperty('--text-color', townDef.theme);
            } else {
                document.documentElement.style.setProperty('--text-color', '#00FF41');
            }

            // Start MP/HP regen (slower in town)
            startMpRegen(true);
            startResting(true);

            const p = gameState.player;
            const screen = document.getElementById('mainScreen');

            // â”€â”€ Portal option logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Town1: shows only if player has white_runestone OR portalUnlocked flag
            // Town2: ALWAYS shows a portal back to town1 (you got here somehow).
            //        First use of town2 portal permanently unlocks bidirectional travel
            //        (sets p.portalUnlocked = true, which also enables town1 â†’ town2).
            const hasRunestone    = p.runestones && p.runestones.includes('white_runestone');
            const portalUnlocked  = !!p.portalUnlocked;
            let portalOption = '';

            if (tid === 'town2') {
                // Town2 always has the return portal visible
                portalOption = `
                    <div class="menu-option" onclick="usePortal('town1')"
                         style="border-color:#AA88FF;background:rgba(170,136,255,0.07);">
                        â–º ğŸŒ€ PORTAL â†’ Silverdale
                        ${!portalUnlocked ? '<span style="color:#AA88FF;font-size:12px;"> [First use unlocks permanent travel]</span>' : ''}
                    </div>`;
            } else if (tid === 'town1' && (hasRunestone || portalUnlocked)) {
                // Town1: portal visible once player has runestone OR used town2 portal
                const destDef  = (typeof TOWNS !== 'undefined' && TOWNS['town2']) ? TOWNS['town2'] : null;
                const destName = destDef ? destDef.name : 'Ashen Harbor';
                portalOption = `
                    <div class="menu-option" onclick="usePortal('town2')"
                         style="border-color:#AA88FF;background:rgba(170,136,255,0.07);">
                        â–º ğŸŒ€ PORTAL â†’ ${destName}
                        ${hasRunestone ? '<span style="color:#AA88FF;font-size:12px;"> [White Runestone âœ¦]</span>' : ''}
                    </div>`;
            }

            // â”€â”€ Dungeon option (level-gated) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            let dungeonOption = '';
            if (townDef && townDef.dungeonKey) {
                const dungeonReady = p.level >= (townDef.dungeonRequiredLevel || 3);
                if (dungeonReady) {
                    dungeonOption = `
                        <div class="menu-option" onclick="enterTownDungeon('${tid}')"
                             style="border-color:var(--highlight-color);">
                            â–º ğŸ° ${townDef.dungeonName || 'DUNGEON'}
                        </div>`;
                } else {
                    dungeonOption = `
                        <div class="menu-option" style="opacity:0.45;cursor:default;"
                             onclick="alert('${townDef.dungeonUnlockMessage || 'Not yet ready.'}')">
                            ğŸ° ${townDef.dungeonName || 'DUNGEON'}
                            <span style="color:var(--error-color);font-size:12px;"> [Requires Lv ${townDef.dungeonRequiredLevel || 3}]</span>
                        </div>`;
                }
            } else if (!townDef) {
                dungeonOption = `<div class="menu-option" onclick="enterDungeons()">â–º ğŸ° DUNGEONS</div>`;
            }

            // â”€â”€ Runestone badges next to town name â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            let runestoneBadge = '';
            if (p.runestones && p.runestones.length > 0) {
                runestoneBadge = p.runestones.map(rsId => {
                    const rs = (typeof RUNESTONES !== 'undefined') ? RUNESTONES[rsId] : null;
                    if (!rs) return '';
                    return `<span title="${rs.name}: ${rs.description}" style="color:${rs.color};margin-left:5px;font-size:14px;cursor:default;">${rs.badgeSymbol}</span>`;
                }).join('');
            }

            // â”€â”€ Custom town renderer hook â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // If townDef defines a render() function, it owns the entire screen.
            // Used by town3 for its full elemental UI.
            if (townDef && typeof townDef.render === 'function') {
                townDef.render(screen, p, dungeonOption, portalOption);
                return;
            }

            screen.innerHTML = `
                <div class="location-header">${townName}</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>${townDesc}</p>
                    <p style="color: var(--border-color); font-size: 14px;">Modem Speed: ${currentModemSpeed}</p>
                </div>
                <div style="margin: 20px 0;">
                    <div class="menu-option" onclick="showShop()">â–º VISIT SHOP</div>
                    <div class="menu-option" onclick="showBank()">â–º ğŸ¦ BANK (${p.bankGold || 0}g stored)</div>
                    <div class="menu-option" onclick="showCharacterStats()">â–º ğŸ“Š CHARACTER STATS</div>
                    <div class="menu-option" onclick="showTemple()">â–º â›ª TEMPLE</div>
                    <div class="menu-option" onclick="showBlacksmith()">â–º âš’ï¸ BLACKSMITH</div>
                    ${dungeonOption}
                    <div class="menu-option" onclick="restAtInn()">â–º REST AT INN (${calcInnCost(p.cha)} Gold)</div>
                    <div class="menu-option" id="townInvBtn" onclick="showInventory()" 
                        onmousedown="_invMenuDown(event)" onmouseup="_invMenuUp()" onmouseleave="_invMenuCancel()"
                        ontouchstart="_invMenuDown(event)" ontouchend="_invMenuUp()" ontouchcancel="_invMenuCancel()">â–º INVENTORY</div>
                    <div class="menu-option" onclick="showExplore()">â–º EXPLORE WORLD</div>
                    ${portalOption}
                    <div class="menu-option" onclick="showModemSettings()">â–º MODEM SETTINGS</div>
                    <div class="menu-option" onclick="saveGame()" style="border-color:var(--text-color);">â–º ğŸ’¾ QUICK SAVE</div>
                    <div class="menu-option" onclick="downloadSaveFile()" style="border-color:var(--highlight-color);background:rgba(255,255,0,0.05);">â–º ğŸ“¥ DOWNLOAD SAVE FILE</div>
                    <div class="menu-option" onclick="confirmQuitToMenu()">â–º â QUIT TO MENU</div>
                </div>
            `;
        }

        // â”€â”€ Travel to another town via portal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function usePortal(destTownId) {
            const p = gameState.player;
            const fromTown = gameState.currentTown || 'town1';

            // Town2 â†’ Town1: always allowed (you're already there).
            // First time using this direction unlocks permanent bidirectional travel.
            if (fromTown === 'town2' && destTownId === 'town1') {
                if (!p.portalUnlocked) {
                    p.portalUnlocked = true;
                    saveGame();
                    // Show unlock announcement
                    const screen = document.getElementById('mainScreen');
                    const flash = document.createElement('div');
                    flash.style.cssText = 'position:fixed;top:15px;left:50%;transform:translateX(-50%);background:#0a0a0a;border:2px solid #AA88FF;padding:12px 24px;color:#AA88FF;font-size:16px;z-index:9999;text-align:center;';
                    flash.innerHTML = 'ğŸŒ€ <strong>Portal Unlocked!</strong><br><span style="font-size:13px;color:#ccc;">You can now travel freely between Silverdale and Ashen Harbor.</span>';
                    document.body.appendChild(flash);
                    setTimeout(() => flash.remove(), 3500);
                }
            } else if (fromTown === 'town1' && destTownId === 'town2') {
                // Town1 â†’ Town2: requires runestone OR already unlocked
                if (!p.portalUnlocked && !(p.runestones && p.runestones.includes('white_runestone'))) {
                    alert('You need to have visited Ashen Harbor first to use this portal!');
                    return;
                }
            }

            const destDef = (typeof TOWNS !== 'undefined' && TOWNS[destTownId]) ? TOWNS[destTownId] : null;
            const destName = destDef ? destDef.name : destTownId;
            gameState.currentTown = destTownId;
            saveGame();
            showTown(destTownId);
            // Flash arrival message
            setTimeout(() => {
                const flash = document.createElement('div');
                flash.style.cssText = 'position:fixed;top:15px;left:50%;transform:translateX(-50%);background:#0a0a0a;border:2px solid #AA88FF;padding:10px 20px;color:#AA88FF;font-size:16px;z-index:9999;';
                flash.textContent = `ğŸŒ€ Arrived in ${destName}`;
                document.body.appendChild(flash);
                setTimeout(() => flash.remove(), 2500);
            }, 50);
        }

        // â”€â”€ Enter the dungeon attached to the current town â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function enterTownDungeon(townId) {
            const tid = townId || gameState.currentTown || 'town1';
            const townDef = (typeof TOWNS !== 'undefined' && TOWNS[tid]) ? TOWNS[tid] : null;
            if (!townDef || !townDef.dungeonKey) {
                alert('No dungeon available here yet!');
                return;
            }
            const p = gameState.player;
            if (p.level < (townDef.dungeonRequiredLevel || 5)) {
                alert(townDef.dungeonUnlockMessage || `You must be level ${townDef.dungeonRequiredLevel} to enter!`);
                return;
            }
            if (typeof DUNGEONS === 'undefined' || !DUNGEONS[townDef.dungeonKey]) {
                alert(`âš ï¸ Dungeon data not loaded! Make sure ${townDef.dungeonKey}.js is in the game folder.`);
                return;
            }

            // â”€â”€ Show dungeon warning modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const hasRecall  = p.inventory.includes('recall_potion');
            const dungeonName = DUNGEONS[townDef.dungeonKey].name || townDef.dungeonKey;
            const recallNote  = hasRecall
                ? `<div style="color:#00ff88;margin-top:8px;">âœ… You carry a <strong>Recall Potion</strong> â€” you can use it to escape at any time.</div>`
                : `<div style="color:#ff4444;margin-top:8px;">âŒ You do NOT have a Recall Potion!<br>
                   Visit the <strong>Shop â†’ Potions</strong> to buy one for <span style="color:#FFD700;">5,000 gold</span> before you go.</div>`;

            // Build modal entirely with createElement â€” no innerHTML template literals
            // so nested quotes / special chars in dungeonName can't break the HTML
            const modal = document.createElement('div');
            modal.id = 'dungeonWarningModal';
            Object.assign(modal.style, {
                position: 'fixed', inset: '0', zIndex: '9999',
                display: 'flex', alignItems: 'center', justifyContent: 'center',
                background: 'rgba(0,0,0,0.88)', fontFamily: "'VT323',monospace",
                padding: '16px'
            });

            // Outer card â€” centered, full border, max-width for readability
            const card = document.createElement('div');
            Object.assign(card.style, {
                width: '100%', maxWidth: '480px',
                background: '#000',
                border: '3px double #ff4444',
                boxShadow: '0 0 40px rgba(255,0,0,0.4)',
                color: '#00ff00',
                boxSizing: 'border-box'
            });

            // Header
            const hdr = document.createElement('div');
            Object.assign(hdr.style, { padding: '14px 20px 10px', textAlign: 'center', borderBottom: '1px solid #330000' });
            hdr.innerHTML = `<div style="font-size:24px;color:#ff4444;letter-spacing:2px;">âš ï¸ DUNGEON WARNING âš ï¸</div>
                             <div style="font-size:18px;color:#ffff00;margin-top:4px;"></div>`;
            hdr.querySelector('div + div').textContent = dungeonName; // safe text assignment
            card.appendChild(hdr);

            // Body
            const body = document.createElement('div');
            Object.assign(body.style, { padding: '12px 20px', fontSize: '15px', lineHeight: '1.6', borderBottom: '1px solid #330000' });
            body.innerHTML = `
                <div style="color:#ff8800;margin-bottom:8px;font-size:16px;">
                    âš ï¸ You <strong>cannot shop or bank</strong> once inside. Prepare first!
                </div>
                <div style="color:#aaa;font-size:14px;margin-bottom:8px;">
                    Leave via: &nbsp;ğŸŒ€ Recall Potion &nbsp;|&nbsp; ğŸšª Walk back out &nbsp;|&nbsp; ğŸ™ï¸ Portal room
                </div>`;
            // Recall note added separately so its HTML is injected cleanly
            const rn = document.createElement('div');
            rn.innerHTML = recallNote;
            body.appendChild(rn);
            card.appendChild(body);

            // Button row
            const btnRow = document.createElement('div');
            Object.assign(btnRow.style, { display: 'flex', gap: '10px', padding: '12px 20px' });

            const btnEnter = document.createElement('button');
            Object.assign(btnEnter.style, {
                flex: '1', fontFamily: "'VT323',monospace", fontSize: '22px',
                padding: '12px 8px', cursor: 'pointer',
                background: 'linear-gradient(180deg,#1a0000,#0a0000)',
                color: '#ff4444', border: '2px solid #ff4444'
            });
            btnEnter.textContent = 'âš”ï¸ ENTER';
            btnEnter.onclick = () => { modal.remove(); startDungeon(townDef.dungeonKey); };

            const btnBack = document.createElement('button');
            Object.assign(btnBack.style, {
                flex: '1', fontFamily: "'VT323',monospace", fontSize: '22px',
                padding: '12px 8px', cursor: 'pointer',
                background: 'linear-gradient(180deg,#001a00,#000a00)',
                color: '#00ff88', border: '2px solid #00ff88'
            });
            btnBack.textContent = 'â† BACK';
            btnBack.onclick = () => modal.remove();

            btnRow.appendChild(btnEnter);
            btnRow.appendChild(btnBack);
            card.appendChild(btnRow);
            modal.appendChild(card);
            document.body.appendChild(modal);
        }

        // â”€â”€ Generic dungeon start (replaces testDungeon) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function startDungeon(dungeonKey) {
            document.body.classList.add("terminal-mode");
            startMpRegen(false);
            startResting(false);

            const dungeon = DUNGEONS[dungeonKey];
            const floor = dungeon.floors[1];

            // Reset only discovered state for fresh run â€” preserve design flags (townExit, etc.)
            Object.values(floor.rooms).forEach(r => {
                r.flags = r.flags || {};
                r.flags.discovered = false;
                // Re-arm firstDiscovery only if player doesn't have runestone yet
                if (r.flags.townExit === 'town2') {
                    const p = gameState.player;
                    const hasRunestone = p && p.runestones && p.runestones.includes('white_runestone');
                    r.flags.firstDiscovery = !hasRunestone;
                }
            });

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Initialize dungeon state with persistent discovered rooms
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const persistentMap = loadDungeonMap(gameState.player, dungeonKey, 1);
            const scopedStartRoom = `1:${floor.startRoom}`;
            persistentMap.add(scopedStartRoom); // Ensure start room is always discovered
            saveRoomDiscovery(gameState.player, dungeonKey, 1, floor.startRoom);
            
            gameState.dungeon = {
                dungeonKey,
                floor: 1,
                currentRoom: floor.startRoom,
                discoveredRooms: persistentMap, // Load from persistent map
                activeEnemies: []
            };

            // â”€â”€ Restore persisted enemy respawn timers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Enemies killed in a previous visit keep their 30-min timer.
            // Expired ones (timer has elapsed) are removed so they spawn normally.
            const savedTimers = (gameState.player.dungeonTimers && gameState.player.dungeonTimers[dungeonKey]) || [];
            if (savedTimers.length > 0) {
                const now = Date.now();
                const stillPending = savedTimers.filter(e => now < e.respawnTime);
                const justRespawned = savedTimers.filter(e => now >= e.respawnTime);
                gameState.dungeon.defeatedEnemies = stillPending;
                if (!gameState.player.dungeonTimers) gameState.player.dungeonTimers = {};
                gameState.player.dungeonTimers[dungeonKey] = stillPending; // prune expired
                if (justRespawned.length > 0)
                    console.log(`â™»ï¸ ${justRespawned.length} enemy timer(s) expired â€” enemies will spawn normally`);
                if (stillPending.length > 0)
                    console.log(`â±ï¸ ${stillPending.length} enemy timer(s) still active for ${dungeonKey}`);
            }

            openTerminalView(dungeonKey);

            const room = floor.rooms[floor.startRoom];
            room.flags.discovered = true;

            termAppend('', 'term-separator');
            termAppend(`<strong>${room.name || 'Entrance'}</strong>`);
            termAppend(room.description || 'You step into the darkness.', 'term-dim');

            const exits = Object.keys(room.exits).map(d => d.toUpperCase()).join(', ');
            termAppend(`You see exits: ${exits}.`, 'term-dim');

            // Check for townExit flag at start room
            checkTownExit(room);

            saveGame();
            renderDungeonActionBar();
        }

        function showBank() {
            checkGameVersion();
            const screen = document.getElementById('mainScreen');
            const p = gameState.player;
            screen.innerHTML = `
                <div class="location-header">ğŸ¦ TOWN BANK</div>
                <button onclick="showTown()" style="margin-bottom:10px;">â† BACK TO TOWN</button>
                ${renderPlayerStats()}
                <div class="message" style="border-color:var(--highlight-color);">
                    <p><strong style="color:var(--highlight-color);">ğŸ’° YOUR VAULT IS SAFE</strong></p>
                    <p style="color:#8aaa8a;">Gold stored in the bank is protected from death penalties in dungeons!</p>
                </div>
                <div class="message">
                    <p><span class="stat-label">Carried Gold:</span> <span style="color:#FFD700;">${p.gold}g</span></p>
                    <p><span class="stat-label">Bank Vault:</span> <span style="color:#00FF00;">${p.bankGold || 0}g</span></p>
                </div>
                <div style="margin: 20px 0;">
                    <div class="message">
                        <p><span class="stat-label">Deposit Gold:</span></p>
                        <input type="number" id="depositAmount" min="1" max="${p.gold}" value="${Math.min(100, p.gold)}" 
                               style="width:150px;padding:8px;background:var(--secondary-bg);color:var(--text-color);border:2px solid var(--border-color);font-family:'Courier New',monospace;font-size:16px;">
                        <button onclick="depositGold()" style="margin-left:10px;">ğŸ’° DEPOSIT</button>
                    </div>
                    <div class="message">
                        <p><span class="stat-label">Withdraw Gold:</span></p>
                        <input type="number" id="withdrawAmount" min="1" max="${p.bankGold || 0}" value="${Math.min(100, p.bankGold || 0)}" 
                               style="width:150px;padding:8px;background:var(--secondary-bg);color:var(--text-color);border:2px solid var(--border-color);font-family:'Courier New',monospace;font-size:16px;">
                        <button onclick="withdrawGold()" style="margin-left:10px;">ğŸ’µ WITHDRAW</button>
                    </div>
                </div>
                <button onclick="showTown()">â† BACK TO TOWN</button>
            `;
        }

        function depositGold() {
            const amount = parseInt(document.getElementById('depositAmount').value);
            const p = gameState.player;
            
            if (isNaN(amount) || amount <= 0) {
                alert('Invalid amount!');
                return;
            }
            
            if (amount > p.gold) {
                alert('You don\'t have that much gold!');
                return;
            }
            
            p.gold -= amount;
            p.bankGold = (p.bankGold || 0) + amount;
            
            saveGame();
            showBank();
        }

        function withdrawGold() {
            const amount = parseInt(document.getElementById('withdrawAmount').value);
            const p = gameState.player;
            
            if (isNaN(amount) || amount <= 0) {
                alert('Invalid amount!');
                return;
            }
            
            if (amount > (p.bankGold || 0)) {
                alert('You don\'t have that much gold in the bank!');
                return;
            }
            
            p.bankGold -= amount;
            p.gold += amount;
            
            saveGame();
            showBank();
        }

        function showModemSettings() {
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">ğŸ“ MODEM SETTINGS ğŸ“</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>Select your connection speed:</p>
                    <p style="font-size: 14px; color: var(--border-color);">Current: ${currentModemSpeed}</p>
                </div>
                <div style="margin: 20px 0;">
                    <div class="menu-option ${currentModemSpeed === '4800' ? 'equipped' : ''}" onclick="setModemSpeed('4800')">
                        â–º 4800 BAUD (Ultra Slow - Maximum Nostalgia)
                    </div>
                    <div class="menu-option ${currentModemSpeed === '9600' ? 'equipped' : ''}" onclick="setModemSpeed('9600')">
                        â–º 9600 BAUD (Very Slow - Early 90s)
                    </div>
                    <div class="menu-option ${currentModemSpeed === '14.4k' ? 'equipped' : ''}" onclick="setModemSpeed('14.4k')">
                        â–º 14.4k MODEM (Slow - Classic BBS Feel)
                    </div>
                    <div class="menu-option ${currentModemSpeed === '28.8k' ? 'equipped' : ''}" onclick="setModemSpeed('28.8k')">
                        â–º 28.8k MODEM (Medium - Mid 90s Standard)
                    </div>
                    <div class="menu-option ${currentModemSpeed === '56k' ? 'equipped' : ''}" onclick="setModemSpeed('56k')">
                        â–º 56k MODEM (Fast - Late 90s)
                    </div>
                    <div class="menu-option ${currentModemSpeed === 'instant' ? 'equipped' : ''}" onclick="setModemSpeed('instant')">
                        â–º INSTANT (No Delay - Modern Broadband)
                    </div>
                </div>
                <div class="message" style="border-color: var(--highlight-color);">
                    <p style="color: var(--highlight-color);">â„¹ï¸ INFO</p>
                    <p style="font-size: 14px;">Modem speed affects how quickly text appears on screen.</p>
                    <p style="font-size: 14px;">Lower speeds = more authentic 1990s BBS experience!</p>
                    <p style="font-size: 14px;">Combat timer won't start until screen finishes loading.</p>
                </div>
                <button onclick="showTown()">BACK TO TOWN</button>
            `;
        }

        function setModemSpeed(speed) {
            currentModemSpeed = speed;
            showModemSettings();
        }

        function renderPlayerStats() {
            const p = gameState.player;
            const hpPercent = (p.hp / p.maxHp) * 100;
            const mpPercent = (p.mp / p.maxMp) * 100;
            const xpAtThisLevel  = getXpForLevel(p.baseClass || p.class || p.class, p.level);
            const xpAtNextLevel  = p.xpToNext;
            const xpIntoLevel    = p.xp - xpAtThisLevel;
            const xpNeededInLevel = xpAtNextLevel - xpAtThisLevel;
            const xpPercent = xpNeededInLevel > 0 ? (xpIntoLevel / xpNeededInLevel) * 100 : 100;
            
            // Get display class name
            let displayClass;
            if (p.hasEvolved) {
                // Show advanced class name if evolved
                displayClass = `<span style="color:#FF00FF;font-weight:bold;">${getAdvancedClassName(p)}</span>`;
            } else if (p.className) {
                // Use stored className
                displayClass = p.className;
            } else if (p.class && CLASSES[p.class]) {
                // Fallback: get from CLASSES object
                displayClass = CLASSES[p.class].name;
            } else {
                // Last resort: capitalize the class key
                displayClass = p.class ? p.class.charAt(0).toUpperCase() + p.class.slice(1) : 'Adventurer';
            }

            return `
                <div class="stats-bar">
                    <div>
                        <span class="stat-label">${p.name}${getRunestonePip(p)}</span> - Level ${p.level} ${displayClass}
                    </div>
                    <div>
                        <span class="stat-label">Gold:</span> ${p.gold}
                    </div>
                </div>
                <div class="stats-bar">
                    <div>
                        <span class="stat-label">HP:</span> <span id="townHp">${p.hp}/${p.maxHp}</span>
                    </div>
                    <div>
                        <span class="stat-label">MP:</span> <span id="townMp">${p.mp}/${p.maxMp}</span>
                    </div>
                    <div>
                        <span class="stat-label">XP:</span> ${p.xp}/${p.xpToNext}
                        <span style="color:#888;font-size:0.85em;"> (${Math.floor(((p.xp - getXpForLevel(p.baseClass||p.class, p.level)) / Math.max(1, p.xpToNext - getXpForLevel(p.baseClass||p.class, p.level))) * 100)}% to next)</span>
                    </div>
                </div>
            `;
        }

        function showShop() {
            checkGameVersion();
            const screen = document.getElementById('mainScreen');
            
            let shopHtml = `
                <div class="location-header">MERCHANT SHOP</div>
                <button onclick="showTown()" style="margin-bottom:10px;">LEAVE SHOP</button>
                ${renderPlayerStats()}
                <div class="message">
                    <p>Welcome to my shop! What can I do for you?</p>
                </div>
                <div style="margin: 20px 0;">
                    <button onclick="showShopBuy()" style="margin-right: 10px;">ğŸ’° BUY ITEMS</button>
                    <button onclick="showShopSell()">ğŸ’ SELL ITEMS</button>
                </div>
                <div id="shopContent"></div>
                <button onclick="showTown()">LEAVE SHOP</button>
            `;
            
            screen.innerHTML = shopHtml;
            showShopBuy(); // Default to buy tab
        }

        function enterDungeons() {
    checkGameVersion();
    termClear();
    testDungeon();
}


        function showShopBuy() {
            const p = gameState.player;
            const playerClass = p.baseClass || p.class;
            
            let shopHtml = `
                <div style="margin: 20px 0;">
                    <h3 style="color: var(--highlight-color);">WEAPONS</h3>
                    <div class="inventory-grid">
            `;

            Object.keys(WEAPONS).forEach(key => {
                const weapon = WEAPONS[key];
                
                // Filter by level, class, and quality â€” shop only sells common (normal) gear.
                // Higher quality items come from drops only. Also enforce class restrictions.
                if (!weapon.unarmed && weapon.quality === 'normal' && weapon.level <= p.level + 2 && canUseWeapon(playerClass, weapon)) {
                    const owned = p.inventory.includes(key);
                    const equipped = p.weapon === key;
                    const qualityColor = QUALITY_CONFIG[weapon.quality].color;
                    const qualityBonus = getQualityBonus(weapon.quality, weapon.baseDamage);
                    const totalDmg = weapon.baseDamage + qualityBonus;
                    const totalMag = weapon.baseMagicDamage + getQualityBonus(weapon.quality, weapon.baseMagicDamage);
                    
                    // Build modifier display
                    let modifierHtml = '';
                    if (weapon.modifiers && weapon.modifiers.length > 0) {
                        modifierHtml = '<div style="margin-top:3px;font-size:11px;">';
                        weapon.modifiers.forEach(modKey => {
                            const mod = WEAPON_MODIFIERS[modKey];
                            if (mod) {
                                modifierHtml += `<div style="color:${mod.color};">â€¢ ${mod.name}</div>`;
                            }
                        });
                        modifierHtml += '</div>';
                    }
                    
                    shopHtml += `
                        <div class="item-card ${equipped ? 'equipped' : ''}">
                            <div style="color: ${qualityColor};">${weapon.name}</div>
                            <div style="font-size:12px;">${buildWeaponDmgLine(weapon)}</div>
                            ${modifierHtml}
                            ${buildGemSlotHtml(weapon)}
                            <div>Level: ${weapon.level}</div>
                            ${owned ? '<div style="color: var(--border-color);">OWNED</div>' : 
                              `<button onclick="buyItem('weapon', '${key}', ${weapon.cost})">Buy ${weapon.cost}G</button>`}
                            ${p.cha ? '<div style="color:#8aaa8a;font-size:15px;">CHA disc: ' + calcChaDiscount(p.cha) + '%</div>' : ''}
                        </div>
                    `;
                }
            });

            shopHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">ARMOR</h3>
                    <div class="inventory-grid">
            `;

            Object.keys(ARMOR).forEach(key => {
                const armor = ARMOR[key];
                
                // Filter: shop only sells normal quality, class-appropriate armor.
                // Better armor drops from enemies. Skip virtual slots and drop-only pieces.
                if (!armor.unarmored && !armor.isDropped && armor.quality === 'normal' && armor.level <= p.level + 2 && canUseArmor(playerClass, armor)) {
                    const owned = p.inventory.includes(key);
                    const equipped = p.armor === key;
                    const qualityColor = QUALITY_CONFIG[armor.quality].color;
                    const qualityBonus = getQualityBonus(armor.quality, armor.baseDefense);
                    const totalDef = armor.baseDefense + qualityBonus;
                    const totalMag = (armor.baseMagicBonus || 0) + getQualityBonus(armor.quality, armor.baseMagicBonus || 0);
                    
                    shopHtml += `
                        <div class="item-card ${equipped ? 'equipped' : ''}">
                            <div style="color: ${qualityColor};">${armor.name}</div>
                            <div>DEF: ${totalDef}</div>
                            ${totalMag > 0 ? `<div>MAG+: ${totalMag}</div>` : ''}
                            <div>Level: ${armor.level}</div>
                            ${owned ? '<div style="color: var(--border-color);">OWNED</div>' : 
                              `<button onclick="buyItem('armor', '${key}', ${armor.cost})">Buy ${armor.cost}G</button>`}
                            ${p.cha ? '<div style="color:#8aaa8a;font-size:15px;">CHA disc: ' + calcChaDiscount(p.cha) + '%</div>' : ''}
                        </div>
                    `;
                }
            });

            shopHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">POTIONS</h3>
                    <div class="inventory-grid">
            `;

            // Add potions to shop
            const potionsForSale = ['health_potion', 'greater_health_potion', 'superior_health_potion',
                                   'mana_potion', 'greater_mana_potion', 'superior_mana_potion', 'elixir',
                                   'recall_potion'];
            
            potionsForSale.forEach(key => {
                if (ITEMS[key]) {
                    const item = ITEMS[key];
                    const p = gameState.player;

                    if (key === 'recall_potion') {
                        // Special recall potion card â€” one per character, dungeon use only
                        const alreadyOwned = p.inventory.includes('recall_potion');
                        shopHtml += `
                            <div class="item-card" style="border-color:#AA88FF;">
                                <div style="color:#AA88FF;font-size:17px;">ğŸŒ€ ${item.name}</div>
                                <div style="color:#888;font-size:13px;font-style:italic;">${item.lore}</div>
                                <div style="color:#ffcc00;margin-top:4px;">${item.description}</div>
                                <div style="color:#ff8800;font-size:13px;">âš  Dungeon use only Â· 1 per adventure</div>
                                ${alreadyOwned
                                    ? '<div style="color:#AA88FF;font-size:14px;margin-top:4px;">ALREADY OWNED</div>'
                                    : `<button onclick="buyItem('item', 'recall_potion', 1000)"
                                        style="border-color:#AA88FF;color:#AA88FF;margin-top:6px;">Buy 1000G</button>`
                                }
                            </div>
                        `;
                    } else {
                        shopHtml += `
                            <div class="item-card">
                                <div style="color: var(--highlight-color);">${item.name}</div>
                                <div>${item.description}</div>
                                <div>Power: ${item.power || 'Full'}</div>
                                <button onclick="buyItem('item', '${key}', ${item.cost})">Buy ${item.cost}G</button>
                                ${p.cha ? '<div style="color:#8aaa8a;font-size:15px;">CHA disc: ' + calcChaDiscount(p.cha) + '%</div>' : ''}
                            </div>
                        `;
                    }
                }
            });

            shopHtml += `
                    </div>
                </div>
            `;
            
            document.getElementById('shopContent').innerHTML = shopHtml;
        }

        function showShopSell() {
            const p = gameState.player;
            const QUALITY_ORDER = ['poor','normal','rare','epic','legendary','godly'];

            // Current sell threshold from UI (default: poor = only poor)
            const thresholdEl = document.getElementById('sellQualityThreshold');
            const threshold   = thresholdEl ? thresholdEl.value : 'poor';
            const thresholdIdx = QUALITY_ORDER.indexOf(threshold);

            // Build sellable item list
            const itemCounts = {};
            p.inventory.forEach(itemKey => {
                if (ITEMS[itemKey] && (ITEMS[itemKey].sellValue > 0)) {
                    if (!itemCounts[itemKey]) itemCounts[itemKey] = { type:'item', count:0 };
                    itemCounts[itemKey].count++;
                } else if (WEAPONS[itemKey] && itemKey !== p.weapon && !WEAPONS[itemKey].unarmed) {
                    // Group by itemKey + quality to avoid stacking different qualities
                    const wpn = WEAPONS[itemKey];
                    const groupKey = `${itemKey}__${wpn.quality || 'normal'}`;
                    if (!itemCounts[groupKey]) itemCounts[groupKey] = { type:'weapon', count:0, baseKey:itemKey, quality:wpn.quality };
                    itemCounts[groupKey].count++;
                } else if (ARMOR[itemKey] && itemKey !== p.armor && !ARMOR[itemKey].unarmored) {
                    // Group by itemKey + quality to avoid stacking different qualities
                    const arm = ARMOR[itemKey];
                    const groupKey = `${itemKey}__${arm.quality || 'normal'}`;
                    if (!itemCounts[groupKey]) itemCounts[groupKey] = { type:'armor', count:0, baseKey:itemKey, quality:arm.quality };
                    itemCounts[groupKey].count++;
                }
            });

            // Determine which items are within the sell threshold
            function getItemQualityIdx(itemKey, type) {
                if (type === 'item') return -1; // items always sellable
                if (type === 'weapon') return QUALITY_ORDER.indexOf(WEAPONS[itemKey]?.quality || 'poor');
                if (type === 'armor')  return QUALITY_ORDER.indexOf(ARMOR[itemKey]?.quality || 'poor');
                return -1;
            }

            // Count gold total for "sell all" preview
            let sellAllGold = 0;
            let sellAllCount = 0;
            Object.entries(itemCounts).forEach(([itemKey, data]) => {
                const qIdx = getItemQualityIdx(itemKey, data.type);
                if (data.type === 'item' || qIdx <= thresholdIdx) {
                    const sv = getSellValue(itemKey, data.type);
                    sellAllGold  += sv * data.count;
                    sellAllCount += data.count;
                }
            });

            const qualityOptions = QUALITY_ORDER.map(q => {
                const cfg = QUALITY_CONFIG[q];
                return `<option value="${q}" ${q === threshold ? 'selected' : ''}>
                    ${cfg.name} and below
                </option>`;
            }).join('');

            let sellHtml = `
                <div style="margin-bottom:12px;">
                    <div style="color:var(--highlight-color);font-size:18px;margin-bottom:8px;">SELL ITEMS</div>
                    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:10px;">
                        <label style="font-size:14px;color:#aaa;">Sell threshold:</label>
                        <select id="sellQualityThreshold"
                            style="background:#111;border:1px solid var(--border-color);color:#fff;padding:4px 8px;font-size:14px;"
                            onchange="showShopSell()">
                            ${qualityOptions}
                        </select>
                        <button onclick="sellAllBelowThreshold()"
                            style="background:#222;border:1px solid #ff8c00;color:#ff8c00;padding:5px 14px;font-size:14px;cursor:pointer;">
                            ğŸ’° SELL ALL (${sellAllCount} items Â· ${sellAllGold}g)
                        </button>
                    </div>
                    <div style="font-size:12px;color:#666;">Items at or below the chosen quality tier will be sold. Equipped gear is never sold.</div>
                </div>
                <div class="inventory-grid">`;

            const itemKeys = Object.keys(itemCounts);
            if (itemKeys.length === 0) {
                sellHtml += '<div class="message">You have nothing to sell.</div>';
            } else {
                itemKeys.forEach(groupKey => {
                    const data = itemCounts[groupKey];
                    // For weapons/armor, use baseKey to lookup the actual item; for items, groupKey = itemKey
                    const actualItemKey = data.baseKey || groupKey;
                    const qIdx = getItemQualityIdx(actualItemKey, data.type);
                    const withinThreshold = data.type === 'item' || qIdx <= thresholdIdx;

                    let itemName, itemColor, sellValue, itemDesc, qualityLabel = '';

                    if (data.type === 'item') {
                        const item = ITEMS[actualItemKey];
                        itemName  = item.name;
                        itemColor = '#00FF00';
                        sellValue = item.sellValue;
                        itemDesc  = item.description;
                    } else if (data.type === 'weapon') {
                        const weapon = WEAPONS[actualItemKey];
                        itemName     = weapon.name;
                        itemColor    = QUALITY_CONFIG[weapon.quality]?.color || '#fff';
                        sellValue    = getSellValue(actualItemKey, 'weapon');
                        qualityLabel = QUALITY_CONFIG[weapon.quality]?.name || '';
                        const qb     = getQualityBonus(weapon.quality, weapon.baseDamage);
                        itemDesc     = `DMG: ${weapon.baseDamage+qb}`;
                    } else if (data.type === 'armor') {
                        const armor = ARMOR[actualItemKey];
                        itemName     = armor.name;
                        itemColor    = QUALITY_CONFIG[armor.quality]?.color || '#fff';
                        sellValue    = getSellValue(actualItemKey, 'armor');
                        qualityLabel = QUALITY_CONFIG[armor.quality]?.name || '';
                        const qb     = getQualityBonus(armor.quality, armor.baseDefense);
                        itemDesc     = `DEF: ${armor.baseDefense+qb}`;
                    }

                    const dimmed = !withinThreshold ? 'opacity:0.4;' : '';

                    sellHtml += `
                        <div class="item-card" style="${dimmed}">
                            <div style="color:${itemColor};">${itemName}${qualityLabel ? ` <span style="font-size:11px;">[${qualityLabel}]</span>` : ''}${data.count > 1 ? ` <span style="color:#FFD700;">x${data.count}</span>` : ''}</div>
                            <div style="font-size:14px;color:#aaa;">${itemDesc}</div>
                            <div style="color:var(--border-color);margin-top:6px;">${sellValue}g each</div>
                            ${withinThreshold
                                ? `<button onclick="sellItemGroup('${groupKey}', ${sellValue}, ${data.count})" style="margin-top:6px;">SELL${data.count > 1 ? ` ALL (${sellValue*data.count}g)` : ` (${sellValue}g)`}</button>`
                                : `<div style="font-size:11px;color:#555;margin-top:6px;">Above threshold</div>`
                            }
                        </div>`;
                });
            }
            sellHtml += '</div>';
            document.getElementById('shopContent').innerHTML = sellHtml;
        }

        // Returns sell value for a weapon or armor (10% of cost)
        function getSellValue(itemKey, type) {
            if (type === 'item') return ITEMS[itemKey]?.sellValue || 0;
            if (type === 'weapon') return Math.max(1, Math.floor((WEAPONS[itemKey]?.cost || 0) * 0.10));
            if (type === 'armor')  return Math.max(1, Math.floor((ARMOR[itemKey]?.cost  || 0) * 0.10));
            return 0;
        }

        function sellAllBelowThreshold() {
            const p = gameState.player;
            const QUALITY_ORDER = ['poor','normal','rare','epic','legendary','godly'];
            const thresholdEl = document.getElementById('sellQualityThreshold');
            const threshold   = thresholdEl ? thresholdEl.value : 'poor';
            const thresholdIdx = QUALITY_ORDER.indexOf(threshold);
            const bonus = calcChaSellBonus(p.cha);

            let totalGold = 0, totalItems = 0;
            const toRemove = [];

            // Collect items to sell (don't remove during iteration)
            p.inventory.forEach(itemKey => {
                if (ITEMS[itemKey] && ITEMS[itemKey].sellValue > 0) {
                    toRemove.push({ key: itemKey, value: ITEMS[itemKey].sellValue });
                } else if (WEAPONS[itemKey] && itemKey !== p.weapon && !WEAPONS[itemKey].unarmed) {
                    const qIdx = QUALITY_ORDER.indexOf(WEAPONS[itemKey]?.quality || 'poor');
                    if (qIdx <= thresholdIdx) toRemove.push({ key: itemKey, value: getSellValue(itemKey, 'weapon') });
                } else if (ARMOR[itemKey] && itemKey !== p.armor && !ARMOR[itemKey].unarmored) {
                    const qIdx = QUALITY_ORDER.indexOf(ARMOR[itemKey]?.quality || 'poor');
                    if (qIdx <= thresholdIdx) toRemove.push({ key: itemKey, value: getSellValue(itemKey, 'armor') });
                }
            });

            if (toRemove.length === 0) {
                showShopSell(); return;
            }

            // Remove all and tally gold
            toRemove.forEach(({ key, value }) => {
                const idx = p.inventory.indexOf(key);
                if (idx !== -1) {
                    p.inventory.splice(idx, 1);
                    const actualValue = Math.floor(value * (1 + bonus/100));
                    totalGold  += actualValue;
                    totalItems++;
                }
            });

            p.gold += totalGold;
            const bonusText = bonus > 0 ? ` (+${bonus}% CHA)` : '';
            // No popup â€” just refresh sell panel with a brief status line
            saveGame();
            showShopSell();
            // Insert a one-line feedback message above the panel
            const content = document.getElementById('shopContent');
            const msg = document.createElement('div');
            msg.style.cssText = 'background:#111;border:1px solid #ff8c00;color:#ff8c00;padding:6px 12px;font-size:15px;margin-bottom:10px;';
            msg.textContent = `Sold ${totalItems} item${totalItems!==1?'s':''} for ${totalGold}g${bonusText}.`;
            content.prepend(msg);
            setTimeout(() => msg.remove(), 3000);
        }

        function sellItemGroup(groupKey, baseValue, quantity = 1) {
            // groupKey might be "itemKey__quality" for weapons/armor, or just "itemKey" for items
            // We need to sell the actual items from inventory that match this group
            const p = gameState.player;
            const parts = groupKey.split('__');
            const actualItemKey = parts[0];
            const targetQuality = parts[1]; // undefined for items
            
            let removed = 0;
            for (let i = p.inventory.length - 1; i >= 0 && removed < quantity; i--) {
                const invKey = p.inventory[i];
                // For items: match key exactly
                // For weapons/armor: match key AND quality
                if (invKey === actualItemKey || invKey.startsWith(actualItemKey)) {
                    // Check quality match for weapons/armor
                    if (targetQuality) {
                        const item = WEAPONS[invKey] || ARMOR[invKey];
                        if (item && item.quality === targetQuality) {
                            p.inventory.splice(i, 1);
                            removed++;
                        }
                    } else {
                        // No quality check needed (it's an item)
                        p.inventory.splice(i, 1);
                        removed++;
                    }
                }
            }
            if (removed === 0) return;
            const bonus      = calcChaSellBonus(p.cha);
            const unitValue  = Math.floor(baseValue * (1 + bonus/100));
            const totalValue = unitValue * removed;
            p.gold += totalValue;
            saveGame();
            showShopSell();
            // Brief inline feedback, no alert()
            const content = document.getElementById('shopContent');
            if (content) {
                const msg = document.createElement('div');
                const name = getItemName(actualItemKey);
                msg.style.cssText = 'background:#111;border:1px solid #4a9a4a;color:#4a9a4a;padding:6px 12px;font-size:15px;margin-bottom:10px;';
                msg.textContent = `Sold ${removed > 1 ? removed+'Ã— ' : ''}${name} for ${totalValue}g.`;
                content.prepend(msg);
                setTimeout(() => msg.remove(), 2500);
            }
        }

        function showSellQuantityPrompt(itemKey, unitPrice, totalCount) {
            // Legacy path â€” no longer used but kept for safety
            sellItem(itemKey, unitPrice, totalCount);
        }

        function sellItem(itemKey, baseValue, quantity = 1) {
            const p = gameState.player;
            let removed = 0;
            for (let i = p.inventory.length - 1; i >= 0 && removed < quantity; i--) {
                if (p.inventory[i] === itemKey) { p.inventory.splice(i, 1); removed++; }
            }
            if (removed === 0) return;
            const bonus      = calcChaSellBonus(p.cha);
            const unitValue  = Math.floor(baseValue * (1 + bonus/100));
            const totalValue = unitValue * removed;
            p.gold += totalValue;
            saveGame();
            showShopSell();
            // Brief inline feedback, no alert()
            const content = document.getElementById('shopContent');
            if (content) {
                const msg = document.createElement('div');
                const name = getItemName(itemKey);
                msg.style.cssText = 'background:#111;border:1px solid #4a9a4a;color:#4a9a4a;padding:6px 12px;font-size:15px;margin-bottom:10px;';
                msg.textContent = `Sold ${removed > 1 ? removed+'Ã— ' : ''}${name} for ${totalValue}g.`;
                content.prepend(msg);
                setTimeout(() => msg.remove(), 2500);
            }
        }

        function buyItem(type, key, baseCost) {
            const p = gameState.player;
            const playerClass = p.baseClass || p.class;
            
            // Recall potion: only one allowed at a time
            if (key === 'recall_potion' && p.inventory.includes('recall_potion')) {
                alert('You already carry a Recall Potion.\nYou can only hold one at a time.');
                return;
            }

            // Validate class restrictions
            if (type === 'weapon') {
                const weapon = WEAPONS[key];
                if (!canUseWeapon(playerClass, weapon)) {
                    alert(`Your class (${playerClass}) cannot use ${weapon.name}!`);
                    return;
                }
                if (weapon.level > p.level) {
                    alert(`You must be level ${weapon.level} to buy ${weapon.name}!`);
                    return;
                }
            } else if (type === 'armor') {
                const armor = ARMOR[key];
                if (!canUseArmor(playerClass, armor)) {
                    alert(`Your class (${playerClass}) cannot use ${armor.name}!`);
                    return;
                }
                if (armor.level > p.level) {
                    alert(`You must be level ${armor.level} to buy ${armor.name}!`);
                    return;
                }
            }
            
            const disc   = calcChaDiscount(p.cha);
            const cost   = Math.max(1, Math.floor(baseCost * (1 - disc/100)));
            if (p.gold < cost) {
                alert('Not enough gold!');
                return;
            }
            p.gold -= cost;
            p.inventory.push(key);
            let itemName;
            if (type === 'weapon') itemName = WEAPONS[key].name;
            else if (type === 'armor') itemName = ARMOR[key].name;
            else if (type === 'item') itemName = ITEMS[key].name;
            alert(`Purchased ${itemName} for ${cost}g!` + (disc > 0 ? ` (${disc}% CHA discount)` : ''));
            
            // ğŸ’¾ AUTO-SAVE after buying
            saveGame();
            
            showShopBuy();
        }

        function restAtInn() {
            const cost = calcInnCost(gameState.player.cha);
            if (gameState.player.gold < cost) {
                alert('Not enough gold!');
                return;
            }
            gameState.player.gold -= cost;
            gameState.player.hp = gameState.player.maxHp;
            gameState.player.mp = gameState.player.maxMp;
            alert('You rest at the inn and recover fully!');
            showTown();
        }

        function showInventory() {
            checkGameVersion();
            const p = gameState.player;
            const playerClass = p.baseClass || p.class;
            const screen = document.getElementById('mainScreen');
            
            let invHtml = `
                <div class="location-header">INVENTORY</div>
                <button onclick="showTown()" style="margin-bottom:10px;">BACK</button>
                ${renderPlayerStats()}
                <div style="margin: 20px 0;">
                    <h3 style="color: var(--highlight-color);">WEAPONS</h3>
                    <div class="inventory-grid">
            `;

            // â”€â”€ Currently equipped weapon slot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const eqWeapon    = WEAPONS[p.weapon];
            const eqWIsUnarmed = !eqWeapon || !!eqWeapon.unarmed;
            if (eqWIsUnarmed) {
                invHtml += `
                    <div class="item-card equipped" style="border-color:#555;">
                        <div style="color:#888;">âœŠ Bare Fists</div>
                        <div style="color:#555;font-size:13px;">DMG: 0 (stats only)</div>
                        <div style="color:#555;font-size:12px;">No weapon equipped</div>
                    </div>
                `;
            } else {
                const qc   = QUALITY_CONFIG[eqWeapon.quality];
                const qb   = getQualityBonus(eqWeapon.quality, eqWeapon.baseDamage);
                const tMin = eqWeapon.baseDamage + qb;
                const tMax = eqWeapon.maxDamage ? eqWeapon.maxDamage + getQualityBonus(eqWeapon.quality, eqWeapon.maxDamage - eqWeapon.baseDamage) : tMin;
                const tMag = (eqWeapon.baseMagicDamage || 0) + Math.floor((eqWeapon.baseMagicDamage || 0) * (qc?.bonusPct || 0));
                
                // Build modifier display for equipped weapon
                let eqModifierHtml = '';
                if (eqWeapon.modifiers && eqWeapon.modifiers.length > 0) {
                    eqModifierHtml = '<div style="margin-top:5px;font-size:12px;">';
                    eqWeapon.modifiers.forEach(modKey => {
                        if (typeof WEAPON_MODIFIERS === 'undefined') {
                            eqModifierHtml += `<div style="color:#FF8800;">â€¢ ${modKey}</div>`;
                            return;
                        }
                        const mod = WEAPON_MODIFIERS[modKey];
                        if (mod) {
                            eqModifierHtml += `<div style="color:${mod.color};">â€¢ ${mod.name}`;
                            if (mod.minDamage) eqModifierHtml += ` (${mod.minDamage}-${mod.maxDamage})`;
                            eqModifierHtml += `</div>`;
                        }
                    });
                    eqModifierHtml += '</div>';
                }
                
                invHtml += `
                    <div class="item-card equipped">
                        <div style="color:${qc?.color || '#0f0'};">âš”ï¸ ${eqWeapon.name}</div>
                        <div style="font-size:12px;">${buildWeaponDmgLine(eqWeapon)}</div>
                        ${eqModifierHtml}
                        ${buildGemSlotHtml(eqWeapon)}
                        <div style="color:var(--border-color);">EQUIPPED</div>
                        <button onclick="unequipItem('weapon')" style="border-color:#ff4444;color:#ff4444;margin-top:4px;">UNEQUIP</button>
                    </div>
                `;
            }

            // â”€â”€ Other weapons in inventory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            p.inventory.filter(item => {
                const weapon = WEAPONS[item];
                // Skip bare_fists (virtual slot) and currently equipped
                return weapon && !weapon.unarmed;
            }).forEach(key => {
                const weapon = WEAPONS[key];
                const equipped = p.weapon === key;
                if (equipped) return; // already shown in the equipped slot above
                
                const canEquip = canUseWeapon(playerClass, weapon);
                const qualityColor = QUALITY_CONFIG[weapon.quality].color;
                const qualityBonus = getQualityBonus(weapon.quality, weapon.baseDamage);
                const totalDmg = weapon.baseDamage + qualityBonus;
                const totalMag = weapon.baseMagicDamage + Math.floor(weapon.baseMagicDamage * (QUALITY_CONFIG[weapon.quality]?.bonusPct || 0));
                const totalMax = weapon.maxDamage ? weapon.maxDamage + getQualityBonus(weapon.quality, weapon.maxDamage - weapon.baseDamage) : totalDmg;
                
                // Build modifier display
                let modifierHtml = '';
                if (weapon.modifiers && weapon.modifiers.length > 0) {
                    modifierHtml = '<div style="margin-top:5px;font-size:12px;">';
                    weapon.modifiers.forEach(modKey => {
                        if (typeof WEAPON_MODIFIERS === 'undefined') {
                            console.warn('WEAPON_MODIFIERS not loaded');
                            modifierHtml += `<div style="color:#FF8800;">â€¢ ${modKey}</div>`;
                            return;
                        }
                        const mod = WEAPON_MODIFIERS[modKey];
                        if (mod) {
                            modifierHtml += `<div style="color:${mod.color};">â€¢ ${mod.name}`;
                            if (mod.minDamage) modifierHtml += ` (${mod.minDamage}-${mod.maxDamage})`;
                            modifierHtml += `</div>`;
                        } else {
                            console.warn(`Modifier ${modKey} not found in WEAPON_MODIFIERS`);
                        }
                    });
                    modifierHtml += '</div>';
                }
                
                invHtml += `
                    <div class="item-card${canEquip ? '' : ' unusable'}" style="${canEquip ? '' : 'opacity:0.5;border-color:#555;'}">
                        <div style="color: ${qualityColor};">${weapon.name}</div>
                        <div style="font-size:12px;">${buildWeaponDmgLine(weapon)}</div>
                        ${modifierHtml}
                        ${buildGemSlotHtml(weapon)}
                        ${canEquip 
                            ? `<button onclick="equipItem('weapon', '${key}')">EQUIP</button>`
                            : `<button disabled style="opacity:0.4;">CANNOT EQUIP</button>`
                        }
                    </div>
                `;
            });

            invHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">ARMOR</h3>
                    <div class="inventory-grid">
            `;

            // â”€â”€ Currently equipped armor slot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const eqArmor      = ARMOR[p.armor];
            const eqAIsUnarmored = !eqArmor || !!eqArmor.unarmored;
            if (eqAIsUnarmored) {
                invHtml += `
                    <div class="item-card equipped" style="border-color:#555;">
                        <div style="color:#888;">ğŸ«¥ No Armor</div>
                        <div style="color:#555;font-size:13px;">DEF: 0</div>
                        <div style="color:#555;font-size:12px;">No armor equipped</div>
                    </div>
                `;
            } else {
                const aqc  = QUALITY_CONFIG[eqArmor.quality];
                const aqb  = getQualityBonus(eqArmor.quality, eqArmor.baseDefense);
                const tDef = eqArmor.baseDefense + aqb;
                const tMag = (eqArmor.baseMagicBonus || 0) + Math.floor((eqArmor.baseMagicBonus || 0) * (aqc?.bonusPct || 0));
                invHtml += `
                    <div class="item-card equipped">
                        <div style="color:${aqc?.color || '#0f0'};">ğŸ›¡ï¸ ${eqArmor.name}</div>
                        <div>DEF: ${tDef}${tMag > 0 ? ` | MAG+: ${tMag}` : ''}</div>
                        <div style="color:var(--border-color);">EQUIPPED</div>
                        <button onclick="unequipItem('armor')" style="border-color:#ff4444;color:#ff4444;margin-top:4px;">UNEQUIP</button>
                    </div>
                `;
            }

            // â”€â”€ Other armors in inventory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            p.inventory.filter(item => {
                const armor = ARMOR[item];
                // Skip no_armor (virtual slot) and currently equipped
                return armor && !armor.unarmored;
            }).forEach(key => {
                const armor = ARMOR[key];
                const equipped = p.armor === key;
                if (equipped) return; // already shown in the equipped slot above
                
                const canEquip = canUseArmor(playerClass, armor);
                const qualityColor = QUALITY_CONFIG[armor.quality].color;
                const qualityBonus = getQualityBonus(armor.quality, armor.baseDefense);
                const totalDef = armor.baseDefense + qualityBonus;
                const totalMag = (armor.baseMagicBonus || 0) + Math.floor((armor.baseMagicBonus || 0) * (QUALITY_CONFIG[armor.quality]?.bonusPct || 0));
                
                invHtml += `
                    <div class="item-card${canEquip ? '' : ' unusable'}" style="${canEquip ? '' : 'opacity:0.5;border-color:#555;'}">
                        <div style="color: ${qualityColor};">${armor.name}</div>
                        <div>DEF: ${totalDef}${totalMag > 0 ? ` | MAG+: ${totalMag}` : ''}</div>
                        ${canEquip
                            ? `<button onclick="equipItem('armor', '${key}')">EQUIP</button>`
                            : `<button disabled style="opacity:0.4;">CANNOT EQUIP</button>`
                        }
                    </div>
                `;
            });

            invHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">SPELLS</h3>
                    <div class="inventory-grid">
            `;

            if (p.knownSpells.length === 0) {
                invHtml += '<div class="message">No spells learned yet.</div>';
            } else {
                p.knownSpells.forEach(spellKey => {
                    const spell = ensureSpellExists(spellKey) || SPELLS[spellKey];
                    if (!spell) {
                        console.warn(`âš ï¸ Spell '${spellKey}' not found in SPELLS object (inventory display)`);
                        return; // Skip this spell
                    }
                    invHtml += `
                        <div class="item-card">
                            <div style="color: var(--highlight-color);">${spell.name}</div>
                            <div>MP Cost: ${spell.mpCost}</div>
                            <div>${spell.minPower !== undefined ? `Power: ${spell.minPower}â€“${spell.maxPower}` : ''}</div>
                            <div>${spell.description}</div>
                        </div>
                    `;
                });
            }

            invHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">CONSUMABLES & ITEMS</h3>
                    <div class="inventory-grid">
            `;

            // Count and display items â€” EXCLUDE dungeon keys (shown in Key Ring below)
            const itemCounts = {};
            p.inventory.filter(item => ITEMS[item] && ITEMS[item].subtype !== 'dungeon_key').forEach(key => {
                itemCounts[key] = (itemCounts[key] || 0) + 1;
            });

            if (Object.keys(itemCounts).length === 0) {
                invHtml += '<div class="message">No items.</div>';
            } else {
                Object.keys(itemCounts).forEach(itemKey => {
                    const item = ITEMS[itemKey];
                    const count = itemCounts[itemKey];
                    const color = item.type === 'sellable' ? '#FFD700' : 
                                 item.subtype === 'heal_hp' ? '#FF0000' :
                                 item.subtype === 'heal_mp' ? '#0000FF' : '#00FF00';
                    
                    // Check if it's a usable potion
                    const isPotion = item.subtype === 'heal_hp' || 
                                    item.subtype === 'heal_mp' || 
                                    item.subtype === 'full_restore' ||
                                    item.subtype?.startsWith('buff_');
                    
                    // Check if at full HP/MP for healing potions
                    let canUse = true;
                    let disabledReason = '';
                    if (item.subtype === 'heal_hp' && p.hp >= p.maxHp) {
                        canUse = false;
                        disabledReason = '(Already at full HP)';
                    } else if (item.subtype === 'heal_mp' && p.mp >= p.maxMp) {
                        canUse = false;
                        disabledReason = '(Already at full MP)';
                    } else if (item.subtype === 'full_restore' && p.hp >= p.maxHp && p.mp >= p.maxMp) {
                        canUse = false;
                        disabledReason = '(Already fully restored)';
                    }
                    
                    // Show total value if sellable and multiple
                    let valueDisplay = '';
                    if (item.sellValue) {
                        if (count > 1) {
                            valueDisplay = `<div style="color: var(--border-color);">${item.sellValue}g each | <span style="color:#FFD700;">Total: ${item.sellValue * count}g</span></div>`;
                        } else {
                            valueDisplay = `<div style="color: var(--border-color);">Value: ${item.sellValue}g</div>`;
                        }
                    }
                    
                    // Add USE button for potions
                    let buttonHtml = '';
                    if (isPotion) {
                        buttonHtml = canUse ? 
                            `<button onclick="useInventoryPotion('${itemKey}')">USE</button>` :
                            `<div style="color:#666;font-size:12px;">${disabledReason}</div>`;
                    }
                    
                    invHtml += `
                        <div class="item-card">
                            <div style="color: ${color};">${item.name} ${count > 1 ? `<span style="color:#FFD700;">x${count}</span>` : ''}</div>
                            <div style="font-size: 16px;">${item.description}</div>
                            ${valueDisplay}
                            ${buttonHtml}
                        </div>
                    `;
                });
            }

            invHtml += `
                    </div>
                </div>
                ${renderKeyRing(p)}
                <button onclick="showTown()">BACK</button>
            `;

            screen.innerHTML = invHtml;
        }

        function renderKeyRing(p) {
            // â”€â”€ Key metadata: ASCII art + color for each key type â”€â”€
            const KEY_META = {
                bronze_key:   { color: '#cd7f32', glow: '#7a3a00', label: 'BRONZE',   ascii: '&lt;=-[O' },
                copper_key:   { color: '#b87333', glow: '#5a2800', label: 'COPPER',   ascii: '&lt;=-{O' },
                iron_key:     { color: '#8a8a8a', glow: '#333333', label: 'IRON',     ascii: '&lt;==|O' },
                brass_key:    { color: '#d4a017', glow: '#6b4c00', label: 'BRASS',    ascii: '&lt;=-&lt;O' },
                silver_key:   { color: '#c0c0c0', glow: '#555577', label: 'SILVER',   ascii: '&lt;==*O' },
                electrum_key: { color: '#88d4c0', glow: '#005544', label: 'ELECTRUM', ascii: '&lt;=~(O' },
                ruby_key:     { color: '#e0115f', glow: '#800030', label: 'RUBY',     ascii: '&lt;=-@O' },
                topaz_key:    { color: '#ffa500', glow: '#804000', label: 'TOPAZ',    ascii: '&lt;=-&Diamond;O' },
                diamond_key:  { color: '#b9f2ff', glow: '#005080', label: 'DIAMOND',  ascii: '&lt;==&lt;&gt;' },
                obsidian_key: { color: '#4a0080', glow: '#200040', label: 'OBSIDIAN', ascii: '&lt;==%O' },
                bone_key:     { color: '#e8dcc8', glow: '#5a4a2a', label: 'BONE',     ascii: '&lt;=-#O' },
            };

            // Collect dungeon keys from inventory (they persist permanently)
            const heldKeys = {};
            (p.inventory || []).forEach(itemKey => {
                if (ITEMS[itemKey] && ITEMS[itemKey].subtype === 'dungeon_key') {
                    heldKeys[itemKey] = (heldKeys[itemKey] || 0) + 1;
                }
            });

            const hasAnyKey = Object.keys(heldKeys).length > 0;

            let html = `
                <div style="margin:20px 0;">
                    <h3 style="
                        color:var(--highlight-color);
                        border-bottom:1px solid var(--border-color);
                        padding-bottom:6px;
                        margin-bottom:12px;
                        letter-spacing:3px;
                    ">âš¿ KEY RING</h3>`;

            if (!hasAnyKey) {
                html += `
                    <div style="
                        font-family:monospace;
                        color:#333;
                        font-size:14px;
                        padding:12px;
                        border:1px solid #1a1a1a;
                        text-align:center;
                        letter-spacing:2px;
                    ">[ NO KEYS COLLECTED ]</div>`;
            } else {
                html += `<div style="display:flex;flex-wrap:wrap;gap:10px;">`;

                Object.entries(heldKeys).forEach(([keyId, count]) => {
                    const meta  = KEY_META[keyId] || { color:'#aaa', glow:'#333', label: keyId.replace('_key','').toUpperCase(), ascii:'&lt;=-[O' };
                    const item  = ITEMS[keyId];
                    const desc  = item ? item.description : '';
                    const cnt   = count > 1 ? ` Ã—${count}` : '';

                    html += `
                        <div title="${desc}" style="
                            font-family:'VT323',monospace;
                            background:#050505;
                            border:1px solid ${meta.color};
                            box-shadow:0 0 8px ${meta.glow},inset 0 0 6px #000;
                            padding:8px 14px;
                            display:inline-flex;
                            flex-direction:column;
                            align-items:center;
                            gap:4px;
                            min-width:90px;
                            cursor:default;
                            position:relative;
                        ">
                            <div style="
                                font-size:22px;
                                letter-spacing:-2px;
                                color:${meta.color};
                                text-shadow:0 0 10px ${meta.color},0 0 4px ${meta.glow};
                                line-height:1;
                            ">${meta.ascii}</div>
                            <div style="
                                font-size:13px;
                                color:${meta.color};
                                letter-spacing:2px;
                                text-shadow:0 0 6px ${meta.color};
                                line-height:1;
                            ">${meta.label}${cnt}</div>
                        </div>`;
                });

                html += `</div>`;
            }

            html += `</div>`;
            return html;
}

// Equip weapon or armor
function equipItem(type, key) {
    const p = gameState.player;
    const playerClass = p.baseClass || p.class;
            
            if (type === 'weapon') {
                const weapon = WEAPONS[key];
                if (!weapon) { alert('Invalid weapon!'); return; }
                // bare_fists always equippable (unequip path)
                if (!weapon.unarmed) {
                    if (!canUseWeapon(playerClass, weapon)) {
                        alert(`Your class (${playerClass}) cannot use ${weapon.name}!`);
                        return;
                    }
                    if (weapon.level > p.level) {
                        alert(`You must be level ${weapon.level} to equip ${weapon.name}!`);
                        return;
                    }
                }
                p.weapon = key;
            } else {
                const armor = ARMOR[key];
                if (!armor) { alert('Invalid armor!'); return; }
                // no_armor always equippable (unequip path)
                if (!armor.unarmored) {
                    if (!canUseArmor(playerClass, armor)) {
                        alert(`Your class (${playerClass}) cannot use ${armor.name}!`);
                        return;
                    }
                    if (armor.level > p.level) {
                        alert(`You must be level ${armor.level} to equip ${armor.name}!`);
                        return;
                    }
                }
                p.armor = key;
            }
            
            // ğŸ’¾ AUTO-SAVE after equipping
            saveGame();
            
            showInventory();
        }

        // Unequip: revert to bare fists or no armor
        function unequipItem(type) {
            const p = gameState.player;
            if (type === 'weapon') {
                p.weapon = 'bare_fists';
            } else {
                p.armor = 'no_armor';
            }
            saveGame();
            showInventory();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // USE POTION FROM INVENTORY
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function useInventoryPotion(potionKey) {
            const potion = ITEMS[potionKey];
            const p = gameState.player;
            
            if (!potion) {
                alert('Invalid potion!');
                return;
            }

            // â”€â”€ Recall Potion â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (potion.subtype === 'recall') {
                alert('Recall Potions can only be used while inside a dungeon.');
                return;
            }
            
            let msg = '';
            let used = false;
            
            // Handle different potion types
            if (potion.subtype === 'heal_hp') {
                if (p.hp >= p.maxHp) {
                    alert("You're already at full HP!");
                    return;
                }
                const actual = Math.min(p.maxHp - p.hp, potion.power);
                p.hp = Math.min(p.maxHp, p.hp + potion.power);
                msg = `Used ${potion.name} â€“ restored ${actual} HP!`;
                used = true;
            } 
            else if (potion.subtype === 'heal_mp') {
                if (p.mp >= p.maxMp) {
                    alert("You're already at full MP!");
                    return;
                }
                const actual = Math.min(p.maxMp - p.mp, potion.power);
                p.mp = Math.min(p.maxMp, p.mp + potion.power);
                msg = `Used ${potion.name} â€“ restored ${actual} MP!`;
                used = true;
            } 
            else if (potion.subtype === 'full_restore') {
                if (p.hp >= p.maxHp && p.mp >= p.maxMp) {
                    alert("You're already fully restored!");
                    return;
                }
                const hpR = p.maxHp - p.hp;
                const mpR = p.maxMp - p.mp;
                p.hp = p.maxHp;
                p.mp = p.maxMp;
                msg = `Used ${potion.name} â€“ fully restored ${hpR} HP & ${mpR} MP!`;
                used = true;
            }
            else if (potion.subtype?.startsWith('buff_')) {
                // Apply buff
                const buffType = potion.subtype;
                const duration = potion.duration || 300000; // 5 minutes default
                
                if (!p.activeBuffs) p.activeBuffs = {};
                
                // Check if buff is already active
                if (p.activeBuffs[buffType] && Date.now() < p.activeBuffs[buffType].endTime) {
                    // Check if we can stack
                    const currentStacks = p.activeBuffs[buffType].stacks || 1;
                    if (currentStacks >= 3) {
                        alert(`${potion.name} is already at maximum stacks (3x)!`);
                        return;
                    }
                    // Stack the buff
                    p.activeBuffs[buffType].stacks = currentStacks + 1;
                    p.activeBuffs[buffType].power = potion.power * (currentStacks + 1);
                    p.activeBuffs[buffType].endTime = Date.now() + duration;
                    msg = `Used ${potion.name} â€“ buff stacked! (${currentStacks + 1}x)`;
                } else {
                    // New buff
                    p.activeBuffs[buffType] = {
                        power: potion.power,
                        endTime: Date.now() + duration,
                        stacks: 1
                    };
                    msg = `Used ${potion.name} â€“ buff activated!`;
                }
                used = true;
            }
            
            if (used) {
                // Remove potion from inventory
                const idx = p.inventory.indexOf(potionKey);
                if (idx !== -1) {
                    p.inventory.splice(idx, 1);
                }
                
                // Update HUD
                updateHud();
                
                // Save game
                saveGame();
                
                // Show message and refresh inventory
                alert(msg);
                showInventory();
            }
        }

        function showExplore() {
            checkGameVersion();
            const screen = document.getElementById('mainScreen');
            const p = gameState.player;
            const tid = gameState.currentTown || 'town1';
            const townDef = (typeof TOWNS !== 'undefined' && TOWNS[tid]) ? TOWNS[tid] : null;

            // Determine which zone keys belong to this town
            // A zone belongs here if: it has no 'town' field (legacy), OR its town matches current
            const townZoneKeys = townDef ? (townDef.zones || []) : null;

            // Auto-unlock zones that are not locked (level-only requirement)
            Object.keys(LOCATIONS).forEach(key => {
                const loc = LOCATIONS[key];
                if (key === 'town') return;
                // Only auto-unlock zones that belong to this town
                if (townZoneKeys && !townZoneKeys.includes(key)) return;
                
                // ALWAYS unlock forest (starter zone) regardless of level
                if (key === 'forest' && !p.unlockedAreas.includes(key)) {
                    p.unlockedAreas.push(key);
                }
                
                if (!loc.locked && loc.requiredLevel && p.level >= loc.requiredLevel) {
                    if (!p.unlockedAreas.includes(key)) {
                        p.unlockedAreas.push(key);
                    }
                }
                // Safety: strip locks that shouldn't be held
                if (loc.locked && loc.requiredLevel && p.level < loc.requiredLevel) {
                    const idx = p.unlockedAreas.indexOf(key);
                    if (idx !== -1) p.unlockedAreas.splice(idx, 1);
                }
            });

            const townName = townDef ? townDef.name : 'World';
            let exploreHtml = `
                <div class="location-header">${townName} â€” EXPLORE</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>Where would you like to explore?</p>
                </div>
                <div style="margin: 20px 0;">
            `;

            // Only show zones that belong to this town (or all zones if no town system)
            Object.keys(LOCATIONS).forEach(key => {
                const loc = LOCATIONS[key];
                if (key === 'town') return;
                // Filter by town
                if (townZoneKeys && !townZoneKeys.includes(key)) return;

                const levelInfo = loc.enemyLevelRange ?
                    ` (Lv ${loc.enemyLevelRange[0]}-${loc.enemyLevelRange[1]})` : '';

                const isUnlocked = p.unlockedAreas.includes(key);
                const meetsLevelReq = p.level >= (loc.requiredLevel || 1);

                // Hide zones that don't meet level requirement and aren't unlocked
                if (!isUnlocked && !meetsLevelReq) return;

                if (isUnlocked) {
                    exploreHtml += `
                        <div class="menu-option" onclick="exploreLocation('${key}')">
                            â–º ${loc.name}${levelInfo} <span style="color: var(--border-color);">âœ“</span>
                        </div>
                    `;
                    // Show master challenge if available
                    const masterKey = `${p.baseClass || p.class}_master_${key}`;
                    if (typeof CLASS_MASTERS !== 'undefined' && CLASS_MASTERS[masterKey] && !p.defeatedMasters.includes(masterKey)) {
                        const master = CLASS_MASTERS[masterKey];
                        if (p.level >= master.requiredLevel) {
                            exploreHtml += `
                                <div class="menu-option" onclick="challengeMaster('${masterKey}')"
                                     style="border-color:var(--highlight-color);background:rgba(255,255,0,0.1);">
                                    âš”ï¸ CHALLENGE MASTER: ${master.name} (Lv ${master.level})
                                </div>
                            `;
                        }
                    }
                } else {
                    // Locked but level met â€” show with unlock requirement
                    const masterKey = typeof getMasterKeyForArea !== 'undefined' ? getMasterKeyForArea(key) : null;
                    const master = masterKey && typeof CLASS_MASTERS !== 'undefined' ? CLASS_MASTERS[masterKey] : null;
                    if (master) {
                        exploreHtml += `
                            <div class="menu-option" style="opacity:0.6;cursor:default;"
                                 onclick="alert('${loc.unlockMessage || 'Locked'}')">
                                ğŸ”’ ${loc.name}${levelInfo} - LOCKED
                            </div>
                            <div class="menu-option" onclick="challengeMaster('${masterKey}')"
                                 style="border-color:var(--error-color);background:rgba(255,0,0,0.1);">
                                âš”ï¸ CHALLENGE MASTER: ${master.name} (Lv ${master.level}) TO UNLOCK
                            </div>
                        `;
                    } else {
                        exploreHtml += `
                            <div class="menu-option" style="opacity:0.6;cursor:default;"
                                 onclick="alert('${loc.unlockMessage || 'Complete previous areas to unlock!'}')">
                                ğŸ”’ ${loc.name}${levelInfo} - LOCKED
                            </div>
                        `;
                    }
                }
            });

            exploreHtml += `
                </div>
                <button onclick="showTown()">RETURN TO TOWN</button>
            `;

            screen.innerHTML = exploreHtml;
        }

        function getMasterKeyForArea(areaKey) {
            // Find which master unlocks this area.
            // 'riverside' is unlocked by the forest master (index 0 â†’ forest master unlocks riverside).
            // All other areas are unlocked by the master of the previous area in order.
            const playerClass = gameState.player.baseClass || gameState.player.class;

            // Map: area â†’ the zone whose master unlocks it
            const unlockedBy = {
                riverside: 'forest',
                plains:    'forest',
                cave:      'plains',
                crypt:     'cave',
                volcano:   'crypt'
            };

            const sourceArea = unlockedBy[areaKey];
            if (sourceArea) {
                return `${playerClass}_master_${sourceArea}`;
            }
            return null;
        }

        function challengeMaster(masterKey) {
            const master = CLASS_MASTERS[masterKey];
            if (!master) {
                alert('Master not found!');
                return;
            }
            
            const p = gameState.player;
            
            // Check if already defeated
            if (p.defeatedMasters.includes(masterKey)) {
                alert('You have already defeated this master!');
                return;
            }
            
            // Check level requirement
            if (p.level < master.requiredLevel) {
                alert(`You need to be level ${master.requiredLevel} to challenge this master!`);
                return;
            }
            
            // Show master challenge screen
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">âš”ï¸ MASTER CHALLENGE âš”ï¸</div>
                ${renderPlayerStats()}
                <div class="message" style="border-color: var(--error-color); background: rgba(255, 0, 0, 0.1);">
                    <p style="color: var(--highlight-color); font-size: 24px;">${master.name}</p>
                    <p style="color: var(--text-color); margin: 10px 0;">${master.description}</p>
                    <p style="color: var(--border-color);">Level: ${master.level} | HP: ${master.baseHp} | Defense: ${master.baseDefense}</p>
                    <p style="color: var(--error-color); margin-top: 15px;">âš ï¸ THIS IS A BOSS FIGHT! âš ï¸</p>
                    <p>Defeating this master will unlock: <span style="color: var(--highlight-color);">${LOCATIONS[master.unlocks].name}</span></p>
                </div>
                <div class="message" style="border-color: var(--highlight-color);">
                    <p style="color: var(--highlight-color);">GUARANTEED REWARDS:</p>
                    ${master.guaranteedDrops.map(item => `<p>â€¢ ${getItemName(item)}</p>`).join('')}
                    <p style="margin-top: 10px;">+ ${master.xp} XP and ${master.gold} Gold</p>
                </div>
                <div style="margin: 20px 0;">
                    <button onclick="startMasterBattle('${masterKey}')" style="background: var(--error-color); font-size: 22px;">âš”ï¸ BEGIN BATTLE âš”ï¸</button>
                    <button onclick="showExplore()">RETREAT</button>
                </div>
            `;
        }

        function startMasterBattle(masterKey) {
            const master = CLASS_MASTERS[masterKey];
            const masterMonster = {
                key: masterKey, name: master.name, rarity: 'epic',
                rarityColor: RARITY_CONFIG.epic.color,
                hp: master.baseHp, maxHp: master.baseHp,
                damage: master.baseDamage, defense: master.baseDefense,
                xp: master.xp, gold: master.gold, level: master.level,
                possibleDrops: master.possibleDrops, dropRates: master.dropRates,
                isMaster: true, masterKey: masterKey,
                guaranteedDrops: master.guaranteedDrops
            };
            const maxHits   = calcPlayerHits(gameState.player);
            const pipTimers = [];
            for (let i = 0; i < maxHits; i++) {
                pipTimers.push(10);
            }
            gameState.combatState = {
                monsters: [masterMonster], currentTarget: 0,
                messages: [], defeatedMonsters: [],
                pipTimers:     pipTimers,
                pipAvailable:  pipTimers.map(() => true),
                enemyTimer:    18,
                enemyDelay:    18,
                enemyHits:     3,
                enemyHitsLeft: 3
            };
            // Open the terminal view (clear it fresh for a boss)
            openTerminalView(gameState.currentLocation);
            // Append intro text (streaming) â€” but render UI immediately so player can act
            termAppend(`<span style="color:${RARITY_CONFIG.epic.color}; font-size:22px;">âš”ï¸ ${master.name} challenges you to an honorable duel! âš”ï¸</span>`, 'term-highlight');
            // Render combat UI immediately â€” don't block on streaming intro
            renderEnemyCards();
            renderActionBar();
            startCombatTimer();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // HUD â€“ write once, update in place
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function initHud() {
            updateHud();
        }
        // â”€â”€ Shared helper: returns HTML âœ¦ pip(s) for the player's runestones â”€â”€
        // font-size:'1em' inherits parent size so pip is always same size as name
        function getRunestonePip(player) {
            if (!player || !player.runestones || !player.runestones.length) return '';
            if (typeof RUNESTONES === 'undefined') return '';
            return player.runestones.map(rsId => {
                const rs = RUNESTONES[rsId];
                return rs
                    ? `<span title="${rs.name}" style="color:${rs.color};margin-left:8px;font-size:16px;vertical-align:middle;line-height:1;">âœ¦</span>`
                    : '';
            }).join('');
        }

        function updateHud() {
    const p = gameState.player;

    // â”€â”€ helper: set element text safely â”€â”€
    const set = (id, txt) => { const el = document.getElementById(id); if (el) el.textContent = txt; };
    // â”€â”€ helper: set element width% safely â”€â”€
    const setBar = (id, pct) => {
        const el = document.getElementById(id);
        if (el) el.style.width = Math.max(0, Math.min(100, pct)) + '%';
    };

    if (!p) {
        set('hudName',   'â€” No Adventurer â€”');
        set('hudHpNums', 'â¤ï¸ HP: â€”');
        set('hudMpNums', 'âœ¨ MP: â€”');
        set('hudXpNums', 'â­ XP: â€”');
        set('hudGold',   'ğŸ’° 0 g');
        setBar('sbHpFill', 0);
        setBar('sbMpFill', 0);
        setBar('sbXpFill', 0);
        return;
    }

    // â”€â”€ Desktop HUD strip (name + numbers, desktop only) â”€â”€
    const runestonePip = getRunestonePip(p);
    const hudNameEl = document.getElementById('hudName');
    if (hudNameEl) {
        hudNameEl.innerHTML = `${p.name} â€“ Lv ${p.level} ${p.className}${runestonePip}`;
    }
    set('hudHpNums', `â¤ï¸ ${p.hp}/${p.maxHp}`);
    set('hudMpNums', `âœ¨ ${p.mp}/${p.maxMp}`);
    set('hudXpNums', `â­ ${p.xp}/${p.xpToNext}`);
    set('hudGold',   `ğŸ’° ${p.gold}g`);

    // â”€â”€ Status bars (HP / MP / XP) â”€â”€
    const hpPct = p.maxHp  > 0 ? (p.hp  / p.maxHp)  * 100 : 0;
    const mpPct = p.maxMp  > 0 ? (p.mp  / p.maxMp)  * 100 : 0;
    // XP bar shows progress within the current level only
    const hudCls = p.baseClass || p.class;
    const xpLevelStart = getXpForLevel(hudCls, p.level);
    const xpLevelEnd   = p.xpToNext;
    const xpInLevel    = p.xp - xpLevelStart;
    const xpSpan       = xpLevelEnd - xpLevelStart;
    const xpPct = xpSpan > 0 ? Math.min(100, (xpInLevel / xpSpan) * 100) : 100;
    setBar('sbHpFill', hpPct);
    setBar('sbMpFill', mpPct);
    setBar('sbXpFill', xpPct);

    // â”€â”€ Low-HP: change HP bar colour and add heartbeat â”€â”€
    const hpFill = document.getElementById('sbHpFill');
    if (hpFill) {
        if (hpPct < 25) {
            hpFill.style.background = 'linear-gradient(90deg, #880000, #ff0000)';
            hpFill.style.animation  = 'hpLowPulse 0.8s ease-in-out infinite';
        } else {
            hpFill.style.background = 'linear-gradient(90deg, #cc0000, #ff3333)';
            hpFill.style.animation  = '';
        }
    }

    // â”€â”€ Low-HP heartbeat border on terminal â”€â”€
    const tw = document.getElementById('terminalWindow');
    if (tw) tw.classList.toggle('danger-heartbeat', hpPct < 15);
}


        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TERMINAL VIEW helpers
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
function openTerminalView(locKey) {
    // CSS body.terminal-mode handles all show/hide â€” just add the class
    document.body.classList.add('terminal-mode');

    const term = document.getElementById('terminalWindow');

    updateHud();
    initHud();

    if (!gameState._terminalOpen) {
        term.innerHTML = '';
        term.scrollTop = 0;

        gameState._terminalOpen = true;
        gameState._currentExploreArea = locKey;

        if (LOCATIONS?.[locKey]) {
            termAppend(`â”€â”€ ${LOCATIONS[locKey].name} â”€â”€`, 'term-separator');
        }
    }

    updateTerminalSafeArea();
}


function stabilizeTerminalLayout() {
    const tw = document.getElementById('terminalWindow');
    if (!tw) return;

    // Force flexbox to resolve height again
    tw.style.display = 'block';
    tw.offsetHeight;   // read triggers reflow

    // Reassert scrolling
    tw.style.overflowY = 'auto';

    // Scroll to bottom â€” triple rAF on mobile to survive layout shifts
    requestAnimationFrame(() => requestAnimationFrame(() => requestAnimationFrame(() => {
        tw.scrollTop = tw.scrollHeight + 9999;
    })));
}



        function closeTerminalView() {
            // Remove terminal-mode class â€” CSS handles all element visibility
            document.body.classList.remove('terminal-mode');
            gameState._terminalOpen = false;
            gameState._currentExploreArea = null;
        }
        // â”€â”€ modem-style line queue â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const termQueue   = [];          // pending { html, extraClass, onDone }
        let   termBusy    = false;       // true while a line is mid-stream



        function termAppend(html, extraClass, onDone) {
            termQueue.push({ html, extraClass, onDone: onDone || null });
            if (!termBusy) termDrain();
        }

        function scrollTerminalToBottom() {
    const tw = document.getElementById('terminalWindow');
    if (!tw) return;
    // Double rAF: first frame paints, second measures correct scrollHeight
    requestAnimationFrame(() => requestAnimationFrame(() => {
        tw.scrollTop = tw.scrollHeight + 9999;
    }));
}


 function termDrain() {
    if (termQueue.length === 0) {
        termBusy = false;
        return;
    }

    termBusy = true;
    const { html, extraClass, onDone } = termQueue.shift();
    const tw = document.getElementById('terminalWindow');

    // Decide whether to auto-scroll BEFORE appending so we know
    // if the user has manually scrolled up.
    // During combat: ALWAYS follow (never let new text appear off-screen).
    // Outside combat: follow only if already near the bottom (user hasn't scrolled up).
    const distFromBottom = tw.scrollHeight - tw.scrollTop - tw.clientHeight;
    const shouldAutoScroll = !!gameState.combatState || distFromBottom < 80;

    const line = document.createElement('div');
    line.className = 'term-line' + (extraClass ? ' ' + extraClass : '');
    tw.appendChild(line);

    // Inline scroll helper â€” fires after paint so scrollHeight is correct
    const doScroll = () => {
        if (shouldAutoScroll) {
            requestAnimationFrame(() => { tw.scrollTop = tw.scrollHeight + 9999; });
        }
    };

    // separator or empty lines â€” no streaming
    if (extraClass === 'term-separator' || html === '') {
        line.innerHTML = html;
        doScroll();
        if (onDone) onDone();
        termDrain();
        return;
    }

    // instant mode
    if (currentModemSpeed === 'instant') {
        line.innerHTML = html;
        doScroll();
        if (onDone) onDone();
        termDrain();
        return;
    }

    // streaming mode â€” scroll on EVERY tick so the line scrolls into view
    // as characters arrive, not just when it completes
    const charsPerTick = MODEM_SPEEDS[currentModemSpeed];
    let visibleCount = 0;
    let totalVisible = 0;

    {
        let inTag = false;
        for (let i = 0; i < html.length; i++) {
            if (html[i] === '<') inTag = true;
            else if (html[i] === '>') inTag = false;
            else if (!inTag) totalVisible++;
        }
    }

    const ticker = setInterval(() => {
        visibleCount += charsPerTick;

        if (visibleCount >= totalVisible) {
            clearInterval(ticker);
            line.innerHTML = html;
            doScroll();
            if (onDone) onDone();
            termDrain();
        } else {
            line.innerHTML =
                sliceToVisible(html, visibleCount) +
                '<span style="animation:blink 1s infinite;">_</span>';
            // Scroll during streaming so text stays visible as it types
            if (shouldAutoScroll) tw.scrollTop = tw.scrollHeight + 9999;
        }
    }, 16);
}



            function sliceToVisible(html, n) {
    let vis = 0;
    let inTag = false;

    for (let i = 0; i < html.length; i++) {
        if (html[i] === '<') inTag = true;
        else if (html[i] === '>') inTag = false;
        else if (!inTag) {
            vis++;
            if (vis >= n) return html.slice(0, i + 1);
        }
    }
    return html;
}


     

       function termClear() {
    const tw = document.getElementById('terminalWindow');
    tw.innerHTML = '';
    tw.scrollTop = 0;  // ğŸ”¥ RESET SCROLL TO TOP
}


        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EXPLORE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function exploreLocation(locKey) {
            document.body.classList.add("terminal-mode");

            const location = LOCATIONS[locKey];
            const p = gameState.player;
            
            // Hard level gate - even if somehow unlocked, enforce min level
            if (location.requiredLevel && p.level < location.requiredLevel) {
                document.body.classList.remove("terminal-mode");
                alert(`You must be level ${location.requiredLevel} to explore ${location.name}!`);
                showExplore();
                return;
            }
            
            if (!p.unlockedAreas.includes(locKey)) {
                document.body.classList.remove("terminal-mode");
                alert(location.unlockMessage || 'This area is locked!');
                showExplore();
                return;
            }

            gameState.currentLocation = locKey;
            
            // Start regeneration when exploring (normal speed)
            startMpRegen(false);
            startResting(false);

            // If we just arrived (from town / map), open the terminal fresh
            if (!gameState._terminalOpen || gameState._currentExploreArea !== locKey) {
                gameState._terminalOpen = false;   // force fresh open
                openTerminalView(locKey);
            } else {
                // Already in this area â€“ just add a separator
                termAppend('', 'term-separator');
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ROLL FOR RANDOM ADVENTURE (if adventure system is loaded)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof rollForAdventure !== 'undefined') {
                const adventureRoll = Math.random();
                const adventureThreshold = location.adventureChance || 0.01;  // 1% rare encounter
                
                if (adventureRoll < adventureThreshold) {
                    const adventure = rollForAdventure(p.level);
                    if (adventure) {
                        startAdventure(adventure);
                        return; // Adventure takes over, no normal combat
                    }
                }
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // NORMAL COMBAT ENCOUNTER
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (Math.random() < 0.7) {
                const numMonsters = rollMonsterCount();
                const enemyKeys = [];
                for (let i = 0; i < numMonsters; i++) {
                    enemyKeys.push(location.encounters[Math.floor(Math.random() * location.encounters.length)]);
                }
                startCombat(enemyKeys);
            } else {
                termAppend(`You explore the areaâ€¦ but find nothing.`, 'term-dim');
                renderActionBar();   // show "Continue / Town" buttons
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COMBAT â€“ start / spawn / rarity
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function rollMonsterCount() {
            const r = Math.random() * 100;
            if (r < 70) return 1;
            if (r < 95) return 2;
            return 3;
        }
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STATUS EFFECTS SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function cleanupCombatStatusEffects() {
            const cs = gameState.combatState;
            if (!cs) return;
            
            // Clear all DOT timers
            for (const timerKey in cs.dotTimers) {
                clearInterval(cs.dotTimers[timerKey]);
            }
            cs.dotTimers = {};
            cs.playerStatusEffects = [];
            cs.monsterStatusEffects = {};
        }
        
        function applyStatusEffect(target, statusKey, isPlayer = false) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            const statusDef = STATUS_EFFECTS[statusKey];
            if (!statusDef) return;
            
            // Get target's status effects array
            let effects;
            if (isPlayer) {
                effects = cs.playerStatusEffects;
            } else {
                if (!cs.monsterStatusEffects[target.index]) {
                    cs.monsterStatusEffects[target.index] = [];
                }
                effects = cs.monsterStatusEffects[target.index];
            }
            
            // ALLOW STACKING: Each status application gets a unique ID
            // Multiple instances of the same status can exist simultaneously
            const effect = {
                type: statusKey,
                id: `${statusKey}_${Date.now()}_${Math.random()}`, // Unique ID per instance
                startTime: Date.now(),
                duration: statusDef.duration
            };
            effects.push(effect);
            
            // Show message â€” use applyMessage for the "caught fire" moment, message for ticks
            const targetName = isPlayer ? 'You' : target.name;
            const applyMsg = statusDef.applyMessage
                ? statusDef.applyMessage(targetName)
                : statusDef.message(targetName, '');  // empty string avoids "undefined"
            
            // Count stacks for display
            const stackCount = effects.filter(e => e.type === statusKey).length;
            const stackTag = stackCount > 1 ? ` <span style="color:#FFD700;">[x${stackCount}]</span>` : '';
            termAppend(applyMsg + stackTag, 'term-warning');
            
            // Start DOT ticks if applicable (each instance ticks independently)
            if (statusDef.type === 'dot') {
                startDOTTicks(target, effect.id, statusKey, isPlayer);
            }
            
            // Auto-remove after duration (remove THIS specific instance)
            setTimeout(() => {
                removeStatusEffectById(target, effect.id, isPlayer);
            }, statusDef.duration);
        }
        
        function removeStatusEffectById(target, effectId, isPlayer = false) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            let effects;
            if (isPlayer) {
                effects = cs.playerStatusEffects;
            } else {
                effects = cs.monsterStatusEffects[target.index] || [];
            }
            
            const index = effects.findIndex(e => e.id === effectId);
            if (index > -1) {
                effects.splice(index, 1);
                
                // Stop DOT timer for this specific instance
                const timerKey = isPlayer ? `player_${effectId}` : `monster_${target.index}_${effectId}`;
                if (cs.dotTimers[timerKey]) {
                    clearInterval(cs.dotTimers[timerKey]);
                    delete cs.dotTimers[timerKey];
                }
            }
        }
        
        function removeStatusEffect(target, statusKey, isPlayer = false) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            let effects;
            if (isPlayer) {
                effects = cs.playerStatusEffects;
            } else {
                effects = cs.monsterStatusEffects[target.index] || [];
            }
            
            // Remove ALL instances of this status type (for cleanse/cure effects)
            const toRemove = effects.filter(e => e.type === statusKey);
            toRemove.forEach(effect => {
                const index = effects.findIndex(e => e.id === effect.id);
                if (index > -1) {
                    effects.splice(index, 1);
                    
                    // Stop DOT timer if exists
                    const timerKey = isPlayer ? `player_${effect.id}` : `monster_${target.index}_${effect.id}`;
                    if (cs.dotTimers[timerKey]) {
                        clearInterval(cs.dotTimers[timerKey]);
                        delete cs.dotTimers[timerKey];
                    }
                }
            });
        }
        
        function startDOTTicks(target, effectId, statusKey, isPlayer = false) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            const statusDef = STATUS_EFFECTS[statusKey];
            if (!statusDef || statusDef.type !== 'dot') return;
            
            const timerKey = isPlayer ? `player_${effectId}` : `monster_${target.index}_${effectId}`;
            
            // Don't start if already ticking (shouldn't happen with unique IDs but safety check)
            if (cs.dotTimers[timerKey]) return;
            
            cs.dotTimers[timerKey] = setInterval(() => {
                if (!cs || !gameState.combatState) {
                    clearInterval(cs.dotTimers[timerKey]);
                    return;
                }

                // â”€â”€ Stop ticking if the enemy is already dead or gone â”€â”€
                if (!isPlayer) {
                    const stillAlive = cs.monsters && cs.monsters.some(m => m === target);
                    if (!stillAlive || target.hp <= 0) {
                        clearInterval(cs.dotTimers[timerKey]);
                        delete cs.dotTimers[timerKey];
                        return;
                    }
                }
                
                const damage = statusDef.damagePerTick;
                target.hp -= damage;
                
                const targetName = isPlayer ? 'You' : target.name;
                // Tick message always has damage value â€” no undefined
                termAppend(statusDef.tickMessage
                    ? statusDef.tickMessage(targetName, damage)
                    : statusDef.message(targetName, damage),
                    'term-warning');
                
                updateHud();
                updateEnemyCards();
                
                // Check if target died from DOT
                if (target.hp <= 0) {
                    // Stop ticking immediately â€” target is dead
                    clearInterval(cs.dotTimers[timerKey]);
                    delete cs.dotTimers[timerKey];

                    if (!isPlayer) {
                        termAppend(`${target.name} succumbs to ${statusDef.name}!`, 'term-victory');
                        checkCombatEnd();
                    } else {
                        gameState.player.hp = 0;
                        checkCombatEnd();
                    }
                }
            }, statusDef.tickInterval);
        }
        
        function hasStatusEffect(target, statusKey, isPlayer = false) {
            const cs = gameState.combatState;
            if (!cs) return false;
            
            const effects = isPlayer ? cs.playerStatusEffects : (cs.monsterStatusEffects[target.index] || []);
            return effects.some(e => e.type === statusKey);
        }
        
        function getStatusEffectIcons(target, isPlayer = false) {
            const cs = gameState.combatState;
            if (!cs) return '';
            
            const effects = isPlayer ? cs.playerStatusEffects : (cs.monsterStatusEffects[target.index] || []);
            if (effects.length === 0) return '';
            
            return effects.map(effect => {
                const def = STATUS_EFFECTS[effect.type];
                return `<span title="${def.description}" style="color:${def.color};">${def.icon}</span>`;
            }).join(' ');
        }
        
        function applyWeaponModifiers(attacker, target, baseDamage, weapon) {
            if (!weapon.modifiers || weapon.modifiers.length === 0) {
                return { totalDamage: baseDamage, messages: [] };
            }
            
            let totalDamage = baseDamage;
            const messages = [];
            
            weapon.modifiers.forEach(modKey => {
                const mod = WEAPON_MODIFIERS[modKey];
                if (!mod) return;
                
                // Add elemental/bonus damage
                if (mod.minDamage !== undefined) {
                    const bonusDmg = Math.floor(Math.random() * (mod.maxDamage - mod.minDamage + 1)) + mod.minDamage;
                    totalDamage += bonusDmg;
                    messages.push(`<span style="color:${mod.color};">+${bonusDmg} ${mod.name} damage</span>`);
                }
                
                // Apply status effect chance
                if (mod.statusEffect && Math.random() < mod.statusChance) {
                    applyStatusEffect(target, mod.statusEffect, false);
                }
                
                // Apply lifesteal
                if (mod.lifestealPercent) {
                    const heal = Math.floor(totalDamage * (mod.lifestealPercent / 100));
                    attacker.hp = Math.min(attacker.maxHp, attacker.hp + heal);
                    messages.push(`<span style="color:#00FF00;">+${heal} HP (Lifesteal)</span>`);
                }
                
                // Apply crit bonus
                if (mod.critBonus) {
                    // This will be used in the attack calculation
                    // Store for now (handled in executeAttack)
                }
            });
            
            return { totalDamage, messages };
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COMBAT FUNCTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function startCombat(enemyKeys, useZoneLevel = true, forcedRarities = null) {
            // Stop resting when combat starts
            stopResting();
            
            if (!Array.isArray(enemyKeys)) enemyKeys = [enemyKeys];
            const monsters = enemyKeys.map((k, index) => {
                const fr = forcedRarities ? (forcedRarities[index] || null) : null;
                const monster = spawnMonsterWithRarity(k, useZoneLevel, fr);
                monster.index = index; // Add index for status effect tracking
                return monster;
            });

            let msg;
            if (monsters.length === 1) {
                const m0 = monsters[0];
                const lvlDiff = (m0.level || 1) - (gameState.player.level || 1);
                const lvlColor = lvlDiff > 2 ? '#ff4444' : lvlDiff > 0 ? '#ff8c00' : lvlDiff < 0 ? '#88ff88' : '#aaa';
                const lvlTag = `<span style="color:${lvlColor};font-size:14px;"> [Lv.${m0.level || '?'}]</span>`;
                msg = `A wild <span style="color:${m0.rarityColor};">${m0.name}</span>${lvlTag} appears!`;
            } else {
                const names = monsters.map(m => {
                    const lvlDiff = (m.level||1) - (gameState.player.level||1);
                    const lvlColor = lvlDiff > 2 ? '#ff4444' : lvlDiff > 0 ? '#ff8c00' : lvlDiff < 0 ? '#88ff88' : '#aaa';
                    return `<span style="color:${m.rarityColor};">${m.name}</span><span style="color:${lvlColor};"> Lv.${m.level||'?'}</span>`;
                }).join(', ');
                msg = `${monsters.length} enemies appear: ${names}!`;
            }

            // All enemies attack once per cycle regardless of rarity
            const eHits = 1;

            const enemyDelay = 12 + Math.floor(Math.random()*4);  // 12-15s, fixed for this combat
            const maxHits    = calcPlayerHits(gameState.player);
            const pipTimers  = [];
            for (let i = 0; i < maxHits; i++) {
                pipTimers.push(10);  // each pip starts at 10s
            }
            gameState.combatState = {
                monsters, currentTarget: 0,
                messages: [], defeatedMonsters: [],
                pipTimers:     pipTimers,    // array of timers, one per pip
                pipAvailable:  pipTimers.map(() => true),  // which pips are ready
                enemyTimer:    enemyDelay,
                enemyDelay:    enemyDelay,
                enemyHits:     eHits,
                enemyHitsLeft: eHits,
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // STATUS EFFECTS SYSTEM
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                playerStatusEffects: [], // Active status effects on player
                monsterStatusEffects: {}, // Active status effects per monster (by index)
                dotTimers: {} // DOT tick interval IDs
            };
            // Stream the encounter line immediately; render combat UI without waiting
            termAppend(msg, 'term-enemy');
            renderEnemyCards();
            renderActionBar();
            setTimeout(updatePipButtons, 0);
            startCombatTimer();
        }

        function spawnMonsterWithRarity(enemyKey, zoneLevel = null, forcedRarity = null) {
            const template = ENEMIES[enemyKey];
            // Dungeon enemies pass a forcedRarity (default 'common' = no random roll).
            // Exploration enemies always roll randomly (forcedRarity = null).
            const rarity   = (forcedRarity && RARITY_CONFIG[forcedRarity]) ? forcedRarity : rollRarity();
            const mult     = RARITY_CONFIG[rarity].multiplier;
            
            // Determine monster level (use template level for dungeons, zone level for exploration)
            let monsterLevel = template.level;
            if (zoneLevel !== null && zoneLevel !== false) {
                // Random level within zone range (exploration zones only)
                const location = LOCATIONS[gameState.currentLocation];
                if (location && location.enemyLevelRange) {
                    const [minLvl, maxLvl] = location.enemyLevelRange;
                    monsterLevel = minLvl + Math.floor(Math.random() * (maxLvl - minLvl + 1));
                }
            }
            
            // Scale stats based on monster level
            const levelMult = 1 + (monsterLevel - 1) * 0.10; // 10% increase per level
            
            // â”€â”€ Damage variance: use template min/max if available, otherwise calculate from baseDamage â”€â”€
            let scaledMin, scaledMax, scaledAvg;
            
            if (template.minDamage !== undefined && template.maxDamage !== undefined) {
                // Use template's predefined min/max damage
                scaledMin = Math.max(1, Math.floor(template.minDamage * mult * levelMult));
                scaledMax = Math.max(scaledMin + 1, Math.floor(template.maxDamage * mult * levelMult));
                scaledAvg = Math.floor((scaledMin + scaledMax) / 2);
            } else {
                // Fallback: calculate from baseDamage (Â±33% variance)
                scaledAvg = Math.floor(template.baseDamage * mult * levelMult);
                scaledMin = Math.max(1, Math.round(scaledAvg * 0.67));
                scaledMax = Math.max(scaledMin + 1, Math.round(scaledAvg * 1.33));
            }

            const monster = {
                key: enemyKey, 
                name: template.name, 
                rarity, 
                rarityColor: RARITY_CONFIG[rarity].color,
                hp: Math.floor(template.baseHp * mult * levelMult), 
                maxHp: Math.floor(template.baseHp * mult * levelMult),
                // damage is the average (kept for backwards-compat); min/max used in combat
                damage:    scaledAvg,
                minDamage: scaledMin,
                maxDamage: scaledMax,
                defense: Math.floor(template.baseDefense * mult * levelMult),
                xp: Math.floor(template.baseXp * mult * levelMult),
                gold: Math.floor(template.baseGold * mult * levelMult),
                level: monsterLevel, 
                possibleDrops: template.possibleDrops, 
                dropRates: template.dropRates
            };
            
            return monster;
        }
        
        function calculateXpReward(monster, playerLevel) {
            // Dynamic XP based on level difference and rarity
            const levelDiff = monster.level - playerLevel;
            
            // Base XP from monster
            let xp = monster.xp;
            
            // Level difference multiplier
            // Same level: 100%
            // 1 level higher: 120%
            // 2 levels higher: 140%
            // 1 level lower: 80%
            // 5+ levels lower: 10%
            let levelMult = 1.0;
            
            if (levelDiff >= 5) {
                levelMult = 2.0; // Huge bonus for fighting much stronger enemies
            } else if (levelDiff >= 3) {
                levelMult = 1.6;
            } else if (levelDiff >= 1) {
                levelMult = 1.0 + (levelDiff * 0.2);
            } else if (levelDiff === 0) {
                levelMult = 1.0;
            } else if (levelDiff >= -2) {
                levelMult = 1.0 + (levelDiff * 0.1); // 90%, 80%
            } else if (levelDiff >= -5) {
                levelMult = 0.5;
            } else {
                levelMult = 0.1; // Killing gray mobs gives almost nothing
            }
            
            // Rarity bonus (already in base XP, but add a small extra)
            const rarityBonus = RARITY_CONFIG[monster.rarity].multiplier * 0.1;
            
            xp = Math.floor(xp * levelMult * (1 + rarityBonus));
            
            // Minimum 1 XP
            return Math.max(1, xp);
        }
        
        function rollRarity() {
            const roll = Math.random() * 100;
            let cum = 0;
            for (const [rarity, config] of Object.entries(RARITY_CONFIG)) {
                cum += config.spawnWeight;
                if (roll < cum) return rarity;
            }
            return 'common';
        }
        function getRarityText(rarity) {
            return `<span style="color:${RARITY_CONFIG[rarity].color}; font-weight:bold;">${RARITY_CONFIG[rarity].name}</span>`;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ENEMY CARDS â€“ rendered into terminal, updated in place
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function renderEnemyCards() {
            // Enemy info is now shown only in terminal messages - no visual cards needed
            // This function is still called for compatibility but does nothing
        }
        function updateEnemyCards() {
            // No longer needed - enemy info shown in terminal only
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ACTION BAR â€“ combat buttons / explore buttons / spell & potion menus
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
       // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       // PERSISTENT DUNGEON MAP HELPERS
       // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       
       function ensureDungeonMapStructure(player, dungeonKey, floorNum) {
           // Initialize dungeonMaps if it doesn't exist
           if (!player.dungeonMaps) player.dungeonMaps = {};
           if (!player.dungeonMaps[dungeonKey]) player.dungeonMaps[dungeonKey] = {};
           if (!player.dungeonMaps[dungeonKey][floorNum]) player.dungeonMaps[dungeonKey][floorNum] = new Set();
       }
       
       function saveRoomDiscovery(player, dungeonKey, floorNum, roomId) {
           // Save to persistent map
           ensureDungeonMapStructure(player, dungeonKey, floorNum);
           const scopedKey = `${floorNum}:${roomId}`;
           player.dungeonMaps[dungeonKey][floorNum].add(scopedKey);
       }
       
       function loadDungeonMap(player, dungeonKey, floorNum) {
           // Return the persistent discovered rooms for this dungeon+floor
           ensureDungeonMapStructure(player, dungeonKey, floorNum);
           return new Set(player.dungeonMaps[dungeonKey][floorNum]);
       }
       
       // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       // DUNGEON MAP SYSTEM
       // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       
       function showDungeonMap() {
           const ds = gameState.dungeon;
           if (!ds) return;
           
           if (typeof DUNGEONS === 'undefined') {
               alert('Dungeon data not loaded!');
               return;
           }
           
           const dungeon = DUNGEONS[ds.dungeonKey];
           const floor = dungeon.floors[ds.floor];
           
           // Build ASCII map (pass floor number for scoped keys)
           const mapAscii = generateAsciiMap(floor, ds.currentRoom, ds.discoveredRooms, ds.floor);
           
           // Show map in terminal
           const term = document.getElementById('terminalWindow');
           term.innerHTML = `
               <div style="font-family: monospace; white-space: pre; line-height: 1.2; color: var(--text-color);">
                   <div style="text-align: center; margin-bottom: 10px; color: var(--highlight-color);">
                       === ${dungeon.name} - Floor ${ds.floor} ===
                   </div>
                   <div style="text-align: center; margin-bottom: 15px; color: #8aaa8a; font-size: 14px;">
                       Legend: [@] = You | [ ] = Room | [?] = Undiscovered | <span style="color:#FF4444;">[T]</span> = Trap | <span style="color:#FFD700;">[H]</span> = Start
                   </div>
${mapAscii}
               </div>
           `;
           
           // Update action bar
           const ab = document.getElementById('actionBar');
           ab.innerHTML = '<button onclick="hideDungeonMap()">â¬… BACK TO DUNGEON</button>';
       }
       
       function hideDungeonMap() {
           const ds = gameState.dungeon;
           if (!ds) return;
           
           // Store combat state before clearing
           const wasInCombat = !!gameState.combatState;
           
           termClear();
           
           // Redraw current room
           const dungeon = DUNGEONS[ds.dungeonKey];
           const floor = dungeon.floors[ds.floor];
           const room = floor.rooms[ds.currentRoom];
           
           termAppend('', 'term-separator');
           termAppend(`<strong>${room.name}</strong>`);
           termAppend(room.description, 'term-dim');
           
           const exits = Object.keys(room.exits).map(d => d.toUpperCase()).join(', ');
           termAppend(`You see exits: ${exits}.`, 'term-dim');
           
           // Restore combat state + action bar (renderDungeonActionBar handles both combat and exploration)
           renderDungeonActionBar();
       }
       
       function generateAsciiMap(floor, currentRoom, discoveredRooms, floorNum) {
           const rooms = floor.rooms;
           
           // Helper to build floor-scoped key
           const scopedKey = (roomId) => `${floorNum}:${roomId}`;
           
           // Find map bounds
           let minX = Infinity, maxX = -Infinity;
           let minY = Infinity, maxY = -Infinity;
           
           Object.keys(rooms).forEach(roomId => {
               const room = rooms[roomId];
               if (room.map && discoveredRooms.has(scopedKey(roomId))) {
                   minX = Math.min(minX, room.map.x);
                   maxX = Math.max(maxX, room.map.x);
                   minY = Math.min(minY, room.map.y);
                   maxY = Math.max(maxY, room.map.y);
               }
           });
           
           // Create grid (each room takes 4 chars wide, 2 chars tall for spacing)
           const cellWidth = 4;
           const cellHeight = 2;
           const width = (maxX - minX + 1) * cellWidth + 1;
           const height = (maxY - minY + 1) * cellHeight + 1;
           const grid = Array(height).fill(null).map(() => Array(width).fill(' '));
           
           // Helper to get grid position
           const toGridX = (mapX) => (mapX - minX) * cellWidth;
           const toGridY = (mapY) => (mapY - minY) * cellHeight;
           
           // First pass: Draw all connections
           Object.keys(rooms).forEach(roomId => {
               const room = rooms[roomId];
               if (!room.map || !discoveredRooms.has(scopedKey(roomId))) return;
               
               const x = toGridX(room.map.x);
               const y = toGridY(room.map.y);
               
               // Draw connections to discovered rooms
               Object.keys(room.exits).forEach(dir => {
                   const targetId = room.exits[dir];
                   const targetRoom = rooms[targetId];
                   
                   if (!targetRoom || !targetRoom.map || !discoveredRooms.has(scopedKey(targetId))) return;
                   
                   const direction = dir.toLowerCase();
                   
                   if (direction === 'n') {
                       grid[y - 1][x + 1] = '|';
                   } else if (direction === 's') {
                       grid[y + 2][x + 1] = '|';
                   } else if (direction === 'e') {
                       grid[y + 1][x + 3] = '-';
                   } else if (direction === 'w') {
                       grid[y + 1][x - 1] = '-';
                   } else if (direction === 'ne') {
                       grid[y][x + 2] = '/';
                   } else if (direction === 'nw') {
                       grid[y][x] = '\\';
                   } else if (direction === 'se') {
                       grid[y + 2][x + 2] = '\\';
                   } else if (direction === 'sw') {
                       grid[y + 2][x] = '/';
                   }
               });
           });
           
           // Second pass: Draw rooms (overwrites connections at room positions)
           Object.keys(rooms).forEach(roomId => {
               const room = rooms[roomId];
               if (!room.map || !discoveredRooms.has(scopedKey(roomId))) return;
               
               const x = toGridX(room.map.x);
               const y = toGridY(room.map.y);
               
               // Draw room with markers
               const isPlayer = roomId === currentRoom;
               const isStart = roomId === floor.startRoom && gameState.dungeon.floor === 1;
               
               const hasTrap = room.contents?.trap;
               
               grid[y + 1][x] = '[';
               if (isPlayer) {
                   grid[y + 1][x + 1] = '@'; // Player
               } else if (hasTrap) {
                   grid[y + 1][x + 1] = 'T'; // Trap (red)
               } else if (isStart) {
                   grid[y + 1][x + 1] = 'H'; // Home/start (yellow)
               } else {
                   grid[y + 1][x + 1] = ' '; // Empty room
               }
               grid[y + 1][x + 2] = ']';
           });
           
           // Convert grid to string with proper coloring
           let result = '';
           for (let y = 0; y < height; y++) {
               let line = '';
               for (let x = 0; x < width; x++) {
                   const char = grid[y][x];
                   if (char === '@') {
                       line += `<span style="color:var(--highlight-color);">${char}</span>`;
                   } else if (char === 'T') {
                       line += `<span style="color:#FF4444;">${char}</span>`; // Red for trap
                   } else if (char === 'H') {
                       line += `<span style="color:#FFD700;">${char}</span>`; // Yellow for home/start
                   } else if (char === '[' || char === ']') {
                       line += `<span style="color:var(--border-color);">${char}</span>`;
                   } else {
                       line += char;
                   }
               }
               result += line + '\n';
           }
           
           return result;
       }

       function renderDungeonActionBar() {
    const ab = document.getElementById('actionBar');

    function updateTerminalSafeArea() {
        // No-op with fixed flex layout
    }

    // Clear action bar
    ab.innerHTML = '';
    ab.style.display = 'block';

    const ds = gameState.dungeon;
    if (!ds) return;

    // Safety check for DUNGEONS
    if (typeof DUNGEONS === 'undefined') {
        console.error('âš ï¸ DUNGEONS not loaded!');
        ab.innerHTML = '<button onclick="returnToTown()">âš ï¸ ERROR - Return to Town</button>';
        return;
    }

    const dungeon = DUNGEONS[ds.dungeonKey];
    const floor = dungeon.floors[ds.floor];
    const room = floor.rooms[ds.currentRoom];

    const cs = gameState.combatState;
    
    // â•â•â• COMBAT BUTTONS (if in combat) â•â•â•
if (cs) {
    const maxHits  = cs.pipAvailable
        ? cs.pipAvailable.length
        : calcPlayerHits(gameState.player);

    const hitsLeft = cs.pipAvailable
        ? cs.pipAvailable.filter(x => x).length
        : maxHits;

    const canAct = hitsLeft > 0;
    const pips = 'â—'.repeat(hitsLeft) + 'â—‹'.repeat(maxHits - hitsLeft);
    const mode = cs.actionMode || 'main';

    const combatDiv = document.createElement('div');
    combatDiv.style.cssText =
        'border-bottom:1px solid var(--border-color);padding-bottom:6px;margin-bottom:6px;';

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ MAIN COMBAT MENU â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    if (mode === 'main') {
        const p = gameState.player;
        const isHunter    = (p.baseClass || p.class) === 'hunter';
        const isWarrior   = (p.baseClass || p.class) === 'warrior';
        const isRunesmith = (p.baseClass || p.class) === 'runesmith';
        const trapBtn   = isHunter  ? `<button onclick="(castTrap())" ${p.mp < 10 ? 'disabled' : ''} class="pip-btn" title="Set Trap [T]" style="border-color:#8B4513;">ğŸª¤<span class="kb-hint">T</span></button>` : '';
        const shieldBtn = isWarrior ? `<button onclick="playerDefend()" ${!canAct ? 'disabled' : ''} title="Shield â€” 70% to halve damage">ğŸ›¡ï¸</button>` : '';

        // Runesmith: overload pip display on spell button, fire glow on attack when charged
        const overloadPips = isRunesmith ? (p.runeOverloadPips || 0) : 0;
        const overloadReady = overloadPips >= 3;
        const pip1 = overloadPips >= 1 ? 'ğŸ”¶' : 'â¬›';
        const pip2 = overloadPips >= 2 ? 'ğŸ”¶' : 'â¬›';
        const pip3 = overloadPips >= 3 ? 'ğŸ”¶' : 'â¬›';
        const attackBtn = isRunesmith
            ? `<button onclick="showAttackMenu()" ${!canAct?'disabled':''} class="pip-btn" id="pipBtn-attack" style="${overloadReady ? 'border-color:#FF4400;box-shadow:0 0 8px #FF4400,0 0 16px #FF8800;animation:runeOverloadPulse 0.7s ease-in-out infinite;' : ''}">${overloadReady ? 'ğŸ”¥âš’ï¸' : 'âš’ï¸'}</button>`
            : `<button onclick="showAttackMenu()" ${!canAct?'disabled':''} class="pip-btn" id="pipBtn-attack" title="Attack">âš”ï¸</button>`;
        const spellBtn = isRunesmith
            ? `<button onclick="showSpellMenu()" ${!canAct?'disabled':''} class="pip-btn" id="pipBtn-spell" title="Cast Rune" style="border-color:#c8a000;"><span style="font-size:9px;display:block;line-height:1;">${overloadReady ? 'âš¡READY' : pip1+pip2+pip3}</span>âœ¨</button>`
            : `<button onclick="showSpellMenu()"  ${!canAct?'disabled':''} class="pip-btn" id="pipBtn-spell" title="Spell">âœ¨</button>`;

        combatDiv.innerHTML = `
            <div style="color:var(--highlight-color);font-size:13px;margin-bottom:3px;text-align:center;letter-spacing:3px;">${pips}</div>
            <div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:center;">
                ${attackBtn}
                ${spellBtn}
                ${shieldBtn}
                ${trapBtn}
                <button onclick="attemptFlee()"    ${!canAct ? 'disabled' : ''} title="Flee">ğŸƒ</button>
                <button onclick="printStatsToTerminal()" title="Show Stats" style="border-color:#4488ff;">ğŸ“Š</button>
            </div>
        `;
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ATTACK TYPE MENU â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    else if (mode === 'attack_type') {
        const normalCost  = 1;
        const heavyCost   = 2;
        const showSpecial = hitsLeft >= 3;

        combatDiv.innerHTML = `
            <div style="color:var(--highlight-color);font-size:14px;margin-bottom:4px;text-align:center;">
                ATTACK TYPE
            </div>
            <div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:center;">
                <button onclick="selectAttackType('normal')" ${hitsLeft < normalCost ? 'disabled' : ''}>
                    âš”ï¸ Normal
                </button>
                <button onclick="selectAttackType('heavy')" ${hitsLeft < heavyCost ? 'disabled' : ''}
                    title="35% miss â€” hits for 3x!">
                    ğŸ’¥ Heavy<span style="font-size:10px;color:#ff8c00;"> âš </span>
                </button>
                ${showSpecial ? `<button onclick="selectAttackType('special')">â­ Special</button>` : ''}
                <button onclick="cancelAction()">âŒ</button>
            </div>
        `;
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ TARGET SELECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    else if (mode === 'target_attack' || mode === 'target_spell') {
        const targetBtns = cs.monsters.map((m, i) => `
            <button onclick="executeTargetedAction(${i})">
                #${i + 1} ${m.name}<br>
                <span style="font-size:11px;">HP ${m.hp}/${m.maxHp}</span>
            </button>
        `).join('');

        combatDiv.innerHTML = `
            <div style="color:var(--highlight-color);font-size:14px;margin-bottom:4px;text-align:center;">
                TARGET
            </div>
            <div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:center;">
                ${targetBtns}
                <button onclick="cancelAction()">âŒ</button>
            </div>
        `;
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ SPELL LIST â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    else if (mode === 'spell_list') {
        const spells = gameState.player.knownSpells || [];

        const spellBtns = spells.map(sk => {
            const spell = SPELLS[sk];
            const disabled = !canAct || gameState.player.mp < spell.mpCost;
            return `
                <button onclick="selectSpell('${sk}')" ${disabled ? 'disabled' : ''}>
                    ${spell.name}<br>
                    <span style="font-size:11px;">${spell.mpCost} MP</span>
                </button>
            `;
        }).join('');

        combatDiv.innerHTML = `
            <div style="color:var(--highlight-color);font-size:14px;margin-bottom:4px;text-align:center;">
                SPELL
            </div>
            <div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:center;">
                ${spellBtns}
                <button onclick="cancelAction()">âŒ</button>
            </div>
        `;
    }

    actionBar.appendChild(combatDiv);
}


    // â•â•â• NAVIGATION BUTTONS (always visible) â•â•â•
    const canMove = !cs || !cs.pipAvailable || cs.pipAvailable.every(x => x);
    
    // Show pip status if in combat/recovery
    if (cs && cs.pipAvailable && !canMove) {
        const available = cs.pipAvailable.filter(x => x).length;
        const total = cs.pipAvailable.length;
        const pips = 'â—'.repeat(available) + 'â—‹'.repeat(total - available);
        
        const statusDiv = document.createElement('div');
        statusDiv.style.cssText = 'color:#8aaa8a;font-size:12px;margin-bottom:4px;text-align:center;';
        statusDiv.innerHTML = `â³ Resting to move: ${pips} (${available}/${total})`;
        ab.appendChild(statusDiv);
    }

    // â•â•â• STATIC COMPASS + UTILITY ROW â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // All 8 compass directions always rendered; exits light up, walls grey out.
    // Keyboard input field alongside for typed navigation.

    const navWrap = document.createElement('div');
    navWrap.style.cssText = 'display:flex;align-items:center;gap:6px;flex-wrap:wrap;justify-content:center;';

    // â”€â”€ 3Ã—3 compass grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Layout: NW N NE / W Â· E / SW S SE
    const compassGrid = document.createElement('div');
    compassGrid.id = 'dungeonCompass';
    compassGrid.style.cssText = 'display:grid;grid-template-columns:repeat(3,36px);grid-template-rows:repeat(3,32px);gap:3px;';

    // [row][col] â†’ direction key (null = centre cell)
    const compassMap = [
        ['nw', 'n',  'ne'],
        ['w',  null, 'e' ],
        ['sw', 's',  'se']
    ];
    const compassLabel = {nw:'NW',n:'N',ne:'NE',w:'W',e:'E',sw:'SW',s:'S',se:'SE'};

    compassMap.forEach(row => {
        row.forEach(dir => {
            if (dir === null) {
                // Centre cell â€” blank spacer
                const spacer = document.createElement('div');
                spacer.style.cssText = 'width:36px;height:32px;display:flex;align-items:center;justify-content:center;';
                spacer.innerHTML = '<span style="color:#1a3a1a;font-size:10px;">âœ¦</span>';
                compassGrid.appendChild(spacer);
                return;
            }
            const hasExit = !!(room.exits && room.exits[dir]);
            const btn = document.createElement('button');
            btn.id = `dBtn-${dir}`;
            btn.textContent = compassLabel[dir];
            btn.title = hasExit ? `Go ${dir.toUpperCase()}` : 'No exit';
            // Always present, styled to show open vs walled
            if (hasExit && canMove) {
                btn.onclick = () => dungeonNav(dir);
                btn.style.cssText = `
                    width:36px;height:32px;padding:0;font-size:12px;font-weight:bold;
                    border:2px solid var(--border-color);background:#0a1a0a;
                    color:var(--text-color);cursor:pointer;`;
            } else if (hasExit && !canMove) {
                // Exit exists but pips not ready
                btn.disabled = true;
                btn.style.cssText = `
                    width:36px;height:32px;padding:0;font-size:12px;font-weight:bold;
                    border:2px solid #1a3a1a;background:#050a05;
                    color:#2a5a2a;cursor:not-allowed;opacity:0.5;`;
            } else {
                // Wall â€” no exit
                btn.disabled = true;
                btn.style.cssText = `
                    width:36px;height:32px;padding:0;font-size:12px;font-weight:bold;
                    border:2px solid #111;background:#070707;
                    color:#1a1a1a;cursor:default;`;
            }
            compassGrid.appendChild(btn);
        });
    });
    navWrap.appendChild(compassGrid);

    // â”€â”€ Utility column: Map + Town/Exit + Ladder + keyboard input â”€â”€â”€â”€
    const utilCol = document.createElement('div');
    utilCol.style.cssText = 'display:flex;flex-direction:column;gap:3px;align-items:stretch;min-width:60px;';

    // MAP button
    const mapBtn = document.createElement('button');
    mapBtn.textContent = 'ğŸ—ºï¸ Map';
    mapBtn.onclick = showDungeonMap;
    mapBtn.style.cssText = 'padding:4px 6px;font-size:12px;border-color:var(--highlight-color);';
    utilCol.appendChild(mapBtn);

    // Entrance/town-exit button
    if (ds.currentRoom === floor.startRoom && gameState.dungeon.floor === 1) {
        const startRoom = floor.rooms[floor.startRoom];
        const exitTown  = startRoom.flags?.townExit || null;
        const exitLabel = startRoom.flags?.townExitLabel || 'â¬… Town';
        const exitBtn   = document.createElement('button');
        exitBtn.innerHTML = exitLabel;
        exitBtn.onclick = () => returnToTown(exitTown || gameState.currentTown);
        exitBtn.style.cssText = 'padding:4px 6px;font-size:12px;';
        utilCol.appendChild(exitBtn);
    } else {
        const curRoom = floor.rooms[ds.currentRoom];
        if (curRoom?.flags?.townExit) {
            const townId    = curRoom.flags.townExit;
            const label     = curRoom.flags.townExitLabel || `Exit`;
            const portalBtn = document.createElement('button');
            portalBtn.innerHTML = label;
            portalBtn.onclick = () => townExitFromDungeon(townId);
            portalBtn.style.cssText = 'padding:4px 6px;font-size:12px;border-color:#AA88FF;color:#AA88FF;';
            utilCol.appendChild(portalBtn);
        }
    }

    // Ladder button (if present)
    if (room.contents?.ladder) {
        const ladderDir = room.contents.ladder.direction;
        const ladderBtn = document.createElement('button');
        ladderBtn.textContent = ladderDir === 'up' ? 'â¬† Up' : 'â¬‡ Down';
        ladderBtn.title = ladderDir === 'up'
            ? `Floor ${room.contents.ladder.leadsTo.floor}`
            : `Floor ${room.contents.ladder.leadsTo.floor}`;
        ladderBtn.onclick = () => dungeonNav(ladderDir);
        ladderBtn.disabled = !canMove;
        ladderBtn.style.cssText = 'padding:4px 6px;font-size:12px;border-color:#FFD700;color:#FFD700;';
        if (!canMove) ladderBtn.style.opacity = '0.4';
        utilCol.appendChild(ladderBtn);
    }

    // â”€â”€ INVENTORY button (replaces keyboard input) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const invBtn = document.createElement('button');
    // Count HP and MP potions for the badge
    const invP = gameState.player;
    let hpPotCount = 0, mpPotCount = 0;
    (invP.inventory || []).forEach(ik => {
        const it = ITEMS[ik];
        if (!it) return;
        if (it.subtype === 'heal_hp' || it.subtype === 'full_restore') hpPotCount++;
        if (it.subtype === 'heal_mp' || it.subtype === 'full_restore') mpPotCount++;
    });
    invBtn.innerHTML = `ğŸ’ Inv<br><span style="font-size:10px;color:#ff6666;">â¤ï¸${hpPotCount}</span> <span style="font-size:10px;color:#6688ff;">ğŸ’™${mpPotCount}</span>`;
    invBtn.title = '';
    invBtn.style.cssText = 'padding:4px 6px;font-size:12px;border-color:#8aaa8a;line-height:1.3;';
    // Long-press (3s) â†’ sysop; short tap â†’ inventory
    let _invHoldTimer = null, _invFired = false;
    const _invDown = (e) => { e.preventDefault(); _invFired = false; _invHoldTimer = setTimeout(() => { _invHoldTimer = null; _invFired = true; openSysopOverlay(); }, POT_HOLD_MS); };
    const _invUp   = ()  => { if (_invHoldTimer) { clearTimeout(_invHoldTimer); _invHoldTimer = null; } if (!_invFired) showDungeonInventory(); _invFired = false; };
    const _invCancel = () => { if (_invHoldTimer) { clearTimeout(_invHoldTimer); _invHoldTimer = null; } _invFired = false; };
    invBtn.addEventListener('mousedown',  _invDown);
    invBtn.addEventListener('mouseup',    _invUp);
    invBtn.addEventListener('mouseleave', _invCancel);
    invBtn.addEventListener('touchstart', _invDown, { passive: false });
    invBtn.addEventListener('touchend',   _invUp);
    invBtn.addEventListener('touchcancel',_invCancel);
    utilCol.appendChild(invBtn);

    navWrap.appendChild(utilCol);
    ab.appendChild(navWrap);
}


// â”€â”€ Full-screen dungeon inventory (replaces old potion menu) â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showDungeonInventory() {
    const ab = document.getElementById('actionBar');
    const p  = gameState.player;
    const cs = gameState.combatState;
    const inCombat = cs && !cs.combatOver;

    function potColor(st) {
        if (st==='heal_hp') return '#ff4444';
        if (st==='heal_mp') return '#4488ff';
        if (st==='full_restore') return '#FFD700';
        if (st==='recall') return '#AA88FF';
        if (st?.startsWith('buff_')) return '#00FF88';
        return '#00FF00';
    }
    function potIcon(st) {
        if (st==='heal_hp') return 'â¤ï¸';
        if (st==='heal_mp') return 'ğŸ’™';
        if (st==='full_restore') return 'âœ¨';
        if (st==='recall') return 'ğŸŒ€';
        if (st==='buff_str') return 'ğŸ’ª';
        if (st==='buff_def') return 'ğŸ›¡ï¸';
        if (st==='buff_magic') return 'ğŸ”®';
        if (st==='buff_damage') return 'âš”ï¸';
        if (st==='buff_regen') return 'ğŸ’š';
        if (st==='buff_crit') return 'ğŸ¯';
        if (st?.startsWith('buff_')) return 'ğŸ§ª';
        return 'ğŸ§ª';
    }
    function backFn() {
        if (inCombat) renderDungeonActionBar();
        else renderDungeonActionBar();
    }

    // â”€â”€ Potions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const potions = {};
    p.inventory.forEach(ik => {
        const item = ITEMS[ik];
        if (!item) return;
        if (item.subtype === 'recall' && inCombat) return; // no recall during combat
        if (['heal_hp','heal_mp','full_restore','recall'].includes(item.subtype) || item.subtype?.startsWith('buff_')) {
            if (!potions[ik]) potions[ik] = { item, count: 0 };
            potions[ik].count++;
        }
    });

    // â”€â”€ Weapons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const playerClass = p.baseClass || p.class;
    const weapons = p.inventory.filter(ik => {
        const w = WEAPONS[ik];
        return w && !w.unarmed && canUseWeapon(playerClass, w);
    });

    // â”€â”€ Armor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const armors = p.inventory.filter(ik => {
        const a = ARMOR[ik];
        return a && !a.unarmored && canUseArmor(playerClass, a);
    });

    let html = `
    <div style="
        position:fixed;inset:0;z-index:9999;
        background:rgba(0,0,0,0.5);
        display:flex;align-items:center;justify-content:center;
        padding:10px;box-sizing:border-box;
    ">
        <div style="
            max-width:800px;width:100%;max-height:90vh;
            background:#000d00;border:2px solid var(--border-color);
            overflow-y:auto;padding:10px;box-sizing:border-box;
            font-family:'VT323',monospace;
        ">
        <div style="display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid var(--border-color);padding-bottom:6px;margin-bottom:10px;">
            <span style="color:var(--highlight-color);font-size:18px;letter-spacing:3px;">ğŸ’ DUNGEON INVENTORY</span>
            <button onclick="document.getElementById('dungeonInvOverlay').remove(); renderDungeonActionBar();" style="font-size:14px;padding:4px 10px;border-color:#ff4444;color:#ff4444;">âœ• CLOSE</button>
        </div>
        <div style="color:#8aaa8a;font-size:13px;margin-bottom:8px;">
            â¤ï¸ ${p.hp}/${p.maxHp} HP &nbsp;|&nbsp; ğŸ’™ ${p.mp}/${p.maxMp} MP
            ${inCombat ? ' &nbsp;|&nbsp; <span style="color:#ff4444;">âš”ï¸ IN COMBAT</span>' : ''}
        </div>
    `;

    // POTIONS SECTION
    html += `<div style="color:var(--highlight-color);font-size:15px;letter-spacing:2px;margin-bottom:6px;">â€” POTIONS â€”</div>`;
    const potKeys = Object.keys(potions);
    if (potKeys.length === 0) {
        html += `<div style="color:#555;font-size:13px;margin-bottom:10px;">No potions.</div>`;
    } else {
        html += `<div style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:14px;">`;
        potKeys.forEach(pk => {
            const pd = potions[pk];
            const col = potColor(pd.item.subtype);
            const ico = potIcon(pd.item.subtype);
            const atFull = (pd.item.subtype==='heal_hp' && p.hp>=p.maxHp) ||
                           (pd.item.subtype==='heal_mp' && p.mp>=p.maxMp) ||
                           (pd.item.subtype==='full_restore' && p.hp>=p.maxHp && p.mp>=p.maxMp);
            const useFn = inCombat ? `usePotion('${pk}');document.getElementById('dungeonInvOverlay').remove();renderDungeonActionBar();`
                                   : `usePotionExplore('${pk}');document.getElementById('dungeonInvOverlay').remove();renderDungeonActionBar();`;
            html += `
            <button onclick="${useFn}" ${atFull?'disabled':''} style="
                min-width:100px;padding:8px 10px;
                color:${col};border:2px solid ${col};
                background:#050a05;font-size:14px;
                opacity:${atFull?0.4:1};text-align:center;
            ">
                ${ico} ${pd.item.name}<br>
                <span style="color:#aaa;font-size:12px;">x${pd.count} â€” Use (no pip)</span>
            </button>`;
        });
        html += `</div>`;
    }

    // WEAPONS SECTION
    html += `<div style="color:var(--highlight-color);font-size:15px;letter-spacing:2px;margin-bottom:6px;">â€” WEAPONS â€”</div>`;
    html += `<div style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:14px;">`;
    // Equipped slot
    const eqW = WEAPONS[p.weapon];
    if (eqW && !eqW.unarmed) {
        const qc = QUALITY_CONFIG[eqW.quality];
        html += `<div style="min-width:120px;padding:8px;border:2px solid ${qc?.color||'#0f0'};background:#050a05;font-size:13px;">
            <div style="color:${qc?.color||'#0f0'};">${eqW.name}</div>
            <div style="color:#aaa;font-size:11px;">DMG ${eqW.baseDamage}-${eqW.maxDamage||eqW.baseDamage}</div>
            <div style="color:var(--highlight-color);font-size:11px;">â˜… EQUIPPED</div>
        </div>`;
    }
    if (weapons.length === 0 && (!eqW || eqW.unarmed)) {
        html += `<div style="color:#555;font-size:13px;">No weapons.</div>`;
    }
    weapons.forEach(ik => {
        if (ik === p.weapon) return;
        const w = WEAPONS[ik];
        const qc = QUALITY_CONFIG[w.quality];
        html += `<button onclick="equipItem('weapon','${ik}');document.getElementById('dungeonInvOverlay').remove();renderDungeonActionBar();" style="
            min-width:120px;padding:8px;border:2px solid ${qc?.color||'#0f0'};
            background:#050a05;font-size:13px;text-align:left;cursor:pointer;">
            <div style="color:${qc?.color||'#0f0'};">${w.name}</div>
            <div style="color:#aaa;font-size:11px;">DMG ${w.baseDamage}-${w.maxDamage||w.baseDamage}</div>
            <div style="color:#FFD700;font-size:11px;">â–¶ EQUIP</div>
        </button>`;
    });
    html += `</div>`;

    // ARMOR SECTION
    html += `<div style="color:var(--highlight-color);font-size:15px;letter-spacing:2px;margin-bottom:6px;">â€” ARMOR â€”</div>`;
    html += `<div style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:14px;">`;
    const eqA = ARMOR[p.armor];
    if (eqA && !eqA.unarmored) {
        const qc = QUALITY_CONFIG[eqA.quality];
        html += `<div style="min-width:120px;padding:8px;border:2px solid ${qc?.color||'#0f0'};background:#050a05;font-size:13px;">
            <div style="color:${qc?.color||'#0f0'};">${eqA.name}</div>
            <div style="color:#aaa;font-size:11px;">DEF ${eqA.baseDefense}</div>
            <div style="color:var(--highlight-color);font-size:11px;">â˜… EQUIPPED</div>
        </div>`;
    }
    if (armors.length === 0 && (!eqA || eqA.unarmored)) {
        html += `<div style="color:#555;font-size:13px;">No armor.</div>`;
    }
    armors.forEach(ik => {
        if (ik === p.armor) return;
        const a = ARMOR[ik];
        const qc = QUALITY_CONFIG[a.quality];
        html += `<button onclick="equipItem('armor','${ik}');document.getElementById('dungeonInvOverlay').remove();renderDungeonActionBar();" style="
            min-width:120px;padding:8px;border:2px solid ${qc?.color||'#0f0'};
            background:#050a05;font-size:13px;text-align:left;cursor:pointer;">
            <div style="color:${qc?.color||'#0f0'};">${a.name}</div>
            <div style="color:#aaa;font-size:11px;">DEF ${a.baseDefense}</div>
            <div style="color:#FFD700;font-size:11px;">â–¶ EQUIP</div>
        </button>`;
    });
    html += `</div>`;

    // Bottom CLOSE button
    html += `
    <div style="margin-top:16px;text-align:center;padding-top:10px;border-top:1px solid var(--border-color);">
        <button onclick="document.getElementById('dungeonInvOverlay').remove(); renderDungeonActionBar();" style="font-size:16px;padding:8px 24px;border-color:#ff4444;color:#ff4444;">âœ• CLOSE</button>
    </div>`;

    html += `</div>`; // end inner container
    html += `</div>`; // end overlay

    // Inject as overlay div (not into actionBar â€” covers whole screen)
    const existing = document.getElementById('dungeonInvOverlay');
    if (existing) existing.remove();
    const overlay = document.createElement('div');
    overlay.id = 'dungeonInvOverlay';
    overlay.innerHTML = html;
    document.body.appendChild(overlay);
}

// â”€â”€ Central dungeon navigation handler (buttons + keyboard) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function dungeonNav(input) {
    // Normalise aliases
    const aliases = {
        'north':'n','south':'s','east':'e','west':'w',
        'northeast':'ne','northwest':'nw','southeast':'se','southwest':'sw',
        'up':'up','down':'down','u':'up','d':'down',
        'n':'n','s':'s','e':'e','w':'w',
        'ne':'ne','nw':'nw','se':'se','sw':'sw'
    };
    const dir = aliases[input.toLowerCase()];
    if (!dir) {
        termAppend(`Unknown direction: <span style="color:#ff4444;">${input}</span> â€” try n, s, e, w, ne, nw, se, sw, up, down`, 'term-warning');
        return;
    }
    moveInDungeon(dir);
}







        
        
        function renderActionBar() {
            const ab = document.getElementById('actionBar');
            showActionBar();
            
            // If in dungeon, always use dungeon action bar with combat overlay
            if (gameState.dungeon) {
                renderDungeonActionBar();
                // Sweep animation + scroll fix (deferred so DOM is settled)
                requestAnimationFrame(() => { updatePipButtons(); stabilizeTerminalLayout(); });
                return;
            }
            
            if (gameState.combatState) {
                const cs       = gameState.combatState;
                const monsters = cs.monsters;
                const p        = gameState.player;
                const maxHits  = cs.pipAvailable ? cs.pipAvailable.length : calcPlayerHits(p);
                const hitsLeft = cs.pipAvailable ? cs.pipAvailable.filter(x => x).length : maxHits;
                const canAct   = hitsLeft > 0;

                // attack-charge pips  â—â—â—‹
                const pips = 'â—'.repeat(hitsLeft) + 'â—‹'.repeat(maxHits - hitsLeft);

                // Check what menu mode we're in
                const mode = cs.actionMode || 'main';

                if (mode === 'main') {
                    // Main combat menu â€” icons only, pip dots only
                    const isHunter    = (p.baseClass || p.class) === 'hunter';
                    const isWarrior   = (p.baseClass || p.class) === 'warrior';
                    const isRunesmith = (p.baseClass || p.class) === 'runesmith';
                    const trapBtn   = isHunter  ? `<button onclick="(castTrap())" ${p.mp < 10 ? 'disabled' : ''} class="action-icon-btn" title="Set Trap [T] - 10 MP" style="border-color:#8B4513;">ğŸª¤<span class="kb-hint">T</span></button>` : '';
                    const shieldBtn = isWarrior ? `<button onclick="playerDefend()" ${!canAct?'disabled':''} class="action-icon-btn" title="Shield [4] â€” 70% to halve damage" style="border-color:#00CCFF;">ğŸ›¡ï¸<span class="kb-hint">4</span></button>` : '';

                    // Runesmith overload UI
                    const rsPips = isRunesmith ? (p.runeOverloadPips || 0) : 0;
                    const rsReady = rsPips >= 3;
                    const rp1 = rsPips >= 1 ? 'ğŸ”¶' : 'â¬›'; const rp2 = rsPips >= 2 ? 'ğŸ”¶' : 'â¬›'; const rp3 = rsPips >= 3 ? 'ğŸ”¶' : 'â¬›';
                    const attackBtnHTML = isRunesmith
                        ? `<button onclick="showAttackMenu()" ${!canAct?'disabled':''} class="action-icon-btn pip-btn" id="pipBtn-attack" title="${rsReady ? 'OVERLOAD â€” Strike! [1]' : 'Attack [1]'}" style="${rsReady ? 'border-color:#FF4400;box-shadow:0 0 8px #FF4400,0 0 16px #FF8800;animation:runeOverloadPulse 0.7s ease-in-out infinite;' : ''}">${rsReady ? 'ğŸ”¥âš’ï¸' : 'âš’ï¸'}<span class="kb-hint">1</span></button>`
                        : `<button onclick="showAttackMenu()" ${!canAct?'disabled':''} class="action-icon-btn pip-btn" title="Attack [1]" id="pipBtn-attack">âš”ï¸<span class="kb-hint">1</span></button>`;
                    const spellBtnHTML = isRunesmith
                        ? `<button onclick="showSpellMenu()" ${!canAct?'disabled':''} class="action-icon-btn pip-btn" id="pipBtn-spell" title="Cast Rune [2]" style="border-color:#c8a000;"><span style="font-size:9px;line-height:1;display:block;">${rsReady ? 'âš¡READY' : rp1+rp2+rp3}</span>âœ¨<span class="kb-hint">2</span></button>`
                        : `<button onclick="showSpellMenu()"  ${!canAct?'disabled':''} class="action-icon-btn pip-btn" title="Cast Spell [2]" id="pipBtn-spell">âœ¨<span class="kb-hint">2</span></button>`;

                    ab.innerHTML = `
                        <div style="color:var(--highlight-color);font-size:13px;line-height:1;margin-bottom:3px;text-align:center;letter-spacing:3px;">${pips}</div>
                        <div style="display:flex;gap:3px;width:100%;">
                            ${attackBtnHTML}
                            ${spellBtnHTML}
                            <button onclick="showCombatInventory()" class="action-icon-btn" title="Inventory [3]" style="border-color:#00FF88;">ğŸ’<span class="kb-hint">3</span></button>
                            ${trapBtn}
                            ${shieldBtn}
                            <button onclick="attemptFlee()"    ${!canAct?'disabled':''} class="action-icon-btn" title="Flee [5]">ğŸƒ<span class="kb-hint">5</span></button>
                            <button onclick="printStatsToTerminal()" class="action-icon-btn" title="Show Stats [6]" style="border-color:#4488ff;">ğŸ“Š<span class="kb-hint">6</span></button>
                        </div>
                    `;
                } else if (mode === 'attack_type') {
                    const normalCost = 1;
                    const heavyCost = 2;
                    const showSpecial = hitsLeft >= 3;
                    ab.innerHTML = `
                        <div style="display:flex;gap:3px;width:100%;">
                            <button onclick="selectAttackType('normal')" ${hitsLeft < normalCost ? 'disabled' : ''} class="action-icon-btn" title="Normal Attack [N]">âš”ï¸<span class="kb-hint">N</span></button>
                            <button onclick="selectAttackType('heavy')"  ${hitsLeft < heavyCost  ? 'disabled' : ''} class="action-icon-btn" title="Heavy â€” 35% miss, 3Ã— dmg [H]" style="border-color:#ff8c00;">ğŸ’¥<span class="kb-hint">H</span></button>
                            ${showSpecial ? `<button onclick="selectAttackType('special')" class="action-icon-btn" title="Special â€” all pips [S]" style="border-color:#FFD700;">â­<span class="kb-hint">S</span></button>` : ''}
                            <button onclick="cancelAction()" class="action-icon-btn" title="Cancel [Esc]" style="border-color:#888;">âŒ<span class="kb-hint">Esc</span></button>
                        </div>
                    `;
                } else if (mode === 'target_attack' || mode === 'target_spell' || mode === 'target_staff_melee') {
                    const targetBtns = monsters.map((m, i) =>
                        `<button onclick="executeTargetedAction(${i})" class="target-btn" style="position:relative;">
                            ${i + 1}. ${m.name}<span class="kb-hint">${i + 1}</span>
                        </button>`
                    ).join('');
                    ab.innerHTML = `
                        <div style="display:flex;flex-wrap:wrap;gap:3px;width:100%;">
                            ${targetBtns}
                            <button onclick="cancelAction()" class="action-icon-btn" style="border-color:#888;position:relative;">âŒ<span class="kb-hint">Esc</span></button>
                        </div>
                    `;
                } else if (mode === 'spell_list') {
                    // Build numbered spell list
                    const validSpells = p.knownSpells.map(sk => {
                        const spell = ensureSpellExists(sk) || SPELLS[sk];
                        if (!spell) { console.warn(`âš ï¸ Spell '${sk}' not found`); return null; }
                        return { sk, spell };
                    }).filter(Boolean);

                    const spellBtns = validSpells.map(({sk, spell}, i) => {
                        const canCast = p.mp >= spell.mpCost;
                        const aoeTag  = spell.type === 'aoe_damage' ? ' <span style="color:#FF8800;">AOE</span>' : '';
                        return `<button onclick="selectSpell('${sk}')" ${!canCast?'disabled':''} class="spell-btn" style="position:relative;">
                            ${spell.name}${aoeTag}<br>
                            <span style="font-size:12px;">${spell.mpCost} MP</span>
                            <span class="kb-hint">${i + 1}</span>
                        </button>`;
                    }).join('');

                    ab.innerHTML = `
                        <div style="display:flex;flex-wrap:wrap;gap:3px;width:100%;">
                            ${spellBtns}
                            <button onclick="cancelAction()" class="action-icon-btn" style="border-color:#888;position:relative;">âŒ<span class="kb-hint">Esc</span></button>
                        </div>
                    `;
                }
            } else {
                // Out of combat - exploring
                // Show pip recovery status if any pips are still cooling down
                const cs2 = gameState.combatState;
                let pipWarning = '';
                let canLeave = true;
                if (cs2 && cs2.pipAvailable) {
                    const ready = cs2.pipAvailable.filter(x => x).length;
                    const total = cs2.pipAvailable.length;
                    canLeave = (ready === total);
                    if (!canLeave) {
                        pipWarning = `<div style="color:#FF8800;font-size:11px;margin-bottom:4px;">
                            â³ Pips recovering: ${'â—'.repeat(ready) + 'â—‹'.repeat(total-ready)} â€” wait to leave</div>`;
                    }
                }
                ab.innerHTML = `
                    ${pipWarning}
                    <div style="display:flex;gap:3px;width:100%;">
                        <button onclick="exploreLocation('${gameState.currentLocation}')" style="flex:2;" title="Explore [1]">ğŸ” Explore<span class="kb-hint">1</span></button>
                        <button onclick="showCombatInventory()" class="action-icon-btn" title="Inventory [3]" style="border-color:#00FF88;">ğŸ’<span class="kb-hint">3</span></button>
                        <button onclick="printStatsToTerminal()" class="action-icon-btn" title="Show Stats [4]" style="border-color:#4488ff;">ğŸ“Š<span class="kb-hint">4</span></button>
                        <button onclick="leaveExploreToTown()" ${canLeave ? '' : 'disabled'}
                            style="flex:1;${canLeave ? '' : 'opacity:0.4;'}border-color:${canLeave ? 'var(--text-color)' : '#888'};" title="Return to Town [5]">
                            ğŸ˜ï¸<span class="kb-hint">5</span>
                        </button>
                    </div>
                `;
            }
            // After any button-set change, fix terminal scroll on mobile
            requestAnimationFrame(() => { updatePipButtons(); stabilizeTerminalLayout(); });
        }
        function goBackToTown() {
            leaveExploreToTown();
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // NEW DYNAMIC COMBAT MENU SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function showAttackMenu() {
            const cs = gameState.combatState;
            if (!cs) return;
            cs.actionMode = 'attack_type';
            renderActionBar();
        }
        
        function selectAttackType(type) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            cs.pendingAttackType = type;
            cs.actionMode = 'target_attack';
            renderActionBar();
        }
        
        function cancelAction() {
            const cs = gameState.combatState;
            if (!cs) return;
            cs.actionMode = 'main';
            cs.pendingAttackType = null;
            cs.pendingSpell = null;
            renderActionBar();
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STAFF MELEE ATTACK (for mages out of MP)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function staffMeleeAttack() {
            const cs = gameState.combatState;
            if (!cs) return;
            
            // Switch to target selection for staff melee
            cs.actionMode = 'target_staff_melee';
            renderActionBar();
        }
        
        function executeStaffMelee(targetIndex) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            const p = gameState.player;
            const enemy = cs.monsters[targetIndex];
            const weapon = WEAPONS[p.weapon];
            
            // Consume 1 pip
            const consumed = consumePips(cs, 1, getPipCooldown(p));
            if (consumed < 1) {
                termAppend('Not enough action points!', 'term-error');
                return;
            }
            markMpAction();  // reset 15s MP regen countdown
            
            // Wands: full physical damage (their design purpose â€” better melee than staffs)
            // Staffs: 70% physical + some magic bleed (still a real hit, not a joke)
            const isWand = weapon && weapon.weaponSubtype === 'wand';
            const meleePct = isWand ? 1.0 : 0.7;
            const qBonus   = getQualityBonus(weapon ? weapon.quality : 'normal', weapon ? weapon.baseDamage : 0);
            const minDmg   = (weapon ? weapon.baseDamage : 1) + qBonus;
            const maxDmg   = (weapon ? (weapon.maxDamage || weapon.baseDamage) : 1) + qBonus;
            const rolled   = Math.floor(Math.random() * (maxDmg - minDmg + 1)) + minDmg;

            let baseDamage = Math.floor(rolled * meleePct);
            const strBonus = Math.floor((p.str || p.strength || 0) * (isWand ? 0.8 : 0.4));
            const magicBleed = isWand ? 0 : Math.floor((weapon ? weapon.baseMagicDamage || 0 : 0) * 0.2);
            
            // Total damage
            let totalDamage = baseDamage + strBonus + magicBleed;
            
            // Apply class damage multiplier (if evolved)
            const classMult = getClassDamageMultiplier(p);
            totalDamage = Math.floor(totalDamage * classMult);
            
            // Calculate final damage with enemy defense
            const result = calculateDamage({
                attacker: p,
                defender: enemy,
                base: totalDamage,
                type: 'physical',
                critChance: calcCritChance(p.lck || 0, p) / 100,
                dodgeChance: enemy.dodge || 0,
                armorPiercing: 0
            });
            
            const tName = cs.monsters.length > 1
                ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${targetIndex+1}</span>`
                : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;
            
            if (result.dodged) {
                termAppend(`You strike at ${tName} but they <span style="color:#88ff88;">DODGE!</span>`);
            } else {
                const critTag = result.crit ? ' <span style="color:#FFD700;">â˜… CRITICAL HIT!</span>' : '';
                const isWand = weapon && weapon.weaponSubtype === 'wand';
                const strikeVerb = isWand
                    ? `snaps <span style="color:#AA88FF;">âœ¦ ${weapon.name}</span> at`
                    : `strikes with <span style="color:#AA88FF;">âœ¦ ${weapon ? weapon.name : 'staff'}</span> at`;
                enemy.hp -= result.damage;
                termAppend(
                    `You ${strikeVerb} ${tName} for <span class="dmg-enemy">${result.damage} damage!</span>${critTag}`,
                    null,
                    () => {
                        checkCombatEnd();
                        updateEnemyCards();
                        updateHud();
                    }
                );
            }
            
            // Return to main combat menu
            cs.actionMode = 'main';
            renderActionBar();
        }
        
        function executeTargetedAction(targetIndex) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            cs.currentTarget = targetIndex;
            
            if (cs.actionMode === 'target_attack') {
                executeAttack(cs.pendingAttackType);
            } else if (cs.actionMode === 'target_spell') {
                castSpellOnTarget(cs.pendingSpell);
            } else if (cs.actionMode === 'target_staff_melee') {
                executeStaffMelee(targetIndex);
            }
            
            // Reset to main menu
            cs.actionMode = 'main';
            cs.pendingAttackType = null;
            cs.pendingSpell = null;
        }
        
        function selectSpell(spellKey) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            const spell = SPELLS[spellKey];
            cs.pendingSpell = spell;
            cs.pendingSpellKey = spellKey;
             
            
            // AOE spells and healing spells don't need target selection - cast immediately
            if (spell && (spell.type === 'aoe_damage' || spell.type === 'heal')) {
                castSpellOnTarget(spell);
                cs.actionMode = 'main';
                cs.pendingSpell = null;
                cs.pendingSpellKey = null;
            } else {
                // Regular spells need target selection
                cs.actionMode = 'target_spell';
                renderActionBar();
            }
        }
        
        // Update showSpellMenu to use the new system
        function showSpellMenuOld() {
            const cs = gameState.combatState;
            if (!cs) return;
            
            cs.actionMode = 'spell_list';
            renderActionBar();
        }
        

        function tryExploreLocation(locKey) {
            checkGameVersion();
            if (!isFullyRested()) {
                termAppend('<span style="color:var(--error-color);">You are too exhausted to continue! Wait for your charges to restoreâ€¦</span>', 'term-error');
                return;
            }
            // Clear old combat state now that we're starting fresh
            gameState.combatState = null;
            exploreLocation(locKey);
        }
        
        function tryGoBackToTown() {
            // Delegate to leaveExploreToTown â€” it handles pip check and enemy preservation
            leaveExploreToTown();
        }
        
        function tryViewWorldMap() {
            if (!isFullyRested()) {
                termAppend('<span style="color:var(--error-color);">You are too exhausted to travel! Wait for your charges to restoreâ€¦</span>', 'term-error');
                return;
            }
            // Preserve combatState â€” enemies wait here until player returns
            closeTerminalView();
            showExplore();
        }
        
        function selectTarget(index) {
            const cs = gameState.combatState;
            if (!cs || !cs.monsters || index < 0 || index >= cs.monsters.length) return;
            cs.currentTarget = index;
            updateEnemyCards();
            renderActionBar();
        }

        function isFullyRested() {
            const cs = gameState.combatState;
            if (!cs || !cs.pipAvailable) return true;
            // all pips must be available
            return cs.pipAvailable.every(x => x);
        }


      function startCombatTimer() {
    if (gameState.combatTimer) clearInterval(gameState.combatTimer);

    gameState.combatTimer = setInterval(() => {
        const cs = gameState.combatState;

        // No combat state at all â†’ stop timer
        if (!cs) {
            clearInterval(gameState.combatTimer);
            gameState.combatTimer = null;
            return;
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // PIP RECOVERY (always runs)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let anyRestored = false;
        const pipCooldown = gameState.player ? getPipCooldown(gameState.player) : BASE_PIP_COOLDOWN;

        for (let i = 0; i < cs.pipTimers.length; i++) {
            if (!cs.pipAvailable[i] && cs.pipTimers[i] > 0) {
                cs.pipTimers[i]--;
                if (cs.pipTimers[i] <= 0) {
                    cs.pipAvailable[i] = true;
                    cs.pipTimers[i] = pipCooldown;
                    anyRestored = true;
                }
            }
        }

        if (anyRestored) {
            renderActionBar();
        }
        // Always update pip sweep animation each tick
        updatePipButtons();

        // â”€â”€ GEM REGEN: bloodstone (HP) and moonstone (MP) tick every second â”€â”€
        const _p = gameState.player;
        const _w = _p && _p.weapon ? WEAPONS[_p.weapon] : null;
        if (_p && _w && _w.gems && !cs.combatOver) {
            let totalHpRegen = 0, totalMpRegen = 0;
            for (const _g of _w.gems) {
                if (!_g || !_g.stats) continue;
                totalHpRegen += _g.stats.hpRegen || 0;
                totalMpRegen += _g.stats.mpRegen || 0;
            }
            if (totalHpRegen > 0 && _p.hp < _p.maxHp) {
                _p.hp = Math.min(_p.maxHp, _p.hp + totalHpRegen);
                updateHud();
            }
            if (totalMpRegen > 0 && _p.mp < _p.maxMp) {
                _p.mp = Math.min(_p.maxMp, _p.mp + totalMpRegen);
                updateHud();
            }
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // POST-COMBAT RECOVERY CLEANUP
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (cs.combatOver) {
            // Once ALL pips are restored, exit recovery
            if (cs.pipAvailable.every(p => p)) {
                gameState.postCombatRecovery = false;
                gameState.combatState = null;

                renderActionBar();
                clearInterval(gameState.combatTimer);
                gameState.combatTimer = null;
            }
            return; // No enemy actions during recovery
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // ENEMY TIMER + INTENT TELEGRAPHING
        // (only while combat is active)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (cs.enemyTimer > 0) cs.enemyTimer--;

        // Telegraph intent 2 second before attack
        if (cs.enemyTimer === 2 && !cs.enemyIntent) {
            const enemy = cs.monsters[cs.currentTarget];
            if (enemy) {
                cs.enemyIntent = selectEnemyIntent(enemy);
                termAppend(
                    `<span style="color:${enemy.rarityColor};">${enemy.name}</span> ${cs.enemyIntent.telegraph}`,
                    'term-dim'
                );
            }
        }

        // Execute enemy attack
        if (cs.enemyTimer <= 0) {
            clearInterval(gameState.combatTimer);
            gameState.combatTimer = null;
            enemyAttackSingle();
        }

    }, 1000);
}


 // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLAYER ACTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ RUNESTONE ROOM EVENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Called every time a room is entered. If the room has contents.runestone
// and the player doesn't already have it, award it with a dramatic flash.
function checkRunestone(room) {
    if (!room || !room.contents || !room.contents.runestone) return;
    const p = gameState.player;
    if (!p) return;

    const rsId = room.contents.runestone;
    if (!p.runestones) p.runestones = [];
    if (p.runestones.includes(rsId)) return;  // already have it â€” no repeat

    // Mark as obtained
    p.runestones.push(rsId);
    if (!p.achievements) p.achievements = [];
    p.achievements.push({ id: rsId, name: rsId.replace('_', ' '), earned: Date.now() });

    // Get registry data for color and name
    const rs = (typeof RUNESTONES !== 'undefined' && RUNESTONES[rsId]) ? RUNESTONES[rsId] : null;
    const rsName  = rs ? rs.name  : rsId.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    const rsColor = rs ? rs.color : '#FFFFFF';
    const rsDesc  = rs ? rs.description : 'A mysterious runestone.';

    // â”€â”€ Dramatic flash cutscene â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    termAppend('', 'term-separator');
    termAppend(
        `<span style="color:#FFFFFF;font-weight:bold;font-size:18px;letter-spacing:2px;">âš¡ A FLASH OF BLINDING LIGHT! âš¡</span>`,
        'term-highlight'
    );
    termAppend(
        `<span style="color:${rsColor};font-weight:bold;">You now have the ${rsName} inscribed upon your forehead!</span>`,
        'term-loot'
    );
    termAppend(
        `<span style="color:#aaa;font-style:italic;">${rsDesc}</span>`,
        'term-dim'
    );
    termAppend('', 'term-separator');

    // Flash overlay on the screen
    const flash = document.createElement('div');
    flash.style.cssText = [
        'position:fixed', 'inset:0', 'background:#FFFFFF', 'opacity:0.9',
        'z-index:99999', 'pointer-events:none',
        'transition:opacity 0.6s ease-out'
    ].join(';');
    document.body.appendChild(flash);
    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            flash.style.opacity = '0';
            setTimeout(() => {
                flash.remove();
                // After flash â€” show colored pip banner
                const banner = document.createElement('div');
                banner.style.cssText = [
                    `position:fixed`, `top:60px`, `left:50%`,
                    `transform:translateX(-50%)`,
                    `background:#0a0a0a`,
                    `border:2px solid ${rsColor}`,
                    `padding:12px 28px`,
                    `color:${rsColor}`,
                    `font-family:'VT323',monospace`,
                    `font-size:20px`,
                    `z-index:9999`,
                    `text-align:center`,
                    `letter-spacing:1px`
                ].join(';');
                banner.innerHTML = `<span style="font-size:22px;">âœ¦</span> ${rsName} <span style="font-size:22px;">âœ¦</span><br><span style="font-size:14px;color:#ccc;">Inscribed upon your forehead</span>`;
                document.body.appendChild(banner);
                setTimeout(() => banner.remove(), 4000);
            }, 650);
        });
    });

    // Update HUD immediately so the pip appears
    updateHud();
    saveGame();
}

function checkRoomEncounter(room) {
    const ds = gameState.dungeon;
    if (!ds) return;
    if (!ds.activeEnemies) ds.activeEnemies = [];

    // â”€â”€ NEW FORMAT: contents.enemies[] from dungeon editor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Each entry: { key: 'giant_scorpion', drop: 'copper_key', rarity: 'epic' }
    // rarity is optional â€” omit or leave blank for base/common stats (no random roll in dungeons).
    // Only spawn once per room per dungeon session.
    if (room.contents && Array.isArray(room.contents.enemies) && room.contents.enemies.length > 0) {
        if (!ds.spawnedRooms) ds.spawnedRooms = new Set();
        if (ds.spawnedRooms.has(ds.currentRoom)) return;
        ds.spawnedRooms.add(ds.currentRoom);

        room.contents.enemies.forEach(entry => {
            const monsterId = typeof entry === 'string' ? entry : entry.key;
            const drop      = typeof entry === 'string' ? null  : (entry.drop || null);
            // Default to 'common' so dungeons never get a random rarity roll
            const rarity    = (typeof entry === 'object' && entry.rarity && RARITY_CONFIG?.[entry.rarity])
                              ? entry.rarity : 'common';
            const enemyDef  = ENEMIES[monsterId];
            if (!enemyDef) { console.warn('Dungeon enemy not found:', monsterId); return; }

            const inst = {
                id: crypto.randomUUID(),
                monsterId,
                rarity,
                name:          enemyDef.name,
                currentRoom:   ds.currentRoom,
                leash:         enemyDef.isBoss ? 6 : 3,
                roomsFollowed: 0,
                drop
            };
            ds.activeEnemies.push(inst);
            termAppend(`\u26a0\ufe0f <strong>${inst.name}</strong> steps out of the shadows!`, 'term-warning');
        });
        return;
    }

    // â”€â”€ OLD FORMAT: room.encounter.monsterId â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (!room || !room.encounter) return;
    if (room.encounter.resolved) return;

    const enemyDef = ENEMIES[room.encounter.monsterId];
    if (!enemyDef) { console.warn('Enemy not found:', room.encounter.monsterId); return; }

    const enemyInstance = {
        id: crypto.randomUUID(),
        monsterId:     room.encounter.monsterId,
        name:          enemyDef.name,
        currentRoom:   ds.currentRoom,
        leash:         enemyDef.isBoss ? 6 : 3,
        roomsFollowed: 0,
        drop:          room.encounter.drop || null
    };

    ds.activeEnemies.push(enemyInstance);
    room.encounter.resolved = true;

    termAppend(`\u26a0\ufe0f <strong>${enemyInstance.name}</strong> steps out of the shadows!`, 'term-warning');
}


function checkDungeonRespawns() {
    const ds = gameState.dungeon;
    if (!ds || !ds.defeatedEnemies || ds.defeatedEnemies.length === 0) return;
    
    const now = Date.now();
    const respawned = [];
    
    // Check each defeated enemy for respawn time
    ds.defeatedEnemies = ds.defeatedEnemies.filter(deadEnemy => {
        if (now >= deadEnemy.respawnTime) {
            // Respawn this enemy - restore to original room with full HP
            const respawnedEnemy = {
                id: deadEnemy.id,
                monsterId: deadEnemy.monsterId,
                name: deadEnemy.name,
                currentRoom: deadEnemy.currentRoom, // Original spawn room
                leash: deadEnemy.leash,
                roomsFollowed: 0,
                drop: deadEnemy.drop,
                isChasing: false, // Reset chase state
                // Reset HP if it was stored (for wounded enemies)
                hp: undefined,
                maxHp: undefined
            };
            
            ds.activeEnemies.push(respawnedEnemy);
            respawned.push(respawnedEnemy);
            
            // Remove from defeated list (filter returns false)
            return false;
        }
        // Keep in defeated list (filter returns true)
        return true;
    });
    
    // Log respawns
    if (respawned.length > 0) {
        console.log(`â™»ï¸ ${respawned.length} dungeon enemy(s) respawned after 30 minutes`);
        
        // Only show message if player is in same room as a respawned enemy
        respawned.forEach(enemy => {
            if (enemy.currentRoom === ds.currentRoom) {
                termAppend(`â™»ï¸ <strong>${enemy.name}</strong> has respawned in this room!`, 'term-warning');
            }
        });
    }
}


function updateDungeonEnemies() {
    const ds = gameState.dungeon;
    if (!ds || !ds.activeEnemies) return [];

    const dungeon = DUNGEONS[ds.dungeonKey];
    const floor = dungeon.floors[ds.floor];
    const arrived = []; // enemies that just moved into player's room

    ds.activeEnemies.forEach(enemy => {
        const enemyRoom = floor.rooms[enemy.currentRoom];
        if (!enemyRoom) return;

        // Start chase when player enters enemy's room for the first time
        if (!enemy.isChasing && enemy.currentRoom === ds.currentRoom) {
            enemy.isChasing = true;
            enemy.roomsFollowed = 0;
        }

        // Not chasing â†’ do nothing
        if (!enemy.isChasing) return;

        // Already in player's room â†’ nothing to move
        if (enemy.currentRoom === ds.currentRoom) return;

        // Leash exhausted â†’ stop
        if (enemy.roomsFollowed >= enemy.leash) {
            enemy.isChasing = false;
            termAppend(`ğŸ›‘ <strong>${enemy.name}</strong> stops the chase.`, 'term-dim');
            return;
        }

        // Follow player â€” find which exit leads toward player's room
        const exits = enemyRoom.exits || {};
        for (const dir in exits) {
            if (exits[dir] === ds.currentRoom) {
                enemy.currentRoom = ds.currentRoom;
                enemy.roomsFollowed++;

                const fromDir = OPPOSITE_DIR[dir] || dir;
                termAppend(
                    `âš ï¸ <strong>${enemy.name}</strong> enters from the <em>${fromDir}</em>.`,
                    'term-warning'
                );
                arrived.push(enemy);
                return;
            }
        }
    });

    return arrived; // caller decides what to do with arrivals
}




function moveInDungeon(direction) {
    // Check if player has full pips (required for movement)
    const cs = gameState.combatState;
    if (cs && cs.pipAvailable) {
        const hasFullPips = cs.pipAvailable.every(x => x);
        if (!hasFullPips) {
            const available = cs.pipAvailable.filter(x => x).length;
            const total = cs.pipAvailable.length;
            termAppend(`âš¡ You're too exhausted to move! (${available}/${total} pips restored)`, 'term-error');
            return;
        }
    }

    if (!gameState.dungeon) {
        console.warn('Not in a dungeon');
        return;
    }

    const ds = gameState.dungeon;
    const dungeonData = DUNGEONS[ds.dungeonKey];

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LADDER MOVEMENT â€” "up" or "down"
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (direction === 'up' || direction === 'down') {
        const currentFloor = dungeonData.floors[ds.floor];
        const currentRoom = currentFloor.rooms[ds.currentRoom];

        if (!currentRoom.contents || !currentRoom.contents.ladder) {
            termAppend(`There is no ladder here.`, 'term-dim');
            return;
        }
        const ladder = currentRoom.contents.ladder;
        if (ladder.direction !== direction) {
            termAppend(`The ladder only goes ${ladder.direction}.`, 'term-dim');
            return;
        }

        const targetFloor = ladder.leadsTo.floor;
        const targetRoom  = ladder.leadsTo.room;

        if (!dungeonData.floors[targetFloor] || !dungeonData.floors[targetFloor].rooms[targetRoom]) {
            termAppend(`âš ï¸ Ladder leads nowhere (floor ${targetFloor} / ${targetRoom} not found).`, 'term-error');
            return;
        }

        // â”€â”€ Transition â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ds.floor      = targetFloor;
        ds.currentRoom = targetRoom;
        
        // Load persistent map for the new floor and merge with current session
        const persistentMap = loadDungeonMap(gameState.player, ds.dungeonKey, targetFloor);
        const scopedKey = `${targetFloor}:${targetRoom}`;
        persistentMap.add(scopedKey); // Add current room
        saveRoomDiscovery(gameState.player, ds.dungeonKey, targetFloor, targetRoom); // Save to persistent
        
        ds.discoveredRooms = persistentMap; // Use persistent map for active session

        const destFloorData = dungeonData.floors[targetFloor];
        const destRoom = destFloorData.rooms[targetRoom];
        destRoom.flags = destRoom.flags || {};
        destRoom.flags.discovered = true;

        termAppend('', 'term-separator');
        termAppend(`ğŸªœ You ${direction === 'up' ? 'climb up' : 'descend'} the ladder to <strong>Floor ${targetFloor}</strong>.`, 'term-highlight');
        termAppend(`<strong>${destRoom.name || targetRoom}</strong>`);
        termAppend(destRoom.description || '', 'term-dim');

        // List exits including any ladder in the destination room
        const exitList = buildExitList(destRoom);
        termAppend(`You see exits: ${exitList}.`, 'term-dim');

        // â™»ï¸ Check for enemy respawns (30min timer)
        checkDungeonRespawns();

        checkTownExit(destRoom);
        triggerRoomTrap(destRoom);
        checkRunestone(destRoom);
        checkRoomEncounter(destRoom);
        checkEnemiesInRoom(targetRoom);
        saveGame();
        renderDungeonActionBar();
        return;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // NORMAL DIRECTION MOVEMENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const floor = dungeonData.floors[ds.floor];
    const currentRoom = floor.rooms[ds.currentRoom];

    const nextRoomId = currentRoom.exits[direction];
    if (!nextRoomId) {
        termAppend(`You cannot go that way.`, 'term-dim');
        return;
    }

    // â”€â”€ DOOR LOCK CHECK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // If a locked door exists on this exit, player must have the matching key.
    const door = currentRoom.contents?.doors?.[direction];
    if (door && door.locked) {
        const keyItem = door.type + '_key';   // e.g. 'copper' â†’ 'copper_key'
        const inv = gameState.player.inventory || [];
        const hasKey = inv.includes(keyItem);

        if (!hasKey) {
            // Door color names for flavour text
            const COLOR_NAMES = {
                bronze:'Bronze', copper:'Copper', iron:'Iron', brass:'Brass',
                silver:'Silver', electrum:'Electrum', ruby:'Ruby', topaz:'Topaz',
                diamond:'Diamond', obsidian:'Obsidian', bone:'Bone'
            };
            const doorName = (COLOR_NAMES[door.type] || door.type) + ' door';
            termAppend(
                `ğŸ”’ A locked <span style="color:${getDoorColor(door.type)}">${doorName}</span> blocks your path. You need a ${COLOR_NAMES[door.type] || door.type} key.`,
                'term-warning'
            );
            return;
        }

        // Player has the key â€” keys are permanent collectibles, door unlocks for session
        const COLOR_NAMES2 = {
            bronze:'Bronze', copper:'Copper', iron:'Iron', brass:'Brass',
            silver:'Silver', electrum:'Electrum', ruby:'Ruby', topaz:'Topaz',
            diamond:'Diamond', obsidian:'Obsidian', bone:'Bone'
        };
        termAppend(
            `ğŸ”“ Your <span style="color:${getDoorColor(door.type)}">${COLOR_NAMES2[door.type] || door.type} key</span> unlocks the door.`,
            'term-highlight'
        );
        door.locked = false; // door stays unlocked for rest of session
    }

    const nextRoom = floor.rooms[nextRoomId];

    ds.currentRoom = nextRoomId;
    if (!ds.discoveredRooms) ds.discoveredRooms = new Set();
    const scopedKey = `${ds.floor}:${nextRoomId}`;
    ds.discoveredRooms.add(scopedKey); // Active session
    saveRoomDiscovery(gameState.player, ds.dungeonKey, ds.floor, nextRoomId); // Persistent map
    nextRoom.flags = nextRoom.flags || {};
    nextRoom.flags.discovered = true;

    termAppend('', 'term-separator');
    termAppend(`<strong>${nextRoom.name || nextRoomId}</strong>`);
    termAppend(nextRoom.description || '', 'term-dim');

    // â™»ï¸ Check for enemy respawns (30min timer)
    checkDungeonRespawns();

    // ğŸ”¥ Spawn encounter (once)
    checkRoomEncounter(nextRoom);

    // âœ¦ Runestone pickup (once, triggers flash cutscene)
    checkRunestone(nextRoom);

    // ğŸ‘£ Move any active enemies that can follow; get list of who just arrived
    const arrivals = updateDungeonEnemies();

    // âš”ï¸ Unified enemy check â€” handles both pre-existing enemies AND followers
    //    Pass arrivals so followers can JOIN an active combat instead of waiting
    checkEnemiesInRoom(nextRoomId, arrivals);

    const exitList = buildExitList(nextRoom);
    termAppend(`You see exits: ${exitList}.`, 'term-dim');

    // ğŸŒ€ Check for town portal exit in this room
    checkTownExit(nextRoom);

    // ğŸª¤ Check for traps
    triggerRoomTrap(nextRoom);

    // ğŸ’¾ AUTO-SAVE after moving in dungeon
    saveGame();

    // ğŸ”‘ update buttons for new room
    renderDungeonActionBar();
}

// Build the exit string including ladder directions
function buildExitList(room) {
    const exits = Object.keys(room.exits || {}).map(d => d.toUpperCase());
    if (room.contents && room.contents.ladder) {
        exits.push(room.contents.ladder.direction === 'up' ? 'â¬† UP' : 'â¬‡ DOWN');
    }
    // Mark locked exits
    if (room.contents && room.contents.doors) {
        return exits.map(d => {
            const dl = d.toLowerCase();
            const door = room.contents.doors[dl];
            if (door && door.locked) {
                return `${d}<span style="color:#e8b84a">ğŸ”’</span>`;
            }
            return d;
        }).join(', ') || 'none';
    }
    return exits.length ? exits.join(', ') : 'none';
}

// Return the CSS color for a door type (matches dungeon editor palette)
function getDoorColor(type) {
    const DOOR_COLORS = {
        bronze:   '#cd7f32',
        copper:   '#b87333',
        iron:     '#a8a9ad',
        brass:    '#b5a642',
        silver:   '#c0c0c0',
        electrum: '#d4af37',
        ruby:     '#e0455b',
        topaz:    '#ffa07a',
        diamond:  '#aef0ff',
        obsidian: '#9b59b6',
        bone:     '#e8dcc8'
    };
    return DOOR_COLORS[type] || '#aaa';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRAP SYSTEM â€” triggers when player enters a room with a trap
// Supports both old singular (room.contents.trap) and new array
// (room.contents.traps[]) format from dungeon editor.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function triggerRoomTrap(room) {
    if (!room || !room.contents) return;
    const p = gameState.player;
    if (!p) return;

    // Build trap list â€” support both old (.trap) and new (.traps[]) formats
    let traps = [];
    if (room.contents.traps && Array.isArray(room.contents.traps)) {
        traps = room.contents.traps;                  // new array format
    } else if (room.contents.trap) {
        traps = [room.contents.trap];                 // old single-trap format
    }

    if (!traps.length) return;

    traps.forEach(trap => {
        if (!trap || !trap.type) return;

        // resetOnLeave = re-arm when player leaves (new format); no field = one-shot legacy
        const resetable = (trap.resetOnLeave === true);
        const dotType   = (trap.type === 'poison' || trap.type === 'acid');

        // Skip if already triggered and not resetable (one-shot spent)
        if (trap.triggered && !resetable && !dotType) return;

        const damage = trap.damage || 0;
        const name   = trap.name   || trap.type;

        switch (trap.type) {

            case 'spike':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`âš ï¸ <span style="color:#FF4444;">SPIKE TRAP!</span> Sharp spikes shoot from the floor â€” you take <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'stone':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`âš ï¸ <span style="color:#AA8866;">STONE TRAP!</span> A massive stone swings from the ceiling â€” you take <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'poison': {
                // DOT: damage spread over duration (default 10s, 5 ticks)
                const duration = trap.duration || 10;
                const ticks = 5;
                const tickInterval = Math.max(1000, (duration * 1000) / ticks);
                const tickDmg = Math.max(1, Math.ceil(damage / ticks));
                termAppend(`â˜ ï¸ <span style="color:#44FF44;">POISON TRAP!</span> Toxic gas floods the room â€” you feel your strength seeping away!`, 'term-error');
                let t = 0;
                const timer = setInterval(() => {
                    if (!gameState.player || t >= ticks) { clearInterval(timer); return; }
                    gameState.player.hp = Math.max(1, gameState.player.hp - tickDmg);
                    termAppend(`â˜ ï¸ Poison deals <strong>${tickDmg}</strong> damage... (${gameState.player.hp}/${gameState.player.maxHp} HP)`, 'term-error');
                    updateHud(); t++;
                }, tickInterval);
                break;
            }

            case 'acid': {
                // Acid: instant damage + short DOT
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`ğŸ§ª <span style="color:#a8e63d;">ACID TRAP!</span> Acid spray burns you â€” <strong>${damage} damage!</strong>`, 'term-error');
                const acidDuration = trap.duration || 5;
                const acidTicks = 3;
                const acidInterval = Math.max(500, (acidDuration * 1000) / acidTicks);
                const acidTickDmg = Math.max(1, Math.ceil(damage * 0.4 / acidTicks));
                let at = 0;
                const acidTimer = setInterval(() => {
                    if (!gameState.player || at >= acidTicks) { clearInterval(acidTimer); return; }
                    gameState.player.hp = Math.max(1, gameState.player.hp - acidTickDmg);
                    termAppend(`ğŸ§ª Acid burns for <strong>${acidTickDmg}</strong> more damage...`, 'term-error');
                    updateHud(); at++;
                }, acidInterval);
                if (!resetable) trap.triggered = true;
                break;
            }

            case 'fire':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`ğŸ”¥ <span style="color:#FF8800;">FIRE TRAP!</span> Flames erupt from hidden vents â€” you take <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'lightning':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`âš¡ <span style="color:#FFDD00;">LIGHTNING TRAP!</span> A bolt of lightning strikes you â€” <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'arrow':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`ğŸ¹ <span style="color:#CCCC44;">ARROW TRAP!</span> A crossbow bolt catches you off guard â€” you take <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'freeze':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`â„ï¸ <span style="color:#88CCFF;">FREEZE TRAP!</span> A burst of ice envelops you â€” you take <strong>${damage} damage</strong> and feel sluggish!`, 'term-error');
                if (gameState.combatState && gameState.combatState.pipTimers) {
                    gameState.combatState.pipTimers = gameState.combatState.pipTimers.map(t => t + 8);
                }
                if (!resetable) trap.triggered = true;
                break;

            case 'pit':
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`ğŸ•³ï¸ <span style="color:#95a5a6;">PIT TRAP!</span> The floor gives way! You fall hard â€” <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'alarm':
                termAppend(`ğŸ”” <span style="color:#dfe6e9;">ALARM TRAP!</span> A deafening bell rings out â€” nearby monsters are alerted!`, 'term-error');
                if (!resetable) trap.triggered = true;
                break;

            case 'web':
                termAppend(`ğŸ•¸ï¸ <span style="color:#b2bec3;">WEB TRAP!</span> Sticky strands bind your limbs â€” you're slowed for 2 rounds!`, 'term-error');
                // Disable movement pip for 2 recovery cycles
                if (gameState.combatState && gameState.combatState.pipTimers) {
                    gameState.combatState.pipTimers = gameState.combatState.pipTimers.map(t => t + 5);
                }
                if (!resetable) trap.triggered = true;
                break;

            case 'curse':
                termAppend(`ğŸŒ€ <span style="color:#a855f7;">CURSE TRAP!</span> Dark energy courses through you â€” your stats are reduced!`, 'term-error');
                // Temporarily reduce attack by 20% for the session
                if (p.curseStacks === undefined) p.curseStacks = 0;
                p.curseStacks = Math.min(3, p.curseStacks + 1);
                if (!resetable) trap.triggered = true;
                break;

            default:
                p.hp = Math.max(1, p.hp - damage);
                termAppend(`âš ï¸ <span style="color:#FF4444;">TRAP!</span> A ${name} catches you â€” you take <strong>${damage} damage!</strong>`, 'term-error');
                if (!resetable) trap.triggered = true;
        }
    });

    updateHud();
}


function getEnemyInRoom(roomId) {
    const ds = gameState.dungeon;
    if (!ds || !ds.activeEnemies) return null;

    return ds.activeEnemies.find(enemy => enemy.currentRoom === roomId) || null;
}



function checkEnemiesInRoom(roomId, newArrivals) {
    const ds = gameState.dungeon;
    if (!ds || !ds.activeEnemies) return;

    const enemiesHere = ds.activeEnemies.filter(e => e.currentRoom === roomId);
    if (enemiesHere.length === 0) return;

    const cs = gameState.combatState;

    // â”€â”€ Active non-finished combat: add ALL room enemies not yet in this fight â”€â”€
    if (cs && !cs.combatOver) {
        const linkedIds = new Set(cs.dungeonEnemyIds || (cs.dungeonEnemyId ? [cs.dungeonEnemyId] : []));

        // Join = any enemy in this room not already tracked in combat
        // (covers both followers from arrivals AND pre-existing room enemies)
        const joining = enemiesHere.filter(e => !linkedIds.has(e.id));
        if (joining.length === 0) return;

        joining.forEach(de => {
            if (!de.monsterId) return;
            const newMonster = spawnMonsterWithRarity(de.monsterId, false, de.rarity || 'common');
            newMonster.index = cs.monsters.length;
            if (de.hp !== undefined && de.hp < de.maxHp) {
                newMonster.hp    = de.hp;
                newMonster.maxHp = de.maxHp;
            }
            cs.monsters.push(newMonster);
            if (!cs.dungeonEnemyIds) cs.dungeonEnemyIds = cs.dungeonEnemyId ? [cs.dungeonEnemyId] : [];
            cs.dungeonEnemyIds.push(de.id);
            linkedIds.add(de.id);
            termAppend(`âš”ï¸ <strong>${newMonster.name}</strong> joins the fight!`, 'term-warning');
        });

        // Ensure combat timer is running and reset actionMode so player sees all targets
        cs.actionMode = 'main';
        if (!gameState.combatTimer) startCombatTimer();
        renderDungeonActionBar();
        return;
    }

    // â”€â”€ No combat or stale finished combat: clear state and start fresh â”€â”€
    if (cs) {
        if (gameState.combatTimer) { clearInterval(gameState.combatTimer); gameState.combatTimer = null; }
        gameState.combatState = null;
        gameState.postCombatRecovery = false;
    }

    if (enemiesHere.length === 1) {
        termAppend(`âš”ï¸ <strong>${enemiesHere[0].name}</strong> confronts you!`, 'term-warning');
    } else {
        const names = enemiesHere.map(e => `<strong>${e.name}</strong>`).join(', ');
        termAppend(`âš”ï¸ ${names} surround you!`, 'term-warning');
    }
    startDungeonCombat(enemiesHere);
}

function startDungeonCombat(dungeonEnemies) {
    // Accept either a single enemy or an array
    if (!Array.isArray(dungeonEnemies)) dungeonEnemies = [dungeonEnemies];
    if (dungeonEnemies.length === 0) return;

    // Clear any stale finished combat state
    if (gameState.combatState && gameState.combatState.combatOver) {
        gameState.combatState = null;
        gameState.postCombatRecovery = false;
    }

    const monsterIds = dungeonEnemies.map(e => e.monsterId).filter(Boolean);
    if (monsterIds.length === 0) {
        console.error('Dungeon enemies missing monsterId:', dungeonEnemies);
        return;
    }

    // Each dungeon enemy carries its rarity from the room definition (default 'common').
    // This prevents any random rarity rolls â€” dungeon difficulty is author-controlled.
    const forcedRarities = dungeonEnemies.map(e => e.rarity || 'common');

    // Start combat with all enemies in room (useZoneLevel=false for dungeons)
    startCombat(monsterIds, false, forcedRarities);

    if (!gameState.combatState) return;

    // Link ALL dungeon enemy IDs to combat state for post-combat cleanup
    gameState.combatState.dungeonEnemyIds = dungeonEnemies.map(e => e.id);
    // Legacy single-enemy field (keeps drops working for first enemy)
    gameState.combatState.dungeonEnemyId = dungeonEnemies[0].id;

    // Restore saved HP for each monster (matched by index)
    dungeonEnemies.forEach((de, idx) => {
        if (de.hp !== undefined && de.hp < de.maxHp) {
            const monster = gameState.combatState.monsters[idx];
            if (monster) {
                monster.hp  = de.hp;
                monster.maxHp = de.maxHp;
            }
        }
    });

    saveGame();
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TEMP: DUNGEON TEST HARNESS (SAFE)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function returnToTown(townId) {
    console.log('â¬… returnToTown() called');
    // â”€â”€ Dungeon keys persist in inventory â€” they are permanent collectibles â”€â”€

    // â”€â”€ Persist defeated-enemy respawn timers so farming is prevented â”€â”€
    if (gameState.dungeon && gameState.dungeon.defeatedEnemies && gameState.dungeon.defeatedEnemies.length > 0) {
        const dKey = gameState.dungeon.dungeonKey;
        if (dKey) {
            if (!gameState.player.dungeonTimers) gameState.player.dungeonTimers = {};
            // Merge with any existing timers for this dungeon
            const existing = gameState.player.dungeonTimers[dKey] || [];
            const existingIds = new Set(existing.map(e => e.id));
            const fresh = gameState.dungeon.defeatedEnemies.filter(e => !existingIds.has(e.id));
            gameState.player.dungeonTimers[dKey] = [...existing, ...fresh];
            console.log(`ğŸ’¾ Preserved ${gameState.player.dungeonTimers[dKey].length} enemy timer(s) for ${dKey}`);
        }
    }

    // Clear dungeon state
    gameState.dungeon = null;
    gameState.combatState = null;
    gameState.postCombatRecovery = false;

    if (gameState.combatTimer) {
        clearInterval(gameState.combatTimer);
        gameState.combatTimer = null;
    }

    // Update current town if specified
    if (townId) gameState.currentTown = townId;

    document.body.classList.remove("terminal-mode");
    termClear();

    const ab = document.getElementById('actionBar');
    ab.innerHTML = '';

    gameState._terminalOpen = false;
    gameState._currentExploreArea = null;

    saveGame();
    showTown();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHECK TOWN EXIT FLAG IN DUNGEON ROOMS
// When a room has flags.townExit, show a portal button to that town.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function checkTownExit(room) {
    if (!room || !room.flags || !room.flags.townExit) return;
    const townId = room.flags.townExit;
    const label  = room.flags.townExitLabel || `Exit to ${townId}`;
    const firstDiscovery = room.flags.firstDiscovery;

    // Special first-discovery logic: award White Runestone
    if (firstDiscovery && townId === 'town2') {
        const p = gameState.player;
        if (!p.runestones) p.runestones = [];
        if (!p.runestones.includes('white_runestone')) {
            p.runestones.push('white_runestone');
            if (!p.achievements) p.achievements = [];
            p.achievements.push({ id: 'white_runestone', name: 'White Runestone', earned: Date.now() });

            termAppend('', 'term-separator');
            termAppend('âœ¦ <span style="color:#FFFFFF;font-weight:bold;">WHITE RUNESTONE</span> âœ¦', 'term-highlight');
            termAppend('You have discovered Ashen Harbor! A pale runestone materializes in your hand.', 'term-loot');
            termAppend('The Portal network is now accessible from both towns.', 'term-dim');
            termAppend('', 'term-separator');

            // Don't trigger again
            room.flags.firstDiscovery = false;
            saveGame();
        }
    }

    // Post a clickable portal message in the terminal
    setTimeout(() => {
        termAppend(
            `<span style="color:#AA88FF;cursor:pointer;font-weight:bold;" onclick="townExitFromDungeon('${townId}')">` +
            `[ ${label} ]</span>`,
            'term-highlight'
        );
    }, 300);
}

// Called when player clicks the town exit link from a dungeon room
function townExitFromDungeon(townId) {
    const townDef = (typeof TOWNS !== 'undefined' && TOWNS[townId]) ? TOWNS[townId] : null;
    const townName = townDef ? townDef.name : townId;
    if (confirm(`Leave the dungeon and travel to ${townName}?`)) {
        returnToTown(townId);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LEAVE EXPLORATION TO TOWN (allowed when pips are full)
// Enemies are preserved via activeCombat save system
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function leaveExploreToTown() {
    const cs = gameState.combatState;
    if (cs) {
        const allReady = cs.pipAvailable && cs.pipAvailable.every(x => x);
        if (!allReady) {
            termAppend('<span style="color:var(--error-color);">âš  You must wait for all pips to recover before leaving!</span>');
            return;
        }
        // Enemies are preserved â€” activeCombat will save them
    }

    // Clear timers but NOT combatState (save will capture it)
    if (gameState.combatTimer) {
        clearInterval(gameState.combatTimer);
        gameState.combatTimer = null;
    }

    // Stop resting timers
    stopResting();

    document.body.classList.remove("terminal-mode");
    document.getElementById('actionBar').innerHTML = '';
    gameState._terminalOpen = false;
    gameState._currentExploreArea = null;

    saveGame();  // Saves activeCombat with enemies still alive
    showTown();
}

function testDungeon() {
    // Legacy redirect â€” use town1's dungeon
    startDungeon('Dungeon1');
}



const BASE_PIP_COOLDOWN = 10;
const MIN_PIP_COOLDOWN = 5;

// â”€â”€ PIP SWEEP BUTTON ANIMATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Called each tick to update the conic-gradient overlay on Attack/Spell btns.
// Uses total "worst" pip state: sweep = fraction of the longest cooling pip.
function updatePipButtons() {
    const cs = gameState.combatState;
    if (!cs || !cs.pipTimers) return;

    const cd     = gameState.player ? getPipCooldown(gameState.player) : BASE_PIP_COOLDOWN;
    const total  = cs.pipTimers.length;
    const ready  = cs.pipAvailable.filter(Boolean).length;
    const cooling = total - ready;

    // Fraction complete = 1 means "fully cooled" (no overlay)
    // We show the cooldown of the pip that will recover SOONEST (smallest remaining)
    let pct = 1; // default = ready (no overlay)
    if (cooling > 0) {
        // Find the minimum remaining timer among cooling pips
        let minRemaining = Infinity;
        for (let i = 0; i < total; i++) {
            if (!cs.pipAvailable[i]) {
                minRemaining = Math.min(minRemaining, cs.pipTimers[i]);
            }
        }
        // pct = fraction ALREADY elapsed (so sweep goes from full â†’ empty as timer counts down)
        pct = 1 - (minRemaining / cd);
        pct = Math.max(0, Math.min(1, pct));
    }

    // For multi-pip, the dial wraps: each full rotation = one pip recovery
    // We rotate based on: (pips already recovered this cycle) + current pip fraction
    // Visual: dial spins continuously once per pip cooldown duration
    const revolutionsLeft = cooling;  // each remaining pip = one more sweep
    // conic-gradient percentage = fraction of current pip elapsed
    const pipPct = (pct * 100).toFixed(1) + '%';

    // Update all pip-btn elements
    document.querySelectorAll('.pip-btn').forEach(btn => {
        btn.style.setProperty('--pip-pct', pipPct);
        if (cooling > 0) {
            btn.classList.add('cooling');
            btn.classList.remove('all-ready');
            // Show pip badge if >1 pip cooling
            let badge = btn.querySelector('.pip-badge');
            if (cooling > 1) {
                if (!badge) { badge = document.createElement('span'); badge.className='pip-badge'; btn.appendChild(badge); }
                badge.textContent = cooling + 'Ã—';
            } else if (badge) {
                badge.remove();
            }
        } else {
            btn.style.setProperty('--pip-pct', '0%');
            btn.classList.remove('cooling');
            btn.classList.add('all-ready');
            const badge = btn.querySelector('.pip-badge');
            if (badge) badge.remove();
        }
    });
}

function getPipCooldown(player){
    // Base is always 10s for all classes regardless of class speed stat.
    // Only active speed_boost buff potions reduce pip recovery time.
    let cooldown = BASE_PIP_COOLDOWN;

    // Check for active speed_boost buff (from speed potions only)
    if (player.buffs) {
        const speedBuff = player.buffs.find(b => b.type === 'speed_boost');
        if (speedBuff) {
            // speedBuff.power is a percentage bonus (e.g. 25 = 25% faster)
            const reduction = Math.floor(cooldown * (speedBuff.power / 100));
            cooldown -= reduction;
        }
    }

    return Math.max(MIN_PIP_COOLDOWN, cooldown);
}



function selectEnemyIntent(enemy) {
    // Default / basic attack
    let intent = {
        type: 'basic',
        damageMult: 1,
        armorPiercing: 0,
        telegraph: 'prepares to strike...'
    };

    // Bosses and elites sometimes wind up a heavy hit
    if (enemy.isBoss && Math.random() < 0.4) {
        intent = {
            type: 'heavy',
            damageMult: 1.75,
            armorPiercing: 0.3,
            telegraph: 'draws in power for a devastating attack!'
        };
    }

    return intent;
}


function consumePips(cs, amount, cooldown) {
    let used = 0;

    for (let i = 0; i < cs.pipAvailable.length && used < amount; i++) {
        if (cs.pipAvailable[i]) {
            cs.pipAvailable[i] = false;
            cs.pipTimers[i] = cooldown;
            used++;
        }
    }
}




        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DAMAGE SCALING (Rebalanced for harder early game)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const DAMAGE_SCALING = {
            // Monster damage multiplier â€” 1.0 = no bonus on top of level/rarity scaling.
            // The level-scaling and rarity system already handle enemy power progression.
            // A 1.3x bonus was pushing same-level hits to ~20 on a Rogue with 85 HP.
            monsterDamageMult: 1.0
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ENEMY DODGE CALCULATION - Based on level difference
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function calculateEnemyDodge(playerLevel, enemyLevel) {
            const levelDiff = enemyLevel - playerLevel;
            
            // Base dodge: 5% when levels are equal
            let dodgeChance = 0.05;
            
            if (levelDiff > 0) {
                // Enemy is higher level: +5% dodge per level difference
                dodgeChance += (levelDiff * 0.05);
            } else if (levelDiff < 0) {
                // Player is higher level: -1% dodge per level difference
                dodgeChance += (levelDiff * 0.01); // levelDiff is negative, so this subtracts
            }
            
            // Cap at 0% minimum (can't go negative)
            dodgeChance = Math.max(0, dodgeChance);
            
            // Cap at 50% maximum (so it's not impossible to hit)
            dodgeChance = Math.min(0.50, dodgeChance);
            
            return dodgeChance;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // LEVEL-SCALING DAMAGE MODIFIER
        // Per level enemy is ABOVE player: player deals -5%, takes +5%
        // Per level enemy is BELOW player: player deals +5%, takes -5%
        // Capped at Â±50%.
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function getLevelDamageMult(playerLevel, enemyLevel) {
            const diff = (enemyLevel || 1) - (playerLevel || 1);
            const PCT  = 0.05;
            const CAP  = 0.50;
            const shift = Math.max(-CAP, Math.min(CAP, diff * PCT));
            return {
                playerDealt: Math.max(0.1, 1 - shift),  // enemy higher â†’ player deals less
                enemyDealt:  Math.max(0.5, 1 + shift)   // enemy higher â†’ player takes more
            };
        }
        
        function calculateDamage({
  attacker,
  defender,
  base,
  type = 'physical', // 'physical' | 'magic'
  critChance = 0,
  critMult = 1.5,
  dodgeChance = 0,
  armorPiercing = 0,
  isSpecial = false
}) {
  // Dodge check
  if (Math.random() < dodgeChance) {
    return { damage: 0, dodged: true, crit: false };
  }

  // Base damage roll
  let damage = base;

  // Defense mitigation â€” percentage-based damage reduction (DR)
  // Each point of defense = 2.8% DR, hard-capped at 75%.
  // This replaces flat subtraction which let even tiny armor eat huge chunks of
  // low-roll damage while leaving high-roll damage almost untouched.
  // DR is consistent regardless of the hit size â€” cloth feels like cloth,
  // plate feels like plate, at every level of the game.
  let rawDefense =
    type === 'magic'
      ? (defender.magicDefense || 0)
      : (defender.defense || 0);

  const DR_PER_POINT = 0.028;
  const DR_CAP       = 0.75;
  const effectiveDR  = Math.min(DR_CAP, rawDefense * DR_PER_POINT) * (1 - armorPiercing);

  damage = Math.max(1, Math.floor(damage * (1 - effectiveDR)));

  // Crit check
  let crit = false;
  if (Math.random() < critChance) {
    damage = Math.floor(damage * critMult);
    crit = true;
  }

  return { damage, dodged: false, crit };
}

        
     function executeAttack(attackType) {
    const cs = gameState.combatState;
    if (!cs) return;

    const p  = gameState.player;
    const ti = cs.currentTarget;
    const enemy = cs.monsters[ti];
    let weapon = WEAPONS[p.weapon];
    
    // No weapon equipped â†’ fight with bare fists
    if (!weapon) {
        if (p.weapon && p.weapon !== 'bare_fists') {
            // Weapon key set but missing from DB â€” silently switch to fists
            console.warn(`âš ï¸ Weapon '${p.weapon}' not found â€” fighting unarmed.`);
        }
        p.weapon = 'bare_fists';
        weapon   = WEAPONS['bare_fists'];
    }
    
    const unarmed = !!weapon.unarmed;
    
    const qBonus = getQualityBonus(weapon.quality, weapon.baseDamage);

    // Determine pip cost and damage multiplier
    let pipCost = 1;
    let damageMultiplier = 1;
    let attackName = unarmed ? 'punches' : 'attack';
    let armorPiercing = 0;

    if (attackType === 'normal') {
        pipCost = 1;
    } 
    else if (attackType === 'heavy') {
        // HIGH RISK / HIGH REWARD: costs 2 pips, 35% miss chance, but hits for 3x damage
        pipCost = 2;
        damageMultiplier = 3.0;
        attackName = unarmed
            ? 'winds up a <span style="color:#FF8800;">HAYMAKER</span>'
            : 'winds up a <span style="color:#FF8800;">HEAVY STRIKE</span>';
        armorPiercing = 0.35;
    } 
    else if (attackType === 'special') {
        const availablePips = cs.pipAvailable.filter(x => x).length;
        pipCost = availablePips;
        damageMultiplier = 1 + (availablePips * 0.5);
        attackName = unarmed
            ? `unleashes a <span style="color:#FFD700;">â­ FLURRY OF BLOWS â­</span> (${availablePips} pips)`
            : `unleashes a <span style="color:#FFD700;">â­ SPECIAL ATTACK â­</span> (${availablePips} pips)`;
        armorPiercing = 0.3;
    }

    // Check pip availability
    const availablePips = cs.pipAvailable.filter(x => x).length;
    if (availablePips < pipCost) {
        termAppend('Not enough attack charges!', 'term-error');
        return;
    }

    // Consume pips
    consumePips(cs, pipCost, getPipCooldown(p));
    markMpAction();  // reset 15s MP regen countdown on every attack
    
    // Always reset action mode to main - whether the attack hits or dodges,
    // the player should see the main combat menu (with updated pips)
    cs.actionMode = 'main';
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ROGUE: SHADOW STRIKE - Guaranteed crit from stealth
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let shadowStrike = false;
    const baseClass = p.baseClass || p.class;
    if (baseClass === 'rogue' && p.shadowStrikeReady) {
        shadowStrike = true;
        p.shadowStrikeReady = false;
        
        // Clear the timer
        if (p.shadowStrikeTimer) {
            clearTimeout(p.shadowStrikeTimer);
            p.shadowStrikeTimer = null;
        }
        
        termAppend('', 'term-separator');
        termAppend('âš« <span style="color:#8888FF;font-weight:bold;">You leap from the shadows!</span> âš«', 'term-highlight');
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // RUNESMITH: RUNE OVERLOAD â€” 3 pips â†’ devastating armor-piercing strike
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let runeOverloadActive = false;
    if (baseClass === 'runesmith' && (p.runeOverloadPips || 0) >= 3) {
        runeOverloadActive = true;
        p.runeOverloadPips = 0;
        termAppend('', 'term-separator');
        termAppend('ğŸ”¥âš’ï¸ <span style="color:#FF8800;font-weight:bold;">RUNE OVERLOAD!</span> <span style="color:#FFaa00;">The runes detonate â€” armor is nothing!</span> ğŸ”¥âš’ï¸', 'term-highlight');
    }

    // Calculate base damage WITH RANGE ROLLING
    // Roll between baseDamage and maxDamage
    const minDmg = weapon.baseDamage + qBonus;
    const maxDmg = (weapon.maxDamage || weapon.baseDamage) + qBonus;
    let weaponDamage = Math.floor(Math.random() * (maxDmg - minDmg + 1)) + minDmg;

    // â”€â”€ Apply socketed gem bonuses â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const socketed = weapon.gems || [];
    let gemMeleeDmg = 0, gemMagicDmg = 0, gemCritBonus = 0, gemPierceBonus = 0;
    let gemPoisonChance = 0, gemLightningDmg = 0, gemLifesteal = 0;
    let gemFireDmg = 0, gemFrostDmg = 0, gemSpellLeech = 0;
    for (const gem of socketed) {
        if (!gem || !gem.stats) continue;
        gemMeleeDmg     += gem.stats.weaponDmg    || 0;
        gemMagicDmg     += gem.stats.spellPower   || 0;
        gemCritBonus    += gem.stats.critBonus    || 0;
        gemPierceBonus  += gem.stats.armorPierce  || 0;
        gemPoisonChance += gem.stats.poisonChance || 0;
        gemLightningDmg += gem.stats.lightningDmg || 0;
        gemLifesteal    += gem.stats.lifesteal     || 0;
        gemFireDmg      += gem.stats.fireDmg      || 0;   // sunstone â€” universal
        gemFrostDmg     += gem.stats.frostDmg     || 0;   // stormglass â€” universal
        gemSpellLeech   += gem.stats.spellLeech   || 0;   // voidstone â€” applies to spells too
    }

    const physicalBase =
        weaponDamage + Math.floor((p.str || 0) * 1.5) + gemMeleeDmg;

    const magicBase =
        (weapon.baseMagicDamage || 0) +
        Math.floor((p.wis || 0) * 1.5) + gemMagicDmg;  // WIS (point-buy) drives magic-weapon bonus

    // Use whichever damage type is higher for this weapon â€” don't add both
    let totalBase = Math.floor(
        Math.max(physicalBase, magicBase) * damageMultiplier
    );

    const classMult = getClassDamageMultiplier(p);
    totalBase = Math.floor(totalBase * classMult);

    // Calculate enemy dodge chance based on level difference
    const enemyDodgeChance = calculateEnemyDodge(p.level, enemy.level);

    // â”€â”€ HEAVY ATTACK: extra 15% miss chance on top of dodge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (attackType === 'heavy' && Math.random() < 0.15) {
        const missVerb = unarmed ? 'swing wildly' : 'overswing';
        termAppend(
            `You ${attackName} but ${missVerb} and <span style="color:#ff8c00;">MISS!</span>`,
            'term-warning'
        );
        updateEnemyCards();
        updateHud();
        renderActionBar();
        return;
    }

    // â”€â”€ LEVEL SCALING: player damage modifier â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const lvlMult = getLevelDamageMult(p.level, enemy.level);
    totalBase = Math.max(1, Math.floor(totalBase * lvlMult.playerDealt));

    // â”€â”€ RUNESMITH OVERLOAD: +50% damage + STR + WIS bonus, full armor pierce, undodgeable â”€â”€
    if (runeOverloadActive) {
        const overloadBonus = Math.floor(totalBase * 0.50)
            + Math.floor((p.str || 0) * 2)
            + Math.floor((p.wis || 0) * 2);
        totalBase += overloadBonus;
        armorPiercing = 1.0;
    }

    // Apply gem universal bonuses (lightning, fire, frost) to totalBase (both melee and magic)
    totalBase += gemLightningDmg + gemFireDmg + gemFrostDmg;

    // Apply gem armor pierce (stacks additively)
    const effectiveArmorPierce = Math.min(1.0, armorPiercing + (gemPierceBonus / 100));

    // Resolve damage
    const result = calculateDamage({
        attacker: p,
        defender: enemy,
        base: totalBase,
        type: magicBase > physicalBase ? 'magic' : 'physical',
        critChance: shadowStrike ? 1.0 : Math.min(0.75, (calcCritChance(p.lck || 0, p) / 100) + (gemCritBonus / 100)),
        dodgeChance: runeOverloadActive ? 0 : enemyDodgeChance,  // Overload cannot be dodged
        armorPiercing: effectiveArmorPierce
    });

    const tName = cs.monsters.length > 1
        ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${ti + 1}</span>`
        : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;

    if (result.dodged) {
        termAppend(
            `You ${attackName} but ${tName} <span style="color:#88ff88;">DODGES!</span>`,
            null,
            () => {
                updateEnemyCards();
                updateHud();
                renderActionBar();
            }
        );
    } 
    else {
        const critTag = result.crit
            ? ' <span style="color:#FFD700;">â˜… CRITICAL HIT!</span>'
            : '';

        // Apply weapon modifiers (elemental damage, status effects, lifesteal)
        const modifierResult = applyWeaponModifiers(p, enemy, result.damage, weapon);
        const finalDamage = modifierResult.totalDamage;
        
        enemy.hp -= finalDamage;
        
        // â”€â”€ HUNTER PET ATTACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Hunter's pet attacks immediately after hunter deals damage
        if (baseClass === 'hunter' && p.activePet && enemy.hp > 0) {
            const petDamage = calculatePetDamage(p, finalDamage);
            if (petDamage > 0) {
                enemy.hp -= petDamage;
                const pet = HUNTER_PETS[p.activePet];
                modifierResult.messages.push(
                    `${pet.icon} <span style="color:#88FF88;">${pet.name} attacks for <span class="dmg-enemy">${petDamage} damage</span>!</span>`
                );
            }
        }
        
        // Check for poison chance on daggers (Venom Spike, Serpent's Tooth, etc.)
        if (weapon.poisonChance && Math.random() < weapon.poisonChance && enemy.hp > 0) {
            applyStatusEffect(enemy, 'poisoned', false);
            modifierResult.messages.push('<span style="color:#00FF00;">ğŸ’€ Poisoned!</span>');
        }

        // â”€â”€ GEM PROCS: poison (universal) and lifesteal (melee only) â”€â”€
        if (gemPoisonChance > 0 && Math.random() < (gemPoisonChance / 100) && enemy.hp > 0) {
            applyStatusEffect(enemy, 'poisoned', false);
            modifierResult.messages.push('<span style="color:#00EE00;">ğŸ’ Emerald: Poisoned!</span>');
        }
        if (gemLifesteal > 0 && finalDamage > 0) {
            const steal = Math.max(1, Math.floor(finalDamage * (gemLifesteal / 100)));
            p.hp = Math.min(p.maxHp, p.hp + steal);
            modifierResult.messages.push(`<span style="color:#FF4488;">ğŸ’ Ruby: Lifesteal +${steal} HP</span>`);
        }
        // Voidstone spell leech â€” converts portion of melee hit to MP (unique: restores mana, not HP)
        if (gemSpellLeech > 0 && finalDamage > 0) {
            const mpSteal = Math.max(1, Math.floor(finalDamage * (gemSpellLeech / 100)));
            p.mp = Math.min(p.maxMp, p.mp + mpSteal);
            modifierResult.messages.push(`<span style="color:#AA55FF;">ğŸ’ Voidstone: Drained +${mpSteal} MP</span>`);
        }

        // â”€â”€ ROGUE DOUBLE-STRIKE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Every dagger pip fires twice. Roll a second independent hit.
        // Triggers if: classRestriction='rogue' OR weapon name/key contains dagger/shiv
        const isDaggerWeapon = weapon.classRestriction === 'rogue'
            || (weapon.name && (weapon.name.toLowerCase().includes('dagger') || weapon.name.toLowerCase().includes('shiv')))
            || (p.weapon && (p.weapon.toLowerCase().includes('dagger') || p.weapon.toLowerCase().includes('shiv')));
        if (baseClass === 'rogue' && isDaggerWeapon && enemy.hp > 0) {
            const minDmg2 = weapon.baseDamage + qBonus;
            const maxDmg2 = (weapon.maxDamage || weapon.baseDamage) + qBonus;
            let weaponDamage2 = Math.floor(Math.random() * (maxDmg2 - minDmg2 + 1)) + minDmg2;
            const physBase2 = weaponDamage2 + Math.floor((p.str || 0) * 1.5);
            let totalBase2  = Math.floor(Math.max(physBase2, magicBase) * damageMultiplier);
            totalBase2 = Math.floor(totalBase2 * classMult);
            totalBase2 = Math.max(1, Math.floor(totalBase2 * lvlMult.playerDealt));

            const result2 = calculateDamage({
                attacker: p, defender: enemy,
                base: totalBase2,
                type: 'physical',
                critChance: calcCritChance(p.lck || 0, p) / 100,
                dodgeChance: enemyDodgeChance,
                armorPiercing
            });

            if (!result2.dodged) {
                const mod2 = applyWeaponModifiers(p, enemy, result2.damage, weapon);
                enemy.hp -= mod2.totalDamage;
                const crit2Tag = result2.crit
                    ? ' <span style="color:#FFD700;">â˜… CRIT!</span>'
                    : '';
                modifierResult.messages.push(
                    `â†ª Second strike: <span class="dmg-enemy">${mod2.totalDamage} damage</span>${crit2Tag}`
                );
                // Poison on second hit too
                if (weapon.poisonChance && Math.random() < weapon.poisonChance && enemy.hp > 0) {
                    applyStatusEffect(enemy, 'poisoned', false);
                    modifierResult.messages.push('<span style="color:#00FF00;">ğŸ’€ Poisoned!</span>');
                }
            } else {
                modifierResult.messages.push('â†ª Second strike: <span style="color:#88ff88;">DODGED!</span>');
            }
        }
        // â”€â”€ END ROGUE DOUBLE-STRIKE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        // Calculate condition text
        const hpPct = Math.max(0, (enemy.hp / enemy.maxHp) * 100);
        let condition = 'healthy';
        if (hpPct < 75) condition = 'injured';
        if (hpPct < 50) condition = 'wounded';
        if (hpPct < 25) condition = 'severely wounded';
        if (hpPct < 10) condition = 'barely standing';

        termAppend(
            `You ${attackName} ${tName} for <span class="dmg-enemy">${finalDamage} damage!</span>${critTag}`,
            null,
            () => {
                // Show modifier messages
                modifierResult.messages.forEach(msg => {
                    termAppend(`â†’ ${msg}`, 'term-loot');
                });

                if (enemy.hp > 0) {
                    termAppend(
                        `â†’ ${tName} is <span style="color:#8aaa8a;">${condition}</span>`,
                        'term-dim'
                    );
                }

                updateEnemyCards();
                updateHud();
                renderActionBar();
                checkCombatEnd();
            }
        );
    }

    // Immediate UI update (pip display â€” callbacks handle full re-render)
    updateEnemyCards();
    updateHud();
    // Note: renderActionBar() is called by termAppend callbacks above
    // to ensure it fires AFTER streaming completes, not before.
}



       // Legacy function kept for compatibility
       function playerAttack() {
    executeAttack('normal');
}

        


            function showSpellMenu() {
            const cs = gameState.combatState;
            if (!cs) return;
            const anyAvail = cs.pipAvailable && cs.pipAvailable.some(x => x);
            if (!anyAvail) return;
            const p = gameState.player;
            if (p.knownSpells.length === 0) {
                termAppend('You have no spells!', 'term-error');
                renderActionBar();
                return;
            }
            
            cs.actionMode = 'spell_list';
            renderActionBar();
        }




            function castSpellOnTarget(spell) {
            const p  = gameState.player;
            const cs = gameState.combatState;
            const spellKey = cs.pendingSpellKey;
            
            if (p.mp < spell.mpCost) {
                termAppend('Not enough MP!', 'term-error');
                return;
            }
            

// --- Pip check for spells ---
const availablePips = cs.pipAvailable.filter(x => x).length;

if (availablePips < (spell.pipCost || 1)) {
    termAppend('Not enough spell charges!', 'term-error');
    return;
}

// Consume spell pips
consumePips(cs, spell.pipCost || 1, getPipCooldown(p));



            p.mp -= spell.mpCost;
            markMpAction();  // reset 15s MP regen countdown on every spell cast

            // â”€â”€ RUNESMITH: charge Rune Overload pip on every spell cast â”€â”€
            if ((p.baseClass || p.class) === 'runesmith' && (p.runeOverloadPips || 0) < 3) {
                p.runeOverloadPips = (p.runeOverloadPips || 0) + 1;
                const rp = p.runeOverloadPips;
                const rp1 = rp >= 1 ? 'ğŸ”¶' : 'â¬›'; const rp2 = rp >= 2 ? 'ğŸ”¶' : 'â¬›'; const rp3 = rp >= 3 ? 'ğŸ”¶' : 'â¬›';
                if (rp >= 3) {
                    termAppend('âš’ï¸ <span style="color:#FF8800;font-weight:bold;">RUNE OVERLOAD CHARGED!</span> <span style="color:#FFaa00;">Strike now for devastating, armor-piercing power!</span> ğŸ”¥');
                } else {
                    termAppend(`âš’ï¸ <span style="color:#c8a000;">Rune charged: ${rp1}${rp2}${rp3}</span>`);
                }
            }

            if (spell.type === 'heal') {
                // Healing spells: 5% chance to fail, random between minPower and maxPower
                const spellFailed = Math.random() < 0.05;
                if (spellFailed) {
                    termAppend(`You cast ${spell.name} but it <span style="color:#ff6666;">fizzles!</span> The gods did not answer.`);
                } else {
                    // Calculate random heal between minPower and maxPower
                    const minHeal = spell.minPower || 10;
                    const maxHeal = spell.maxPower || minHeal;
                    const baseHeal = Math.floor(Math.random() * (maxHeal - minHeal + 1)) + minHeal;
                    const heal = baseHeal + Math.floor(p.magic * 1.5) + (p.wis || 0);
                    const actualHeal = Math.min(p.maxHp - p.hp, heal);
                    p.hp = Math.min(p.maxHp, p.hp + actualHeal);
                    updateHud();
                    renderActionBar();
                    termAppend(`You cast ${spell.name} and restore <span style="color:#88ff88;">${actualHeal} HP!</span>`);
                }
            } else if (spell.type === 'aoe_damage') {
                // AOE DAMAGE - Hit all enemies for reduced damage each
                const monsters = cs.monsters;
                let totalDamage = 0;
                let hitCount = 0;
                
                termAppend(`You cast ${spell.name}!`, 'term-highlight');
                termAppend(`<span style="color:#FF8800;">ğŸ”¥ AREA OF EFFECT! ğŸ”¥</span>`, 'term-victory');
                
                // Check if fire spell for burning
                const spellName = spell.name.toLowerCase();
                const isFire = spellName.includes('fire') || spellName.includes('flame') || 
                               spellName.includes('burn') || spellName.includes('pyro') || 
                               spellName.includes('inferno') || spellName.includes('ember');
                
                monsters.forEach((enemy, i) => {
                    if (enemy.hp > 0) {
                        // Calculate enemy dodge chance
                        const enemyDodgeChance = calculateEnemyDodge(p.level, enemy.level);
                        
                        const tName = monsters.length > 1
                            ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${i+1}</span>`
                            : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;
                        
                        // Check if enemy dodges
                        if (Math.random() < enemyDodgeChance) {
                            termAppend(`â†’ ${tName} <span style="color:#88ff88;">DODGES!</span>`);
                            return; // Skip this enemy
                        }
                        
                        // SPELL DAMAGE WITH WIDE RANGE ROLLING (each enemy rolls independently!)
                        const minPower = spell.minPower || spell.power;
                        const maxPower = spell.maxPower || spell.power;
                        const spellRoll = Math.floor(Math.random() * (maxPower - minPower + 1)) + minPower;
                        
                        // Add weapon modifier bonus to offensive spells
                        const modifierBonus = getWeaponModifierSpellBonus();
                        
                        let dmg = Math.max(1, (spellRoll + p.magic + (p.wis || 0) + modifierBonus) - Math.floor(enemy.defense / 2));
                        let crit = false;
                        if (Math.random() * 100 < calcCritChance(p.lck || 0, p)) { 
                            dmg = Math.floor(dmg * 1.75); 
                            crit = true; 
                        }
                        
                        // Apply weapon modifiers to spell (status effects + elemental damage)
                        const weapon = WEAPONS[p.weapon];
                        const modifierResult = weapon ? applyWeaponModifiers(p, enemy, dmg, weapon) : { totalDamage: dmg, messages: [] };
                        const finalDamage = modifierResult.totalDamage;
                        
                        enemy.hp -= finalDamage;
                        totalDamage += finalDamage;
                        hitCount++;
                        
                        const critTag = crit ? ' <span style="color:#FFD700;">â˜… CRIT!</span>' : '';
                        let msg = `â†’ ${tName} takes <span class="dmg-enemy">${finalDamage} damage!</span>${critTag}`;
                        if (modifierResult.messages.length > 0) {
                            msg += ' ' + modifierResult.messages.join(' ');
                        }
                        termAppend(msg);
                        
                        // Apply burning to each enemy hit (AOE fire spells)
                        if (isFire && Math.random() < 0.5 && enemy.hp > 0) { // 50% chance per target
                            applyStatusEffect(enemy, 'burning', false);
                        }
                    }
                });
                
                termAppend(`<span style="color:#FFD700;">Total: ${totalDamage} damage to ${hitCount} ${hitCount === 1 ? 'enemy' : 'enemies'}!</span>`, 'term-loot');
                checkCombatEnd();
                updateEnemyCards();
                updateHud();
                renderActionBar();
            } else if (spell.type === 'lifesteal') {
                // LIFESTEAL - damage enemy and heal yourself
                const ti = cs.currentTarget;
                const enemy = cs.monsters[ti];
                
                // Calculate enemy dodge chance
                const enemyDodgeChance = calculateEnemyDodge(p.level, enemy.level);
                
                const tName = cs.monsters.length > 1
                    ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${ti+1}</span>`
                    : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;
                
                // Check if enemy dodges
                if (Math.random() < enemyDodgeChance) {
                    termAppend(`You cast ${spell.name} but ${tName} <span style="color:#88ff88;">DODGES!</span>`);
                    updateEnemyCards();
                    updateHud();
                    cs.actionMode = 'main';
                    cs.pendingSpellKey = null;
                    renderActionBar();
                    return;
                }
                
                // SPELL DAMAGE WITH WIDE RANGE ROLLING
                const minPower = spell.minPower || spell.power;
                const maxPower = spell.maxPower || spell.power;
                const spellRoll = Math.floor(Math.random() * (maxPower - minPower + 1)) + minPower;
                
                // Add weapon modifier bonus to offensive spells
                const modifierBonus = getWeaponModifierSpellBonus();

                // â”€â”€ Gem bonuses for spells â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                const spellWeapon = WEAPONS[p.weapon];
                let gemSpellBonus = 0, gemSpellCrit = 0, gemSpellPoison = 0;
                let gemSpellUniversal = 0; // lightning + fire + frost all apply to spells
                let gemSpellLeechPct = 0;  // voidstone: spell leech â†’ MP
                if (spellWeapon && spellWeapon.gems) {
                    for (const sg of spellWeapon.gems) {
                        if (!sg || !sg.stats) continue;
                        gemSpellBonus    += sg.stats.spellPower    || 0;  // magic-only
                        gemSpellCrit     += sg.stats.critBonus     || 0;  // universal
                        gemSpellPoison   += sg.stats.poisonChance  || 0;  // universal
                        gemSpellUniversal += (sg.stats.lightningDmg || 0)
                                          + (sg.stats.fireDmg       || 0)
                                          + (sg.stats.frostDmg      || 0); // universal elements
                        gemSpellLeechPct += sg.stats.spellLeech    || 0;  // voidstone: MP leech
                    }
                }
                
                let dmg = Math.max(1, (spellRoll + p.magic + (p.wis || 0) + modifierBonus + gemSpellBonus + gemSpellUniversal) - Math.floor(enemy.defense / 2));
                let crit = false;
                const spellCritChance = Math.min(75, calcCritChance(p.lck || 0, p) + gemSpellCrit);
                if (Math.random() * 100 < spellCritChance) { dmg = Math.floor(dmg * 1.75); crit = true; }
                
                // Apply weapon modifiers to spell (status effects + elemental damage)
                const weapon = WEAPONS[p.weapon];
                const modifierResult = weapon ? applyWeaponModifiers(p, enemy, dmg, weapon) : { totalDamage: dmg, messages: [] };
                const finalDamage = modifierResult.totalDamage;

                // Gem poison proc on spell (universal gem)
                if (gemSpellPoison > 0 && Math.random() < (gemSpellPoison / 100) && enemy.hp > 0) {
                    applyStatusEffect(enemy, 'poisoned', false);
                    modifierResult.messages.push('<span style="color:#00EE00;">ğŸ’ Emerald: Poisoned!</span>');
                }
                
                // Gem lifesteal on spells (ruby â€” works on both melee and spells per design)
                let gemSpellLifesteal = 0;
                if (spellWeapon && spellWeapon.gems) {
                    for (const sg of spellWeapon.gems) {
                        if (sg && sg.stats) gemSpellLifesteal += sg.stats.lifesteal || 0;
                    }
                }
                if (gemSpellLifesteal > 0) {
                    const lsHeal = Math.max(1, Math.floor(finalDamage * (gemSpellLifesteal / 100)));
                    p.hp = Math.min(p.maxHp, p.hp + lsHeal);
                    modifierResult.messages.push(`<span style="color:#FF4488;">ğŸ’ Ruby: Lifesteal +${lsHeal} HP</span>`);
                }
                // Voidstone spell leech â†’ drains MP from enemy (magic absorb, not HP)
                if (gemSpellLeechPct > 0) {
                    const mpDrain = Math.max(1, Math.floor(finalDamage * (gemSpellLeechPct / 100)));
                    p.mp = Math.min(p.maxMp, p.mp + mpDrain);
                    modifierResult.messages.push(`<span style="color:#AA55FF;">ğŸ’ Voidstone: Absorbed +${mpDrain} MP</span>`);
                }

                enemy.hp -= finalDamage;
                
                // Heal based on lifesteal percentage (from the final damage including modifiers)
                const lifestealPercent = spell.lifestealPercent || 25;
                const healAmount = Math.floor(finalDamage * (lifestealPercent / 100));
                p.hp = Math.min(p.maxHp, p.hp + healAmount);
                
                const critTag = crit ? ' <span style="color:#FFD700;">â˜… CRIT!</span>' : '';
                let spellMsg = `You cast ${spell.name} on ${tName} for <span class="dmg-enemy">${finalDamage} damage!</span>${critTag}`;
                if (modifierResult.messages.length > 0) {
                    spellMsg += '<br>' + modifierResult.messages.join('<br>');
                }
                
                termAppend(spellMsg, null, () => {
                    termAppend(`<span style="color:#00FF00;">ğŸ©¸ Drained ${healAmount} HP!</span>`, 'term-loot');
                    if (enemy.hp > 0) {
                        const hpPct = Math.max(0, (enemy.hp / enemy.maxHp) * 100);
                        let condition = 'healthy';
                        if (hpPct < 75) condition = 'injured';
                        if (hpPct < 50) condition = 'wounded';
                        if (hpPct < 25) condition = 'severely wounded';
                        if (hpPct < 10) condition = 'barely standing';
                        termAppend(`â†’ ${tName} is <span style="color:#8aaa8a;">${condition}</span>`, 'term-dim');
                    }
                    checkCombatEnd();
                });
            } else {
                // REGULAR DAMAGE SPELL
                const ti    = cs.currentTarget;
                const enemy = cs.monsters[ti];
                
                // Calculate enemy dodge chance based on level difference
                const enemyDodgeChance = calculateEnemyDodge(p.level, enemy.level);
                
                // Check if enemy dodges the spell
                if (Math.random() < enemyDodgeChance) {
                    const tName = cs.monsters.length > 1
                        ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${ti+1}</span>`
                        : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;
                    termAppend(`You cast ${spell.name} but ${tName} <span style="color:#88ff88;">DODGES!</span>`);
                    updateEnemyCards();
                    updateHud();
                    cs.actionMode = 'main';
                    cs.pendingSpellKey = null;
                    renderActionBar();
                    return;
                }
                
                // SPELL DAMAGE WITH WIDE RANGE ROLLING
                const minPower = spell.minPower || spell.power;
                const maxPower = spell.maxPower || spell.power;
                const spellRoll = Math.floor(Math.random() * (maxPower - minPower + 1)) + minPower;
                
                // Add weapon modifier bonus to offensive spells
                const modifierBonus = getWeaponModifierSpellBonus();
                
                let   dmg   = Math.max(1, (spellRoll + p.magic + (p.wis||0) + modifierBonus) - Math.floor(enemy.defense / 2));
                let crit = false;
                if (Math.random()*100 < calcCritChance(p.lck||0, p)) { dmg = Math.floor(dmg*1.75); crit = true; }
                
                // Apply weapon modifiers to spell (status effects + elemental damage)
                const weapon = WEAPONS[p.weapon];
                const modifierResult = weapon ? applyWeaponModifiers(p, enemy, dmg, weapon) : { totalDamage: dmg, messages: [] };
                const finalDamage = modifierResult.totalDamage;
                
                enemy.hp -= finalDamage;
                
                // Check for spell status effects (burning from fire spells, etc.)
                const spellName = spell.name.toLowerCase();
                if ((spellName.includes('fire') || spellName.includes('flame') || spellName.includes('burn') || 
                     spellName.includes('pyro') || spellName.includes('inferno') || spellName.includes('ember')) && 
                    Math.random() < 0.5) { // 50% chance
                    enemy.statusToApply = 'burning';
                } else if ((spellName.includes('ice') || spellName.includes('frost') || spellName.includes('frozen')) && 
                           Math.random() < 0.4) { // 40% chance
                    enemy.statusToApply = 'frozen';
                } else if (spellName.includes('lightning') && Math.random() < 0.2) { // 20% chance
                    enemy.statusToApply = 'stunned';
                } else if (spellName.includes('shadow') && Math.random() < 0.3) { // 30% chance
                    enemy.statusToApply = 'blinded';
                }
                
                const tName = cs.monsters.length > 1
                    ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${ti+1}</span>`
                    : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;
              
                const critTag = crit ? ' <span style="color:#FFD700;">â˜… CRIT!</span>' : '';
                const hpPct = Math.max(0, (enemy.hp / enemy.maxHp) * 100);
                let condition = 'healthy';
                if (hpPct < 75) condition = 'injured';
                if (hpPct < 50) condition = 'wounded';
                if (hpPct < 25) condition = 'severely wounded';
                if (hpPct < 10) condition = 'barely standing';
                
                // Build message with weapon modifier bonuses
                let spellMsg = `You cast ${spell.name} on ${tName} for <span class="dmg-enemy">${finalDamage} damage!</span>${critTag}`;
                if (modifierResult.messages.length > 0) {
                    spellMsg += '<br>' + modifierResult.messages.join('<br>');
                }
                
                termAppend(spellMsg, null, () => {
                    // Apply status effect if flagged
                    if (enemy.statusToApply && enemy.hp > 0) {
                        applyStatusEffect(enemy, enemy.statusToApply, false);
                        enemy.statusToApply = null;
                    }
                    
                    if (enemy.hp > 0) {
                        termAppend(`â†’ ${tName} is <span style="color:#8aaa8a;">${condition}</span>`, 'term-dim');
                    }
                    checkCombatEnd();
                });
            }
              updateEnemyCards();
                updateHud();
            
            // Reset to main combat menu after spell cast
            cs.actionMode = 'main';
            cs.pendingSpellKey = null;
            renderActionBar();
        }

        // Legacy function for backward compatibility
        function castSpell(spellKey) {
            const spell = SPELLS[spellKey];
            castSpellOnTarget(spell);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // HUNTER TRAP ABILITY
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function castTrap() {
            const cs = gameState.combatState;
            const p = gameState.player;
            
            if (!cs || cs.combatOver) return;
            
            // Check if hunter
            if ((p.baseClass || p.class) !== 'hunter') {
                termAppend('Only hunters can set traps!', 'term-error');
                return;
            }
            
            // Check MP
            if (p.mp < 10) {
                termAppend('Not enough MP to set a trap! (Need 10 MP)', 'term-error');
                return;
            }
            
            // Check if trap already active
            if (cs.trapActive) {
                termAppend('A trap is already set!', 'term-warning');
                return;
            }
            
            // Consume MP
            p.mp -= 10;
            markMpAction();
            
            // Setting the trap...
            termAppend('', 'term-separator');
            termAppend('ğŸª¤ <span style="color:#8B4513;">You carefully set a concealed trap...</span>', null, () => {
                // 2 second pause for dramatic effect
                setTimeout(() => {
                    // 15% fail rate
                    const failed = Math.random() < 0.15;
                    
                    if (failed) {
                        termAppend('<span style="color:#ff4444;">ğŸ’¨ The trap mechanism fails! The enemies avoid it!</span>', 'term-error');
                    } else {
                        // Success! Apply 50% slow to enemy timer
                        const slowMultiplier = 0.5; // 50% slow = add 50% to timer
                        const originalDelay = cs.enemyDelay;
                        const slowAmount = Math.floor(originalDelay * slowMultiplier);
                        
                        // Mark trap as active for this combat
                        cs.trapActive = true;
                        cs.trapSlowAmount = slowAmount;
                        
                        // Apply slow to current enemy timer
                        cs.enemyTimer += slowAmount;
                        
                        termAppend(`<span style="color:#00FF88;">âš™ï¸ SNAP! The enemies are caught in the trap!</span>`, 'term-loot');
                        termAppend(`<span style="color:#FFD700;">ğŸŒ Enemy attack speed slowed by 50%! (+${slowAmount}s to attack timer)</span>`, 'term-highlight');
                    }
                    
                    updateHud();
                    renderActionBar();
                }, 2000);
            });
        }

        function playerDefend() {
            const cs = gameState.combatState;
            const p  = gameState.player;
            if (!cs || cs.hitsLeft <= 0) return;
            if ((p.baseClass || p.class) !== 'warrior') return; // Warriors only
            cs.shieldActive = true;
            cs.hitsLeft     = 0;   // end player's turn
            renderActionBar();
            termAppend('ğŸ›¡ï¸ You raise your shield â€” bracing for the blowâ€¦');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SHOW PLAYER STATS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function showPlayerStats() {
            const p = gameState.player;
            if (!p) return;
            
            termAppend('', 'term-separator');
            termAppend('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'term-highlight');
            termAppend(`ğŸ“Š CHARACTER STATS - ${p.name.toUpperCase()}`, 'term-highlight');
            termAppend('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'term-highlight');
            termAppend('');
            
            // Basic Info
            const className = p.hasEvolved ? getAdvancedClassName(p) : (p.className || p.class);
            termAppend(`<span style="color:var(--highlight-color);">Name:</span> ${p.name}`);
            termAppend(`<span style="color:var(--highlight-color);">Class:</span> ${className} ${p.hasEvolved ? '<span style="color:#FFD700;">âš¡ (Evolved)</span>' : ''}`);
            termAppend(`<span style="color:var(--highlight-color);">Level:</span> ${p.level}`);
            termAppend('');
            
            // Resources
            termAppend(`<span style="color:#ff6666;">â¤ï¸  HP:</span> ${p.hp} / ${p.maxHp}`);
            termAppend(`<span style="color:#4488ff;">âœ¨ MP:</span> ${p.mp} / ${p.maxMp}`);
            termAppend(`<span style="color:#FFD700;">ğŸ’° Gold:</span> ${p.gold}g`);
            termAppend(`<span style="color:var(--text-color);">â­ XP:</span> ${p.xp} / ${p.xpToNext} (${Math.floor((p.xp / p.xpToNext) * 100)}%)`);
            termAppend('');
            
            // Combat Stats
            termAppend('<span style="color:var(--highlight-color);">â•â•â• COMBAT STATS â•â•â•</span>');
            
            // Primary Stats (D&D style if they exist)
            if (p.str !== undefined) {
                termAppend(`<span style="color:#FF8800;">STR:</span> ${p.str} (Strength)`);
                termAppend(`<span style="color:#00FF88;">DEX:</span> ${p.dex} (Dexterity)`);
                termAppend(`<span style="color:#8888FF;">WIS:</span> ${p.wis} (Wisdom)`);
                termAppend(`<span style="color:#FF88FF;">CHA:</span> ${p.cha} (Charisma)`);
                termAppend(`<span style="color:#FFAA00;">CON:</span> ${p.con} (Constitution)`);
                termAppend(`<span style="color:#FFD700;">LCK:</span> ${p.lck} (Luck)`);
                termAppend('');
            }
            
            // Legacy stats
            if (p.strength !== undefined) {
                termAppend(`<span style="color:#FF8800;">Strength:</span> ${p.strength}`);
                termAppend(`<span style="color:#00AAFF;">Defense:</span> ${p.defense}`);
                termAppend(`<span style="color:#8888FF;">Magic:</span> ${p.magic}`);
                termAppend(`<span style="color:#00FF88;">Speed:</span> ${p.speed}`);
                termAppend('');
            }
            
            // Derived Stats
            const weapon = WEAPONS[p.weapon];
            const armor = ARMOR[p.armor];
            const weaponDmg = weapon ? `${weapon.baseDamage}-${weapon.maxDamage || weapon.baseDamage}` : '0';
            const weaponMag = weapon && weapon.baseMagicDamage ? `+${weapon.baseMagicDamage}` : '';
            const armorDef = armor ? armor.baseDefense : 0;
            
            termAppend(`<span style="color:#FF4444;">âš”ï¸  Weapon Damage:</span> ${weaponDmg} ${weaponMag}`);
            termAppend(`<span style="color:#4444FF;">ğŸ›¡ï¸  Armor Defense:</span> ${armorDef}`);
            termAppend(`<span style="color:#FFD700;">ğŸ¯ Crit Chance:</span> ${calcCritChance(p.lck || 0, p)}%`);
            
            // Rogue Shadow Strike status
            const baseClass = p.baseClass || p.class;
            if (baseClass === 'rogue') {
                if (p.shadowStrikeReady) {
                    termAppend(`<span style="color:#8888FF;">ğŸŒ‘ Shadow Strike:</span> READY! (Next attack guaranteed crit)`);
                } else {
                    termAppend(`<span style="color:#666666;">ğŸŒ‘ Shadow Strike:</span> On cooldown (activate after 5s out of combat)`);
                }
            }
            
            // Class damage multiplier if evolved
            if (p.hasEvolved) {
                const dmgMult = getClassDamageMultiplier(p);
                termAppend(`<span style="color:#FFD700;">âš¡ Damage Multiplier:</span> ${dmgMult}x (Class Evolution)`);
            }
            
            termAppend('');
            
            // Equipment
            termAppend('<span style="color:var(--highlight-color);">â•â•â• EQUIPMENT â•â•â•</span>');
            termAppend(`<span style="color:#FFD700;">Weapon:</span> ${weapon ? weapon.name : 'None'}`);
            termAppend(`<span style="color:#4488FF;">Armor:</span> ${armor ? armor.name : 'None'}`);
            termAppend('');
            
            // Active Buffs
            if (p.activeBuffs && Object.keys(p.activeBuffs).length > 0) {
                termAppend('<span style="color:var(--highlight-color);">â•â•â• ACTIVE BUFFS â•â•â•</span>');
                for (const [buffType, buff] of Object.entries(p.activeBuffs)) {
                    if (Date.now() < buff.endTime) {
                        const timeLeft = Math.ceil((buff.endTime - Date.now()) / 1000);
                        const minutes = Math.floor(timeLeft / 60);
                        const seconds = timeLeft % 60;
                        const timeStr = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                        
                        let buffName = buffType.replace('buff_', '').toUpperCase();
                        termAppend(`<span style="color:#00FF88;">âœ¨ ${buffName}:</span> +${buff.power} (${timeStr})`);
                    }
                }
                termAppend('');
            }
            
            // Progress
            termAppend('<span style="color:var(--highlight-color);">â•â•â• PROGRESSION â•â•â•</span>');
            termAppend(`<span style="color:#FFD700;">Defeated Masters:</span> ${p.defeatedMasters?.length || 0}`);
            termAppend(`<span style="color:#4488FF;">Unlocked Areas:</span> ${p.unlockedAreas?.length || 0}`);
            termAppend(`<span style="color:#FF8800;">Known Spells:</span> ${p.knownSpells?.length || 0}`);
            termAppend(`<span style="color:#00FF88;">Inventory Items:</span> ${p.inventory?.length || 0}`);
            
            termAppend('');
            termAppend('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'term-highlight');
        }

        function attemptFlee() {
            const cs = gameState.combatState;
            if (!cs) return;
            
            // find first available pip
            let pipIndex = -1;
            for (let i = 0; i < cs.pipAvailable.length; i++) {
                if (cs.pipAvailable[i]) {
                    pipIndex = i;
                    break;
                }
            }
            if (pipIndex === -1) return;

            clearInterval(gameState.combatTimer);
            const p        = gameState.player;
            const fleePct  = Math.min(70, 30 + (p.dex||0)*3);
            if (Math.random()*100 < fleePct) {
                gameState.combatState = null;
                termAppend('You successfully fled!', 'term-highlight', () => {
                    renderActionBar();
                });
            } else {
                cs.pipAvailable[pipIndex] = false;
                cs.pipTimers[pipIndex] = gameState.player ? getPipCooldown(gameState.player) : BASE_PIP_COOLDOWN;
                renderActionBar();
                termAppend('Failed to escape!', 'term-error');
                startCombatTimer();
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // POTION MENU (in action bar)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UNIFIED COMBAT INVENTORY (replaces old potion menu in exploration)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function showCombatInventory() {
            const isDungeon = !!gameState.dungeon;
            if (isDungeon) {
                // In dungeon, use the full-screen overlay
                showDungeonInventory();
            } else {
                // In exploration, show inline inventory in action bar
                const ab = document.getElementById('actionBar');
                const p  = gameState.player;
                const cs = gameState.combatState;
                const inCombat = cs && !cs.combatOver;

                // Count potions
                const potions = {};
                p.inventory.forEach(ik => {
                    const item = ITEMS[ik];
                    if (!item) return;
                    if (item.subtype === 'recall' && inCombat) return; // no recall during combat
                    if (['heal_hp','heal_mp','full_restore','recall'].includes(item.subtype) || item.subtype?.startsWith('buff_')) {
                        if (!potions[ik]) potions[ik] = { item, count: 0 };
                        potions[ik].count++;
                    }
                });

                const playerClass = p.baseClass || p.class;

                // Get equippable weapons and armor
                const weapons = p.inventory.filter(ik => {
                    const w = WEAPONS[ik];
                    return w && !w.unarmed;
                });

                const armors = p.inventory.filter(ik => {
                    const a = ARMOR[ik];
                    return a && !a.unarmored;
                });

                let html = `<div style="color:var(--highlight-color);font-size:12px;margin-bottom:4px;">
                    ğŸ’ INVENTORY â€” HP: ${p.hp}/${p.maxHp} | MP: ${p.mp}/${p.maxMp}
                </div>`;

                // Potions
                const potKeys = Object.keys(potions);
                if (potKeys.length > 0) {
                    html += `<div style="display:flex;flex-wrap:wrap;gap:3px;margin-bottom:6px;">`;
                    potKeys.forEach(pk => {
                        const pd = potions[pk];
                        const col = pd.item.subtype === 'heal_hp' ? '#ff4444' : pd.item.subtype === 'heal_mp' ? '#4488ff' : pd.item.subtype === 'full_restore' ? '#FFD700' : '#00FF88';
                        const atFull = (pd.item.subtype==='heal_hp' && p.hp>=p.maxHp) || (pd.item.subtype==='heal_mp' && p.mp>=p.maxMp) || (pd.item.subtype==='full_restore' && p.hp>=p.maxHp && p.mp>=p.maxMp);
                        const useFn = inCombat ? `usePotion('${pk}')` : `usePotionExplore('${pk}')`;
                        html += `<button onclick="${useFn};renderActionBar();" ${atFull?'disabled':''} style="min-width:60px;padding:3px 5px;font-size:11px;color:${col};border-color:${col};opacity:${atFull?0.4:1};">
                            ${pd.item.name.substring(0,10)} x${pd.count}</button>`;
                    });
                    html += `</div>`;
                }

                // Weapons (show first 3)
                if (weapons.length > 0) {
                    html += `<div style="font-size:11px;color:#8aaa8a;margin-bottom:2px;">Weapons:</div>`;
                    html += `<div style="display:flex;flex-wrap:wrap;gap:3px;margin-bottom:6px;">`;
                    weapons.slice(0, 3).forEach(ik => {
                        if (ik === p.weapon) return;
                        const w = WEAPONS[ik];
                        const canEquip = canUseWeapon(playerClass, w);
                        const qc = QUALITY_CONFIG[w.quality];
                        html += `<button onclick="equipItem('weapon','${ik}');renderActionBar();" ${canEquip?'':'disabled'} style="padding:3px 5px;font-size:10px;color:${qc?.color||'#0f0'};opacity:${canEquip?1:0.4};">
                            ${w.name.substring(0,12)}</button>`;
                    });
                    if (weapons.length > 3) html += `<span style="font-size:10px;color:#666;">+${weapons.length-3} more</span>`;
                    html += `</div>`;
                }

                // Armor (show first 3)
                if (armors.length > 0) {
                    html += `<div style="font-size:11px;color:#8aaa8a;margin-bottom:2px;">Armor:</div>`;
                    html += `<div style="display:flex;flex-wrap:wrap;gap:3px;margin-bottom:6px;">`;
                    armors.slice(0, 3).forEach(ik => {
                        if (ik === p.armor) return;
                        const a = ARMOR[ik];
                        const canEquip = canUseArmor(playerClass, a);
                        const qc = QUALITY_CONFIG[a.quality];
                        html += `<button onclick="equipItem('armor','${ik}');renderActionBar();" ${canEquip?'':'disabled'} style="padding:3px 5px;font-size:10px;color:${qc?.color||'#0f0'};opacity:${canEquip?1:0.4};">
                            ${a.name.substring(0,12)}</button>`;
                    });
                    if (armors.length > 3) html += `<span style="font-size:10px;color:#666;">+${armors.length-3} more</span>`;
                    html += `</div>`;
                }

                // Healing Spells (available out of combat)
                if (!inCombat && p.knownSpells && p.knownSpells.length > 0) {
                    const classKey = p.baseClass || p.class;
                    const spellTree = CLASS_SPELL_TREES[classKey]?.spellTree || {};
                    
                    // Find healing spells
                    const healingSpells = p.knownSpells.filter(sk => {
                        const spell = SPELLS[sk] || spellTree[sk];
                        return spell && (spell.type === 'heal' || spell.type === 'lifesteal');
                    });
                    
                    if (healingSpells.length > 0) {
                        html += `<div style="font-size:11px;color:#8aaa8a;margin-bottom:2px;">Healing Spells:</div>`;
                        html += `<div style="display:flex;flex-wrap:wrap;gap:3px;margin-bottom:6px;">`;
                        healingSpells.forEach(sk => {
                            const spell = SPELLS[sk] || spellTree[sk];
                            const atFull = p.hp >= p.maxHp;
                            const notEnoughMp = p.mp < spell.mpCost;
                            const disabled = atFull || notEnoughMp;
                            html += `<button onclick="castHealingSpellOutOfCombat('${sk}');renderActionBar();" ${disabled?'disabled':''} style="padding:3px 5px;font-size:10px;color:#00FF00;border-color:#00FF00;opacity:${disabled?0.4:1};">
                                ${spell.name} (${spell.mpCost} MP)</button>`;
                        });
                        html += `</div>`;
                    }
                }

                html += `<button onclick="renderActionBar()" style="width:100%;padding:4px;">â† BACK</button>`;
                ab.innerHTML = html;
            }
        }

        function castHealingSpellOutOfCombat(spellKey) {
            const p = gameState.player;
            const classKey = p.baseClass || p.class;
            const spellTree = CLASS_SPELL_TREES[classKey]?.spellTree || {};
            const spell = SPELLS[spellKey] || spellTree[spellKey];
            
            if (!spell) {
                termAppend('Spell not found!', 'term-error');
                return;
            }
            
            // Check if player has enough MP
            if (p.mp < spell.mpCost) {
                termAppend(`Not enough MP to cast ${spell.name}! (Need ${spell.mpCost} MP)`, 'term-error');
                return;
            }
            
            // Check if already at full HP
            if (p.hp >= p.maxHp) {
                termAppend(`You're already at full health!`, 'term-warning');
                return;
            }
            
            // Consume MP
            p.mp -= spell.mpCost;
            
            // Calculate healing amount
            const minPower = spell.minPower || spell.power;
            const maxPower = spell.maxPower || spell.power;
            const healRoll = Math.floor(Math.random() * (maxPower - minPower + 1)) + minPower;
            const healAmount = healRoll + (p.wis || 0);
            
            // Apply healing
            const actualHeal = Math.min(healAmount, p.maxHp - p.hp);
            p.hp = Math.min(p.maxHp, p.hp + actualHeal);
            
            // Show message
            termAppend(`<span style="color:#00FF00;">âœ¨ You cast ${spell.name} and restore <strong>${actualHeal} HP</strong>!</span>`, 'term-loot');
            termAppend(`HP: ${p.hp}/${p.maxHp} | MP: ${p.mp}/${p.maxMp}`, 'term-dim');
            
            // Save game
            saveGame();
            
            // Update UI
            updateHud();
        }

        function showPotionMenu() {
            const cs = gameState.combatState;
            if (!cs) return;
            const p = gameState.player;
            const inDungeon = !!gameState.dungeon;
            const potions = {};
            p.inventory.forEach(ik => {
                const item = ITEMS[ik];
                if (!item) return;
                const isRecall = item.subtype === 'recall';
                // recall only available outside combat (cs exists here so block it)
                if (isRecall) return;
                if (
                    ['heal_hp','heal_mp','full_restore'].includes(item.subtype) ||
                    item.subtype?.startsWith('buff_')
                ) {
                    if (!potions[ik]) potions[ik] = { item: item, count: 0 };
                    potions[ik].count++;
                }
            });
            const keys = Object.keys(potions);
            if (keys.length === 0) {
                termAppend('You have no potions!', 'term-error');
                renderActionBar();
                return;
            }
            
            // Set action mode for potion menu
            cs.actionMode = 'potion_list';
            
            const ab = document.getElementById('actionBar');
            let html = '<div style="color:var(--highlight-color);font-size:10px;margin-bottom:4px;">USE POTION (No pip cost!):</div>';
            html += '<div style="display:flex;flex-wrap:wrap;gap:4px;max-width:100%;justify-content:flex-start;">';
            keys.forEach(pk => {
                const pd  = potions[pk];
                const item = pd.item;
                
                // Color based on potion type
                let col = '#00FF00';
                if (item.subtype === 'recall') col = '#AA88FF';
                else if (item.subtype === 'heal_hp') col = '#ff4444';
                else if (item.subtype === 'heal_mp') col = '#4488ff';
                else if (item.subtype === 'full_restore') col = '#FFD700';
                else if (item.subtype === 'buff_str') col = '#FF8800';
                else if (item.subtype === 'buff_def') col = '#00AAFF';
                else if (item.subtype === 'buff_xp') col = '#FFD700';
                else if (item.subtype === 'buff_gold') col = '#FFD700';
                else if (item.subtype === 'buff_magic') col = '#8888FF';
                else if (item.subtype === 'buff_damage') col = '#FF0000';
                else if (item.subtype === 'buff_invuln') col = '#AAAAAA';
                else if (item.subtype === 'buff_luck') col = '#FFAA00';
                else if (item.subtype === 'buff_regen') col = '#00FF88';
                else if (item.subtype === 'buff_speed') col = '#00FF00';
                else if (item.subtype === 'buff_crit') col = '#FF00FF';
                
                // Icon based on potion type
                let icon = 'ğŸ§ª';
                if (item.subtype === 'recall') icon = 'ğŸŒ€';
                else if (item.subtype === 'heal_hp') icon = 'â¤ï¸';
                else if (item.subtype === 'heal_mp') icon = 'ğŸ’™';
                else if (item.subtype === 'full_restore') icon = 'âœ¨';
                else if (item.subtype === 'buff_str') icon = 'ğŸ’ª';
                else if (item.subtype === 'buff_def') icon = 'ğŸ›¡ï¸';
                else if (item.subtype === 'buff_xp') icon = 'â­';
                else if (item.subtype === 'buff_gold') icon = 'ğŸ’°';
                else if (item.subtype === 'buff_magic') icon = 'ğŸ”®';
                else if (item.subtype === 'buff_damage') icon = 'âš”ï¸';
                else if (item.subtype === 'buff_invuln') icon = 'ğŸ—¿';
                else if (item.subtype === 'buff_luck') icon = 'ğŸ€';
                else if (item.subtype === 'buff_regen') icon = 'ğŸ’š';
                else if (item.subtype === 'buff_speed') icon = 'âš¡';
                else if (item.subtype === 'buff_crit') icon = 'ğŸ¯';
                
                html += `<button onclick="usePotion('${pk}')" style="
                    color:${col};
                    border-color:${col};
                    background:var(--secondary-bg);
                    padding:4px 6px;
                    min-width:70px;
                    max-width:90px;
                    height:auto;
                    font-size:11px;
                    text-align:center;
                    cursor:pointer;
                    border:1px solid ${col};
                    flex:0 0 auto;
                    white-space:nowrap;
                    overflow:hidden;
                    text-overflow:ellipsis;
                ">
                    ${icon} ${item.name.substring(0, 12)}${item.name.length > 12 ? '...' : ''} x${pd.count}
                </button>`;
            });
            html += `<button onclick="renderActionBar();" style="
                padding:4px 8px;
                min-width:60px;
                background:var(--secondary-bg);
                border:1px solid var(--border-color);
                color:var(--text-color);
                cursor:pointer;
                font-size:11px;
                flex:0 0 auto;
            ">âŒ Back</button>`;
            html += '</div>';
            ab.innerHTML = html;
        }

        function usePotion(potionKey) {
            const potion = ITEMS[potionKey];
            const p      = gameState.player;
            let msg;

            // â”€â”€ Recall Potion â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (potion.subtype === 'recall') {
                if (!gameState.dungeon) {
                    termAppend('<span style="color:#ff8800;">âš  Recall Potions only work inside dungeons!</span>');
                    renderActionBar();
                    return;
                }
                if (gameState.combatState) {
                    termAppend('<span style="color:#ff4444;">âš  You cannot recall while in combat! Defeat or flee your enemies first.</span>');
                    renderActionBar();
                    return;
                }
                // Consume and recall
                const idx = p.inventory.indexOf(potionKey);
                if (idx !== -1) p.inventory.splice(idx, 1);
                updateHud();
                const dest = gameState.currentTown || 'town1';
                termAppend(`<span style="color:#AA88FF;">ğŸŒ€ The Recall Potion dissolves in your hand â€” a swirling portal opens beneath you...</span>`);
                termAppend(`<span style="color:#AA88FF;">You are swept away to safety!</span>`);
                setTimeout(() => {
                    gameState.dungeon      = null;
                    gameState.combatState  = null;
                    if (gameState.combatTimer) { clearInterval(gameState.combatTimer); gameState.combatTimer = null; }
                    document.getElementById('actionBar').innerHTML = '';
                    document.body.classList.remove('terminal-mode');
                    gameState._terminalOpen = false;
                    saveGame();
                    showTown(dest);
                }, 1800);
                return;
            }

            if (potion.subtype === 'heal_hp') {
                const actual = Math.min(p.maxHp - p.hp, potion.power);
                p.hp = Math.min(p.maxHp, p.hp + actual);
                msg = `Used ${potion.name} â€“ restored <span style="color:#88ff88;">${actual} HP!</span>`;
            } else if (potion.subtype === 'heal_mp') {
                const actual = Math.min(p.maxMp - p.mp, potion.power);
                p.mp = Math.min(p.maxMp, p.mp + potion.power);
                msg = `Used ${potion.name} â€“ restored <span style="color:#88ff88;">${actual} MP!</span>`;
            } else if (potion.subtype === 'full_restore') {
                const hpR = p.maxHp - p.hp, mpR = p.maxMp - p.mp;
                p.hp = p.maxHp; p.mp = p.maxMp;
                msg = `Used ${potion.name} â€“ fully restored <span style="color:#88ff88;">${hpR} HP & ${mpR} MP!</span>`;
            } else if (potion.subtype === 'buff_xp') {
                // XP Boost buff
                applyBuff(p, 'xp_boost', potion.duration || 900000, potion.power); // 15 min default
                msg = `Used ${potion.name} â€“ <span style="color:#FFD700;">+${potion.power}% XP for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_str') {
                // Strength buff
                applyBuff(p, 'strength_boost', potion.duration || 300000, potion.power); // 5 min default
                msg = `Used ${potion.name} â€“ <span style="color:#FF8800;">+${potion.power} Strength for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_def') {
                // Defense buff
                applyBuff(p, 'defense_boost', potion.duration || 300000, potion.power); // 5 min default
                msg = `Used ${potion.name} â€“ <span style="color:#00AAFF;">+${potion.power} Defense for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_crit') {
                // Crit chance buff
                applyBuff(p, 'crit_boost', potion.duration || 300000, potion.power); // 5 min default
                msg = `Used ${potion.name} â€“ <span style="color:#FFD700;">+${potion.power}% Crit Chance for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_speed') {
                // Speed buff (faster pip regen)
                applyBuff(p, 'speed_boost', potion.duration || 300000, potion.power); // 5 min default
                msg = `Used ${potion.name} â€“ <span style="color:#00FF00;">+${potion.power}% Attack Speed for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_gold') {
                // Gold boost buff
                applyBuff(p, 'gold_boost', potion.duration || 900000, potion.power);
                msg = `Used ${potion.name} â€“ <span style="color:#FFD700;">+${potion.power}% Gold for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_magic') {
                // Magic buff
                applyBuff(p, 'magic_boost', potion.duration || 300000, potion.power);
                msg = `Used ${potion.name} â€“ <span style="color:#8888FF;">+${potion.power} Magic for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_damage') {
                // Damage boost buff
                applyBuff(p, 'damage_boost', potion.duration || 180000, potion.power);
                msg = `Used ${potion.name} â€“ <span style="color:#FF0000;">+${potion.power}% Damage for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_invuln') {
                // Damage reduction buff
                applyBuff(p, 'damage_reduction', potion.duration || 120000, potion.power);
                msg = `Used ${potion.name} â€“ <span style="color:#AAAAAA;">+${potion.power}% Damage Resist for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_luck') {
                // Luck buff
                applyBuff(p, 'luck_boost', potion.duration || 600000, potion.power);
                msg = `Used ${potion.name} â€“ <span style="color:#FFD700;">+${potion.power} Luck for ${(potion.duration/60000)} minutes!</span>`;
            } else if (potion.subtype === 'buff_regen') {
                // Regeneration buff
                applyBuff(p, 'regen_boost', potion.duration || 300000, potion.power);
                msg = `Used ${potion.name} â€“ <span style="color:#00FF88;">+${potion.power} HP/sec for ${(potion.duration/60000)} minutes!</span>`;
            }
            const idx = p.inventory.indexOf(potionKey);
            if (idx !== -1) p.inventory.splice(idx, 1);
            updateHud();
            
            // Reset to main combat menu after using potion
            const cs = gameState.combatState;
            if (cs) {
                cs.actionMode = 'main';
            }
            
            renderActionBar();
            termAppend(msg);   // no callback â€“ timer keeps ticking, player can still act
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUFF SYSTEM - Temporary stat boosts from potions
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function applyBuff(player, buffType, duration, power) {
            if (!player.activeBuffs) player.activeBuffs = {};
            
            // If buff already active, extend duration and stack power
            if (player.activeBuffs[buffType]) {
                const existing = player.activeBuffs[buffType];
                clearTimeout(existing.timer);
                existing.power = Math.min(existing.power + power, power * 3); // Cap at 3x
                existing.endTime = Date.now() + duration;
            } else {
                player.activeBuffs[buffType] = {
                    power: power,
                    endTime: Date.now() + duration
                };
            }
            
            // Set timer to remove buff
            player.activeBuffs[buffType].timer = setTimeout(() => {
                delete player.activeBuffs[buffType];
                termAppend(`<span style="color:#888;">Your ${buffType.replace('_', ' ')} has worn off.</span>`, 'term-dim');
            }, duration);
        }
        
        function getActiveBuff(player, buffType) {
            if (!player.activeBuffs || !player.activeBuffs[buffType]) return 0;
            const buff = player.activeBuffs[buffType];
            if (Date.now() > buff.endTime) {
                delete player.activeBuffs[buffType];
                return 0;
            }
            return buff.power;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // POTION MENU - EXPLORATION (Out of Combat)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function showPotionMenuExplore() {
            const p = gameState.player;
            const ab = document.getElementById('actionBar');
            const inDungeon = !!gameState.dungeon;
            
            // Count all usable potions (healing + buffs + recall if in dungeon)
            const potions = {};
            p.inventory.forEach(ik => {
                const item = ITEMS[ik];
                if (!item) return;
                const isRecall = item.subtype === 'recall';
                if (isRecall && !inDungeon) return; // recall only usable in dungeon
                if (
                    isRecall ||
                    ['heal_hp','heal_mp','full_restore'].includes(item.subtype) ||
                    item.subtype?.startsWith('buff_')
                ) {
                    if (!potions[ik]) potions[ik] = { item, count: 0 };
                    potions[ik].count++;
                }
            });
            
            const keys = Object.keys(potions);
            if (keys.length === 0) {
                ab.innerHTML = `
                    <div style="color:var(--error-color);font-size:10px;margin-bottom:4px;">You have no potions!</div>
                    <button onclick="renderActionBar()">â† BACK</button>
                `;
                return;
            }
            
            // Color + icon lookup (mirrors combat potion menu)
            function potionColor(subtype) {
                if (subtype==='recall') return '#AA88FF';
                if (subtype==='heal_hp') return '#ff4444';
                if (subtype==='heal_mp') return '#4488ff';
                if (subtype==='full_restore') return '#FFD700';
                if (subtype==='buff_str') return '#FF8800';
                if (subtype==='buff_def') return '#00AAFF';
                if (subtype==='buff_xp') return '#FFD700';
                if (subtype==='buff_gold') return '#FFD700';
                if (subtype==='buff_magic') return '#8888FF';
                if (subtype==='buff_damage') return '#FF0000';
                if (subtype==='buff_invuln') return '#AAAAAA';
                if (subtype==='buff_luck') return '#FFAA00';
                if (subtype==='buff_regen') return '#00FF88';
                if (subtype==='buff_speed') return '#00FF00';
                if (subtype==='buff_crit') return '#FF00FF';
                return '#00FF00';
            }
            function potionIcon(subtype) {
                if (subtype==='recall') return 'ğŸŒ€';
                if (subtype==='heal_hp') return 'â¤ï¸';
                if (subtype==='heal_mp') return 'ğŸ’™';
                if (subtype==='full_restore') return 'âœ¨';
                if (subtype==='buff_str') return 'ğŸ’ª';
                if (subtype==='buff_def') return 'ğŸ›¡ï¸';
                if (subtype==='buff_xp') return 'â­';
                if (subtype==='buff_gold') return 'ğŸ’°';
                if (subtype==='buff_magic') return 'ğŸ”®';
                if (subtype==='buff_damage') return 'âš”ï¸';
                if (subtype==='buff_invuln') return 'ğŸ—¿';
                if (subtype==='buff_luck') return 'ğŸ€';
                if (subtype==='buff_regen') return 'ğŸ’š';
                if (subtype==='buff_speed') return 'âš¡';
                if (subtype==='buff_crit') return 'ğŸ¯';
                return 'ğŸ§ª';
            }

            let html = `<div style="color:var(--highlight-color);font-size:10px;margin-bottom:4px;">USE POTION (HP: ${p.hp}/${p.maxHp} | MP: ${p.mp}/${p.maxMp}):</div>`;
            html += `<div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:flex-start;">`;
            
            keys.forEach(pk => {
                const pd  = potions[pk];
                const col = potionColor(pd.item.subtype);
                const icon = potionIcon(pd.item.subtype);
                const atFull = (pd.item.subtype === 'heal_hp' && p.hp >= p.maxHp) ||
                               (pd.item.subtype === 'heal_mp' && p.mp >= p.maxMp) ||
                               (pd.item.subtype === 'full_restore' && p.hp >= p.maxHp && p.mp >= p.maxMp);
                const shortName = pd.item.name.length > 12 ? pd.item.name.substring(0,12)+'â€¦' : pd.item.name;
                html += `<button onclick="usePotionExplore('${pk}')" ${atFull ? 'disabled' : ''} style="
                    color:${col}; border:1px solid ${col};
                    background:var(--secondary-bg);
                    padding:4px 6px; min-width:70px; max-width:90px;
                    font-size:11px; flex:0 0 auto;
                    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
                    opacity:${atFull ? 0.4 : 1};
                ">${icon} ${shortName} x${pd.count}</button>`;
            });
            
            html += `<button onclick="renderActionBar()" style="
                padding:4px 8px; min-width:60px; flex:0 0 auto;
                background:var(--secondary-bg); border:1px solid var(--border-color);
                color:var(--text-color); font-size:11px;">âŒ Back</button>`;
            html += `</div>`;
            ab.innerHTML = html;
        }
        
        function usePotionExplore(potionKey) {
            const potion = ITEMS[potionKey];
            const p = gameState.player;
            
            // â”€â”€ Recall Potion â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (potion.subtype === 'recall') {
                if (!gameState.dungeon) {
                    termAppend('<span style="color:#ff8800;">âš  Recall Potions only work inside dungeons!</span>');
                    return;
                }
                const idx2 = p.inventory.indexOf(potionKey);
                if (idx2 !== -1) p.inventory.splice(idx2, 1);
                updateHud();
                const dest = gameState.currentTown || 'town1';
                termAppend(`<span style="color:#AA88FF;">ğŸŒ€ The Recall Potion dissolves in your hand â€” a swirling portal opens beneath you...</span>`);
                termAppend(`<span style="color:#AA88FF;">You are swept away to safety!</span>`);
                setTimeout(() => {
                    gameState.dungeon      = null;
                    gameState.combatState  = null;
                    if (gameState.combatTimer) { clearInterval(gameState.combatTimer); gameState.combatTimer = null; }
                    document.getElementById('actionBar').innerHTML = '';
                    document.body.classList.remove('terminal-mode');
                    gameState._terminalOpen = false;
                    saveGame();
                    showTown(dest);
                }, 1800);
                return;
            }

            let msg;
            if (potion.subtype === 'heal_hp') {
                const actual = Math.min(p.maxHp - p.hp, potion.power);
                if (actual === 0) {
                    msg = `You're already at full HP!`;
                } else {
                    p.hp = Math.min(p.maxHp, p.hp + actual);
                    msg = `Used ${potion.name} â€“ restored <span style="color:#88ff88;">${actual} HP!</span>`;
                }
            } else if (potion.subtype === 'heal_mp') {
                const actual = Math.min(p.maxMp - p.mp, potion.power);
                if (actual === 0) {
                    msg = `You're already at full MP!`;
                } else {
                    p.mp = Math.min(p.maxMp, p.mp + potion.power);
                    msg = `Used ${potion.name} â€“ restored <span style="color:#88ff88;">${actual} MP!</span>`;
                }
            } else if (potion.subtype === 'full_restore') {
                const hpR = p.maxHp - p.hp;
                const mpR = p.maxMp - p.mp;
                if (hpR === 0 && mpR === 0) {
                    msg = `You're already fully restored!`;
                } else {
                    p.hp = p.maxHp;
                    p.mp = p.maxMp;
                    msg = `Used ${potion.name} â€“ fully restored <span style="color:#88ff88;">${hpR} HP & ${mpR} MP!</span>`;
                }
            }
            
            // Remove potion from inventory
            const idx = p.inventory.indexOf(potionKey);
            if (idx !== -1) p.inventory.splice(idx, 1);
            
            updateHud();
            termAppend(msg);
            
            // Refresh potion menu to show updated counts
            showPotionMenuExplore();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ENEMY ATTACK
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       function enemyAttackSingle() {
    // Enemy uses ONE charge, attacks once, then resets its own timer
    const cs       = gameState.combatState;
    const monsters = cs.monsters;
    const p        = gameState.player;

    // Defensive stats
    let armor = ARMOR[p.armor];
    
    // No armor equipped â†’ bare skin (no_armor gives 0 defense)
    if (!armor) {
        if (p.armor && p.armor !== 'no_armor') {
            console.warn(`âš ï¸ Armor '${p.armor}' not found â€” treating as unarmored.`);
        }
        p.armor = 'no_armor';
        armor   = ARMOR['no_armor'] || { baseDefense: 0, baseMagicBonus: 0, quality: 'poor' };
    }
    
    const qBonus = getQualityBonus(armor.quality, armor.baseDefense);
    let totalDef = armor.baseDefense + qBonus + (p.con || 0);

        // â”€â”€ Warrior Shield: 70% chance to halve ALL incoming damage each attack â”€â”€
    // cs.shieldActive is set by playerDefend() and persists until combat ends.
    const shieldTriggered = cs.shieldActive && (Math.random() < 0.70);

    // Pull intent (or fallback)
    const intent = cs.enemyIntent || {
        type: 'basic',
        damageMult: 1,
        armorPiercing: 0
    };

    // Each monster in the pack gets ONE hit
    const hits = [];

    monsters.forEach((enemy, i) => {
        const eName = monsters.length > 1
            ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${i + 1}</span>`
            : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;

        // God mode bypass
        if (p.godMode) {
            hits.push({ eName, godMode: true });
            return;
        }

        // â”€â”€ Pick a random damage roll within the enemy's min/max range â”€â”€
        // Stats are already scaled for level and rarity at spawn.
        // enemyDealt applies an additional 5% reduction per level the player is above the enemy.
        const eMin = Math.max(1, enemy.minDamage ?? Math.round(enemy.damage * 0.67));
        const eMax = Math.max(eMin + 1, enemy.maxDamage ?? Math.round(enemy.damage * 1.33));
        const rolledDamage = eMin + Math.floor(Math.random() * (eMax - eMin + 1));

        const _lvlMult = getLevelDamageMult(p.level, enemy.level);
        const _scaledBase = Math.max(1,
            Math.floor(rolledDamage * intent.damageMult * DAMAGE_SCALING.monsterDamageMult * _lvlMult.enemyDealt)
        );

        const result = calculateDamage({
            attacker: enemy,
            defender: {
                defense: totalDef,
                magicDefense: totalDef
            },
            base: _scaledBase,
            type: enemy.magicAttack ? 'magic' : 'physical',
            dodgeChance: calcDodgeChance(p.dex || 0) / 100,
            armorPiercing: intent.armorPiercing
        });

        if (result.dodged) {
            hits.push({ eName, dodged: true });
            return;
        }

        let finalDmg = result.damage;
        let shieldBlocked = false;
        if (shieldTriggered) {
            finalDmg     = Math.max(1, Math.floor(finalDmg * 0.5));
            shieldBlocked = true;
        }

        p.hp -= finalDmg;

        hits.push({
            eName,
            dmg:          finalDmg,
            crit:         result.crit,
            shieldBlocked
        });
    });

    updateHud();

    // After attack messages stream, reset enemy timer and resume
    const afterAttack = () => {
        cs.enemyIntent = null; // clear intent after execution

        if (p.hp <= 0 && !p.godMode) {
            endCombat(false);
        } else {
            cs.enemyTimer = cs.enemyDelay;
            
            // Apply trap slow if active
            if (cs.trapActive && cs.trapSlowAmount) {
                cs.enemyTimer += cs.trapSlowAmount;
            }
            
            renderActionBar();
            startCombatTimer();
        }
    };

    hits.forEach((hit, i) => {
        const isLast = (i === hits.length - 1);

        if (hit.godMode) {
            termAppend(
                `${hit.eName} attacks but you are <span class="term-highlight">INVINCIBLE!</span>`,
                null,
                isLast ? afterAttack : null
            );
        } else if (hit.dodged) {
            termAppend(
                `${hit.eName} attacksâ€¦ <span style="color:#88ff88;">DODGED!</span>`,
                null,
                isLast ? afterAttack : null
            );
        } else {
            const critTag    = hit.crit
                ? ' <span style="color:#FF4444;">ğŸ’€ ENEMY CRITICAL!</span>'
                : '';
            const shieldTag  = hit.shieldBlocked
                ? ' <span style="color:#00CCFF;">ğŸ›¡ï¸ SHIELD! (âˆ’50%)</span>'
                : '';

            termAppend(
                `${hit.eName} attacks for <span class="dmg-player">${hit.dmg} damage!</span>${critTag}${shieldTag}`,
                null,
                isLast ? afterAttack : null
            );
        }
    });
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHECK / END COMBAT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function checkCombatEnd() {
    const cs = gameState.combatState;
    if (!cs || !cs.monsters || cs.monsters.length === 0) return;

    let ti = cs.currentTarget;

    // Clamp target index (important after splicing)
    if (ti < 0 || ti >= cs.monsters.length) {
        cs.currentTarget = 0;
        ti = 0;
    }

    const target = cs.monsters[ti];
    if (!target) return;

    if (!cs.defeatedMonsters) cs.defeatedMonsters = [];

    if (target.hp <= 0) {
        const dead = target;

        // Calculate rewards for THIS enemy immediately
        const baseXp = dead.xp || (dead.level * 10);
        const baseGold = dead.gold || (dead.level * 5);
        
        termAppend(
            `<span style="color:${dead.rarityColor};">${dead.name}</span> has been defeated!`,
            'term-victory'
        );
        
        // Show individual rewards immediately
        termAppend(`Gained <span style="color:#FFD700;">${baseXp} XP</span> and <span style="color:#FFD700;">${baseGold} Gold!</span>`, 'term-loot');
        
        // Apply rewards immediately
        const p = gameState.player;
        p.xp += baseXp;
        p.gold += baseGold;
        
        // Check for level up
        if (p.xp >= p.xpToNext) {
            levelUp();
            termAppend(`<span style="color:var(--highlight-color);font-size:18px;">â¬†ï¸ LEVEL UP! You are now level ${p.level}!</span>`, 'term-victory');
            termAppend(`<span style="color:#FFD700;">+3 Stat Points! </span><span style="color:#00FFFF;">â†’ Spend them at CHARACTER STATS in town.</span>`, 'term-loot');
        }
        
        // Add to defeated list and remove from active combat
        cs.defeatedMonsters.push(dead);
        cs.monsters.splice(ti, 1);

        // Adjust target after removal
        if (cs.currentTarget >= cs.monsters.length) {
            cs.currentTarget = Math.max(0, cs.monsters.length - 1);
        }

        // Update cards and HUD immediately
        updateEnemyCards();
        updateHud();
        
        // Check if all enemies dead
        if (cs.monsters.length === 0) {
            // All enemies dead - end combat
            // Don't give rewards again in endCombat
            cs.rewardsAlreadyGiven = true;
            endCombat(true);
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// END COMBAT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function endCombat(victory) {

    // â”€â”€ defeat â”€â”€
    if (!victory) {
        clearInterval(gameState.combatTimer);
        gameState.combatTimer = null;

        const p = gameState.player;
        const inDungeon = !!gameState.dungeon;

        // â”€â”€ Calculate penalties BEFORE applying them â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Level 1 players are immune to all penalties
        const isLevel1 = p.level <= 1;

        let xpLost   = 0;
        let goldLost = 0;

        if (!isLevel1) {
            // â”€â”€ XP penalty: 10% of total accumulated XP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // p.xp is now a running total, so it IS the total XP so far.
            xpLost = Math.floor(p.xp * 0.10);

            // Never drop a level â€” floor XP at the start-of-current-level threshold
            const xpFloor = getXpForLevel(p.class, p.level);
            p.xp = Math.max(xpFloor, p.xp - xpLost);
            // xpToNext stays the same (level doesn't change)

            // â”€â”€ Gold penalty: lose ALL carried gold (bank is safe) â”€â”€â”€â”€â”€â”€
            goldLost = p.gold;
            p.gold   = 0;
        }

        // Restore HP/MP to full
        p.hp = p.maxHp;
        p.mp = p.maxMp;

        // Clear dungeon / combat state
        gameState.dungeon              = null;
        gameState.combatState          = null;
        gameState.postCombatRecovery   = false;

        updateHud();
        saveGame();  // persist penalties immediately

        // â”€â”€ Build death screen shown IN THE TERMINAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Separator
        termAppend('', 'term-separator');

        // Big skull header
        termAppend(
            `<span style="color:#ff2222;font-size:26px;letter-spacing:4px;">ğŸ’€  YOU HAVE DIED  ğŸ’€</span>`,
            'term-error'
        );
        termAppend('', 'term-separator');

        if (isLevel1) {
            // No penalties at level 1
            termAppend(
                `<span style="color:#88ff88;">You are a <strong>Level 1</strong> adventurer â€” no penalties apply.</span>`,
                'term-loot'
            );
            termAppend(
                `<span style="color:#aaaaaa;">You wake up bruised but no worse for wear...</span>`
            );
        } else {
            // Show each penalty
            termAppend(
                `<span style="color:#ff6666;">ğŸ’¸ Gold Lost: </span>` +
                `<span style="color:#ffaa00;font-size:18px;">${goldLost.toLocaleString()}g</span>` +
                `<span style="color:#888;"> (gold in your <strong>Bank</strong> is safe)</span>`
            );

            const xpBefore = p.xp + xpLost;
            termAppend(
                `<span style="color:#ff6666;">ğŸ“‰ XP Lost: </span>` +
                `<span style="color:#ff8888;font-size:18px;">${xpLost.toLocaleString()} XP</span>`
            );
            termAppend(
                `<span style="color:#888;">XP: ${xpBefore.toLocaleString()} â†’ ${p.xp.toLocaleString()}` +
                `${p.xp === getXpForLevel(p.class, p.level) ? ' <span style="color:#ff4444;">(floored at level start)</span>' : ''}</span>`
            );

            if (inDungeon) {
                termAppend(
                    `<span style="color:#ff4444;">ğŸšï¸ Expelled from the dungeon!</span>`
                );
            }

            termAppend('', 'term-separator');
            termAppend(
                `<span style="color:#666;">Your level remains <strong style="color:#aaa;">Lv ${p.level}</strong>. ` +
                `Gold in your bank is untouched.</span>`
            );
        }

        termAppend('', 'term-separator');
        termAppend(
            `<span style="color:#888888;">Press <strong style="color:#00ff88;">[CONTINUE]</strong> to return to town...</span>`
        );

        // â”€â”€ Inject CONTINUE button into the action bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const ab = document.getElementById('actionBar');
        if (ab) {
            ab.innerHTML = `
                <div style="display:flex;gap:6px;width:100%;padding:4px;">
                    <button onclick="confirmDeathReturn()"
                        style="flex:1;font-size:20px;min-height:50px;
                               background:linear-gradient(180deg,#0a0000,#000);
                               color:#ff4444;border:2px solid #ff4444;
                               font-family:'VT323',monospace;letter-spacing:2px;">
                        ğŸ’€ CONTINUE
                    </button>
                </div>`;
        }
        return;
    }

    // â”€â”€ victory â”€â”€
    const defeated   = gameState.combatState.defeatedMonsters || [];
    const cs = gameState.combatState;
    const isMaster   = defeated.some(m => m.isMaster);
    let masterData   = null;
    let unlockedArea = null;

    if (isMaster) {
        const m = defeated.find(d => d.isMaster);
        masterData   = CLASS_MASTERS[m.masterKey];
        unlockedArea = masterData.unlocks;

        if (!gameState.player.defeatedMasters.includes(m.masterKey))
            gameState.player.defeatedMasters.push(m.masterKey);

        if (!gameState.player.unlockedAreas.includes(unlockedArea))
            gameState.player.unlockedAreas.push(unlockedArea);

        masterData.guaranteedDrops.forEach(ik => {
            if (!defeated[0].possibleDrops) defeated[0].possibleDrops = [];
            if (!defeated[0].possibleDrops.includes(ik))
                defeated[0].possibleDrops.push(ik);

            if (!defeated[0].dropRates) defeated[0].dropRates = {};
            defeated[0].dropRates[
                (WEAPONS[ik] || ARMOR[ik]) ? getItemQuality(ik) : 'common'
            ] = 1.0;
        });
    }

    // Check if rewards were already given during combat (multi-enemy)
    const rewardsAlreadyGiven = cs.rewardsAlreadyGiven;
    
    let totalXp = 0, totalGold = 0, allLoot = [];
    
    // Only calculate if NOT already given
    if (!rewardsAlreadyGiven) {
        defeated.forEach(e => {
            // Calculate XP based on level difference and rarity
            const xpReward = calculateXpReward(e, gameState.player.level);
            totalXp   += xpReward;
            totalGold += e.gold;
            allLoot    = allLoot.concat(rollLoot(e));
        });

        gameState.player.xp   += totalXp;
        gameState.player.gold += totalGold;
    } else {
        // Still roll for loot even if XP/gold already given
        defeated.forEach(e => {
            allLoot = allLoot.concat(rollLoot(e));
        });
    }

    // â”€â”€ Remove ALL defeated dungeon enemies & award drops â”€â”€
    if (gameState.dungeon && gameState.combatState) {
        const cs = gameState.combatState;
        // Collect all dungeon enemy IDs linked to this combat
        const linkedIds = cs.dungeonEnemyIds || (cs.dungeonEnemyId ? [cs.dungeonEnemyId] : []);

        linkedIds.forEach(dungeonEnemyId => {
            const defeatedDungeonEnemy = gameState.dungeon.activeEnemies.find(
                e => e.id === dungeonEnemyId
            );

            // Award the drop item if set
            if (defeatedDungeonEnemy && defeatedDungeonEnemy.drop) {
                const dropKey = defeatedDungeonEnemy.drop;
                if (dropKey && ITEMS[dropKey]) {
                    gameState.player.inventory.push(dropKey);
                    const dropItem = ITEMS[dropKey];
                    const dropIcon = dropItem.icon || 'ğŸ“¦';
                    const keyColor = dropItem.subtype === 'dungeon_key' ? '#e8b84a' : '#00FF88';
                    termAppend(
                        `${dropIcon} <span style="color:${keyColor};">${dropItem.name}</span> found on the body!`,
                        'term-loot'
                    );
                }
            }
        });

        // Move defeated enemies to defeatedEnemies with death timestamp for 30min respawn
        if (linkedIds.length > 0) {
            if (!gameState.dungeon.defeatedEnemies) gameState.dungeon.defeatedEnemies = [];
            
            linkedIds.forEach(dungeonEnemyId => {
                const defeatedEnemy = gameState.dungeon.activeEnemies.find(e => e.id === dungeonEnemyId);
                if (defeatedEnemy) {
                    // Store with death timestamp for respawn system
                    gameState.dungeon.defeatedEnemies.push({
                        ...defeatedEnemy,
                        deathTime: Date.now(),
                        respawnTime: Date.now() + (30 * 60 * 1000) // 30 minutes from now
                    });
                }
            });
            
            // Remove from active enemies
            gameState.dungeon.activeEnemies = gameState.dungeon.activeEnemies.filter(
                e => !linkedIds.includes(e.id)
            );
            console.log(`ğŸ—‘ï¸ Removed ${linkedIds.length} dungeon enemy(s) - will respawn in 30min`);
        }
    }

    // â”€â”€ terminal output â”€â”€
    termAppend('', 'term-separator');

    if (isMaster) {
        termAppend(`ğŸ† ${masterData.name} HAS BEEN DEFEATED! ğŸ†`, 'term-victory');
        termAppend(`âœ¨ ${LOCATIONS[unlockedArea].name} IS NOW UNLOCKED! âœ¨`, 'term-loot');
    }

    if (defeated.length === 1) {
        termAppend(
            `You defeated <span style="color:${defeated[0].rarityColor};">${defeated[0].name}</span>!`,
            'term-highlight'
        );
    } else {
        termAppend(`You defeated ${defeated.length} enemies!`, 'term-highlight');
        defeated.forEach(e =>
            termAppend(`  â€¢ <span style="color:${e.rarityColor};">${e.name}</span>`)
        );
    }

    // Only show total XP/Gold if NOT already shown during combat
    if (!rewardsAlreadyGiven) {
        termAppend(
            `Gained <span style="color:#FFD700;">${totalXp} XP</span> and ` +
            `<span style="color:#FFD700;">${totalGold} Gold</span>!`
        );
    }

    if (allLoot.length > 0) {
        termAppend('âš¡ LOOT:', 'term-loot');
        allLoot.forEach(ik => {
            gameState.player.inventory.push(ik);
            termAppend(
                `  + <span style="color:${getItemColor(ik)};">${getItemName(ik)}</span>`,
                'term-loot'
            );
        });
    } else {
        termAppend('No items droppedâ€¦', 'term-dim');
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WEAPON + ARMOR DROPS ğŸ—¡ï¸ğŸ›¡ï¸
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    defeated.forEach((monster, index) => {
        // â”€â”€ Weapon drop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const weaponDrop = generateWeaponDrop(
            gameState.player, 
            monster.level, 
            monster.rarity || 'common'
        );
        
        if (weaponDrop) {
            // Add to WEAPONS object
            WEAPONS[weaponDrop.id] = weaponDrop;
            
            // Add to player inventory
            gameState.player.inventory.push(weaponDrop.id);
            
            // Show drop message with quality color
            const qualityColor = QUALITY_CONFIG[weaponDrop.quality].color;
            termAppend('', 'term-separator');
            termAppend(`ğŸ’ <span style="color:${qualityColor};font-size:18px;font-weight:bold;">WEAPON DROP!</span>`, 'term-victory');
            termAppend(`<span style="color:${qualityColor};">${weaponDrop.name}</span>`, 'term-loot');
            termAppend(`<span style="color:#8aaa8a;">Level ${weaponDrop.level} ${weaponDrop.quality} ${weaponDrop.type}</span>`, 'term-dim');
            termAppend(`<span style="color:#FFD700;">DMG: ${weaponDrop.baseDamage}-${weaponDrop.maxDamage}</span>`);
            // Show gem slots on drop
            const dropSlots = getGemSlots(weaponDrop.quality || 'normal');
            if (dropSlots > 0) {
                const slotCircles = 'â¬¤'.repeat(dropSlots);
                termAppend(`<span style="color:#333;font-size:13px;">${slotCircles}</span> <span style="color:#555;font-size:11px;">${dropSlots} gem slot${dropSlots>1?'s':''} â€” visit the Blacksmith to socket gems</span>`);
            }
            
            // Show modifiers
            if (weaponDrop.modifiers && weaponDrop.modifiers.length > 0) {
                termAppend('<span style="color:#00FFFF;">Special Properties:</span>');
                weaponDrop.modifiers.forEach(modKey => {
                    const mod = WEAPON_MODIFIERS[modKey];
                    if (mod) {
                        let modText = `  â€¢ <span style="color:${mod.color};">${mod.name}`;
                        if (mod.minDamage) {
                            modText += ` (${mod.minDamage}-${mod.maxDamage} dmg)`;
                        }
                        if (mod.statusEffect) {
                            const status = STATUS_EFFECTS[mod.statusEffect];
                            modText += ` - ${Math.floor(mod.statusChance * 100)}% ${status.icon} ${status.name}`;
                        }
                        modText += `</span>`;
                        termAppend(modText, 'term-loot');
                    }
                });
            }
            termAppend('', 'term-separator');
        }

        // â”€â”€ Armor drop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (typeof generateArmorDrop !== 'undefined') {
            const armorKey = generateArmorDrop(
                gameState.player,
                monster.level,
                monster.rarity || 'common'
            );

            if (armorKey && typeof ARMOR !== 'undefined' && ARMOR[armorKey]) {
                const armorDef = ARMOR[armorKey];
                gameState.player.inventory.push(armorKey);

                const qColor = QUALITY_CONFIG[armorDef.quality]?.color || '#00FF00';
                const qBonus = getQualityBonus(armorDef.quality, armorDef.baseDefense);
                const totalDef = armorDef.baseDefense + qBonus;

                termAppend('', 'term-separator');
                termAppend(`ğŸ›¡ï¸ <span style="color:${qColor};font-size:18px;font-weight:bold;">ARMOR DROP!</span>`, 'term-victory');
                termAppend(`<span style="color:${qColor};">${armorDef.name}</span>`, 'term-loot');
                termAppend(`<span style="color:#8aaa8a;">Level ${armorDef.level || 1} ${armorDef.quality} armor</span>`, 'term-dim');
                termAppend(`<span style="color:#00AAFF;">DEF: ${totalDef}${armorDef.baseMagicBonus > 0 ? ` | MAG BONUS: +${armorDef.baseMagicBonus}` : ''}</span>`);
                termAppend('', 'term-separator');
            }
        }
    });

    // Check for level-up (possibly multiple levels)
    while (gameState.player.xp >= gameState.player.xpToNext && gameState.player.level < 25) {
        levelUp();
        termAppend(`â¬†ï¸ LEVEL UP! You are now level ${gameState.player.level}!`, 'term-victory');
        termAppend(`<span style="color:#00FFFF;">+3 Stat Points! â†’ Spend them at CHARACTER STATS in town.</span>`, 'term-loot');
        
        // Check for class evolution announcement
        if (gameState.player._justEvolved) {
            termAppend('', 'term-separator');
            termAppend(`<span style="color:#FF00FF;font-size:24px;font-weight:bold;">âš¡ CLASS EVOLUTION! âš¡</span>`, 'term-victory');
            termAppend(gameState.player._evolutionMessage, 'term-victory');
            termAppend(`<span style="color:#FFD700;">Your power has DOUBLED!</span>`, 'term-loot');
            gameState.player._justEvolved = false;
            gameState.player._evolutionMessage = null;
        }
    }
    
    // Max level message
    if (gameState.player.level >= 25 && gameState.player.xp >= gameState.player.xpToNext) {
        termAppend(`ğŸŒŸ You have reached MAX LEVEL! (25)`, 'term-victory');
        gameState.player.xp = gameState.player.xpToNext; // Cap at max threshold
    }

    updateHud();
    
    // ğŸ’¾ AUTO-SAVE after victory
    saveGame();

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // âœ… EXIT COMBAT, ENTER EXHAUSTION
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Mark combat as finished, but keep state for timers & UI
  cleanupCombatStatusEffects(); // Clear all DOT timers and status effects
gameState.combatState.combatOver = true;
gameState.postCombatRecovery = true;

    // Resume regeneration after combat (normal speed - you're still in the field)
    startMpRegen(false);
    startResting(false);

    const ab = document.getElementById('actionBar');
    
    // Check if we're in a dungeon
    if (gameState.dungeon) {
        // After a short delay, check if more enemies are still in the room
        if (victory) {
            setTimeout(() => {
                const ds = gameState.dungeon;
                if (!ds) return;
                const remaining = ds.activeEnemies.filter(e => e.currentRoom === ds.currentRoom);
                if (remaining.length > 0) {
                    // More enemies in room â€” start new combat
                    checkEnemiesInRoom(ds.currentRoom);
                } else {
                    // No more enemies â€” show exploration buttons
                    renderDungeonActionBar();
                }
            }, 400);
        } else {
            renderDungeonActionBar();
        }
    } else if (isMaster) {
        ab.innerHTML = `
            <button onclick="tryViewWorldMap()">ğŸ—ºï¸ VIEW WORLD MAP</button>
            <button onclick="tryGoBackToTown()">ğŸ˜ï¸ RETURN TO TOWN</button>`;
        renderActionBar();
    } else {
        ab.innerHTML = `
            <button onclick="tryExploreLocation('${gameState.currentLocation}')">ğŸ” CONTINUE EXPLORING</button>
            <button onclick="tryGoBackToTown()">ğŸ˜ï¸ RETURN TO TOWN</button>`;
        renderActionBar();

        stabilizeTerminalLayout();
    }

    if (!gameState.combatTimer) {
        startCombatTimer();
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ROGUE: SHADOW STRIKE - Activate stealth after combat
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const p = gameState.player;
    const baseClass = p.baseClass || p.class;
    if (baseClass === 'rogue' && victory) {
        // Clear any existing timer
        if (p.shadowStrikeTimer) {
            clearTimeout(p.shadowStrikeTimer);
        }
        
        // Set 5-second timer for Shadow Strike
        p.shadowStrikeTimer = setTimeout(() => {
            p.shadowStrikeReady = true;
            termAppend('', 'term-separator');
            termAppend('ğŸŒ‘ You melt into the shadows... <span style="color:#8888FF;">[Shadow Strike Ready]</span>', 'term-highlight');
        }, 5000);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DEATH CONFIRMATION â€” player presses [CONTINUE] to return to town
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function confirmDeathReturn() {
    // Start regen fresh in town
    startMpRegen(true);
    startResting(true);
    closeTerminalView();
    showTown();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POST-COMBAT EXHAUSTION CHECK
// (used by navigation actions)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function continueDungeonExploration() {
    // Clear combat state and show dungeon navigation
    gameState.combatState = null;
    gameState.postCombatRecovery = false;
    
    // Clear combat timer
    if (gameState.combatTimer) {
        clearInterval(gameState.combatTimer);
        gameState.combatTimer = null;
    }
    
    // Return to dungeon navigation
    renderDungeonActionBar();
}

function playerIsExhausted() {
    if (!gameState.postCombatRecovery) return false;

    const cs = gameState.combatState;
    if (!cs || !cs.pipAvailable) return false;

    return cs.pipAvailable.some(p => !p);
}
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ADVANCED CLASS EVOLUTION (Level 20)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const ADVANCED_CLASSES = {
            warrior: {
                advancedClass: 'warlord',
                advancedName: 'Warlord',
                description: 'Master of all weapons and combat. Unstoppable in battle.',
                damageMultiplier: 2.0,
                bonusStats: { str: 10, con: 10, dex: 5 },
                newSpells: ['battle_fury', 'titan_strike'],
                announcement: 'âš”ï¸ You have mastered the art of war! You are now a WARLORD!'
            },
            rogue: {
                advancedClass: 'shadowmaster',
                advancedName: 'Shadowmaster',
                description: 'Master assassin who strikes from the void itself.',
                damageMultiplier: 2.5,
                bonusStats: { dex: 15, lck: 10, str: 5 },
                newSpells: ['shadow_strike', 'void_step'],
                announcement: 'ğŸ—¡ï¸ You have become one with the shadows! You are now a SHADOWMASTER!'
            },
            acolyte: {
                advancedClass: 'high_priest',
                advancedName: 'High Priest',
                description: 'Chosen of the divine, wielding ultimate holy power.',
                damageMultiplier: 2.0,
                bonusStats: { wis: 15, cha: 10, con: 5 },
                newSpells: ['divine_judgment', 'mass_resurrection', 'holy_nova'],
                announcement: 'âœ¨ The gods have chosen you! You are now a HIGH PRIEST!'
            },
            necrolyte: {
                advancedClass: 'lich',
                advancedName: 'Lich',
                description: 'Immortal master of death itself. Reality bends to your will.',
                damageMultiplier: 2.0,
                bonusStats: { wis: 15, magic: 10, con: 5 },
                newSpells: ['death_wave', 'summon_undead_army', 'soul_drain'],
                announcement: 'ğŸ’€ You have transcended mortality! You are now a LICH!'
            },
            archer: {
                advancedClass: 'deadeye',
                advancedName: 'Deadeye',
                description: 'Perfect marksman whose arrows never miss their mark.',
                damageMultiplier: 2.3,
                bonusStats: { dex: 15, lck: 10, str: 5 },
                newSpells: ['piercing_shot', 'rain_of_arrows'],
                announcement: 'ğŸ¹ Your aim is now perfect! You are now a DEADEYE!'
            },
            druid: {
                advancedClass: 'archdruid',
                advancedName: 'Archdruid',
                description: 'Master of nature and the primal forces of creation.',
                damageMultiplier: 2.0,
                bonusStats: { wis: 15, con: 10, str: 5 },
                newSpells: ['natures_wrath', 'wild_shape', 'earthquake'],
                announcement: 'ğŸŒ¿ Nature itself answers your call! You are now an ARCHDRUID!'
            },
            sorceror: {
                advancedClass: 'archmage',
                advancedName: 'Archmage',
                description: 'Master of all magic. Reality itself obeys your command.',
                damageMultiplier: 2.5,
                bonusStats: { wis: 20, magic: 15, cha: 5 },
                newSpells: ['apocalypse', 'time_stop', 'disintegrate'],
                announcement: 'ğŸ”® You have mastered all magic! You are now an ARCHMAGE!'
            },
            hunter: {
                advancedClass: 'beastlord',
                advancedName: 'Beastlord',
                description: 'Master of beasts and the wild. Animals bow to your command.',
                damageMultiplier: 2.2,
                bonusStats: { dex: 12, str: 8, con: 8, wis: 5 },
                newSpells: ['beast_stampede', 'primal_bond'],
                announcement: 'ğŸº All beasts obey you! You are now a BEASTLORD!'
            },
            rogue: {
                advancedClass: 'shadowmaster',
                advancedName: 'Shadowmaster',
                description: 'Master assassin who strikes from the void itself.',
                damageMultiplier: 2.5,
                bonusStats: { dex: 15, lck: 10, str: 5 },
                newSpells: ['shadow_strike', 'void_step'],
                announcement: 'ğŸ—¡ï¸ You have become one with the shadows! You are now a SHADOWMASTER!'
            },
            paladin: {
                advancedClass: 'crusader',
                advancedName: 'Crusader',
                description: 'Holy warrior blessed by the gods themselves.',
                damageMultiplier: 2.2,
                bonusStats: { str: 10, wis: 10, con: 8, cha: 5 },
                newSpells: ['holy_crusade', 'divine_shield', 'smite_evil'],
                announcement: 'âš¡ The heavens bless your crusade! You are now a CRUSADER!'
            },
            warlock: {
                advancedClass: 'demonlord',
                advancedName: 'Demonlord',
                description: 'Master of dark pacts who commands legions of demons.',
                damageMultiplier: 2.4,
                bonusStats: { wis: 18, cha: 12, con: 5 },
                newSpells: ['summon_demon', 'dark_pact', 'soul_harvest'],
                announcement: 'ğŸ˜ˆ You have bound demons to your will! You are now a DEMONLORD!'
            }
        };

        function evolveClass(player) {
            if (player.level !== 20) return false;
            if (player.hasEvolved) return false; // Already evolved
            
            const baseClass = player.class;
            const evolution = ADVANCED_CLASSES[baseClass];
            
            if (!evolution) return false;
            
            // Store original class
            player.baseClass = baseClass;
            player.class = evolution.advancedClass;
            player.className = evolution.advancedName;
            player.hasEvolved = true;
            
            // Apply bonus stats
            Object.keys(evolution.bonusStats).forEach(stat => {
                if (player[stat] !== undefined) {
                    player[stat] += evolution.bonusStats[stat];
                }
            });
            
            // Apply damage multiplier
            player.advancedClassMultiplier = evolution.damageMultiplier;
            
            // Add new spells
            evolution.newSpells.forEach(spell => {
                if (!player.knownSpells.includes(spell)) {
                    player.knownSpells.push(spell);
                }
            });
            
            // Heal to full and boost HP/MP
            player.maxHp = Math.floor(player.maxHp * 1.5);
            player.maxMp = Math.floor(player.maxMp * 1.5);
            player.hp = player.maxHp;
            player.mp = player.maxMp;
            
            return true;
        }

        function getAdvancedClassName(player) {
            if (player.hasEvolved && ADVANCED_CLASSES[player.baseClass]) {
                return ADVANCED_CLASSES[player.baseClass].advancedName;
            }
            return player.className || player.class;
        }

        function getClassDamageMultiplier(player) {
            return player.advancedClassMultiplier || 1.0;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // END ADVANCED CLASS SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function levelUp() {
            const p = gameState.player;
            
            // Cap at level 25
            if (p.level >= 25) {
                p.xp = p.xpToNext; // Pin running total at the max threshold
                return;
            }
            
            const oldLevel = p.level;
            p.level++;
            // XP is now a running total â€” do NOT subtract xpToNext.
            // Just raise the bar to the next level's cumulative threshold.
            p.xpToNext = getXpToNextLevel(p.baseClass || p.class, p.level);

            // HP/MP increases (CON scaling for HP)
            p.maxHp += 15 + (p.con||0);   // CON scales HP gain
            p.hp     = p.maxHp;
            p.maxMp += 10;
            p.mp     = p.maxMp;
            
            // Legacy stats still auto-increase for backwards compatibility
            p.strength += 2;
            p.defense  += 2;
            p.magic    += 2;
            p.speed    += 1;

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // NEW STAT POINT SYSTEM (3 points per level to allocate)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (p.statPoints === undefined) {
                p.statPoints = 0; // Initialize if not present (old saves)
            }
            p.statPoints += 3; // Give 3 stat points per level
            
            // Auto-allocate 1 point to each stat (base progression)
            if (p.str !== undefined) {
                p.str++; p.dex++; p.wis++; p.cha++; p.con++; p.lck++;
                // Paladin bonus: extra +1 to both STR and WIS
                if (p.class === 'paladin' || p.baseClass === 'paladin') { 
                    p.str++; p.wis++; 
                }
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CHECK FOR NEW ZONE DISCOVERY
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            Object.keys(LOCATIONS).forEach(key => {
                const loc = LOCATIONS[key];
                if (key !== 'town' && loc.requiredLevel === p.level) {
                    // Just reached the level for this zone!
                    termAppend('', 'term-separator');
                    termAppend(`<span style="color:#00FFFF;font-size:18px;">ğŸ—ºï¸ NEW AREA DISCOVERED!</span>`, 'term-victory');
                    termAppend(`<span style="color:#FFD700;">${loc.name} is now visible on the world map!</span>`, 'term-loot');
                    termAppend(`<span style="color:#8aaa8a;">Check "Explore World" to visit this area.</span>`, 'term-dim');
                }
            });
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CHECK FOR CLASS EVOLUTION AT LEVEL 20
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (p.level === 20 && evolveClass(p)) {
                const evolution = ADVANCED_CLASSES[p.baseClass];
                // Evolution message will be shown in endCombat
                p._justEvolved = true;
                p._evolutionMessage = evolution.announcement;
            }
            
            // Spells are no longer auto-learned - must be purchased at temple!
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // LOOT DROP SYSTEM (Phase 1)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function rollLoot(monster) {
            const loot = [];
            const rarityBonus = RARITY_CONFIG[monster.rarity].dropBonus || 0;
            
            if (!monster.possibleDrops || monster.possibleDrops.length === 0) {
                return loot;
            }
            
            monster.possibleDrops.forEach(itemKey => {
                let dropChance = 0;
                
                // Determine base drop chance
                if (ITEMS[itemKey]) {
                    // Consumable/sellable items use common drop rate
                    dropChance = monster.dropRates.common || 0.3;
                } else if (WEAPONS[itemKey] || ARMOR[itemKey]) {
                    // Equipment uses quality-based drop rates
                    const quality = getItemQuality(itemKey);
                    dropChance = monster.dropRates[quality] || 0.05;
                }
                
                // Apply rarity bonus + player LCK luck bonus
                const lckBonus = gameState.player ? calcLootBonus(gameState.player.lck || 0) / 100 : 0;
                const adjustedChance = Math.min(0.95, dropChance * (1 + rarityBonus * 0.1 + lckBonus));
                
                if (Math.random() < adjustedChance) {
                    loot.push(itemKey);
                }
            });
            
            // SPECIAL: Magical Butterknife check (Red Dragons only!)
            if (monster.key === 'red_dragon' && Math.random() < 0.000001) {
                loot.push('magical_butterknife');
                // Alert SYSOP terminal if active
                if (gameState.sysop && gameState.sysop.authenticated) {
                    terminalPrint('âš ï¸âš ï¸âš ï¸ ULTRA RARE DROP: MAGICAL BUTTERKNIFE! âš ï¸âš ï¸âš ï¸', 'success');
                }
            }

            // â”€â”€ GEM DROP: 2% base chance, any enemy, tier by enemy level â”€â”€
            if (Math.random() < 0.02) {
                const tier = getGemTier(monster.level || 1);
                const gemTypeKey = GEM_KEYS[Math.floor(Math.random() * GEM_KEYS.length)];
                const rawGemId = `raw_${gemTypeKey}_t${tier}`;
                loot.push(rawGemId);
            }
            
            return loot;
        }

        function getItemName(itemKey) {
            if (WEAPONS[itemKey]) return WEAPONS[itemKey].name;
            if (ARMOR[itemKey]) return ARMOR[itemKey].name;
            if (ITEMS[itemKey]) return ITEMS[itemKey].name;
            if (SPELLS[itemKey]) return SPELLS[itemKey].name;
            // Raw gems: raw_ruby_t1, raw_sapphire_t2, etc.
            if (typeof itemKey === 'string' && itemKey.startsWith('raw_')) {
                const parts = itemKey.split('_');
                const typeKey = parts[1];
                const tier = parts[2] ? parts[2].replace('t','') : '1';
                const gem = GEM_TYPES[typeKey];
                return gem ? `T${tier} Raw ${gem.name}` : itemKey;
            }
            // Cut gems stored as objects in inventory
            if (typeof itemKey === 'object' && itemKey && itemKey.cut) {
                return `${itemKey.name} [${itemKey.description}]`;
            }
            return itemKey;
        }

        function getItemColor(itemKey) {
            if (WEAPONS[itemKey]) {
                return QUALITY_CONFIG[WEAPONS[itemKey].quality].color;
            }
            if (ARMOR[itemKey]) {
                return QUALITY_CONFIG[ARMOR[itemKey].quality].color;
            }
            // Raw gems
            if (typeof itemKey === 'string' && itemKey.startsWith('raw_')) {
                const typeKey = itemKey.split('_')[1];
                return (GEM_TYPES[typeKey] && GEM_TYPES[typeKey].color) || '#AAFFEE';
            }
            // Default green for items
            return '#00FF00';
        }

        function getItemQualityText(itemKey) {
            if (WEAPONS[itemKey]) {
                const quality = WEAPONS[itemKey].quality;
                return `[${QUALITY_CONFIG[quality].name}]`;
            }
            if (ARMOR[itemKey]) {
                const quality = ARMOR[itemKey].quality;
                return `[${QUALITY_CONFIG[quality].name}]`;
            }
            return '';
        }

        function getItemQuality(itemKey) {
            if (WEAPONS[itemKey]) return WEAPONS[itemKey].quality;
            if (ARMOR[itemKey]) return ARMOR[itemKey].quality;
            return 'normal';
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // END LOOT DROP SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


        function respawn() {
            gameState.player.hp = gameState.player.maxHp;
            gameState.player.mp = gameState.player.maxMp;
            gameState.player.gold = Math.floor(gameState.player.gold / 2);
            gameState.combatState = null;
            showTown();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ADVENTURE SYSTEM (Choose-Your-Own-Adventure encounters)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function startAdventure(adventure) {
            gameState.currentAdventure = adventure;
            
            termAppend('', 'term-separator');
            termAppend(`<span style="color:#FFD700;font-size:20px;">âœ¨ ${adventure.name}! âœ¨</span>`, 'term-highlight');
            termAppend('', 'term-separator');
            termAppend(adventure.intro, 'term-dim');
            termAppend('', 'term-separator');
            termAppend('<span style="color:var(--highlight-color);">What do you do?</span>');
            termAppend('', 'term-separator');
            
            // Show choices
            adventure.choices.forEach((choice, index) => {
                termAppend(`<span style="color:var(--highlight-color);">${index + 1}.</span> ${choice.text}`, 'term-highlight');
            });
            
            // Render adventure action bar
            renderAdventureActionBar();
        }
        
        function renderAdventureActionBar() {
            const adventure = gameState.currentAdventure;
            if (!adventure) return;
            
            const ab = document.getElementById('actionBar');
            ab.style.display = 'flex';
            ab.innerHTML = '';
            
            adventure.choices.forEach((choice, index) => {
                const btn = document.createElement('button');
                btn.textContent = `${index + 1}. ${choice.text.substring(0, 30)}${choice.text.length > 30 ? '...' : ''}`;
                btn.style.fontSize = '12px';
                btn.style.padding = '6px';
                btn.onclick = () => chooseAdventurePath(index);
                ab.appendChild(btn);
            });
        }
        
        function chooseAdventurePath(choiceIndex) {
            const adventure = gameState.currentAdventure;
            if (!adventure) return;
            
            const choice = adventure.choices[choiceIndex];
            
            termAppend('', 'term-separator');
            termAppend(`<span style="color:var(--text-color);">â–º You choose: ${choice.text}</span>`, 'term-highlight');
            termAppend('', 'term-separator');
            
            // Roll for outcome
            let totalWeight = 0;
            choice.outcomes.forEach(o => totalWeight += o.weight);
            
            let roll = Math.random() * totalWeight;
            let selectedOutcome = choice.outcomes[0];
            
            for (const outcome of choice.outcomes) {
                roll -= outcome.weight;
                if (roll <= 0) {
                    selectedOutcome = outcome;
                    break;
                }
            }
            
            // Show outcome
            termAppend(selectedOutcome.text, 'term-highlight');
            
            // Apply rewards
            if (selectedOutcome.rewards) {
                applyAdventureRewards(selectedOutcome.rewards);
            }
            
            // Start combat if needed
            if (selectedOutcome.combat) {
                termAppend('', 'term-separator');
                gameState.currentAdventure = null;
                startCombat(selectedOutcome.combat);
                return;
            }
            
            // Check if this outcome leads to another choice
            if (selectedOutcome.nextChoices && selectedOutcome.nextChoices.length > 0) {
                // Continue the adventure with new choices
                termAppend('', 'term-separator');
                termAppend('<span style="color:var(--highlight-color);">What do you do?</span>');
                termAppend('', 'term-separator');
                
                // Update adventure choices
                adventure.choices = selectedOutcome.nextChoices;
                
                // Show new choices
                adventure.choices.forEach((choice, index) => {
                    termAppend(`<span style="color:var(--highlight-color);">${index + 1}.</span> ${choice.text}`, 'term-highlight');
                });
                
                // Render new choice buttons
                renderAdventureActionBar();
                return;
            }
            
            // Adventure over, return to exploration
            gameState.currentAdventure = null;
            termAppend('', 'term-separator');
            renderActionBar();
        }
        
        function applyAdventureRewards(rewards) {
            const p = gameState.player;
            
            if (rewards.gold) {
                p.gold = Math.max(0, p.gold + rewards.gold);
                if (rewards.gold > 0) {
                    termAppend(`<span style="color:#FFD700;">ğŸ’° +${rewards.gold} Gold!</span>`, 'term-loot');
                } else {
                    termAppend(`<span style="color:#FF6666;">ğŸ’° ${rewards.gold} Gold (paid)</span>`, 'term-error');
                }
            }
            
            if (rewards.xp) {
                p.xp += rewards.xp;
                termAppend(`<span style="color:#88FF88;">â­ +${rewards.xp} XP!</span>`, 'term-loot');
                
                // Check for level up
                while (p.xp >= p.xpToNext && p.level < 25) {
                    levelUp();
                    termAppend(`â¬†ï¸ LEVEL UP! You are now level ${p.level}!`, 'term-victory');
                    
                    // Check for class evolution
                    if (p._justEvolved) {
                        termAppend('', 'term-separator');
                        termAppend(`<span style="color:#FF00FF;font-size:24px;font-weight:bold;">âš¡ CLASS EVOLUTION! âš¡</span>`, 'term-victory');
                        termAppend(p._evolutionMessage, 'term-victory');
                        termAppend(`<span style="color:#FFD700;">Your power has DOUBLED!</span>`, 'term-loot');
                        p._justEvolved = false;
                        p._evolutionMessage = null;
                    }
                }
            }
            
            if (rewards.damage) {
                p.hp -= rewards.damage;
                termAppend(`<span style="color:#FF6666;">ğŸ’” Took ${rewards.damage} damage!</span>`, 'term-error');
                if (p.hp <= 0) {
                    p.hp = 1; // Can't die from adventure damage
                    termAppend(`<span style="color:#FFAA00;">You barely survive!</span>`, 'term-warning');
                }
            }
            
            if (rewards.heal === 'full') {
                p.hp = p.maxHp;
                p.mp = p.maxMp;
                termAppend(`<span style="color:#00FF00;">âœ¨ Fully restored!</span>`, 'term-victory');
            }
            
            if (rewards.items) {
                rewards.items.forEach(itemKey => {
                    p.inventory.push(itemKey);
                    const item = ITEMS[itemKey] || WEAPONS[itemKey] || ARMOR[itemKey];
                    if (item) {
                        termAppend(`<span style="color:#00FFFF;">ğŸ Received: ${item.name}!</span>`, 'term-loot');
                    } else {
                        termAppend(`<span style="color:#00FFFF;">ğŸ Received: ${itemKey}!</span>`, 'term-loot');
                    }
                });
            }
            
            if (rewards.spell) {
                if (!p.knownSpells.includes(rewards.spell)) {
                    p.knownSpells.push(rewards.spell);
                    termAppend(`<span style="color:#FF00FF;">ğŸ“– Learned spell: ${rewards.spell}!</span>`, 'term-victory');
                }
            }
            
            updateHud();
            saveGame();
        }


        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CHARACTER STATS & STAT ALLOCATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function showCharacterStats() {
            checkGameVersion();
            const p = gameState.player;
            const screen = document.getElementById('mainScreen');
            
            // Initialize stat points if not present (old saves)
            if (p.statPoints === undefined) p.statPoints = 0;
            
            const hasPoints = p.statPoints > 0;
            
            screen.innerHTML = `
                <div class="location-header">ğŸ“Š CHARACTER STATS</div>
                <button onclick="showTown()" style="margin-bottom:10px;">â† BACK TO TOWN</button>
                ${renderPlayerStats()}
                
                <div class="message" style="border-color:${hasPoints ? '#FFD700' : 'var(--border-color)'};">
                    <p><strong style="color:${hasPoints ? '#FFD700' : 'var(--highlight-color)'};">Available Stat Points: ${p.statPoints}</strong></p>
                    ${hasPoints ? '<p style="color:#00FF00;">You have unspent stat points! Allocate them below.</p>' : '<p style="color:#888;">You gain 3 stat points per level up.</p>'}
                </div>
                
                <div class="message">
                    <h3 style="color:var(--highlight-color);">Core Stats</h3>
                    ${renderStatRow('STR (Strength)', p.str, 'Increases physical damage')}
                    ${renderStatRow('DEX (Dexterity)', p.dex, 'Increases dodge, accuracy, crit chance')}
                    ${renderStatRow('CON (Constitution)', p.con, 'Increases HP gain per level')}
                    ${renderStatRow('WIS (Wisdom)', p.wis, 'Increases spell damage and magic defense')}
                    ${renderStatRow('CHA (Charisma)', p.cha, 'Reduces shop prices and inn costs')}
                    ${renderStatRow('LCK (Luck)', p.lck, 'Increases crit chance and rare drops')}
                </div>
                
                <div class="message">
                    <h3 style="color:var(--highlight-color);">Derived Stats</h3>
                    <p><span class="stat-label">Level:</span> ${p.level}</p>
                    <p><span class="stat-label">XP:</span> ${p.xp} / ${p.xpToNext}</p>
                    <p><span class="stat-label">HP:</span> ${p.hp} / ${p.maxHp}</p>
                    <p><span class="stat-label">MP:</span> ${p.mp} / ${p.maxMp}</p>
                    <p><span class="stat-label">Physical Damage:</span> ${calculatePhysicalDamage()}</p>
                    <p><span class="stat-label">Magic Damage:</span> ${calculateMagicDamage()}</p>
                    <p><span class="stat-label">Defense:</span> ${calculateTotalDefense()}</p>
                    <p><span class="stat-label">Crit Chance:</span> ${calcCritChance(p.lck, p)}%</p>
                </div>
                
                ${hasPoints ? `
                    <div class="message" style="border-color:#FFD700;">
                        <h3 style="color:#FFD700;">Allocate Stat Points (${p.statPoints} remaining)</h3>
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;">
                            <button onclick="allocateStat('str')">+1 STR</button>
                            <button onclick="allocateStat('dex')">+1 DEX</button>
                            <button onclick="allocateStat('con')">+1 CON</button>
                            <button onclick="allocateStat('wis')">+1 WIS</button>
                            <button onclick="allocateStat('cha')">+1 CHA</button>
                            <button onclick="allocateStat('lck')">+1 LCK</button>
                        </div>
                    </div>
                ` : ''}
                
                <button onclick="showTown()">â† BACK TO TOWN</button>
            `;
        }
        
        function renderStatRow(name, value, description) {
            return `
                <p>
                    <span class="stat-label">${name}:</span> 
                    <span style="color:#FFD700;">${value}</span>
                    <span style="color:#888;font-size:12px;"> - ${description}</span>
                </p>
            `;
        }
        
        function calculatePhysicalDamage() {
            const p = gameState.player;
            const weapon = WEAPONS[p.weapon] || { baseDamage: 1, quality: 'poor' };
            const qBonus = getQualityBonus(weapon.quality, weapon.baseDamage);
            let weaponDamage = weapon.baseDamage + qBonus;
            if (p.level <= 5) weaponDamage = Math.floor(weaponDamage * 0.7);
            return weaponDamage + (p.str || 0);
        }
        
        function calculateMagicDamage() {
            const p = gameState.player;
            const weapon = WEAPONS[p.weapon] || { baseMagicDamage: 0, baseDamage: 0, quality: 'poor' };
            const qBonus = getQualityBonus(weapon.quality, weapon.baseMagicDamage || 0);
            return (weapon.baseMagicDamage || 0) + qBonus + (p.magic || 0) + (p.wis || 0);
        }
        
        /**
         * Get bonus damage from weapon modifiers for offensive spells
         * Only applies to damage/lifesteal spells, not healing
         */
        function getWeaponModifierSpellBonus() {
            const p = gameState.player;
            if (!p || !p.weapon) return 0;
            
            const weapon = WEAPONS[p.weapon];
            if (!weapon || !weapon.modifiers || weapon.modifiers.length === 0) return 0;
            
            // Check if WEAPON_MODIFIERS is available
            if (typeof WEAPON_MODIFIERS === 'undefined') return 0;
            
            let totalBonus = 0;
            weapon.modifiers.forEach(modKey => {
                const mod = WEAPON_MODIFIERS[modKey];
                if (mod && mod.minDamage) {
                    // Roll for bonus damage (min to max)
                    const bonusDmg = Math.floor(Math.random() * (mod.maxDamage - mod.minDamage + 1)) + mod.minDamage;
                    totalBonus += bonusDmg;
                }
            });
            
            return totalBonus;
        }
        
        function calculateTotalDefense() {
            const p = gameState.player;
            const armor = ARMOR[p.armor] || { baseDefense: 0, quality: 'poor' };
            const qBonus = getQualityBonus(armor.quality, armor.baseDefense);
            return armor.baseDefense + qBonus + (p.con || 0);
        }
        
        function allocateStat(statName) {
            const p = gameState.player;
            
            if (p.statPoints <= 0) {
                alert('No stat points available!');
                return;
            }
            
            p[statName]++;
            p.statPoints--;
            
            // Update max HP if CON was increased
            if (statName === 'con') {
                p.maxHp += 1; // Small bonus for increasing CON
                p.hp = Math.min(p.hp, p.maxHp);
            }
            
            saveGame();
            showCharacterStats(); // Refresh display
        }
        

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BLACKSMITH â€” Cut gems (200g) and Socket gems (100g)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function showBlacksmith(subview) {
            const p = gameState.player;
            const screen = document.getElementById('mainScreen');
            subview = subview || 'main';

            // â”€â”€ Helper: find raw gems in inventory â”€â”€
            function getRawGems() {
                return (p.inventory || []).filter(k => typeof k === 'string' && k.startsWith('raw_'));
            }
            // â”€â”€ Helper: find cut gems (objects) in inventory â”€â”€
            function getCutGems() {
                return (p.inventory || []).filter(k => typeof k === 'object' && k && k.cut);
            }

            const anvil = `<pre style="color:#cc5500;font-size:9.5px;line-height:1.18;text-align:center;font-family:'Courier New',monospace;">
            ___________________
      _____/                   \_____
     /    /   V A L D R A K ' S \    \
    /    /        F O R G E      \    \
   /    /___________________________\   \
   |   /  .  .  A N V I L  .  .  \   |
   |  /____________________________\  |
   | /  _________________________  \ |
   |/ /  ~~~~~~~ FIRE ~~~~~~~~~~  \ \|
   | |   ğŸ”¥   ğŸ”¥   ğŸ”¥   ğŸ”¥   ğŸ”¥  | |
   |_|_________________________________|_|
     |        âš’ï¸  SMITH  âš’ï¸           |
     |___________________________________|</pre>`;

            if (subview === 'main') {
                const rawCount = getRawGems().length;
                const cutCount = getCutGems().length;
                screen.innerHTML = `
                    <div class="location-header">âš’ï¸ VALDRAK'S FORGE</div>
                    ${anvil}
                    <div class="message" style="color:#cc7733;font-style:italic;text-align:center;margin-bottom:12px;">
                        "Bring me your rough stones and I'll make them sing."<br>
                        <span style="font-size:11px;color:#664422;">â€” Valdrak, Master Smith</span>
                    </div>
                    <div style="margin:16px 0;">
                        <div class="menu-option" onclick="showBlacksmith('cut')" style="border-color:#FF7722;">
                            â–º ğŸ’ CUT GEMS <span style="color:#888;font-size:12px;">(200g each â€” ${rawCount} raw gem${rawCount!==1?'s':''} in bag)</span>
                        </div>
                        <div class="menu-option" onclick="showBlacksmith('socket')" style="border-color:#c8a000;">
                            â–º âš™ï¸ SOCKET GEM INTO WEAPON <span style="color:#888;font-size:12px;">(100g â€” ${cutCount} cut gem${cutCount!==1?'s':''} available)</span>
                        </div>
                        <div class="menu-option" onclick="showBlacksmith('info')" style="border-color:#444;">
                            â–º ğŸ“– HOW GEMS WORK
                        </div>
                        <div class="menu-option" onclick="showTown()">â† BACK TO TOWN</div>
                    </div>`;
            }

            else if (subview === 'cut') {
                const rawGems = getRawGems();
                if (rawGems.length === 0) {
                    screen.innerHTML = `
                        <div class="location-header">âš’ï¸ CUT GEMS</div>
                        ${anvil}
                        <div class="message" style="color:#888;text-align:center;padding:20px;">
                            You have no raw gems to cut.<br>
                            <span style="font-size:12px;color:#555;">Gems drop from enemies (2% chance). Keep adventuring!</span>
                        </div>
                        <button onclick="showBlacksmith()" style="margin-top:10px;">â† BACK</button>`;
                    return;
                }
                let gemListHtml = rawGems.map(gk => {
                    const parts = gk.split('_');
                    const typeKey = parts[1];
                    const tier = parts[2] ? parseInt(parts[2].replace('t','')) : 1;
                    const gem = GEM_TYPES[typeKey];
                    const canAfford = p.gold >= 200;
                    return `<div style="display:flex;align-items:center;justify-content:space-between;padding:8px 12px;margin:4px 0;border:1px solid ${gem?gem.color:'#444'};background:rgba(0,0,0,0.3);">
                        <span style="color:${gem?gem.color:'#ccc'};">${gem?gem.emoji:'ğŸ’'} T${tier} Raw ${gem?gem.name:typeKey} <span style="color:#555;font-size:11px;">${gem?gem.desc:''}</span></span>
                        <button onclick="doCutGem('${gk}')" ${canAfford?'':'disabled title="Not enough gold"'}
                            style="border-color:#FF7722;color:#FF7722;font-size:12px;padding:4px 10px;">CUT (200g)</button>
                    </div>`;
                }).join('');
                screen.innerHTML = `
                    <div class="location-header">âš’ï¸ CUT GEMS â€” ${p.gold}g</div>
                    ${anvil}
                    <div class="message" style="color:#888;font-size:12px;text-align:center;">
                        Cutting reveals a gem's permanent stats at random. Stats cannot be rerolled.
                    </div>
                    <div style="margin:10px 0;">${gemListHtml}</div>
                    <button onclick="showBlacksmith()" style="margin-top:8px;">â† BACK</button>`;
            }

            else if (subview === 'socket') {
                const weapon = p.weapon ? WEAPONS[p.weapon] : null;
                const cutGems = getCutGems();
                if (!weapon) {
                    screen.innerHTML = `<div class="location-header">âš’ï¸ SOCKET GEM</div>${anvil}
                        <div class="message" style="color:#888;text-align:center;padding:20px;">You have no weapon equipped.</div>
                        <button onclick="showBlacksmith()">â† BACK</button>`;
                    return;
                }
                const slots = getGemSlots(weapon.quality);
                const usedSlots = (weapon.gems || []).length;
                const openSlots = slots - usedSlots;
                if (cutGems.length === 0) {
                    screen.innerHTML = `<div class="location-header">âš’ï¸ SOCKET GEM</div>${anvil}
                        <div class="message" style="color:#888;text-align:center;padding:20px;">
                            You have no cut gems to socket.<br>
                            <span style="font-size:12px;">Cut a raw gem first at the forge.</span>
                        </div>
                        <button onclick="showBlacksmith()">â† BACK</button>`;
                    return;
                }
                const slotsHtml = Array.from({length:slots}).map((_,i) => {
                    const g = (weapon.gems||[])[i];
                    return g
                        ? `<span style="color:${g.color};">${g.emoji} ${g.name} [${g.description}]</span>`
                        : `<span style="color:#444;">[ OPEN SLOT ]</span>`;
                }).join('<br>');
                const gemButtons = openSlots > 0 ? cutGems.map((g,idx) =>
                    `<div style="display:flex;align-items:center;justify-content:space-between;padding:8px 12px;margin:4px 0;border:1px solid ${g.color};background:rgba(0,0,0,0.3);">
                        <span style="color:${g.color};">${g.emoji} ${g.name}<br><span style="color:#888;font-size:11px;">${g.description}</span></span>
                        <button onclick="doSocketGem(${idx})" ${p.gold>=100?'':'disabled title="Need 100g"'}
                            style="border-color:#c8a000;color:#c8a000;font-size:12px;padding:4px 10px;">SOCKET (100g)</button>
                    </div>`).join('')
                : `<div style="color:#888;text-align:center;padding:10px;">No open slots. Gems are permanent once socketed.</div>`;

                screen.innerHTML = `
                    <div class="location-header">âš’ï¸ SOCKET GEM â€” ${p.gold}g</div>
                    ${anvil}
                    <div style="padding:10px 16px;border:1px solid #333;margin:8px 0;">
                        <div style="color:#ccc;font-size:13px;margin-bottom:4px;">âš’ï¸ ${weapon.name} <span style="color:#888;font-size:11px;">[${weapon.quality}]</span></div>
                        <div style="font-size:12px;color:#888;">Slots: ${usedSlots}/${slots} used</div>
                        <div style="margin-top:4px;font-size:12px;">${slotsHtml}</div>
                    </div>
                    <div style="margin-top:10px;color:#aaa;font-size:12px;text-align:center;">âš ï¸ Socketed gems are permanent and cannot be removed.</div>
                    <div style="margin:8px 0;">${gemButtons}</div>
                    <button onclick="showBlacksmith()" style="margin-top:8px;">â† BACK</button>`;
            }

            else if (subview === 'info') {
                screen.innerHTML = `
                    <div class="location-header">âš’ï¸ HOW GEMS WORK</div>
                    ${anvil}
                    <div class="message" style="font-size:13px;line-height:1.6;">
                        <p><strong style="color:#FF7722;">Finding Gems</strong><br>
                        Raw gems have a <strong>2% drop chance</strong> from any enemy. Enemy level determines gem tier:<br>
                        Lv1-6 = Tier 1 &nbsp;|&nbsp; Lv7-12 = Tier 2 &nbsp;|&nbsp; Lv13-18 = Tier 3 &nbsp;|&nbsp; Lv19+ = Tier 4</p>
                        <p><strong style="color:#c8a000;">Cutting (200g)</strong><br>
                        Cutting a raw gem gives it permanent random stats. Higher tier gems roll stronger bonuses. Stats cannot be rerolled â€” choose wisely.</p>
                        <p><strong style="color:#00FF88;">Socketing (100g)</strong><br>
                        Socket a cut gem into your equipped weapon. Once socketed, a gem <strong>cannot be removed or replaced</strong>.</p>
                        <p><strong style="color:#AA88FF;">Gem Slots by Quality</strong><br>
                        Normal/Rare: 1 slot &nbsp;|&nbsp; Epic: 2 slots &nbsp;|&nbsp; Legendary: 3 slots &nbsp;|&nbsp; Godly: 4 slots</p>
                        <p><strong style="color:#FF6688;">Gem Colors â€” Original</strong><br>
                        ğŸ”´ Ruby: Weapon DMG + Lifesteal &nbsp;|&nbsp; ğŸ”µ Sapphire: Spell Power + MP<br>
                        ğŸŸ¡ Topaz: Crit + Lightning &nbsp;|&nbsp; ğŸŸ¢ Emerald: Poison + STR<br>
                        ğŸŸ£ Amethyst: Defense + HP &nbsp;|&nbsp; â¬› Onyx: Armor Pierce + Speed<br>
                        ğŸ”· Opal: Luck + Gold Find &nbsp;|&nbsp; ğŸŸ¤ Garnet: STR + CON</p>
                        <p><strong style="color:#FF6688;">Gem Colors â€” Rare</strong><br>
                        ğŸ©¸ Bloodstone: Max HP + HP Regen per turn<br>
                        ğŸŒ™ Moonstone: MP Regen per turn + Cooldown reduction<br>
                        â˜€ï¸ Sunstone: Fire DMG + STR (works on spells)<br>
                        ğŸ”® Voidstone: Spell Leech â†’ absorbs MP + WIS<br>
                        ğŸ©¶ Ironheart: Defense + CON<br>
                        â›ˆï¸ Stormglass: Lightning DMG + Frost DMG (both elements, both damage types)</p>
                        <p style="color:#888;font-size:11px;">Lightning, Fire, Frost, Poison all apply to both melee and spells.<br>
                        Weapon DMG (Ruby) is melee only. Spell Power (Sapphire) is spells only.<br>
                        Lifesteal (Ruby) works on both melee and spells.</p>
                    </div>
                    <button onclick="showBlacksmith()">â† BACK</button>`;
            }
        }

        function doCutGem(rawGemKey) {
            const p = gameState.player;
            if (p.gold < 200) { alert("You need 200 gold to cut a gem."); return; }
            const idx = p.inventory.indexOf(rawGemKey);
            if (idx < 0) { alert("Gem not found in inventory."); return; }
            p.gold -= 200;
            p.inventory.splice(idx, 1);
            const cut = cutGem(rawGemKey);
            if (!cut) { alert("Could not cut gem â€” unknown type."); p.gold += 200; return; }
            p.inventory.push(cut);
            saveGame();
            const parts = rawGemKey.split('_');
            const typeKey = parts[1];
            const gem = GEM_TYPES[typeKey];
            // Show result flash
            const flash = document.createElement('div');
            flash.style.cssText = `position:fixed;top:15px;left:50%;transform:translateX(-50%);background:#0a0a0a;border:2px solid ${gem?gem.color:'#FF7722'};padding:14px 24px;color:${gem?gem.color:'#FF7722'};font-size:15px;z-index:9999;text-align:center;max-width:340px;`;
            flash.innerHTML = `âš’ï¸ <strong>Gem Cut!</strong><br><span style="font-size:12px;color:#ccc;">${cut.name}<br>${cut.description}</span>`;
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 3500);
            showBlacksmith('cut');
        }

        function doSocketGem(cutGemInventoryIndex) {
            const p = gameState.player;
            if (p.gold < 100) { alert("You need 100 gold to socket a gem."); return; }
            const weapon = p.weapon ? WEAPONS[p.weapon] : null;
            if (!weapon) { alert("No weapon equipped."); return; }
            if (!weapon.gems) weapon.gems = [];
            const slots = getGemSlots(weapon.quality);
            if (weapon.gems.length >= slots) { alert("No open slots on this weapon."); return; }
            // Find cut gems in inventory
            const cutGems = p.inventory.filter(k => typeof k === 'object' && k && k.cut);
            const gem = cutGems[cutGemInventoryIndex];
            if (!gem) { alert("Gem not found."); return; }
            const invIdx = p.inventory.indexOf(gem);
            if (invIdx < 0) { alert("Gem not in inventory."); return; }
            if (!confirm(`Socket ${gem.name} into ${weapon.name}? This is permanent and cannot be undone.`)) return;
            p.gold -= 100;
            p.inventory.splice(invIdx, 1);
            weapon.gems.push(gem);
            saveGame();
            const flash = document.createElement('div');
            flash.style.cssText = `position:fixed;top:15px;left:50%;transform:translateX(-50%);background:#0a0a0a;border:2px solid ${gem.color};padding:14px 24px;color:${gem.color};font-size:15px;z-index:9999;text-align:center;max-width:340px;`;
            flash.innerHTML = `âš™ï¸ <strong>Gem Socketed!</strong><br><span style="font-size:12px;color:#ccc;">${gem.name} fused into ${weapon.name} permanently.</span>`;
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 3500);
            showBlacksmith('socket');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TEMPLE OF REBIRTH (Stat Reset)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function showTemple() {
            checkGameVersion();
            const p = gameState.player;
            const screen = document.getElementById('mainScreen');
            
            // Calculate total stat points that have been allocated
            const totalAllocated = calculateTotalAllocatedPoints();
            const respecCost = calculateRespecCost(p.level);
            
            screen.innerHTML = `
                <div class="location-header">â›ª TEMPLE</div>
                <button onclick="showTown()" style="margin-bottom:10px;">â† BACK TO TOWN</button>
                ${renderPlayerStats()}
                
                <div class="message">
                    <p style="color:var(--highlight-color);font-size:16px;">
                        <strong>Welcome to the Temple</strong>
                    </p>
                    <p>
                        Here, the priests offer spiritual services: ${(p.baseClass || p.class) === 'hunter' ? 'pet training,' : ''} spell training${(p.baseClass || p.class) === 'hunter' ? ',' : ''} and personal rebirth.
                    </p>
                </div>
                
                <div style="margin: 20px 0;">
                    ${(p.baseClass || p.class) === 'hunter' ? '<div class="menu-option" onclick="showPetTrainer()">ğŸº PET TRAINING</div>' : ''}
                    <div class="menu-option" onclick="showSpellShop()">ğŸ“– SPELL TRAINING</div>
                    <div class="menu-option" onclick="showRespec()">ğŸ”„ STAT RESPEC (${respecCost}g)</div>
                    <button onclick="showTown()">â† BACK TO TOWN</button>
                </div>
            `;
        }
        
        function showRespec() {
            const p = gameState.player;
            const screen = document.getElementById('mainScreen');
            
            const totalAllocated = calculateTotalAllocatedPoints();
            const respecCost = calculateRespecCost(p.level);
            
            screen.innerHTML = `
                <div class="location-header">ğŸ”„ STAT RESPEC</div>
                <button onclick="showTemple()" style="margin-bottom:10px;">â† BACK</button>
                ${renderPlayerStats()}
                
                <div class="message" style="border-color:#8aaa8a;">
                    <p>Refund all allocated stat points to rebuild your character.</p>
                </div>
                
                <div class="message" style="border-color:#FFD700;">
                    <h3 style="color:#FFD700;">Respec Info</h3>
                    <p><span class="stat-label">Level:</span> ${p.level}</p>
                    <p><span class="stat-label">Allocated:</span> ${totalAllocated}</p>
                    <p><span class="stat-label">Available:</span> ${p.statPoints || 0}</p>
                    <p><span class="stat-label">Cost:</span> <span style="color:#FFD700;">${respecCost}g</span></p>
                </div>
                
                <div class="message" style="border-color:var(--error-color);">
                    <p style="color:var(--error-color);"><strong>âš ï¸ Warning:</strong> This resets ALL stat points.</p>
                </div>
                
                <div style="margin: 20px 0;">
                    ${p.gold >= respecCost ? `<button onclick="confirmRespec()" style="border-color:#FFD700;">ğŸ’° RESPEC (${respecCost}g)</button>` : `<button disabled>Need ${respecCost - p.gold}g more</button>`}
                    <button onclick="showTemple()">â† BACK</button>
                </div>
            `;
        }
        
        function calculateTotalAllocatedPoints() {
            const p = gameState.player;
            // Each level gives 3 points, so total available = level * 3
            const totalAvailable = (p.level - 1) * 3; // -1 because level 1 has no points yet
            const remaining = p.statPoints || 0;
            return totalAvailable - remaining;
        }
        
        function calculateRespecCost(level) {
            // Cost scales with level: 1000g per level
            return level * 1000;
        }
        
        function confirmRespec() {
            const p = gameState.player;
            const cost = calculateRespecCost(p.level);
            
            if (p.gold < cost) {
                alert('Not enough gold!');
                return;
            }
            
            if (!confirm(`Are you sure you want to respec for ${cost} gold? This will refund all your allocated stat points.`)) {
                return;
            }
            
            performRespec();
        }
        
        function performRespec() {
            const p = gameState.player;
            const cost = calculateRespecCost(p.level);
            
            // Deduct gold
            p.gold -= cost;
            
            // Calculate how many points were manually allocated
            const totalLevelPoints = (p.level - 1) * 3;
            
            // Reset stats to base (level 1 + auto-gains)
            // Auto-gains: +1 to each stat per level (except paladin gets +2 str/wis)
            const baseLevels = p.level - 1; // Levels gained beyond 1
            
            p.str = 10 + baseLevels; // Base 10 + 1 per level
            p.dex = 10 + baseLevels;
            p.wis = 10 + baseLevels;
            p.cha = 10 + baseLevels;
            p.con = 10 + baseLevels;
            p.lck = 10 + baseLevels;
            
            // Paladin bonus (gets extra str/wis each level)
            if (p.class === 'paladin' || p.baseClass === 'paladin') {
                p.str += baseLevels;
                p.wis += baseLevels;
            }
            
            // Refund all allocated points
            p.statPoints = totalLevelPoints;
            
            // Recalculate HP based on new CON
            p.maxHp = 100 + (p.level - 1) * 15 + ((p.level - 1) * (p.con - 10)); // Base + level gains + con bonus
            p.hp = Math.min(p.hp, p.maxHp);
            
            saveGame();
            
            alert(`Respec complete! You have ${p.statPoints} stat points to reallocate.`);
            showCharacterStats();
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SPELL SHOP - Temple Spell Training
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function showSpellShop() {
            const p = gameState.player;
            const screen = document.getElementById('mainScreen');
            
            // Get class spell tree
            const classKey = p.baseClass || p.class;
            const spellTree = CLASS_SPELL_TREES[classKey];
            
            if (!spellTree) {
                screen.innerHTML = `
                    <div class="location-header">ğŸ“– SPELL TRAINING</div>
                    ${renderPlayerStats()}
                    <div class="message" style="border-color:var(--error-color);">
                        <p>Your class (${classKey}) does not have spell training available.</p>
                    </div>
                    <button onclick="showTemple()">â† BACK TO TEMPLE</button>
                `;
                return;
            }
            
            // Build spell lists
            const availableSpells = [];   // can learn now
            const upcomingSpells  = [];   // locked by level (but prereq met or no prereq)
            const currentSpells   = [];   // already known

            Object.entries(spellTree.spellTree).forEach(([key, spell]) => {
                const hasSpell       = p.knownSpells.includes(key);
                const levelReq       = p.level >= spell.level;
                const meetsReq       = !spell.requires || p.knownSpells.includes(spell.requires);
                const canAfford      = p.gold >= spell.cost;

                // Check if this spell has already been superseded â€” i.e. the player knows
                // a spell that lists this one as its 'requires' (meaning they skipped past it).
                const alreadySuperseded = Object.values(spellTree.spellTree).some(
                    s => s.requires === key && p.knownSpells.includes(s.requires === key ? s.requires : null)
                ) || p.knownSpells.some(known => {
                    const knownSpell = spellTree.spellTree[known];
                    return knownSpell && knownSpell.requires === key;
                });

                if (hasSpell) {
                    currentSpells.push({ key, spell });
                } else if (!alreadySuperseded && levelReq && meetsReq) {
                    availableSpells.push({ key, spell, canAfford });
                } else if (!hasSpell && !levelReq && meetsReq && !alreadySuperseded) {
                    // Coming soon â€” player hasn't reached the level yet
                    upcomingSpells.push({ key, spell });
                }
            });
            
            let html = `
                <div class="location-header">ğŸ“– SPELL TRAINING</div>
                <button onclick="showTemple()" style="margin-bottom:10px;">â† BACK</button>
                ${renderPlayerStats()}
                
                <div class="message">
                    <p style="color:var(--highlight-color);"><strong>The priests offer to teach you the sacred arts</strong></p>
                    <p style="color:#8aaa8a;">Learn new spells or upgrade existing ones</p>
                </div>
            `;
            
            // Show current spells
            if (currentSpells.length > 0) {
                html += `<div class="message" style="border-color:#00FF00;"><h3 style="color:#00FF00;">Your Known Spells</h3>`;
                currentSpells.forEach(({ key, spell }) => {
                    const typeColor = spell.type === 'heal' || spell.type === 'lifesteal' ? '#00FF00' : '#FF6666';
                    const typeIcon = spell.type === 'heal' ? 'ğŸ’š' : spell.type === 'lifesteal' ? 'ğŸ©¸' : spell.type === 'aoe_damage' ? 'ğŸ”¥' : 'ğŸ’¥';
                    const lifestealInfo = spell.lifestealPercent ? ` (${spell.lifestealPercent}%)` : '';
                    const aoeTag = spell.type === 'aoe_damage' ? ' <span style="color:#FF8800;">[AOE]</span>' : '';
                    const powerDisplay = spell.minPower !== undefined ? `${spell.minPower}â€“${spell.maxPower}` : '?';
                    html += `<p>${typeIcon} <strong>${spell.name}${aoeTag}</strong> - <span style="color:${typeColor};">${powerDisplay} ${spell.type === 'heal' ? 'HP' : 'DMG'}${lifestealInfo}</span> (${spell.mpCost} MP)${spell.upgradesTo ? `<br><span style="color:#FFD700;font-size:12px;">â†’ Upgrade available</span>` : ''}</p>`;
                });
                html += `</div>`;
            }
            
            // Show available spells
            if (availableSpells.length > 0) {
                html += `<div class="message" style="border-color:#FFD700;"><h3 style="color:#FFD700;">Available Training</h3>`;
                availableSpells.forEach(({ key, spell, canAfford }) => {
                    const typeColor = spell.type === 'heal' || spell.type === 'lifesteal' ? '#00FF00' : '#FF6666';
                    const typeIcon = spell.type === 'heal' ? 'ğŸ’š' : spell.type === 'lifesteal' ? 'ğŸ©¸' : spell.type === 'aoe_damage' ? 'ğŸ”¥' : 'ğŸ’¥';
                    const lifestealInfo = spell.lifestealPercent ? ` (${spell.lifestealPercent}% lifesteal)` : '';
                    const aoeTag = spell.type === 'aoe_damage' ? ' <span style="color:#FF8800;">[AOE]</span>' : '';
                    const isUpgrade = spell.requires && p.knownSpells.includes(spell.requires);
                    
                    const powerDisplay2 = spell.minPower !== undefined ? `${spell.minPower}â€“${spell.maxPower}` : '?';
                    html += `<div style="margin:10px 0;padding:10px;border:1px solid ${canAfford ? '#FFD700' : '#666'};"><p>${typeIcon} <strong style="color:${typeColor};">${spell.name}${aoeTag}</strong> ${isUpgrade ? '(Upgrade)' : '(New)'}<br><span style="font-size:12px;">${spell.description}</span><br><span style="color:${typeColor};">${powerDisplay2} ${spell.type === 'heal' ? 'HP' : 'DMG'}${lifestealInfo}</span> | ${spell.mpCost} MP | Level ${spell.level}<br><span style="color:#FFD700;">Cost: ${spell.cost}g</span></p>${canAfford ? `<button onclick="learnSpell('${key}')" style="border-color:#FFD700;">ğŸ’° Learn (${spell.cost}g)</button>` : `<button disabled style="opacity:0.5;">Need ${spell.cost - p.gold}g more</button>`}</div>`;
                });
                html += `</div>`;
            } else {
                html += `<div class="message"><p style="color:#888;">No new spells available at your level.</p></div>`;
            }

            // Show upcoming locked spells
            if (upcomingSpells.length > 0) {
                html += `<div class="message" style="border-color:#444;"><h3 style="color:#888;">Coming Soon</h3>`;
                upcomingSpells.forEach(({ key, spell }) => {
                    const typeIcon = spell.type === 'heal' ? 'ğŸ’š' : spell.type === 'lifesteal' ? 'ğŸ©¸' : spell.type === 'aoe_damage' ? 'ğŸ”¥' : 'ğŸ’¥';
                    const aoeTag = spell.type === 'aoe_damage' ? ' <span style="color:#664400;">[AOE]</span>' : '';
                    html += `<div style="margin:8px 0;padding:8px;border:1px solid #333;opacity:0.6;">
                        <p>${typeIcon} <strong style="color:#666;">${spell.name}${aoeTag}</strong> â€” Unlocks at <span style="color:#888;">Level ${spell.level}</span><br>
                        <span style="font-size:12px;color:#555;">${spell.description}</span><br>
                        <span style="color:#666;">${spell.mpCost} MP | Cost: ${spell.cost}g</span></p>
                    </div>`;
                });
                html += `</div>`;
            }
            
            html += `<button onclick="showTemple()">â† BACK</button>`;
            screen.innerHTML = html;
        }
        
        function learnSpell(spellKey) {
            const p = gameState.player;
            const classKey = p.baseClass || p.class;
            const spell = CLASS_SPELL_TREES[classKey].spellTree[spellKey];
            
            if (!spell || p.gold < spell.cost || p.level < spell.level) {
                alert('Cannot learn this spell!');
                return;
            }
            
            if (spell.requires && !p.knownSpells.includes(spell.requires)) {
                alert('Learn previous spell first!');
                return;
            }
            
            p.gold -= spell.cost;
            
            // Remove old spell if upgrade
            if (spell.requires) {
                const idx = p.knownSpells.indexOf(spell.requires);
                if (idx > -1) p.knownSpells.splice(idx, 1);
            }
            
            p.knownSpells.push(spellKey);
            
            // Add to SPELLS if not present
            if (!SPELLS[spellKey]) {
                SPELLS[spellKey] = { ...spell, pipCost: 1 };
            }

            // â”€â”€ Enforce slot order after every learn â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Slot 1 = single-target (damage / heal for healers)
            // Slot 2 = AOE (heal for healers)
            // Rule: for healer classes damage goes first, for others single-target damage first, AOE second
            const healerClasses = ['cleric','priest','paladin','shaman'];
            const isHealer = healerClasses.includes(classKey);

            p.knownSpells.sort((a, b) => {
                const sa = SPELLS[a] || CLASS_SPELL_TREES[classKey]?.spellTree?.[a];
                const sb = SPELLS[b] || CLASS_SPELL_TREES[classKey]?.spellTree?.[b];
                if (!sa || !sb) return 0;
                function rank(s) {
                    if (isHealer) {
                        // healers: damage=0 (slot1), heal=1 (slot2), aoe=2
                        if (s.type === 'damage') return 0;
                        if (s.type === 'heal' || s.type === 'lifesteal') return 1;
                        if (s.type === 'aoe_damage') return 2;
                        return 3;
                    } else {
                        // mages/others: single-target damage=0 (slot1), aoe=1 (slot2), heal=2
                        if (s.type === 'damage') return 0;
                        if (s.type === 'aoe_damage') return 1;
                        if (s.type === 'heal' || s.type === 'lifesteal') return 2;
                        return 3;
                    }
                }
                return rank(sa) - rank(sb);
            });
            
            saveGame();
            alert(`Learned ${spell.name}!`);
            showSpellShop();
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PET TRAINER (Hunter Only)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function showPetTrainer() {
            const p = gameState.player;
            const screen = document.getElementById('mainScreen');
            
            if ((p.baseClass || p.class) !== 'hunter') {
                screen.innerHTML = `
                    <div class="location-header">ğŸº PET TRAINING</div>
                    ${renderPlayerStats()}
                    <div class="message" style="border-color:var(--error-color);">
                        <p>The beast trainer shakes their head. "Only hunters may bond with beasts."</p>
                    </div>
                    <button onclick="showTemple()">â† BACK TO TEMPLE</button>
                `;
                return;
            }
            
            // Determine current and next pet
            const currentPet = p.activePet ? HUNTER_PETS[p.activePet] : null;
            const nextPetKey = currentPet?.upgradesTo || (p.level >= 3 ? 'hunting_dog' : null);
            const nextPet = nextPetKey ? HUNTER_PETS[nextPetKey] : null;
            
            let html = `
                <div class="location-header">ğŸº PET TRAINING</div>
                <button onclick="showTemple()" style="margin-bottom:10px;">â† BACK</button>
                ${renderPlayerStats()}
                
                <div class="message">
                    <p style="color:var(--highlight-color);"><strong>The Beast Trainer greets you with a pack of loyal companions</strong></p>
                    <p style="color:#8aaa8a;">Bond with a beast to fight alongside you in battle</p>
                </div>
            `;
            
            // Show current pet
            if (currentPet) {
                html += `
                    <div class="message" style="border-color:#00FF00;">
                        <h3 style="color:#00FF00;">Your Current Companion</h3>
                        <p>${currentPet.icon} <strong style="color:#00FF00;">${currentPet.name}</strong> (Level ${currentPet.level})</p>
                        <p style="font-size:14px;color:#8aaa8a;">${currentPet.description}</p>
                        <p><span style="color:#FFD700;">Damage:</span> ${Math.floor(currentPet.damagePercent * 100)}% of weapon damage + ${currentPet.bonusDamage}</p>
                        ${currentPet.upgradesTo ? '<p style="color:#FFD700;font-size:12px;">â†’ Upgrade available!</p>' : '<p style="color:#888;">Max level companion</p>'}
                    </div>
                `;
            } else {
                html += `
                    <div class="message" style="border-color:#666;">
                        <p style="color:#888;">You don't have a companion yet.</p>
                        ${p.level >= 3 ? '<p style="color:#FFD700;">You can bond with your first pet!</p>' : `<p style="color:#888;">Reach level 3 to bond with a pet.</p>`}
                    </div>
                `;
            }
            
            // Show available upgrade
            if (nextPet && p.level >= nextPet.level) {
                const canAfford = p.gold >= nextPet.cost;
                html += `
                    <div class="message" style="border-color:#FFD700;">
                        <h3 style="color:#FFD700;">${currentPet ? 'Available Upgrade' : 'First Companion'}</h3>
                        <div style="margin:10px 0;padding:10px;border:1px solid ${canAfford ? '#FFD700' : '#666'};">
                            <p>${nextPet.icon} <strong style="color:#FFD700;">${nextPet.name}</strong> ${currentPet ? '(Upgrade)' : '(Bond)'}</p>
                            <p style="font-size:12px;color:#8aaa8a;">${nextPet.description}</p>
                            <p><span style="color:#FFD700;">Damage:</span> ${Math.floor(nextPet.damagePercent * 100)}% of weapon damage + ${nextPet.bonusDamage}</p>
                            <p style="font-size:12px;">Requires Level ${nextPet.level} | Cost: <span style="color:#FFD700;">${nextPet.cost}g</span></p>
                            ${canAfford 
                                ? `<button onclick="upgradePet('${nextPetKey}')" style="border-color:#FFD700;">ğŸ’° ${currentPet ? 'Upgrade' : 'Bond'} (${nextPet.cost}g)</button>`
                                : `<button disabled style="opacity:0.5;">Need ${nextPet.cost - p.gold}g more</button>`
                            }
                        </div>
                    </div>
                `;
            } else if (nextPet) {
                html += `
                    <div class="message" style="border-color:#444;">
                        <h3 style="color:#888;">Coming Soon</h3>
                        <div style="margin:8px 0;padding:8px;border:1px solid #333;opacity:0.6;">
                            <p>${nextPet.icon} <strong style="color:#666;">${nextPet.name}</strong> â€” Unlocks at Level ${nextPet.level}</p>
                            <p style="font-size:12px;color:#555;">${nextPet.description}</p>
                            <p style="color:#666;">${Math.floor(nextPet.damagePercent * 100)}% weapon damage + ${nextPet.bonusDamage} | Cost: ${nextPet.cost}g</p>
                        </div>
                    </div>
                `;
            }
            
            // Show pet progression path
            html += `
                <div class="message" style="border-color:#444;">
                    <h3 style="color:#8aaa8a;">Companion Progression</h3>
                    <p style="font-size:12px;color:#666;">
                        Lv 3: ğŸ• Dog (35%) â†’ Lv 6: ğŸº Wolf (40%) â†’ Lv 9: ğŸº Dire Wolf (45%) â†’ <br>
                        Lv 12: ğŸ‘»ğŸ• Shadow Hound (50%) â†’ Lv 15: ğŸº Warg (55%) â†’ <br>
                        Lv 18: ğŸ”¥ğŸ• Hellhound (60%) â†’ Lv 21: ğŸŒ™ğŸº Fenrir (70%)
                    </p>
                </div>
            `;
            
            html += `<button onclick="showTemple()">â† BACK</button>`;
            screen.innerHTML = html;
        }
        
        function upgradePet(petKey) {
            const p = gameState.player;
            const pet = HUNTER_PETS[petKey];
            
            if (!pet || p.gold < pet.cost || p.level < pet.level) {
                alert('Cannot bond with this companion!');
                return;
            }
            
            // Deduct gold and set new pet
            p.gold -= pet.cost;
            p.activePet = petKey;
            
            saveGame();
            alert(`${pet.icon} You bonded with ${pet.name}! They will fight by your side!`);
            showPetTrainer();
        }


        // Start the game
        
        // Load all class spells from CLASS_SPELL_TREES
        if (typeof CLASS_SPELL_TREES !== 'undefined') {
            loadAllClassSpells();
        }
        
        checkGameVersion();
        initGame();



    </script>
</body>
</html>