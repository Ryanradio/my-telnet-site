<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>âš”ï¸ DUNGEON QUEST  âš”ï¸</title>
   
   
   <style>

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ GLOBAL LAYOUT FIX (PUT THIS FIRST) â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
*,
*::before,
*::after {
    box-sizing: border-box;
}

html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden; /* prevents whole-page scrolling */
}

body {
    -webkit-user-select: none;
    user-select: none;
    touch-action: manipulation;
}

#gameWrapper {
    height: 100vh;
    height: 100dvh;   /* dynamic viewport height (fixes iOS) */
    display: flex;
    flex-direction: column;
    overflow: hidden;
    width: 100%;
}

#actionBar button {
    min-width: 64px;
    min-height: 44px;
    padding: 10px 14px;
    font-size: 16px;
    border-radius: 10px;
}

        @import url('https://fonts.googleapis.com/css2?family=VT323&family=Press+Start+2P&display=swap');

        :root {
            --primary-bg: #000080;
            --secondary-bg: #000000;
            --text-color: #00FF00;
            --highlight-color: #FFFF00;
            --error-color: #FF0000;
            --border-color: #00FFFF;
            --menu-color: #FFFFFF;
        }

        body {
            background: var(--primary-bg);
            color: var(--text-color);
            font-family: 'VT323', monospace;
            font-size: 20px;
            line-height: 1.4;
        }

        .scanline {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                transparent 50%,
                rgba(0, 0, 0, 0.25) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 1000;
            animation: flicker 0.15s infinite;
        }

        @keyframes flicker {
            0% { opacity: 0.95; }
            50% { opacity: 1; }
            100% { opacity: 0.95; }
        }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }

        @keyframes flashOrange {
            0%, 100% { color: #FF8C00; text-shadow: 0 0 6px #FF8C00; }
            50%      { color: #FFD700; text-shadow: 0 0 14px #FFD700; }
        }

        @keyframes flashRed {
            0%, 100% { color: #FF0000; text-shadow: 0 0 6px #FF0000; }
            50%      { color: #FF4444; text-shadow: 0 0 14px #FF4444; }
        }

        .dmg-player {
            animation: flashOrange 0.6s ease-in-out infinite;
            font-weight: bold;
        }

        .dmg-enemy {
            animation: flashRed 0.6s ease-in-out infinite;
            font-weight: bold;
        }

     .container {
    height: 100%;
    max-width: 900px;
    margin: 0 auto;
    padding: 0;
    display: flex;
    flex-direction: column;
    overflow: hidden; /* prevent container overflow */
}


        .header {
            flex-shrink: 0; /* prevent header from shrinking */
            text-align: center;
            border: 3px double var(--border-color);
            padding: 8px;
            margin-bottom: 8px;
            background: var(--secondary-bg);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .header h1 {
            font-family: 'Press Start 2P', monospace;
            font-size: 20px;
            color: var(--highlight-color);
            text-shadow: 2px 2px var(--error-color);
            margin-bottom: 5px;
            animation: titlePulse 2s infinite;
            transition: all 0.3s ease;
        }
        
        .header p {
            margin: 0;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        /* Compact header during gameplay */
        body.terminal-mode .header {
            padding: 4px;
            margin-bottom: 4px;
            border-width: 2px;
        }
        
        body.terminal-mode .header h1 {
            font-size: 12px;
            margin-bottom: 2px;
            animation: none; /* disable pulse during gameplay */
        }
        
        body.terminal-mode .header > div {
            display: none; /* hide decorative lines and subtitle */
        }

        @keyframes titlePulse {
            0%, 100% { text-shadow: 2px 2px var(--error-color); }
            50% { text-shadow: 2px 2px var(--error-color), 0 0 10px var(--highlight-color); }
        }
        
        @keyframes flash-green {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3) hue-rotate(10deg); }
        }
        
        @keyframes flash-blue {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2) hue-rotate(-20deg); }
        }

        /* â”€â”€â”€ main screen used by town / shop / menus â”€â”€â”€ */
        .screen {
            flex: 1 1 auto; /* allow screen to grow/shrink */
            min-height: 0; /* critical for flex scrolling */
            overflow-y: auto; /* enable scrolling */
            -webkit-overflow-scrolling: touch; /* smooth scrolling on iOS */
            
            background: var(--secondary-bg);
            border: 2px solid var(--border-color);
            padding: 12px;
            margin-bottom: 8px;
            box-shadow: inset 0 0 50px rgba(0, 255, 0, 0.1);
        }
        
        .menu-option {
            color: var(--menu-color);
            cursor: pointer;
            padding: 8px;
            margin: 5px 0;
            transition: all 0.1s;
        }
        .menu-option:hover {
            background: var(--primary-bg);
            color: var(--highlight-color);
            padding-left: 20px;
        }
        .menu-option.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            color: #666;
        }
        .menu-option.disabled:hover {
            background: transparent;
            padding-left: 8px;
        }

        /* â”€â”€â”€ static HUD â”€â”€â”€ */
#hud {
    display: none; /* JS controls visibility */
    flex-shrink: 0; /* prevent HUD from shrinking */
    
    background: var(--secondary-bg);
    border: 2px solid var(--border-color);
    border-bottom: none;
    padding: 6px 10px;
    box-shadow: inset 0 0 30px rgba(0,255,0,0.08);
}


        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 4px;
        }
        .hud-top .hud-name { color: var(--highlight-color); font-size: 18px; }
        .hud-top .hud-gold { color: #FFD700; font-size: 16px; }
        .hud-bars {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }
        .hud-bar-group label {
            color: var(--highlight-color);
            font-size: 14px;
            display: block;
            margin-bottom: 2px;
        }
        .hud-bar-group .bar-nums { color: var(--text-color); font-size: 14px; }
        .progress-bar {
            width: 100%;
            height: 12px;
            background: #111;
            border: 1px solid var(--border-color);
            margin-top: 2px;
        }
        .progress-fill { height: 100%; transition: width 0.35s ease; }
        .hp-bar { background: var(--error-color); }
        .mp-bar { background: #4488ff; }
        .xp-bar { background: var(--text-color); }

        /* â”€â”€â”€ scrolling terminal â”€â”€â”€ */
#terminalWindow {
    display: none;
    flex: 1 1 auto;
    min-height: 0; /* REQUIRED for flex scrolling */
    overflow-y: auto;
    -webkit-overflow-scrolling: touch; /* smooth scrolling on iOS */
    
    background: var(--secondary-bg);
    border: 2px solid var(--border-color);
    border-top: 1px solid #333;
    padding: 8px 10px;
    box-shadow: inset 0 0 40px rgba(0,255,0,0.07);
    scroll-behavior: smooth;
}

        .term-line {
            padding: 2px 0;
            font-size: 16px;
            color: var(--text-color);
            line-height: 1.3;
        }
        .term-line.term-dim       { color: #3a7a3a; }
        .term-line.term-highlight { color: var(--highlight-color); }
        .term-line.term-enemy     { color: var(--border-color); font-size: 17px; }
        .term-line.term-loot      { font-size: 17px; }
        .term-line.term-system    { color: #888; font-style: italic; }
        .term-line.term-separator { margin-top: 6px; padding-top: 6px; border-top: 1px solid #2a4a2a; }

        /* â”€â”€â”€ action bar at bottom â”€â”€â”€ */
#actionBar {
    flex: 0 0 110px;
    height: 110px;

    background: var(--secondary-bg);
    border: 2px solid var(--border-color);
    border-top: 1px solid #444;

    display: flex;
    justify-content: center;
    align-items: center;

    gap: 6px;
    padding: 6px;

    box-sizing: border-box;
}


        #actionBar button {
            background: linear-gradient(180deg, #1a1a1a 0%, #0a0a0a 100%);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            padding: 8px 12px;
            font-family: 'VT323', monospace;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.15s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
            min-width: 60px;
            min-height: 40px;
        }
        
        /* Combat action buttons */
        .action-icon-btn {
            flex: 1;
            min-width: 80px !important;
            padding: 10px 8px !important;
            text-align: center;
        }
        
        /* Target selection buttons */
        .target-btn {
            flex: 1;
            min-width: 120px !important;
            padding: 10px !important;
            background: linear-gradient(180deg, #0a2a0a 0%, #051505 100%) !important;
            border-color: var(--text-color) !important;
        }
        
        .target-btn:hover:not(:disabled) {
            background: linear-gradient(180deg, #0f3f0f 0%, #0a2a0a 100%) !important;
            border-color: var(--highlight-color) !important;
            color: var(--highlight-color) !important;
        }
        
        /* Spell selection buttons */
        .spell-btn {
            flex: 1;
            min-width: 100px !important;
            padding: 10px !important;
            background: linear-gradient(180deg, #1a1a2a 0%, #0a0a15 100%) !important;
            border-color: #4488ff !important;
        }
        
        .spell-btn:hover:not(:disabled) {
            background: linear-gradient(180deg, #2a2a4a 0%, #1a1a2a 100%) !important;
            border-color: #88bbff !important;
            color: #88bbff !important;
        }
        #actionBar button:hover {
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
            color: var(--highlight-color);
            border-color: var(--highlight-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 255, 0, 0.3);
        }
        #actionBar button:active {
            transform: translateY(0);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.8);
        }
        #actionBar button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        /* Mobile adjustments */
        @media (max-width: 600px) {
            .header {
                padding: 6px;
                margin-bottom: 6px;
            }
            
            .header h1 {
                font-size: 16px;
                margin-bottom: 3px;
            }
            
            .header p {
                font-size: 14px;
            }
            
            /* Even more compact header during gameplay on mobile */
            body.terminal-mode .header {
                padding: 3px;
                margin-bottom: 3px;
                border-width: 1px;
            }
            
            body.terminal-mode .header h1 {
                font-size: 10px;
                margin-bottom: 0;
            }
            
            #hud {
                padding: 4px 8px;
            }
            
            .hud-top .hud-name { font-size: 16px; }
            .hud-top .hud-gold { font-size: 14px; }
            
            .hud-bars {
                grid-template-columns: 1fr;
                gap: 4px;
            }
            
            .hud-bar-group label {
                font-size: 13px;
            }
            
            .hud-bar-group .bar-nums {
                font-size: 13px;
            }
            
            .progress-bar {
                height: 10px;
            }
            
            #terminalWindow {
                padding: 6px 8px;
            }
            
            .term-line {
                font-size: 15px;
                line-height: 1.25;
            }
            
            #actionBar {
                padding: 4px;
                gap: 3px;
            }
            
            #actionBar button {
                font-size: 12px;
                padding: 5px 6px;
                min-width: 40px;
                min-height: 36px;
            }
            
            /* Compact dungeon navigation on mobile */
            #actionBar > div {
                gap: 3px;
            }
        }

        .term-line.term-victory   { color: var(--border-color); font-size: 22px; }
        .term-line.term-loot      { color: #FFD700; }
        .term-line.term-error     { color: var(--error-color); }
        .term-line.term-separator { border-top: 1px solid #2a5a2a; margin: 6px 0 4px; padding-top: 4px; }
        .enemy-card {
            border: 2px solid var(--error-color);
            padding: 8px 12px;
            margin: 6px 0;
            background: rgba(255,0,0,0.05);
            display: inline-block;
            min-width: 260px;
            vertical-align: top;
        }
        .enemy-card.is-target { border-color: var(--highlight-color); }
        .enemy-card .ec-name  { font-size: 21px; margin-bottom: 4px; }
        .enemy-card .ec-hp    { font-size: 18px; color: var(--text-color); }

   
   
  #actionBar {
    flex-shrink: 0;

    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;

    padding: 12px;
    background: var(--secondary-bg);
    border-top: 2px solid var(--border-color);
}



#actionBar button {
    flex: 0 0 auto;
}





        #actionBar .action-label { color: var(--highlight-color); font-size: 18px; margin-bottom: 6px; }
        #actionBar .timer-line   { color: var(--highlight-color); font-size: 19px; margin-bottom: 4px; }

        /* â”€â”€â”€ legacy helpers for shop / inventory / town â”€â”€â”€ */
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid var(--border-color);
            background: rgba(0,128,0,0.1);
        }
        .stat       { color: var(--text-color); }
        .stat-label { color: var(--highlight-color); }
        .message {
            padding: 10px;
            margin: 10px 0;
            border-left: 3px solid var(--border-color);
        }
        .combat-message  { color: var(--highlight-color); font-weight: bold; }
        .error-message   { color: var(--error-color); }
        .success-message { color: var(--border-color); }

        button {
            background: var(--secondary-bg);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            padding: 10px 20px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) {
            background: var(--primary-bg);
            color: var(--highlight-color);
            box-shadow: 0 0 10px var(--border-color);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        input {
            background: var(--secondary-bg);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            padding: 10px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            width: 100%;
            margin: 10px 0;
        }

        .character-select {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .class-card {
            border: 2px solid var(--border-color);
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--secondary-bg);
        }

        .class-card:hover {
            background: var(--primary-bg);
            box-shadow: 0 0 15px var(--border-color);
            transform: scale(1.05);
        }

        .class-card.selected {
            border-color: var(--highlight-color);
            background: var(--primary-bg);
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .item-card {
            border: 1px solid var(--border-color);
            padding: 10px;
            background: rgba(0, 128, 0, 0.05);
        }

        .equipped {
            border-color: var(--highlight-color);
            background: rgba(255, 255, 0, 0.1);
        }

        .cursor {
            display: inline-block;
            width: 10px;
            height: 20px;
            background: var(--text-color);
            animation: blink 1s infinite;
            margin-left: 5px;
        }

        .location-header {
            font-family: 'Press Start 2P', monospace;
            font-size: 16px;
            color: var(--border-color);
            text-align: center;
            padding: 10px;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: 15px;
        }

        .enemy-display {
            text-align: center;
            padding: 20px;
            border: 2px solid var(--error-color);
            margin: 15px 0;
            background: rgba(255, 0, 0, 0.05);
        }

        .ascii-art {
            font-family: monospace;
            font-size: 14px;
            line-height: 1.2;
            white-space: pre;
            color: var(--text-color);
        }

        /* SYSOP Terminal Styles */
        .terminal-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--secondary-bg);
            border-top: 3px solid var(--error-color);
            padding: 10px 20px;
            z-index: 999;
            max-height: 300px;
            overflow-y: auto;
            display: none;
            box-shadow: 0 -5px 20px rgba(255, 0, 0, 0.5);
        }

        .terminal-container.active {
            display: block;
            animation: terminalSlideUp 0.3s;
        }

        @keyframes terminalSlideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        .terminal-header {
            color: var(--error-color);
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            margin-bottom: 10px;
            text-align: center;
            border-bottom: 1px solid var(--error-color);
            padding-bottom: 5px;
        }

        .terminal-output {
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
            color: var(--text-color);
        }

        .terminal-line {
            margin: 3px 0;
        }

        .terminal-error {
            color: var(--error-color);
        }

        .terminal-success {
            color: var(--border-color);
        }

        .terminal-warning {
            color: var(--highlight-color);
        }

        .terminal-input-line {
            display: flex;
            align-items: center;
        }

        .terminal-prompt {
            color: var(--error-color);
            margin-right: 10px;
        }

        .terminal-input {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--text-color);
            font-family: 'VT323', monospace;
            font-size: 20px;
            outline: none;
        }

        .sysop-badge {
            position: fixed;
            top: 10px;
            right: 10px;
            background: var(--error-color);
            color: var(--secondary-bg);
            padding: 5px 10px;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            border: 2px solid var(--highlight-color);
            z-index: 998;
            display: none;
            animation: badgePulse 2s infinite;
        }

        .sysop-badge.active {
            display: block;
        }

        @keyframes badgePulse {
            0%, 100% { box-shadow: 0 0 5px var(--error-color); }
            50% { box-shadow: 0 0 20px var(--error-color); }
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1001;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: var(--secondary-bg);
            border: 3px solid var(--error-color);
            padding: 20px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 30px var(--error-color);
        }


        .action-icon-btn {
            width: 52px;
            height: 52px;
            font-size: 24px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 2px solid var(--border-color);
            background: var(--secondary-bg);
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .action-icon-btn:hover:not(:disabled) {
            background: var(--primary-bg);
            border-color: var(--highlight-color);
            transform: scale(1.05);
        }
        
        .action-icon-btn:active:not(:disabled) {
            transform: scale(0.95);
        }
        
        .action-icon-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RESPONSIVE MOBILE/TABLET DESIGN
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        @media (max-width: 768px) {
            body {
                font-size: 18px;
                padding: 0;
                margin: 0;
            }
            
            .container {
                max-width: 100%;
                padding: 8px;
                margin: 0;
            }
            
            .header {
                padding: 8px;
                margin-bottom: 8px;
            }
            
            .header h1 {
                font-size: 18px;
                margin-bottom: 4px;
            }
            
            .header .subtitle {
                font-size: 12px;
            }
            
            .screen {
                padding: 10px;
                min-height: 300px;
                margin-bottom: 10px;
            }
            
            .location-header {
                font-size: 20px;
                padding: 8px;
                margin-bottom: 8px;
            }
            
            .stats-bar {
                font-size: 16px;
                padding: 8px;
                margin-bottom: 8px;
            }
            
            .progress-bar {
                height: 12px;
            }
            
            .menu-option {
                padding: 10px;
                font-size: 18px;
                margin: 6px 0;
            }
            
            button {
                padding: 10px 15px;
                font-size: 16px;
                margin: 4px 2px;
            }
            
            input[type="text"] {
                font-size: 18px;
                padding: 10px;
                width: 100%;
                box-sizing: border-box;
            }
            
            /* Character select cards - stack vertically */
            .character-select {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .class-card {
                padding: 12px;
            }
            
            .class-card div {
                font-size: 16px !important;
            }
            
            /* Inventory grid - 2 columns on mobile */
            .inventory-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }
            
            .item-card {
                padding: 8px;
                font-size: 15px;
            }
            
            .item-card button {
                padding: 6px 10px;
                font-size: 14px;
            }
            
            /* HUD - compact on mobile */
            #hud > div {
                padding: 6px !important;
                font-size: 16px !important;
            }
            
            #hud > div > div {
                gap: 10px !important;
            }
            
           /* Terminal - adjust for mobile screen */
#terminalWindow {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
    font-size: 17px;
}

            
            .term-line {
                font-size: 17px;
                line-height: 1.3;
                margin: 3px 0;
            }
            
            /* Enemy cards removed - info shown in terminal only */
            
            /* Action bar - stack buttons vertically on very small screens */
            #actionBar {
                padding: 8px;
            }
            
            #actionBar button {
                margin: 3px 2px;
                padding: 8px 10px;
                font-size: 15px;
            }
            
            .action-icon-btn {
                width: 48px;
                height: 48px;
                font-size: 22px;
            }
            
            .action-label {
                font-size: 16px;
                margin: 6px 0 3px 0;
            }
            
            /* Stat allocation screen */
            #mainScreen > div[style*="max-width:520px"] {
                max-width: 100% !important;
            }
            
            /* Make tables/grids more compact */
            .message {
                padding: 10px;
                font-size: 17px;
            }
            
            .stat-label {
                font-size: 17px;
            }
            
            /* ASCII art - smaller on mobile */
            .ascii-art {
                font-size: 10px;
                line-height: 1.1;
            }
        }
        
        /* Extra small phones */
        @media (max-width: 480px) {
            body {
                font-size: 16px;
            }
            
            .container {
                padding: 4px;
            }
            
            .header h1 {
                font-size: 16px;
            }
            
            button {
                padding: 8px 12px;
                font-size: 14px;
                margin: 3px 1px;
            }
            
            .menu-option {
                padding: 8px;
                font-size: 16px;
            }
            
            #terminalWindow {
                
                padding: 8px;
                font-size: 16px;
            }
            
            .term-line {
                font-size: 16px;
            }
            
            /* Inventory - single column on very small screens */
            .inventory-grid {
                grid-template-columns: 1fr;
            }
            
            /* Action icon buttons stay as icons on small phones */
            .action-icon-btn {
                width: 44px;
                height: 44px;
                font-size: 20px;
            }
            
            /* Other action bar buttons (target selection, etc) */
            #actionBar button:not(.action-icon-btn) {
                padding: 8px 12px;
                margin: 3px 2px;
            }
            
            .location-header {
                font-size: 18px;
            }
            
            /* Enemy cards removed - info shown in terminal only */
        }
        
        /* Landscape tablets */
        @media (min-width: 769px) and (max-width: 1024px) {
            .container {
                max-width: 95%;
                padding: 15px;
            }
            
            .character-select {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .inventory-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        /* Portrait tablets */
        @media (min-width: 481px) and (max-width: 768px) and (orientation: portrait) {
            .character-select {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .inventory-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            #terminalWindow {
                }
        }
        
        /* Prevent text selection on double-tap (mobile) */
        @media (hover: none) and (pointer: coarse) {
            button, .menu-option, .class-card, .item-card, .enemy-card {
                -webkit-tap-highlight-color: rgba(0, 255, 0, 0.2);
                user-select: none;
                -webkit-user-select: none;
            }
        }

       
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   TERMINAL MODE â€“ SHOW GAMEPLAY UI
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* Hide menu when in terminal mode */
body.terminal-mode #mainScreen {
    display: none;
}

/* Hide gameplay wrapper when NOT in terminal mode */
body:not(.terminal-mode) #gameWrapper {
    display: none;
}

/* Show gameplay wrapper in terminal mode */
body.terminal-mode #gameWrapper {
    display: flex;
    flex-direction: column;
    height: 100%;
}

/* HUD and action bar should be visible */
body.terminal-mode #hud,
body.terminal-mode #actionBar {
    display: block;
}

/* Terminal should fill remaining space */
body.terminal-mode #terminalWindow {
    display: block;
    flex: 1;
    min-height: 0;   /* IMPORTANT for flex scroll */
    overflow-y: auto;
}


        
    </style>
</head>
<body>
    <div class="scanline"></div>
    
    <div class="container">
        <div class="header">
            <h1>âš”ï¸ DUNGEON QUEST âš”ï¸</h1>
            <div style="color: var(--border-color);">â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</div>
            <div style="color: var(--menu-color); font-size: 16px;">A Classic Text Adventure</div>
        </div>

  
  <div class="screen" id="mainScreen">
    <!-- Menu / town content -->
</div>

<!-- GAMEPLAY WRAPPER -->
<div id="gameWrapper">

    <!-- HUD -->
    <div id="hud">
        <div class="hud-inner">
            <div id="hudName"></div>
            <div class="hud-stats">
                <span id="hudGold"></span>
                <span id="hudHpNums"></span>
                <span id="hudMpNums"></span>
                <span id="hudXpNums"></span>
            </div>
        </div>
    </div>

    <!-- TERMINAL -->
    <div id="terminalWindow"></div>

    <!-- ACTION BAR -->
    <div id="actionBar"></div>

</div>


</div>

    </div>
</div>    

    <!-- SYSOP Terminal -->
    <div class="sysop-badge" id="sysopBadge">âš  SYSOP MODE âš </div>
    <div class="terminal-container" id="terminalContainer">
        <div class="terminal-header">â•â•â• SYSOP TERMINAL â•â•â•</div>
        <div class="terminal-output" id="terminalOutput"></div>
        <div class="terminal-input-line">
            <span class="terminal-prompt">root@dungeon:~#</span>
            <input type="text" class="terminal-input" id="terminalInput" autocomplete="off">
        </div>
    </div>

    <!-- Modal for forms -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal-content" id="modalContent"></div>
    </div>

    <!-- External Game Data Files -->
    <script src="dungeon-data.js"></script>
    <script src="monsters.js"></script>
    <script src="weapons.js"></script>
    <script src="armor.js"></script>
    <script src="items.js"></script>
    <script src="class-masters.js"></script>
    <script src="exploration-zones.js"></script>
    <script src="adventures.js"></script>

    <script>

        // ğŸ”‘ Prevent UI reset after restore (mobile fix)
// gameState.hasRestoredGame = false;


function updateTerminalSafeArea() {
    const term = document.getElementById('terminalWindow');
    const bar  = document.getElementById('actionBar');
    if (!term || !bar) return;

    const barHeight = bar.offsetHeight;
    term.style.paddingBottom = barHeight + 'px';
}



// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Direction helpers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const OPPOSITE_DIR = {
    N: 'South',
    S: 'North',
    E: 'West',
    W: 'East',
    NE: 'Southwest',
    NW: 'Southeast',
    SE: 'Northwest',
    SW: 'Northeast'
};



        // Game Data Structures
        const CLASSES = {
            warrior: {
                name: 'Warrior',
                hp: 120,
                mp: 20,
                strength: 15,
                defense: 12,
                magic: 3,
                speed: 7,
                description: 'Master of melee combat with high HP and defense',
                startWeapon: 'iron_sword',
                startArmor: 'leather_armor'
            },
            rogue: {
                name: 'Rogue',
                hp: 80,
                mp: 30,
                strength: 10,
                defense: 6,
                magic: 5,
                speed: 15,
                description: 'Swift and deadly, strikes first with critical hits',
                startWeapon: 'dagger',
                startArmor: 'cloth_armor'
            },
            paladin: {
                name: 'Paladin',
                hp: 100,
                mp: 50,
                strength: 12,
                defense: 10,
                magic: 8,
                speed: 8,
                description: 'Holy warrior with healing magic and strong defense',
                startWeapon: 'mace',
                startArmor: 'chainmail'
            },
            mage: {
                name: 'Mage',
                hp: 60,
                mp: 100,
                strength: 5,
                defense: 4,
                magic: 18,
                speed: 9,
                description: 'Powerful spellcaster with devastating magic',
                startWeapon: 'staff',
                startArmor: 'robes'
            },
            cleric: {
                name: 'Cleric',
                hp: 90,
                mp: 70,
                strength: 8,
                defense: 8,
                magic: 12,
                speed: 7,
                description: 'Divine healer with support spells and moderate combat',
                startWeapon: 'mace',
                startArmor: 'leather_armor'
            },
            ranger: {
                name: 'Ranger',
                hp: 85,
                mp: 40,
                strength: 11,
                defense: 7,
                magic: 6,
                speed: 13,
                description: 'Skilled archer with nature magic and tracking',
                startWeapon: 'bow',
                startArmor: 'leather_armor'
            }
        };


        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STAT SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const STAT_BUDGET  = 30;
        const STAT_NAMES   = ['str','dex','wis','cha','con','lck'];
        const STAT_LABELS  = { str:'STR', dex:'DEX', wis:'WIS', cha:'CHA', con:'CON', lck:'LCK' };
        const STAT_DESCS   = {
            str:'Physical damage & multi-hit',
            dex:'Dodge chance & flee success',
            wis:'Spell power & magic resist',
            cha:'Shop prices & negotiation',
            con:'Max HP bonus & defense',
            lck:'Crit chance & loot luck'
        };
        // Opposed pairs: reroll engine biases against extremes in both.
        // Paladin is EXEMPT from str<->wis opposition.
        const OPPOSED_PAIRS = [['str','wis'],['dex','cha'],['con','lck']];

        const CLASS_STAT_PRESETS = {
            warrior : { str:10, dex:4, wis:2, cha:2, con:8, lck:4 },
            rogue   : { str:4,  dex:10,wis:2, cha:4, con:4, lck:6 },
            paladin : { str:7,  dex:3, wis:7, cha:4, con:6, lck:3 },
            mage    : { str:2,  dex:3, wis:10,cha:3, con:4, lck:8 },
            cleric  : { str:3,  dex:2, wis:9, cha:6, con:6, lck:4 },
            ranger  : { str:5,  dex:8, wis:3, cha:3, con:5, lck:6 }
        };
        const CLASS_AFFINITIES = {
            warrior :['str','con'],
            rogue   :['dex','lck'],
            paladin :['str','wis','cha'],
            mage    :['wis','lck'],
            cleric  :['wis','cha'],
            ranger  :['dex','lck']
        };

        // â”€â”€ derived-stat helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function calcPlayerHits(p) {
            let h = 1;
            if (p.class === 'rogue') h++;           // rogue class bonus
            h += Math.floor((p.level || 1) / 4);    // +1 every 4 levels
            h += Math.floor(Math.max(0, (p.str||0) - 8) / 6);  // STR scaling
            return h;
        }
        function calcChaDiscount(cha) { return Math.min(30, (cha||0) * 2); }   // buy %  off
        function calcChaSellBonus(cha){ return Math.min(15, (cha||0) * 1); }   // sell %  bonus
        function calcInnCost(cha)     { return Math.max(20, 50 - (cha||0)); }
        function calcCritChance(lck)  { return Math.min(30,  5 + (lck||0)); }  // %
        function calcDodgeChance(dex) { return Math.min(40, (dex||0) * 2); }   // %
        function calcLootBonus(lck)   { return Math.min(25, (lck||0) * 2); }   // extra %

        // random reroll: scatter STAT_BUDGET among 6 stats (min 1 each)
        function rerollStats(classKey) {
            const s = { str:1, dex:1, wis:1, cha:1, con:1, lck:1 };
            let rem = STAT_BUDGET - 6;
            while (rem-- > 0) s[STAT_NAMES[Math.floor(Math.random()*6)]]++;
            return s;
        }

        const SPELLS = {
    heal: {
        name: 'Heal',
        mpCost: 15,
        pipCost: 1,
        power: 30,
        type: 'heal',
        level: 1,
        description: 'Restore HP'
    },
    fireball: {
        name: 'Fireball',
        mpCost: 20,
        pipCost: 1,
        power: 35,
        type: 'attack',
        level: 2,
        description: 'Fiery attack'
    },
    lightning: {
        name: 'Lightning',
        mpCost: 25,
        pipCost: 2,
        power: 45,
        type: 'attack',
        level: 4,
        description: 'Electric damage'
    },
    greater_heal: {
        name: 'Greater Heal',
        mpCost: 30,
        pipCost: 2,
        power: 60,
        type: 'heal',
        level: 5,
        description: 'Major healing'
    },
    ice_storm: {
        name: 'Ice Storm',
        mpCost: 35,
        pipCost: 2,
        power: 55,
        type: 'attack',
        level: 6,
        description: 'Freezing assault'
    },
    holy_light: {
        name: 'Holy Light',
        mpCost: 20,
        pipCost: 1,
        power: 25,
        type: 'attack',
        level: 3,
        description: 'Divine damage'
    },
    meteor: {
        name: 'Meteor',
        mpCost: 50,
        pipCost: 3,
        power: 80,
        type: 'attack',
        level: 8,
        description: 'Devastating spell'
    }
};


        const LOCATIONS = {
    town: {
        name: 'Silverdale Town',
        description: 'A peaceful town with shops and an inn. Your adventure begins here.',
        canRest: true,
        hasShop: true
    },

    forest: {
        name: 'Whispering Forest',
        description: 'A dark forest filled with minor creatures.',
        enemyLevelRange: [1, 5],
        encounters: ['goblin', 'wolf', 'giant_spider'],
        requiredLevel: 1,
        locked: false
    },

    plains: {
        name: 'Endless Plains',
        description: 'Open grasslands with roaming beasts.',
        enemyLevelRange: [6, 10],
        encounters: ['orc', 'dire_wolf', 'bandit'],
        requiredLevel: 6,
        locked: true,
        unlockMessage: 'Defeat your class master in the forest to unlock this area!'
    },

    cave: {
        name: 'Shadow Cavern',
        description: 'A dungeon filled with dangerous monsters.',
        enemyLevelRange: [11, 15],
        encounters: ['troll', 'skeleton_warrior', 'dark_mage'],
        requiredLevel: 11,
        locked: true,
        unlockMessage: 'Defeat your class master in the plains to unlock this area!'
    },

    crypt: {
        name: 'Ancient Crypt',
        description: 'An ancient tomb haunted by the undead.',
        enemyLevelRange: [16, 20],
        encounters: ['lich', 'death_knight', 'wraith'],
        requiredLevel: 16,
        locked: true,
        unlockMessage: 'Defeat your class master in the cave to unlock this area!'
    },

    volcano: {
        name: 'Volcanic Wastes',
        description: 'A scorched wasteland of fire and ash.',
        enemyLevelRange: [21, 25],
        encounters: ['fire_elemental', 'lava_golem', 'phoenix'],
        requiredLevel: 21,
        locked: true,
        unlockMessage: 'Defeat your class master in the crypt to unlock this area!'
    },

    fireMountain: {
        name: 'Fire Mountain',
        description: 'A volcanic peak home to fierce creatures.',
        enemyLevelRange: [8, 12],
        encounters: ['fire_elemental', 'red_dragon', 'demon'],
        requiredLevel: 12,
        locked: true,
        unlockMessage: 'Defeat your class master in the crypt to unlock this area!'
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MERGE EXPANDED ZONES (if exploration-zones.js is loaded)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if (typeof EXPLORATION_ZONES !== 'undefined') {
    // Merge new zones while keeping custom zones
    Object.assign(LOCATIONS, EXPLORATION_ZONES);
    console.log('âœ… Loaded expanded exploration zones');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MERGE ZONE MONSTERS (if exploration-zones.js is loaded)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if (typeof ZONE_MONSTERS !== 'undefined') {
    Object.assign(ENEMIES, ZONE_MONSTERS);
    console.log('âœ… Loaded zone-specific monsters');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MERGE ADVENTURE ENEMIES (if adventures.js is loaded)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if (typeof ADVENTURE_ENEMIES !== 'undefined') {
    Object.assign(ENEMIES, ADVENTURE_ENEMIES);
    console.log('âœ… Loaded adventure enemies');
}



        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MODEM SPEED SIMULATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const MODEM_SPEEDS = {
            '56k': 7,      // ~7 characters per frame (56k modem)
            '28.8k': 4,    // ~4 characters per frame (28.8k modem)
            '14.4k': 2,    // ~2 characters per frame (14.4k modem)
            'instant': -1  // No delay
        };
        
        let currentModemSpeed = '14.4k'; // Default to 14.4k modem (authentic BBS experience)
        let isStreaming = false;
        let streamCancelled = false;
        
        function streamText(element, html, callback) {
           if (currentModemSpeed === 'instant') {
    line.innerHTML = html;

    // âœ… STEP 3A: scroll AFTER line is fully rendered
    if (shouldAutoScroll) {
        tw.scrollTop = tw.scrollHeight;
    }

line.innerHTML =
    sliceToVisible(html, visibleCount) +
    '<span style="animation:blink 1s infinite;">_</span>';


    if (onDone) onDone();
    termDrain();
    return;
}

            
            isStreaming = true;
            streamCancelled = false;
            
            // Strip HTML tags for character counting but keep them for display
            const charsPerFrame = MODEM_SPEEDS[currentModemSpeed];
            let currentIndex = 0;
            
            const interval = setInterval(() => {
                if (streamCancelled) {
                    clearInterval(interval);
                    element.innerHTML = html;
                    isStreaming = false;
                    if (callback) callback();
                    return;
                }
                
                currentIndex += charsPerFrame;
                
                if (currentIndex >= html.length) {
                    clearInterval(interval);
                    element.innerHTML = html;
                    isStreaming = false;
                    if (callback) callback();
                } else {
                    // Display partial HTML up to current index
                    element.innerHTML = html.substring(0, currentIndex) + '<span style="animation: blink 1s infinite;">_</span>';
                }
            }, 16); // ~60fps
        }
        
        function cancelStream() {
            streamCancelled = true;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SAVE FILE ENCRYPTION (Anti-Cheat)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // Simple but effective encryption key (obfuscated in code)
        const SAVE_KEY = 'DQ_' + btoa('DUNGEON_QUEST_2026').split('').reverse().join('');
        
        function encryptSave(data) {
            try {
                const jsonStr = JSON.stringify(data);
                const encoded = btoa(encodeURIComponent(jsonStr));
                
                // Add checksum to detect tampering
                const checksum = generateChecksum(jsonStr);
                
                // XOR cipher with key
                let encrypted = '';
                for (let i = 0; i < encoded.length; i++) {
                    encrypted += String.fromCharCode(
                        encoded.charCodeAt(i) ^ SAVE_KEY.charCodeAt(i % SAVE_KEY.length)
                    );
                }
                
                return btoa(JSON.stringify({
                    v: 1, // version
                    d: btoa(encrypted), // data
                    c: checksum // checksum
                }));
            } catch (e) {
                console.error('Encryption failed:', e);
                return null;
            }
        }
        
        function decryptSave(encryptedData) {
            try {
                const wrapper = JSON.parse(atob(encryptedData));
                
                if (wrapper.v !== 1) {
                    throw new Error('Invalid save version');
                }
                
                const encrypted = atob(wrapper.d);
                
                // XOR decipher
                let decoded = '';
                for (let i = 0; i < encrypted.length; i++) {
                    decoded += String.fromCharCode(
                        encrypted.charCodeAt(i) ^ SAVE_KEY.charCodeAt(i % SAVE_KEY.length)
                    );
                }
                
                const jsonStr = decodeURIComponent(atob(decoded));
                
                // Verify checksum
                const calculatedChecksum = generateChecksum(jsonStr);
                if (calculatedChecksum !== wrapper.c) {
                    throw new Error('Save file has been tampered with!');
                }
                
                return JSON.parse(jsonStr);
            } catch (e) {
                console.error('Decryption failed:', e);
                throw new Error('Invalid or corrupted save file');
            }
        }
        
        function generateChecksum(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return hash.toString(36);
        }
        
        function downloadSaveFile() {
            try {
                const snapshot = buildSaveSnapshot();
                if (!snapshot) {
                    alert('No character data to save!');
                    return;
                }
                
                const encrypted = encryptSave(snapshot);
                if (!encrypted) {
                    alert('Failed to encrypt save file!');
                    return;
                }
                
                // Create filename with character name and timestamp
                const timestamp = new Date().toISOString().slice(0, 10);
                const filename = `DungeonQuest_${snapshot.characterName}_${timestamp}.dqsave`;
                
                // Create blob and download
                const blob = new Blob([encrypted], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert(`âœ… Save file downloaded: ${filename}`);
            } catch (e) {
                console.error('Download failed:', e);
                alert('Failed to download save file!');
            }
        }
        
        function loadFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.dqsave';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const encryptedData = event.target.result;
                        const data = decryptSave(encryptedData);
                        
                        // Validate the save data
                        if (!data.player || !data.characterId) {
                            throw new Error('Invalid save file structure');
                        }
                        
                        // Save to localStorage
                        const key = `dq_save_${data.characterId}`;
                        localStorage.setItem(key, JSON.stringify(data));
                        
                        // Update character list
                        updateCharacterList(data);
                        
                        alert(`âœ… Character "${data.characterName}" loaded successfully!`);
                        
                        // Load the character
                        loadCharacter(data.characterId);
                    } catch (e) {
                        console.error('Load failed:', e);
                        alert('âŒ Failed to load save file: ' + e.message);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        // Game State
        let gameState = {
            player: null,
            currentLocation: 'town',
            combatState: null,
            combatTimer: null,
            lastAction: null,
            restState: {
                isResting: false,
                restStartTime: null,
                hpRegenTimer: null,
                mpRegenTimer: null
            },
            sysop: {
                authenticated: false,
                username: null,
                terminalActive: false,
                commandHistory: []
            }
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PASSIVE REGENERATION SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function startMpRegen(isTown = false) {
    if (gameState.restState.mpRegenTimer) {
        clearInterval(gameState.restState.mpRegenTimer);
        gameState.restState.mpRegenTimer = null;
    }

    // â³ Wait 30 seconds before MP regen begins
    setTimeout(() => {

        // If combat started or player gone, abort
        if (gameState.combatState) return;
        if (!gameState.player) return;

        const regenInterval = isTown ? 10000 : 5000;

        gameState.restState.mpRegenTimer = setInterval(() => {
            const p = gameState.player;

            if (!p || p.mp >= p.maxMp || gameState.combatState) {
                if (p && p.mp >= p.maxMp) {
                    p.mp = p.maxMp;
                    updateHud();
                }
                return;
            }

            const mpRestore = Math.ceil(p.maxMp * 0.10);
            p.mp = Math.min(p.maxMp, p.mp + mpRestore);
            updateHud();

            // Visual feedback (dungeon only)
            if (gameState.currentLocation !== 'town') {
                const hudMp = document.querySelector('#hud');
                if (hudMp) {
                    hudMp.style.animation = 'none';
                    setTimeout(() => {
                        hudMp.style.animation = 'flash-blue 0.3s ease';
                    }, 10);
                }
            }

        }, regenInterval);

    }, 30000); // ğŸ”¥ 30 second delay
}
        
        function startResting(isTown = false) {
            const p = gameState.player;
            if (!p) return;
            
            // Can't rest in combat
            if (!gameState.restState.isResting || gameState.combatState) return;

            
            // Already at full HP? No need to rest
            if (p.hp >= p.maxHp) {
                gameState.restState.isResting = false;
                return;
            }
            
            gameState.restState.isResting = true;
            gameState.restState.restStartTime = Date.now();
            
            // Wait 30 seconds before HP regen starts (same for town and dungeon)
            setTimeout(() => {
                // Check if still resting (not interrupted by combat)
                if (!gameState.restState.isResting || gameState.combatState) {
                    return;
                }
                
                // Start HP regeneration
                // Town: 5% every 20s (50% slower)
                // Dungeon/Exploration: 5% every 10s (normal)
                if (gameState.restState.hpRegenTimer) {
                    clearInterval(gameState.restState.hpRegenTimer);
                }
                
                const regenInterval = isTown ? 20000 : 10000; // Town is 2x slower
                
                gameState.restState.hpRegenTimer = setInterval(() => {
                    const player = gameState.player;
                    if (!player || player.hp >= player.maxHp || !gameState.restState.isResting || gameState.combatState) {
                        // Stop regen if HP full, no longer resting, or combat started
                        if (player && player.hp >= player.maxHp) {
                            player.hp = player.maxHp;
                            updateHud();
                        }
                        stopResting();
                        return;
                    }
                    
                    // Restore 5% of max HP
                    const hpRestore = Math.ceil(player.maxHp * 0.05);
                    player.hp = Math.min(player.maxHp, player.hp + hpRestore);
                    updateHud();
                    
                    // Visual feedback
                    const hudHp = document.querySelector('#hud');
                    if (hudHp) {
                        hudHp.style.animation = 'none';
                        setTimeout(() => {
                            hudHp.style.animation = 'flash-green 0.3s ease';
                        }, 10);
                    }
                }, regenInterval);
                
            }, 30000); // 30 second delay before HP regen
        }
        
        function stopResting() {
            gameState.restState.isResting = false;
            gameState.restState.restStartTime = null;
            
            if (gameState.restState.hpRegenTimer) {
                clearInterval(gameState.restState.hpRegenTimer);
                gameState.restState.hpRegenTimer = null;
            }
        }
        
        function stopAllRegen() {
            stopResting();
            
            if (gameState.restState.mpRegenTimer) {
                clearInterval(gameState.restState.mpRegenTimer);
                gameState.restState.mpRegenTimer = null;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // END REGENERATION SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // ğŸ”‘ Prevent UI reset after restore (mobile fix)
gameState.hasRestoredGame = false;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SYSOP TERMINAL SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const SYSOP_CREDENTIALS = {
            username: 'sysop',
            password: 'Radojcsics'
        };

        // Toggle terminal with ~ key
        document.addEventListener('keydown', (e) => {
            if (e.key === '~' || e.key === '`') {
                e.preventDefault();
                toggleTerminal();
            }
            if (e.key === 'Escape' && gameState.sysop.terminalActive) {
                toggleTerminal();
            }
        });

function showActionBar() {
    const ab = document.getElementById('actionBar');
    if (ab) ab.style.display = 'block';
}

function hideActionBar() {
    const ab = document.getElementById('actionBar');
    if (ab) ab.style.display = 'none';
}


function buildSaveSnapshot() {
    if (!gameState.player) {
        console.warn('No player state to save');
        return null;
    }

    const p = gameState.player;
    
    const snapshot = {
        version: 1,
        characterId: p.id || 'default',
        characterName: p.name,
        timestamp: Date.now(),
        lastSaved: new Date().toLocaleString(),

        player: {
            // Identity
            id: p.id || 'default',
            name: p.name,
            class: p.class,
            
            // Core stats
            level: p.level,
            xp: p.xp,
            xpToNext: p.xpToNext,
            
            // Resources
            hp: p.hp,
            maxHp: p.maxHp,
            mp: p.mp,
            maxMp: p.maxMp,
            gold: p.gold,
            bankGold: p.bankGold || 0,  // Bank storage
            
            // Legacy base stats
            strength: p.strength,
            defense: p.defense,
            magic: p.magic,
            speed: p.speed,
            
            // New stat block (if exists)
            str: p.str,
            dex: p.dex,
            con: p.con,
            wis: p.wis,
            cha: p.cha,
            lck: p.lck,
            
            // Equipment
            weapon: p.weapon,
            armor: p.armor,
            
            // Inventory & spells
            inventory: [...(p.inventory || [])],
            knownSpells: [...(p.knownSpells || [])],
            
            // Progression
            defeatedMasters: [...(p.defeatedMasters || [])],
            unlockedAreas: [...(p.unlockedAreas || [])],
            
            // Special flags
            godMode: p.godMode || false
        },

        // Current location/state
        currentLocation: gameState.currentLocation,

        // Dungeon state (if in dungeon)
        dungeon: gameState.dungeon ? {
            dungeonKey: gameState.dungeon.dungeonKey,
            floor: gameState.dungeon.floor,
            currentRoom: gameState.dungeon.currentRoom,
            discoveredRooms: [...gameState.dungeon.discoveredRooms],
            activeEnemies: gameState.dungeon.activeEnemies.map(e => ({
                id: e.id,
                monsterId: e.monsterId,
                name: e.name,
                hp: e.hp,
                maxHp: e.maxHp,
                currentRoom: e.currentRoom,
                leash: e.leash
            }))
        } : null,

        meta: {
            inDungeon: !!gameState.dungeon
        }
    };

    return snapshot;
}


function saveGame() {
    try {
        const snapshot = buildSaveSnapshot();
        if (!snapshot) return;

        const key = `dq_save_${snapshot.characterId}`;
        localStorage.setItem(key, JSON.stringify(snapshot));
        
        // Also update character list
        updateCharacterList(snapshot);

        console.log(`âœ… Game saved: ${snapshot.characterName} (${snapshot.lastSaved})`);
        
        // Show brief save confirmation
        const hud = document.getElementById('hud');
        if (hud && hud.style.display !== 'none') {
            const saveMsg = document.createElement('div');
            saveMsg.style.cssText = 'position:fixed;top:10px;right:10px;background:#0a0a0a;border:2px solid var(--text-color);padding:8px 12px;color:var(--text-color);font-size:14px;z-index:9999;';
            saveMsg.textContent = 'ğŸ’¾ Game Saved';
            document.body.appendChild(saveMsg);
            setTimeout(() => saveMsg.remove(), 2000);
        }
    } catch (e) {
        console.error('Error saving game:', e);
    }
}

function updateCharacterList(snapshot) {
    try {
        let charList = JSON.parse(localStorage.getItem('dq_character_list') || '[]');
        
        // Remove old entry for this character if exists
        charList = charList.filter(c => c.id !== snapshot.characterId);
        
        // Add new entry
        charList.push({
            id: snapshot.characterId,
            name: snapshot.characterName,
            level: snapshot.player.level,
            class: snapshot.player.class,
            timestamp: snapshot.timestamp,
            lastSaved: snapshot.lastSaved
        });
        
        // Sort by most recent
        charList.sort((a, b) => b.timestamp - a.timestamp);
        
        localStorage.setItem('dq_character_list', JSON.stringify(charList));
    } catch (e) {
        console.error('Error updating character list:', e);
    }
}

function getAllCharacters() {
    try {
        return JSON.parse(localStorage.getItem('dq_character_list') || '[]');
    } catch (e) {
        console.error('Error getting character list:', e);
        return [];
    }
}

function deleteCharacter(characterId) {
    try {
        // Remove save data
        localStorage.removeItem(`dq_save_${characterId}`);
        
        // Remove from character list
        let charList = getAllCharacters();
        charList = charList.filter(c => c.id !== characterId);
        localStorage.setItem('dq_character_list', JSON.stringify(charList));
        
        console.log(`ğŸ—‘ï¸ Deleted character: ${characterId}`);
        return true;
    } catch (e) {
        console.error('Error deleting character:', e);
        return false;
    }
}

// Auto-save on page unload
window.addEventListener('beforeunload', () => {
    saveGame();
});



        function toggleTerminal() {
            const terminal = document.getElementById('terminalContainer');
            const input = document.getElementById('terminalInput');
            
            gameState.sysop.terminalActive = !gameState.sysop.terminalActive;
            
            if (gameState.sysop.terminalActive) {
                terminal.classList.add('active');
                input.focus();
                if (!gameState.sysop.authenticated) {
                    terminalPrint('Terminal activated. Type /login <username> <password> to authenticate.', 'warning');
                }
            } else {
                terminal.classList.remove('active');
            }
        }

        function terminalPrint(message, type = 'normal') {
            const output = document.getElementById('terminalOutput');
            const line = document.createElement('div');
            line.className = `terminal-line ${type === 'error' ? 'terminal-error' : ''} ${type === 'success' ? 'terminal-success' : ''} ${type === 'warning' ? 'terminal-warning' : ''}`;
            line.textContent = message;
            output.appendChild(line);
            
        }

        function clearTerminal() {
            document.getElementById('terminalOutput').innerHTML = '';
        }

        // Terminal input handler
        document.getElementById('terminalInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const input = e.target.value.trim();
                e.target.value = '';
                
                if (input) {
                    terminalPrint(`root@dungeon:~# ${input}`, 'normal');
                    gameState.sysop.commandHistory.push(input);
                    executeCommand(input);
                }
            }
        });

        function executeCommand(input) {
            const parts = input.split(' ');
            const command = parts[0].toLowerCase();
            const args = parts.slice(1);

            // Login command (always available)
            if (command === '/login') {
                handleLogin(args);
                return;
            }

            // Check authentication for all other commands
            if (!gameState.sysop.authenticated) {
                terminalPrint('ERROR: Authentication required. Use /login <username> <password>', 'error');
                return;
            }

            // Execute authenticated commands
            switch(command) {
                case '/help':
                    showHelp();
                    break;
                case '/logout':
                    handleLogout();
                    break;
                case '/clear':
                    clearTerminal();
                    break;
                case '/give':
                    handleGive(args);
                    break;
                case '/addmonster':
                    openAddMonsterForm();
                    break;
                case '/addweapon':
                    openAddWeaponForm();
                    break;
                case '/addarmor':
                    openAddArmorForm();
                    break;
                case '/additem':
                    openAddItemForm();
                    break;
                case '/listmonsters':
                    listMonsters();
                    break;
                case '/listweapons':
                    listWeapons();
                    break;
                case '/listarmor':
                    listArmor();
                    break;
                case '/listitems':
                    listItems();
                    break;
                case '/setlevel':
                    handleSetLevel(args);
                    break;
                case '/setgold':
                    handleSetGold(args);
                    break;
                case '/heal':
                    handleHeal();
                    break;
                case '/godmode':
                    handleGodMode(args);
                    break;
                case '/teleport':
                    handleTeleport(args);
                    break;
                case '/killmonster':
                    handleKillMonster();
                    break;
                case '/export':
                    handleExport(args);
                    break;
                default:
                    terminalPrint(`ERROR: Unknown command '${command}'. Type /help for available commands.`, 'error');
            }
        }

        function handleLogin(args) {
            if (args.length < 2) {
                terminalPrint('ERROR: Usage: /login <username> <password>', 'error');
                return;
            }

            const username = args[0];
            const password = args[1];

            if (username === SYSOP_CREDENTIALS.username && password === SYSOP_CREDENTIALS.password) {
                gameState.sysop.authenticated = true;
                gameState.sysop.username = username;
                document.getElementById('sysopBadge').classList.add('active');
                terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
                terminalPrint('  AUTHENTICATION SUCCESSFUL', 'success');
                terminalPrint('  Welcome, SYSOP ' + username, 'success');
                terminalPrint('  Type /help for available commands', 'success');
                terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
            } else {
                terminalPrint('ERROR: Authentication failed. Invalid credentials.', 'error');
            }
        }

        function handleLogout() {
            gameState.sysop.authenticated = false;
            gameState.sysop.username = null;
            document.getElementById('sysopBadge').classList.remove('active');
            terminalPrint('Logged out. Terminal locked.', 'warning');
        }

        function showHelp() {
            terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
            terminalPrint('SYSOP COMMANDS:', 'warning');
            terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
            terminalPrint('');
            terminalPrint('AUTHENTICATION:');
            terminalPrint('  /login <user> <pass>  - Authenticate as sysop');
            terminalPrint('  /logout               - End sysop session');
            terminalPrint('');
            terminalPrint('PLAYER COMMANDS:');
            terminalPrint('  /give <type> <id>     - Give item (weapon/armor/item/spell)');
            terminalPrint('  /setlevel <level>     - Set player level (1-25)');
            terminalPrint('                          âš¡ Level 20 triggers class evolution!');
            terminalPrint('  /setgold <amount>     - Set gold amount');
            terminalPrint('  /heal                 - Fully heal player');
            terminalPrint('  /godmode <on/off>     - Toggle invincibility');
            terminalPrint('');
            terminalPrint('GAME CONTENT:');
            terminalPrint('  /addmonster           - Add new monster (opens form)');
            terminalPrint('  /addweapon            - Add new weapon (opens form)');
            terminalPrint('  /addarmor             - Add new armor (opens form)');
            terminalPrint('  /additem              - Add new item (opens form)');
            terminalPrint('');
            terminalPrint('LISTING:');
            terminalPrint('  /listmonsters         - Show all monsters');
            terminalPrint('  /listweapons          - Show all weapons');
            terminalPrint('  /listarmor            - Show all armor');
            terminalPrint('  /listitems            - Show all items');
            terminalPrint('');
            terminalPrint('UTILITIES:');
            terminalPrint('  /teleport <location>  - Teleport to area');
            terminalPrint('  /killmonster          - Instantly kill current enemy');
            terminalPrint('  /export <type>        - Export data (monsters/weapons/armor/items)');
            terminalPrint('  /clear                - Clear terminal output');
            terminalPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
        }

        function handleGive(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            if (args.length < 2) {
                terminalPrint('ERROR: Usage: /give <type> <id>', 'error');
                terminalPrint('Types: weapon, armor, item, spell', 'error');
                return;
            }

            const type = args[0].toLowerCase();
            const id = args[1].toLowerCase();

            switch(type) {
                case 'weapon':
                    if (WEAPONS[id]) {
                        if (!gameState.player.inventory.includes(id)) {
                            gameState.player.inventory.push(id);
                        }
                        terminalPrint(`SUCCESS: Gave weapon '${WEAPONS[id].name}' to player`, 'success');
                    } else {
                        terminalPrint(`ERROR: Weapon '${id}' not found`, 'error');
                    }
                    break;
                case 'armor':
                    if (ARMOR[id]) {
                        if (!gameState.player.inventory.includes(id)) {
                            gameState.player.inventory.push(id);
                        }
                        terminalPrint(`SUCCESS: Gave armor '${ARMOR[id].name}' to player`, 'success');
                    } else {
                        terminalPrint(`ERROR: Armor '${id}' not found`, 'error');
                    }
                    break;
                case 'item':
                    if (ITEMS[id]) {
                        if (!gameState.player.inventory.includes(id)) {
                            gameState.player.inventory.push(id);
                        }
                        terminalPrint(`SUCCESS: Gave item '${ITEMS[id].name}' to player`, 'success');
                    } else {
                        terminalPrint(`ERROR: Item '${id}' not found`, 'error');
                    }
                    break;
                case 'spell':
                    if (SPELLS[id]) {
                        if (!gameState.player.knownSpells.includes(id)) {
                            gameState.player.knownSpells.push(id);
                        }
                        terminalPrint(`SUCCESS: Taught spell '${SPELLS[id].name}' to player`, 'success');
                    } else {
                        terminalPrint(`ERROR: Spell '${id}' not found`, 'error');
                    }
                    break;
                default:
                    terminalPrint(`ERROR: Invalid type '${type}'`, 'error');
            }
        }

        function handleSetLevel(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const targetLevel = parseInt(args[0]);
            if (isNaN(targetLevel) || targetLevel < 1 || targetLevel > 25) {
                terminalPrint('ERROR: Invalid level. Use 1-25', 'error');
                return;
            }

            const p = gameState.player;
            const currentLevel = p.level;
            
            // Calculate how many levels to add
            const levelsToAdd = targetLevel - currentLevel;
            
            if (levelsToAdd === 0) {
                terminalPrint(`Player is already level ${targetLevel}`, 'info');
                return;
            }
            
            // Apply level-ups manually
            for (let i = 0; i < Math.abs(levelsToAdd); i++) {
                if (levelsToAdd > 0) {
                    // Level up
                    p.level++;
                    p.maxHp += 15 + (p.con || 0);
                    p.hp = p.maxHp;
                    p.maxMp += 10;
                    p.mp = p.maxMp;
                    p.strength += 2;
                    p.defense += 2;
                    p.magic += 2;
                    p.speed += 1;
                    
                    if (p.str !== undefined) {
                        p.str++; p.dex++; p.wis++; p.cha++; p.con++; p.lck++;
                        if (p.class === 'paladin' || p.baseClass === 'paladin') { 
                            p.str++; p.wis++; 
                        }
                    }
                    
                    // Check for class evolution at 20
                    if (p.level === 20 && evolveClass(p)) {
                        const evolution = ADVANCED_CLASSES[p.baseClass];
                        terminalPrint(`âš¡ CLASS EVOLUTION! ${evolution.announcement}`, 'success');
                    }
                } else {
                    // Level down
                    p.level--;
                    p.maxHp = Math.max(20, p.maxHp - 15 - (p.con || 0));
                    p.hp = Math.min(p.hp, p.maxHp);
                    p.maxMp = Math.max(10, p.maxMp - 10);
                    p.mp = Math.min(p.mp, p.maxMp);
                    p.strength = Math.max(1, p.strength - 2);
                    p.defense = Math.max(1, p.defense - 2);
                    p.magic = Math.max(1, p.magic - 2);
                    p.speed = Math.max(1, p.speed - 1);
                    
                    if (p.str !== undefined) {
                        p.str = Math.max(1, p.str - 1);
                        p.dex = Math.max(1, p.dex - 1);
                        p.wis = Math.max(1, p.wis - 1);
                        p.cha = Math.max(1, p.cha - 1);
                        p.con = Math.max(1, p.con - 1);
                        p.lck = Math.max(1, p.lck - 1);
                    }
                }
            }
            
            // Update XP to next
            p.xpToNext = getXpToNextLevel(p.baseClass || p.class, p.level);
            p.xp = 0; // Reset XP within level
            
            updateHud();
            terminalPrint(`SUCCESS: Set player level to ${targetLevel}`, 'success');
            
            if (p.hasEvolved) {
                terminalPrint(`Player is now a ${getAdvancedClassName(p)} with ${getClassDamageMultiplier(p)}x damage!`, 'info');
            }
        }

        function handleSetGold(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const gold = parseInt(args[0]);
            if (isNaN(gold) || gold < 0) {
                terminalPrint('ERROR: Invalid gold amount', 'error');
                return;
            }

            gameState.player.gold = gold;
            terminalPrint(`SUCCESS: Set gold to ${gold}`, 'success');
        }

        function handleHeal() {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            gameState.player.hp = gameState.player.maxHp;
            gameState.player.mp = gameState.player.maxMp;
            terminalPrint('SUCCESS: Player fully healed', 'success');
        }

        function handleGodMode(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const mode = args[0]?.toLowerCase();
            if (mode === 'on') {
                gameState.player.godMode = true;
                terminalPrint('SUCCESS: God Mode ENABLED - Player is invincible', 'success');
            } else if (mode === 'off') {
                gameState.player.godMode = false;
                terminalPrint('SUCCESS: God Mode DISABLED', 'success');
            } else {
                terminalPrint('ERROR: Usage: /godmode <on/off>', 'error');
            }
        }

        function handleTeleport(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const location = args[0]?.toLowerCase();
            if (LOCATIONS[location]) {
                gameState.currentLocation = location;
                if (location === 'town') {
                    showTown();
                } else {
                    exploreLocation(location);
                }
                terminalPrint(`SUCCESS: Teleported to ${LOCATIONS[location].name}`, 'success');
            } else {
                terminalPrint(`ERROR: Unknown location '${location}'`, 'error');
                terminalPrint('Available: ' + Object.keys(LOCATIONS).join(', '), 'warning');
            }
        }

        function handleKillMonster() {
            if (!gameState.combatState) {
                terminalPrint('ERROR: Not in combat', 'error');
                return;
            }

            gameState.combatState.enemy.hp = 0;
            terminalPrint('SUCCESS: Enemy eliminated', 'success');
            checkCombatEnd();
        }

        function listMonsters() {
            terminalPrint('â•â•â• ALL MONSTERS â•â•â•', 'warning');
            Object.keys(ENEMIES).forEach(key => {
                const m = ENEMIES[key];
                terminalPrint(`${key}: ${m.name} (Lv${m.level}, HP:${m.hp}, DMG:${m.damage})`);
            });
        }

        function listWeapons() {
            terminalPrint('â•â•â• ALL WEAPONS â•â•â•', 'warning');
            Object.keys(WEAPONS).forEach(key => {
                const w = WEAPONS[key];
                terminalPrint(`${key}: ${w.name} (Lv${w.level}, DMG:${w.damage}, MAG:${w.magicDamage})`);
            });
        }

        function listArmor() {
            terminalPrint('â•â•â• ALL ARMOR â•â•â•', 'warning');
            Object.keys(ARMOR).forEach(key => {
                const a = ARMOR[key];
                terminalPrint(`${key}: ${a.name} (Lv${a.level}, DEF:${a.defense})`);
            });
        }

        function listItems() {
            terminalPrint('â•â•â• ALL ITEMS â•â•â•', 'warning');
            Object.keys(ITEMS).forEach(key => {
                const i = ITEMS[key];
                terminalPrint(`${key}: ${i.name} (${i.type}, Lv${i.level})`);
            });
        }

        function openAddMonsterForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW MONSTER</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Monster ID (lowercase, underscores):</label>
                    <input type="text" id="monsterId" placeholder="fire_dragon">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="monsterName" placeholder="Fire Dragon">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">HP:</label>
                    <input type="number" id="monsterHp" value="100">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Damage:</label>
                    <input type="number" id="monsterDamage" value="20">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Defense:</label>
                    <input type="number" id="monsterDefense" value="10">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">XP Reward:</label>
                    <input type="number" id="monsterXp" value="100">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Gold Reward:</label>
                    <input type="number" id="monsterGold" value="80">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level:</label>
                    <input type="number" id="monsterLevel" value="5">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="monsterDesc" placeholder="A fearsome creature">
                </div>
                <button onclick="submitAddMonster()">ADD MONSTER</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddMonster() {
            const id = document.getElementById('monsterId').value.trim().toLowerCase();
            const name = document.getElementById('monsterName').value.trim();
            const hp = parseInt(document.getElementById('monsterHp').value);
            const damage = parseInt(document.getElementById('monsterDamage').value);
            const defense = parseInt(document.getElementById('monsterDefense').value);
            const xp = parseInt(document.getElementById('monsterXp').value);
            const gold = parseInt(document.getElementById('monsterGold').value);
            const level = parseInt(document.getElementById('monsterLevel').value);
            const description = document.getElementById('monsterDesc').value.trim();

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            ENEMIES[id] = {
                name: name,
                hp: hp,
                damage: damage,
                defense: defense,
                xp: xp,
                gold: gold,
                level: level,
                description: description
            };

            closeModal();
            terminalPrint(`SUCCESS: Added monster '${name}' with ID '${id}'`, 'success');
            terminalPrint('Remember to add it to a location\'s encounter list!', 'warning');
        }

        function openAddWeaponForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW WEAPON</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Weapon ID:</label>
                    <input type="text" id="weaponId" placeholder="flame_sword">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="weaponName" placeholder="Flame Sword">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Damage:</label>
                    <input type="number" id="weaponDamage" value="30">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Magic Damage:</label>
                    <input type="number" id="weaponMagic" value="10">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Cost:</label>
                    <input type="number" id="weaponCost" value="200">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level Requirement:</label>
                    <input type="number" id="weaponLevel" value="5">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="weaponDesc" placeholder="A blazing weapon">
                </div>
                <button onclick="submitAddWeapon()">ADD WEAPON</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddWeapon() {
            const id = document.getElementById('weaponId').value.trim().toLowerCase();
            const name = document.getElementById('weaponName').value.trim();
            const damage = parseInt(document.getElementById('weaponDamage').value);
            const magicDamage = parseInt(document.getElementById('weaponMagic').value);
            const cost = parseInt(document.getElementById('weaponCost').value);
            const level = parseInt(document.getElementById('weaponLevel').value);
            const description = document.getElementById('weaponDesc').value.trim();

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            WEAPONS[id] = {
                name: name,
                damage: damage,
                magicDamage: magicDamage,
                cost: cost,
                level: level,
                description: description
            };

            closeModal();
            terminalPrint(`SUCCESS: Added weapon '${name}' with ID '${id}'`, 'success');
        }

        function openAddArmorForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW ARMOR</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Armor ID:</label>
                    <input type="text" id="armorId" placeholder="dragon_mail">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="armorName" placeholder="Dragon Mail">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Defense:</label>
                    <input type="number" id="armorDefense" value="25">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Magic Bonus:</label>
                    <input type="number" id="armorMagic" value="0">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Cost:</label>
                    <input type="number" id="armorCost" value="300">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level Requirement:</label>
                    <input type="number" id="armorLevel" value="6">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="armorDesc" placeholder="Strong protective armor">
                </div>
                <button onclick="submitAddArmor()">ADD ARMOR</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddArmor() {
            const id = document.getElementById('armorId').value.trim().toLowerCase();
            const name = document.getElementById('armorName').value.trim();
            const defense = parseInt(document.getElementById('armorDefense').value);
            const magicBonus = parseInt(document.getElementById('armorMagic').value);
            const cost = parseInt(document.getElementById('armorCost').value);
            const level = parseInt(document.getElementById('armorLevel').value);
            const description = document.getElementById('armorDesc').value.trim();

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            ARMOR[id] = {
                name: name,
                defense: defense,
                magicBonus: magicBonus,
                cost: cost,
                level: level,
                description: description
            };

            closeModal();
            terminalPrint(`SUCCESS: Added armor '${name}' with ID '${id}'`, 'success');
        }

        function openAddItemForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW ITEM</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Item ID:</label>
                    <input type="text" id="itemId" placeholder="super_potion">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="itemName" placeholder="Super Potion">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Type:</label>
                    <select id="itemType" style="width: 100%; background: var(--secondary-bg); color: var(--text-color); border: 2px solid var(--border-color); padding: 10px; font-family: 'VT323', monospace; font-size: 18px;">
                        <option value="consumable">Consumable</option>
                        <option value="quest">Quest</option>
                        <option value="permanent">Permanent</option>
                        <option value="utility">Utility</option>
                        <option value="passive">Passive</option>
                    </select>
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Subtype:</label>
                    <input type="text" id="itemSubtype" placeholder="heal_hp">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Power:</label>
                    <input type="number" id="itemPower" value="50">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Cost:</label>
                    <input type="number" id="itemCost" value="30">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level:</label>
                    <input type="number" id="itemLevel" value="1">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="itemDesc" placeholder="Restores HP">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">
                        <input type="checkbox" id="itemStackable" checked> Stackable
                    </label>
                </div>
                <button onclick="submitAddItem()">ADD ITEM</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddItem() {
            const id = document.getElementById('itemId').value.trim().toLowerCase();
            const name = document.getElementById('itemName').value.trim();
            const type = document.getElementById('itemType').value;
            const subtype = document.getElementById('itemSubtype').value.trim();
            const power = parseInt(document.getElementById('itemPower').value);
            const cost = parseInt(document.getElementById('itemCost').value);
            const level = parseInt(document.getElementById('itemLevel').value);
            const description = document.getElementById('itemDesc').value.trim();
            const stackable = document.getElementById('itemStackable').checked;

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            ITEMS[id] = {
                name: name,
                type: type,
                subtype: subtype,
                power: power,
                cost: cost,
                level: level,
                description: description,
                stackable: stackable
            };

            closeModal();
            terminalPrint(`SUCCESS: Added item '${name}' with ID '${id}'`, 'success');
        }

        function closeModal() {
            document.getElementById('modalOverlay').classList.remove('active');
        }

        function handleExport(args) {
            const type = args[0]?.toLowerCase();
            let data;
            let filename;

            switch(type) {
                case 'monsters':
                    data = JSON.stringify(ENEMIES, null, 2);
                    filename = 'monsters.json';
                    break;
                case 'weapons':
                    data = JSON.stringify(WEAPONS, null, 2);
                    filename = 'weapons.json';
                    break;
                case 'armor':
                    data = JSON.stringify(ARMOR, null, 2);
                    filename = 'armor.json';
                    break;
                case 'items':
                    data = JSON.stringify(ITEMS, null, 2);
                    filename = 'items.json';
                    break;
                default:
                    terminalPrint('ERROR: Usage: /export <monsters/weapons/armor/items>', 'error');
                    return;
            }

            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);

            terminalPrint(`SUCCESS: Exported ${type} to ${filename}`, 'success');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CLASS-SPECIFIC XP TABLES (Levels 1-25)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const XP_TABLES = {
            acolyte: [0, 1150, 3490, 9625, 20640, 42200, 78200, 134300, 216900, 333500, 492000, 701800, 972800, 1315900, 1742800],
            necrolyte: [0, 1150, 3490, 9625, 20640, 42200, 78200, 134300, 216900, 333500, 492000, 701800, 972800, 1315900, 1742800],
            archer: [0, 1125, 3240, 8025, 17890, 36000, 66300, 113400, 182600, 280200, 413000, 588700, 815600, 1102800, 1460100],
            druid: [0, 1180, 3800, 10290, 24160, 50000, 93000, 161400, 261500, 402700, 595000, 849600, 1178400, 1594900, 2113200],
            sorceror: [0, 1180, 3800, 10290, 24160, 50000, 93000, 161400, 261500, 402700, 595000, 849600, 1178400, 1594900, 2113200],
            hunter: [0, 1125, 3240, 8025, 17890, 36000, 66300, 113400, 182600, 280200, 413000, 588700, 815600, 1102800, 1460100],
            rogue: [0, 1120, 3200, 7860, 17440, 35000, 64400, 109000, 177000, 271500, 400000, 570100, 789600, 1067600, 1413500],
            warrior: [0, 1125, 3240, 8025, 17890, 36000, 66300, 113400, 182600, 280200, 413000, 588700, 815600, 1102800, 1460100],
            paladin: [0, 1125, 3240, 8025, 17890, 36000, 66300, 113400, 182600, 280200, 413000, 588700, 815600, 1102800, 1460100]
        };
        
        // Extend to level 25 (levels 16-25)
        XP_TABLES.acolyte.push(2266200, 2895900, 3657600, 4555300, 5609100, 6836000, 8254100, 9882100, 11739900, 13048000);
        XP_TABLES.necrolyte.push(2266200, 2895900, 3657600, 4555300, 5609100, 6836000, 8254100, 9882100, 11739900, 13048000);
        XP_TABLES.archer.push(1898300, 2428600, 3063100, 3814700, 4696900, 5724000, 6911200, 8274200, 9829700, 11594700);
        XP_TABLES.druid.push(2748800, 3518100, 4438700, 5529300, 6809500, 8300000, 10022900, 12001000, 14258400, 16820200);
        XP_TABLES.sorceror.push(2748800, 3518100, 4438700, 5529300, 6809500, 8300000, 10022900, 12001000, 14258400, 16820200);
        XP_TABLES.hunter.push(1898300, 2428600, 3063100, 3814700, 4696900, 5724000, 6911200, 8274200, 9829700, 11594700);
        XP_TABLES.rogue.push(1637500, 2350000, 2964800, 3692200, 4546000, 5540000, 6689000, 8008000, 9513300, 11221500);
        XP_TABLES.warrior.push(1898300, 2428600, 3063100, 3814700, 4696900, 5724000, 6911200, 8274200, 9829700, 11594700);
        XP_TABLES.paladin.push(1898300, 2428600, 3063100, 3814700, 4696900, 5724000, 6911200, 8274200, 9829700, 11594700);
        
        function getXpForLevel(playerClass, level) {
            const table = XP_TABLES[playerClass] || XP_TABLES.warrior;
            if (level < 1) return 0;
            if (level > 25) return table[24]; // Max at level 25
            return table[level - 1];
        }
        
        function getXpToNextLevel(playerClass, currentLevel) {
            if (currentLevel >= 25) return 999999999; // Max level
            return getXpForLevel(playerClass, currentLevel + 1);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // END XP TABLES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        window.submitAddMonster = submitAddMonster;
        window.submitAddWeapon = submitAddWeapon;
        window.submitAddArmor = submitAddArmor;
        window.submitAddItem = submitAddItem;
        window.closeModal = closeModal;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // END SYSOP TERMINAL SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•





        // Initialize Game
        function initGame() {
            try {
                // Try to auto-restore character (especially important for dungeons!)
                const characters = getAllCharacters();
                
                if (characters.length > 0) {
                    // Check if any character is currently in a dungeon
                    let dungeonChar = null;
                    try {
                        dungeonChar = characters.find(char => {
                            try {
                                const saveData = localStorage.getItem(`dq_save_${char.id}`);
                                if (saveData) {
                                    const data = JSON.parse(saveData);
                                    return data.meta?.inDungeon === true;
                                }
                            } catch (e) {
                                console.error(`Corrupted save for ${char.id}:`, e);
                                // Delete corrupted save
                                localStorage.removeItem(`dq_save_${char.id}`);
                            }
                            return false;
                        });
                    } catch (e) {
                        console.error('Error checking for dungeon characters:', e);
                    }
                    
                    if (dungeonChar) {
                        // Auto-load character that was in a dungeon (prevent cheating!)
                        console.log('ğŸ° Auto-restoring dungeon session:', dungeonChar.name);
                        try {
                            loadCharacter(dungeonChar.id);
                            return;
                        } catch (e) {
                            console.error('Failed to load dungeon character:', e);
                            alert('âš ï¸ Your dungeon save was corrupted. Returning to main menu.');
                            // Delete corrupted save and continue to main menu
                            deleteCharacter(dungeonChar.id);
                        }
                    }
                    
                    // If single character and not in dungeon, auto-load for convenience
                    if (characters.length === 1) {
                        console.log('Auto-loading single character:', characters[0].name);
                        try {
                            loadCharacter(characters[0].id);
                            return;
                        } catch (e) {
                            console.error('Failed to load character:', e);
                            alert('âš ï¸ Your save was corrupted. Returning to main menu.');
                            // Delete corrupted save and continue to main menu
                            deleteCharacter(characters[0].id);
                        }
                    }
                }
            } catch (e) {
                console.error('Critical error in initGame:', e);
                // Clear potentially corrupted data
                try {
                    localStorage.removeItem('dq_character_list');
                } catch (clearError) {
                    console.error('Could not clear character list:', clearError);
                }
            }
            
            // Always fall back to main menu if anything goes wrong
            showMainMenu();
            
            // Warn before leaving page without saving
            window.addEventListener('beforeunload', function(e) {
                // Only warn if player exists and has made progress
                if (gameState.player && gameState.player.level >= 1) {
                    const message = 'You have unsaved progress! Are you sure you want to leave?';
                    e.preventDefault();
                    e.returnValue = message;  // Chrome requires returnValue
                    return message;           // Some browsers use return value
                }
            });
        }

        function showMainMenu() {
            const screen = document.getElementById('mainScreen');
            const characters = getAllCharacters();
            const hasCharacters = characters.length > 0;
            
            screen.innerHTML = `
                <div class="location-header">MAIN MENU</div>
                <div style="text-align: center; margin: 30px 0;">
                    <div class="ascii-art" style="color: var(--highlight-color);">
    âš”ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• âš”ï¸
       â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
       â•‘   DUNGEON QUEST AWAITS!   â•‘
       â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    ğŸ—¡ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ—¡ï¸
                    </div>
                </div>
                <div style="max-width: 400px; margin: 0 auto;">
                    <div class="menu-option" onclick="newGame()">â–º NEW GAME</div>
                    <div class="menu-option ${!hasCharacters?'disabled':''}" onclick="${hasCharacters?'showCharacterSelect()':''}">
                        â–º CONTINUE ${hasCharacters?`(${characters.length} local save${characters.length>1?'s':''})`:' (No saves)'}
                    </div>
                    <div class="menu-option" onclick="loadFromFile()">ğŸ“ LOAD FROM FILE (.dqsave)</div>
                    <div class="menu-option" onclick="showInstructions()">â–º INSTRUCTIONS</div>
                </div>
            `;
        }

        function showCharacterSelect() {
            const characters = getAllCharacters();
            if (characters.length === 0) {
                alert('No saved characters found!');
                return;
            }
            
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">SELECT CHARACTER</div>
                <div id="characterList" style="max-width: 600px; margin: 20px auto;"></div>
                <button onclick="showMainMenu()">â† BACK TO MENU</button>
            `;
            
            const charList = document.getElementById('characterList');
            
            characters.forEach(char => {
                const card = document.createElement('div');
                card.className = 'character-card';
                card.style.cssText = `
                    background: var(--secondary-bg);
                    border: 2px solid var(--border-color);
                    padding: 15px;
                    margin-bottom: 15px;
                    cursor: pointer;
                    transition: all 0.2s;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                `;
                
                card.innerHTML = `
                    <div style="flex: 1;">
                        <div style="color: var(--highlight-color); font-size: 22px; margin-bottom: 5px;">
                            ${char.name}
                        </div>
                        <div style="color: var(--text-color); font-size: 16px;">
                            Level ${char.level} ${char.class || 'Adventurer'}
                        </div>
                        <div style="color: #8aaa8a; font-size: 14px; margin-top: 5px;">
                            Last played: ${char.lastSaved}
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="event.stopPropagation(); loadCharacter('${char.id}')" 
                                style="padding: 8px 16px; background: #0a3a0a; border: 2px solid var(--text-color);">
                            â–¶ PLAY
                        </button>
                        <button onclick="event.stopPropagation(); confirmDeleteCharacter('${char.id}', '${char.name}')" 
                                style="padding: 8px 16px; background: #3a0a0a; border: 2px solid var(--error-color); color: var(--error-color);">
                            ğŸ—‘ï¸ DELETE
                        </button>
                    </div>
                `;
                
                card.addEventListener('mouseenter', () => {
                    card.style.background = 'var(--primary-bg)';
                    card.style.borderColor = 'var(--highlight-color)';
                });
                
                card.addEventListener('mouseleave', () => {
                    card.style.background = 'var(--secondary-bg)';
                    card.style.borderColor = 'var(--border-color)';
                });
                
                charList.appendChild(card);
            });
        }

        function confirmDeleteCharacter(charId, charName) {
            if (confirm(`Are you sure you want to DELETE ${charName}? This cannot be undone!`)) {
                if (deleteCharacter(charId)) {
                    showCharacterSelect(); // Refresh the list
                } else {
                    alert('Error deleting character!');
                }
            }
        }

        function loadCharacter(characterId) {
            try {
                const saveData = localStorage.getItem(`dq_save_${characterId}`);
                if (!saveData) {
                    console.error('Save file not found:', characterId);
                    alert('âš ï¸ Save file not found!');
                    showMainMenu();
                    return;
                }

                const data = JSON.parse(saveData);
                
                // Validate save data structure
                if (!data.player) {
                    throw new Error('Invalid save data: missing player data');
                }
                
                // Restore complete player state
                gameState.player = {
                    ...data.player,
                    // Ensure all arrays are properly restored
                    inventory: data.player.inventory || [],
                    knownSpells: data.player.knownSpells || [],
                    defeatedMasters: data.player.defeatedMasters || [],
                    unlockedAreas: data.player.unlockedAreas || [],
                    // Ensure bankGold exists (for old saves)
                    bankGold: data.player.bankGold || 0
                };
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // EQUIPMENT MIGRATION (fix old save data with missing weapons/armor)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                const p = gameState.player;
                
                // Check if weapon exists
                if (!WEAPONS[p.weapon]) {
                    console.warn(`âš ï¸ Weapon '${p.weapon}' not found. Migrating to default weapon...`);
                    // Try to find a suitable replacement based on class
                    const classDefaults = {
                        warrior: 'iron_sword',
                        rogue: 'rusty_dagger',
                        acolyte: 'bent_staff',
                        necrolyte: 'bent_staff',
                        paladin: 'worn_mace',
                        hunter: 'cracked_bow',
                        archer: 'cracked_bow',
                        druid: 'bent_staff',
                        sorceror: 'bent_staff'
                    };
                    p.weapon = classDefaults[p.class] || 'iron_sword';
                    console.log(`âœ… Migrated weapon to: ${p.weapon}`);
                }
                
                // Check if armor exists
                if (!ARMOR[p.armor]) {
                    console.warn(`âš ï¸ Armor '${p.armor}' not found. Migrating to default armor...`);
                    p.armor = 'leather_vest'; // Universal default
                    console.log(`âœ… Migrated armor to: ${p.armor}`);
                }
                
                gameState.currentLocation = data.currentLocation || 'silverdale';
                
                // Restore dungeon state if applicable
                if (data.meta?.inDungeon && data.dungeon) {
                    // Check if DUNGEONS is loaded
                    if (typeof DUNGEONS === 'undefined') {
                        console.error('âš ï¸ DUNGEONS not loaded! Check dungeon-data.js for syntax errors.');
                        alert('âš ï¸ Dungeon data failed to load. Returning to town.');
                        gameState.dungeon = null;
                        showTown();
                        return;
                    }
                    
                    console.log('ğŸ” Loading dungeon:', data.dungeon.dungeonKey);
                    console.log('ğŸ“¦ Available dungeons:', Object.keys(DUNGEONS));
                    
                    let dungeonKey = data.dungeon.dungeonKey;
                    
                    // Migrate old dungeon keys if needed
                    if (!DUNGEONS[dungeonKey]) {
                        console.warn(`âš ï¸ Dungeon "${dungeonKey}" not found. Attempting migration...`);
                        const availableDungeons = Object.keys(DUNGEONS);
                        if (availableDungeons.length > 0) {
                            dungeonKey = availableDungeons[0];
                            console.log(`âœ… Migrated to dungeon: ${dungeonKey}`);
                        } else {
                            console.error('âŒ No dungeons available!');
                            alert('âš ï¸ Dungeon not found. Returning to town.');
                            gameState.dungeon = null;
                            showTown();
                            return;
                        }
                    }
                    
                    const dungeon = DUNGEONS[dungeonKey];
                    
                    gameState.dungeon = {
                        dungeonKey: dungeonKey,
                        floor: data.dungeon.floor,
                        currentRoom: data.dungeon.currentRoom,
                        discoveredRooms: new Set(data.dungeon.discoveredRooms),
                        activeEnemies: (data.dungeon.activeEnemies || []).map(e => ({
                            ...e,
                            isChasing: false,
                            roomsFollowed: 0
                        }))
                    };
                    
                    // Open dungeon UI
                    openTerminalView(dungeonKey);
                    
                    const floor = dungeon.floors[data.dungeon.floor];
                    if (!floor) {
                        console.error(`âš ï¸ Floor ${data.dungeon.floor} not found!`);
                        alert('âš ï¸ Invalid dungeon floor. Returning to town.');
                        gameState.dungeon = null;
                        showTown();
                        return;
                    }
                    
                    const room = floor.rooms[data.dungeon.currentRoom];
                    if (!room) {
                        console.error(`âš ï¸ Room ${data.dungeon.currentRoom} not found!`);
                        alert('âš ï¸ Invalid dungeon room. Returning to town.');
                        gameState.dungeon = null;
                        showTown();
                        return;
                    }
                    
                    termAppend('', 'term-separator');
                    termAppend(`<strong>${room.name}</strong>`);
                    termAppend(room.description, 'term-dim');
                    
                    const exits = Object.keys(room.exits).map(d => d.toUpperCase()).join(', ');
                    termAppend(`You see exits: ${exits}.`, 'term-dim');
                    
                    checkEnemiesInRoom(data.dungeon.currentRoom);
                    renderDungeonActionBar();
                    
                    // Start regeneration in dungeon (normal speed)
                    startMpRegen(false);
                    startResting(false);
                } else {
                    showTown();
                }
                
                console.log(`âœ… Character loaded: ${data.characterName}`);
                console.log(`   Weapon: ${gameState.player.weapon} | Armor: ${gameState.player.armor}`);
            } catch (e) {
                console.error('Error loading character:', e);
                alert('âš ï¸ Failed to load save file. The data may be corrupted. Returning to main menu.');
                
                // Clean up corrupted state
                gameState.player = null;
                gameState.dungeon = null;
                gameState.combatState = null;
                
                // Try to delete corrupted save
                try {
                    deleteCharacter(characterId);
                } catch (deleteError) {
                    console.error('Could not delete corrupted save:', deleteError);
                }
                
                // Always return to main menu on error
                showMainMenu();
            }
        }

        function showInstructions() {
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">INSTRUCTIONS</div>
                <div class="message">
                    <p><span class="stat-label">OBJECTIVE:</span> Explore dungeons, defeat monsters, level up, and become legendary!</p>
                    <br>
                    <p><span class="stat-label">COMBAT:</span> Combat is turn-based with a timer. Choose your action before time runs out!</p>
                    <br>
                    <p><span class="stat-label">EXPLORATION:</span> Travel to different locations, each with stronger monsters.</p>
                    <br>
                    <p><span class="stat-label">PROGRESSION:</span> Gain XP, level up, buy better equipment, and learn new spells.</p>
                    <br>
                    <p><span class="stat-label">SAVING:</span> Save your game at any time from the town menu.</p>
                </div>
                <button onclick="showMainMenu()">BACK TO MENU</button>
            `;
        }

        function newGame() {
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">CHARACTER CREATION</div>
                <div class="message">
                    <p>Enter your character name:</p>
                    <input type="text" id="playerName" maxlength="20" placeholder="Hero Name">
                </div>
                <div class="message">
                    <p><span class="stat-label">Choose your class:</span></p>
                </div>
                <div class="character-select" id="classSelect"></div>
                <button onclick="goToStatAlloc()" id="createBtn" disabled>ALLOCATE STATS â†’</button>
                <button onclick="showMainMenu()">CANCEL</button>
            `;

            const classSelect = document.getElementById('classSelect');
            window._selectedClass = null;

            Object.keys(CLASSES).forEach(classKey => {
                const cd   = CLASSES[classKey];
                const card = document.createElement('div');
                card.className = 'class-card';
                card.innerHTML = `
                    <div style="color:var(--highlight-color);font-size:22px;margin-bottom:8px;">${cd.name}</div>
                    <div style="font-size:16px;margin-bottom:8px;">${cd.description}</div>
                    <div class="stat">HP: ${cd.hp} | MP: ${cd.mp}</div>
                    <div class="stat" style="color:#8aaa8a;">STR/DEF/MAG/SPD set at creation</div>
                `;
                card.onclick = () => {
                    document.querySelectorAll('.class-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    window._selectedClass = classKey;
                    document.getElementById('createBtn').disabled = false;
                };
                classSelect.appendChild(card);
            });
        }

        // â”€â”€ stat allocation screen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window._pendingStats = null;
        window._pendingName  = '';

        function goToStatAlloc() {
            const name = document.getElementById('playerName').value.trim();
            if (!name)                { alert('Please enter a character name!'); return; }
            if (!window._selectedClass) { alert('Please select a class!');       return; }
            window._pendingName  = name;
            window._pendingStats = Object.assign({}, CLASS_STAT_PRESETS[window._selectedClass]);
            renderStatAllocScreen();
        }

        function renderStatAllocScreen() {
            const classKey   = window._selectedClass;
            const classData  = CLASSES[classKey];
            const stats      = window._pendingStats;
            const spent      = STAT_NAMES.reduce((a,k) => a + stats[k], 0);
            const remaining  = STAT_BUDGET - spent;
            const affinities = CLASS_AFFINITIES[classKey];
            const screen     = document.getElementById('mainScreen');

            // preview derived values
            const previewHp   = classData.hp + stats.con * 5;
            const previewHits = (function(){
                let h=1;
                if(classKey==='rogue') h++;
                h += Math.floor(Math.max(0, stats.str-8)/6);
                return h;
            })();

            let rows = '';
            STAT_NAMES.forEach(s => {
                const isAff   = affinities.includes(s);
                const canUp   = remaining > 0 && stats[s] < 15;
                const canDown = stats[s] > 1;
                rows += `
                <div style="display:flex;align-items:center;gap:6px;padding:5px 0;border-bottom:1px solid #1a4a1a;flex-wrap:wrap;">
                    <span style="min-width:36px;color:${isAff?'var(--highlight-color)':'var(--text-color)'};font-weight:bold;">${STAT_LABELS[s]}</span>
                    <span style="flex:1;min-width:120px;font-size:16px;color:#8aaa8a;">${STAT_DESCS[s]}${isAff?' â˜…':''}</span>
                    <button onclick="statAdj('${s}',-1)" ${canDown?'':'disabled'} style="width:32px;padding:4px 0;margin:0;font-size:20px;">âˆ’</button>
                    <span style="min-width:28px;text-align:center;color:var(--highlight-color);font-size:22px;">${stats[s]}</span>
                    <button onclick="statAdj('${s}',+1)" ${canUp ?'':'disabled'} style="width:32px;padding:4px 0;margin:0;font-size:20px;">+</button>
                </div>`;
            });

            screen.innerHTML = `
                <div class="location-header">ALLOCATE STATS â€“ ${classData.name}</div>
                <div class="message" style="border-color:var(--highlight-color);">
                    <span style="color:var(--highlight-color);">Points remaining: </span>
                    <span style="color:${remaining>0?'var(--text-color)':'var(--error-color)'};font-size:22px;">${remaining}</span>
                    <span style="color:#8aaa8a;font-size:15px;"> (â˜… = class affinity)</span>
                </div>
                <div style="max-width:520px;margin:0 auto;">${rows}</div>
                <div class="message" style="border-color:#005500;margin-top:12px;font-size:15px;">
                    <span style="color:#8aaa8a;">PREVIEW:</span><br>
                    <span style="color:var(--highlight-color);">HP ${previewHp}</span>
                    <span style="color:var(--border-color);"> | ATK/rd: ${previewHits}</span><br>
                    <span style="color:#8aaa8a;">Crit ${calcCritChance(stats.lck)}% | Dodge ${calcDodgeChance(stats.dex)}%</span>
                </div>
                <div style="margin-top:14px;display:flex;flex-wrap:wrap;gap:8px;">
                    <button onclick="window._pendingStats=Object.assign({},CLASS_STAT_PRESETS['${classKey}']);renderStatAllocScreen();">ğŸ“‹ CLASS PRESET</button>
                    <button onclick="window._pendingStats=rerollStats('${classKey}');renderStatAllocScreen();">ğŸ² REROLL</button>
                </div>
                <div style="margin-top:14px;">
                    <button onclick="finaliseCharacter()" ${remaining===0?'':'disabled'} style="font-size:20px;">âš”ï¸ BEGIN ADVENTURE âš”ï¸</button>
                    <button onclick="newGame()">â† BACK</button>
                </div>
            `;
        }

        window.statAdj = function(stat, dir) {
            const stats = window._pendingStats;
            const spent = STAT_NAMES.reduce((a,k) => a + stats[k], 0);
            if (dir > 0 && spent >= STAT_BUDGET) return;
            if (dir < 0 && stats[stat] <= 1)      return;
            stats[stat] += dir;
            renderStatAllocScreen();
        };

        function finaliseCharacter() {
            const classKey  = window._selectedClass;
            const classData = CLASSES[classKey];
            const stats     = window._pendingStats;

            // Generate unique character ID
            const charId = 'char_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

            gameState.player = {
                id: charId,  // Unique character ID
                name: window._pendingName,
                class: classKey,  className: classData.name,
                level: 1,  xp: 0,  xpToNext: getXpToNextLevel(classKey, 1),
                hp: classData.hp + stats.con * 5,
                maxHp: classData.hp + stats.con * 5,
                mp: classData.mp,  maxMp: classData.mp,
                strength: classData.strength,   // legacy weapon-calc field
                defense:  classData.defense,
                magic:    classData.magic,
                speed:    classData.speed,
                gold: 100,
                bankGold: 0,  // Bank storage starts empty
                weapon: classData.startWeapon,
                armor:  classData.startArmor,
                inventory:  [classData.startWeapon, classData.startArmor],
                knownSpells: getStartingSpells(classKey),
                defeatedMasters: [],
                unlockedAreas:  ['forest'],
                // â”€â”€ new stat block â”€â”€
                str: stats.str,  dex: stats.dex,  wis: stats.wis,
                cha: stats.cha,  con: stats.con,  lck: stats.lck
            };
            gameState.currentLocation = 'town';
            
            // Auto-save new character
            saveGame();
            
            showTown();
        }

        function getStartingSpells(classKey) {
            const spellMap = {
                mage: ['fireball'],
                cleric: ['heal'],
                paladin: ['heal', 'holy_light'],
                ranger: [],
                warrior: [],
                rogue: []
            };
            return spellMap[classKey] || [];
        }

        function showTown() {
            document.body.classList.remove("terminal-mode");
            
            // Start MP regeneration (slower in town)
            startMpRegen(true);
            // Start resting for HP regen (slower in town)
            startResting(true);
            
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">${LOCATIONS.town.name}</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>${LOCATIONS.town.description}</p>
                    <p style="color: var(--border-color); font-size: 14px;">Modem Speed: ${currentModemSpeed}</p>
                </div>
                <div style="margin: 20px 0;">
                    <div class="menu-option" onclick="showShop()">â–º VISIT SHOP</div>
                    <div class="menu-option" onclick="showBank()">ğŸ¦ BANK (${gameState.player.bankGold || 0}g stored)</div>
                    <div class="menu-option" onclick="enterDungeons()">ğŸ° DUNGEONS</div>
                    <div class="menu-option" onclick="restAtInn()">â–º REST AT INN (${calcInnCost(gameState.player.cha)} Gold)</div>
                    <div class="menu-option" onclick="showInventory()">â–º INVENTORY</div>
                    <div class="menu-option" onclick="showExplore()">â–º EXPLORE WORLD</div>
                    <div class="menu-option" onclick="showModemSettings()">â–º MODEM SETTINGS</div>
                    <div class="menu-option" onclick="saveGame()" style="border-color:var(--text-color);">ğŸ’¾ QUICK SAVE (auto-backup)</div>
                    <div class="menu-option" onclick="downloadSaveFile()" style="border-color:var(--highlight-color);background:rgba(255,255,0,0.05);">ğŸ“¥ DOWNLOAD SAVE FILE (backup to device)</div>
                    <div class="menu-option" onclick="showMainMenu()">â–º QUIT TO MENU</div>
                </div>
            `;
        }

        function showBank() {
            const screen = document.getElementById('mainScreen');
            const p = gameState.player;
            screen.innerHTML = `
                <div class="location-header">ğŸ¦ TOWN BANK</div>
                ${renderPlayerStats()}
                <div class="message" style="border-color:var(--highlight-color);">
                    <p><strong style="color:var(--highlight-color);">ğŸ’° YOUR VAULT IS SAFE</strong></p>
                    <p style="color:#8aaa8a;">Gold stored in the bank is protected from death penalties in dungeons!</p>
                </div>
                <div class="message">
                    <p><span class="stat-label">Carried Gold:</span> <span style="color:#FFD700;">${p.gold}g</span></p>
                    <p><span class="stat-label">Bank Vault:</span> <span style="color:#00FF00;">${p.bankGold || 0}g</span></p>
                </div>
                <div style="margin: 20px 0;">
                    <div class="message">
                        <p><span class="stat-label">Deposit Gold:</span></p>
                        <input type="number" id="depositAmount" min="1" max="${p.gold}" value="${Math.min(100, p.gold)}" 
                               style="width:150px;padding:8px;background:var(--secondary-bg);color:var(--text-color);border:2px solid var(--border-color);font-family:'Courier New',monospace;font-size:16px;">
                        <button onclick="depositGold()" style="margin-left:10px;">ğŸ’° DEPOSIT</button>
                    </div>
                    <div class="message">
                        <p><span class="stat-label">Withdraw Gold:</span></p>
                        <input type="number" id="withdrawAmount" min="1" max="${p.bankGold || 0}" value="${Math.min(100, p.bankGold || 0)}" 
                               style="width:150px;padding:8px;background:var(--secondary-bg);color:var(--text-color);border:2px solid var(--border-color);font-family:'Courier New',monospace;font-size:16px;">
                        <button onclick="withdrawGold()" style="margin-left:10px;">ğŸ’µ WITHDRAW</button>
                    </div>
                </div>
                <button onclick="showTown()">â† BACK TO TOWN</button>
            `;
        }

        function depositGold() {
            const amount = parseInt(document.getElementById('depositAmount').value);
            const p = gameState.player;
            
            if (isNaN(amount) || amount <= 0) {
                alert('Invalid amount!');
                return;
            }
            
            if (amount > p.gold) {
                alert('You don\'t have that much gold!');
                return;
            }
            
            p.gold -= amount;
            p.bankGold = (p.bankGold || 0) + amount;
            
            saveGame();
            showBank();
        }

        function withdrawGold() {
            const amount = parseInt(document.getElementById('withdrawAmount').value);
            const p = gameState.player;
            
            if (isNaN(amount) || amount <= 0) {
                alert('Invalid amount!');
                return;
            }
            
            if (amount > (p.bankGold || 0)) {
                alert('You don\'t have that much gold in the bank!');
                return;
            }
            
            p.bankGold -= amount;
            p.gold += amount;
            
            saveGame();
            showBank();
        }

        function showModemSettings() {
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">ğŸ“ MODEM SETTINGS ğŸ“</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>Select your connection speed:</p>
                    <p style="font-size: 14px; color: var(--border-color);">Current: ${currentModemSpeed}</p>
                </div>
                <div style="margin: 20px 0;">
                    <div class="menu-option ${currentModemSpeed === '14.4k' ? 'equipped' : ''}" onclick="setModemSpeed('14.4k')">
                        â–º 14.4k MODEM (Slowest - Most Authentic)
                    </div>
                    <div class="menu-option ${currentModemSpeed === '28.8k' ? 'equipped' : ''}" onclick="setModemSpeed('28.8k')">
                        â–º 28.8k MODEM (Slow - Classic BBS Feel)
                    </div>
                    <div class="menu-option ${currentModemSpeed === '56k' ? 'equipped' : ''}" onclick="setModemSpeed('56k')">
                        â–º 56k MODEM (Medium - Faster Loading)
                    </div>
                    <div class="menu-option ${currentModemSpeed === 'instant' ? 'equipped' : ''}" onclick="setModemSpeed('instant')">
                        â–º INSTANT (No Delay - Modern)
                    </div>
                </div>
                <div class="message" style="border-color: var(--highlight-color);">
                    <p style="color: var(--highlight-color);">â„¹ï¸ INFO</p>
                    <p style="font-size: 14px;">Modem speed affects how quickly text appears on screen.</p>
                    <p style="font-size: 14px;">Lower speeds = more authentic 1990s BBS experience!</p>
                    <p style="font-size: 14px;">Combat timer won't start until screen finishes loading.</p>
                </div>
                <button onclick="showTown()">BACK TO TOWN</button>
            `;
        }

        function setModemSpeed(speed) {
            currentModemSpeed = speed;
            showModemSettings();
        }

        function renderPlayerStats() {
            const p = gameState.player;
            const hpPercent = (p.hp / p.maxHp) * 100;
            const mpPercent = (p.mp / p.maxMp) * 100;
            const xpPercent = (p.xp / p.xpToNext) * 100;
            
            // Show advanced class name if evolved
            const displayClass = p.hasEvolved 
                ? `<span style="color:#FF00FF;font-weight:bold;">${getAdvancedClassName(p)}</span>`
                : p.className;

            return `
                <div class="stats-bar">
                    <div>
                        <span class="stat-label">${p.name}</span> - Level ${p.level} ${displayClass}
                    </div>
                    <div>
                        <span class="stat-label">Gold:</span> ${p.gold}
                    </div>
                </div>
                <div class="stats-bar">
                    <div>
                        <span class="stat-label">HP:</span> ${p.hp}/${p.maxHp}
                    </div>
                    <div>
                        <span class="stat-label">MP:</span> ${p.mp}/${p.maxMp}
                    </div>
                    <div>
                        <span class="stat-label">XP:</span> ${p.xp}/${p.xpToNext}
                    </div>
                </div>
            `;
        }

        function showShop() {
            const screen = document.getElementById('mainScreen');
            
            let shopHtml = `
                <div class="location-header">MERCHANT SHOP</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>Welcome to my shop! What can I do for you?</p>
                </div>
                <div style="margin: 20px 0;">
                    <button onclick="showShopBuy()" style="margin-right: 10px;">ğŸ’° BUY ITEMS</button>
                    <button onclick="showShopSell()">ğŸ’ SELL ITEMS</button>
                </div>
                <div id="shopContent"></div>
                <button onclick="showTown()">LEAVE SHOP</button>
            `;
            
            screen.innerHTML = shopHtml;
            showShopBuy(); // Default to buy tab
        }

        function enterDungeons() {
    termClear();
    testDungeon();
}


        function showShopBuy() {
            let shopHtml = `
                <div style="margin: 20px 0;">
                    <h3 style="color: var(--highlight-color);">WEAPONS</h3>
                    <div class="inventory-grid">
            `;

            Object.keys(WEAPONS).forEach(key => {
                const weapon = WEAPONS[key];
                if (weapon.level <= gameState.player.level + 2) {
                    const owned = gameState.player.inventory.includes(key);
                    const equipped = gameState.player.weapon === key;
                    const qualityColor = QUALITY_CONFIG[weapon.quality].color;
                    const qualityBonus = QUALITY_CONFIG[weapon.quality].bonus;
                    const totalDmg = weapon.baseDamage + qualityBonus;
                    const totalMag = weapon.baseMagicDamage + qualityBonus;
                    
                    shopHtml += `
                        <div class="item-card ${equipped ? 'equipped' : ''}">
                            <div style="color: ${qualityColor};">${weapon.name}</div>
                            <div>DMG: ${totalDmg} | MAG: ${totalMag}</div>
                            <div>Level: ${weapon.level}</div>
                            ${owned ? '<div style="color: var(--border-color);">OWNED</div>' : 
                              `<button onclick="buyItem('weapon', '${key}', ${weapon.cost})">Buy ${weapon.cost}G</button>`}
                            ${gameState.player.cha ? '<div style="color:#8aaa8a;font-size:15px;">CHA disc: ' + calcChaDiscount(gameState.player.cha) + '%</div>' : ''}
                        </div>
                    `;
                }
            });

            shopHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">ARMOR</h3>
                    <div class="inventory-grid">
            `;

            Object.keys(ARMOR).forEach(key => {
                const armor = ARMOR[key];
                if (armor.level <= gameState.player.level + 2) {
                    const owned = gameState.player.inventory.includes(key);
                    const equipped = gameState.player.armor === key;
                    const qualityColor = QUALITY_CONFIG[armor.quality].color;
                    const qualityBonus = QUALITY_CONFIG[armor.quality].bonus;
                    const totalDef = armor.baseDefense + qualityBonus;
                    const totalMag = (armor.baseMagicBonus || 0) + (qualityBonus > 0 ? Math.floor(qualityBonus / 2) : 0);
                    
                    shopHtml += `
                        <div class="item-card ${equipped ? 'equipped' : ''}">
                            <div style="color: ${qualityColor};">${armor.name}</div>
                            <div>DEF: ${totalDef}</div>
                            ${totalMag > 0 ? `<div>MAG+: ${totalMag}</div>` : ''}
                            <div>Level: ${armor.level}</div>
                            ${owned ? '<div style="color: var(--border-color);">OWNED</div>' : 
                              `<button onclick="buyItem('armor', '${key}', ${armor.cost})">Buy ${armor.cost}G</button>`}
                            ${gameState.player.cha ? '<div style="color:#8aaa8a;font-size:15px;">CHA disc: ' + calcChaDiscount(gameState.player.cha) + '%</div>' : ''}
                        </div>
                    `;
                }
            });

            shopHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">POTIONS</h3>
                    <div class="inventory-grid">
            `;

            // Add potions to shop
            const potionsForSale = ['health_potion', 'greater_health_potion', 'superior_health_potion',
                                   'mana_potion', 'greater_mana_potion', 'superior_mana_potion', 'elixir'];
            
            potionsForSale.forEach(key => {
                if (ITEMS[key]) {
                    const item = ITEMS[key];
                    shopHtml += `
                        <div class="item-card">
                            <div style="color: var(--highlight-color);">${item.name}</div>
                            <div>${item.description}</div>
                            <div>Power: ${item.power || 'Full'}</div>
                            <button onclick="buyItem('item', '${key}', ${item.cost})">Buy ${item.cost}G</button>
                            ${gameState.player.cha ? '<div style="color:#8aaa8a;font-size:15px;">CHA disc: ' + calcChaDiscount(gameState.player.cha) + '%</div>' : ''}
                        </div>
                    `;
                }
            });

            shopHtml += `
                    </div>
                </div>
            `;
            
            document.getElementById('shopContent').innerHTML = shopHtml;
        }

        function showShopSell() {
            const p = gameState.player;
            
            // Get all sellable items
            const sellableItems = p.inventory.filter(itemKey => {
                // Items with sellValue
                if (ITEMS[itemKey] && ITEMS[itemKey].sellValue > 0) return true;
                // Duplicate weapons/armor (not currently equipped)
                if (WEAPONS[itemKey] && itemKey !== p.weapon) return true;
                if (ARMOR[itemKey] && itemKey !== p.armor) return true;
                return false;
            });
            
            let sellHtml = '<h3 style="color: var(--highlight-color);">YOUR SELLABLE ITEMS</h3>';
            sellHtml += '<div class="inventory-grid">';
            
            if (sellableItems.length === 0) {
                sellHtml += '<div class="message">You have nothing to sell.</div>';
            } else {
                sellableItems.forEach(itemKey => {
                    let itemName, itemColor, sellValue, itemDesc;
                    
                    if (ITEMS[itemKey]) {
                        const item = ITEMS[itemKey];
                        itemName = item.name;
                        itemColor = '#00FF00';
                        sellValue = item.sellValue;
                        itemDesc = item.description;
                    } else if (WEAPONS[itemKey]) {
                        const weapon = WEAPONS[itemKey];
                        itemName = weapon.name;
                        itemColor = QUALITY_CONFIG[weapon.quality].color;
                        sellValue = Math.floor(weapon.cost * 0.5); // 50% of purchase price
                        const qualityBonus = QUALITY_CONFIG[weapon.quality].bonus;
                        itemDesc = `DMG: ${weapon.baseDamage + qualityBonus} | MAG: ${weapon.baseMagicDamage + qualityBonus}`;
                    } else if (ARMOR[itemKey]) {
                        const armor = ARMOR[itemKey];
                        itemName = armor.name;
                        itemColor = QUALITY_CONFIG[armor.quality].color;
                        sellValue = Math.floor(armor.cost * 0.5); // 50% of purchase price
                        const qualityBonus = QUALITY_CONFIG[armor.quality].bonus;
                        itemDesc = `DEF: ${armor.baseDefense + qualityBonus}`;
                    }
                    
                    sellHtml += `
                        <div class="item-card">
                            <div style="color: ${itemColor};">${itemName}</div>
                            <div style="font-size: 16px;">${itemDesc}</div>
                            <div style="color: var(--border-color); margin-top: 10px;">Sell for: ${sellValue}G</div>
                            <button onclick="sellItem('${itemKey}', ${sellValue})">SELL</button>
                        </div>
                    `;
                });
            }
            
            sellHtml += '</div>';
            document.getElementById('shopContent').innerHTML = sellHtml;
        }

        function sellItem(itemKey, baseValue) {
            const index = gameState.player.inventory.indexOf(itemKey);
            if (index === -1) { alert('Item not found!'); return; }
            const bonus = calcChaSellBonus(gameState.player.cha);
            const value = Math.floor(baseValue * (1 + bonus/100));
            gameState.player.inventory.splice(index, 1);
            gameState.player.gold += value;
            const itemName = getItemName(itemKey);
            alert(`Sold ${itemName} for ${value}g!` + (bonus > 0 ? ` (+${bonus}% CHA bonus)` : ''));
            
            // ğŸ’¾ AUTO-SAVE after selling
            saveGame();
            
            showShopSell();
        }

        function buyItem(type, key, baseCost) {
            const disc   = calcChaDiscount(gameState.player.cha);
            const cost   = Math.max(1, Math.floor(baseCost * (1 - disc/100)));
            if (gameState.player.gold < cost) {
                alert('Not enough gold!');
                return;
            }
            gameState.player.gold -= cost;
            gameState.player.inventory.push(key);
            let itemName;
            if (type === 'weapon') itemName = WEAPONS[key].name;
            else if (type === 'armor') itemName = ARMOR[key].name;
            else if (type === 'item') itemName = ITEMS[key].name;
            alert(`Purchased ${itemName} for ${cost}g!` + (disc > 0 ? ` (${disc}% CHA discount)` : ''));
            
            // ğŸ’¾ AUTO-SAVE after buying
            saveGame();
            
            showShopBuy();
        }

        function restAtInn() {
            const cost = calcInnCost(gameState.player.cha);
            if (gameState.player.gold < cost) {
                alert('Not enough gold!');
                return;
            }
            gameState.player.gold -= cost;
            gameState.player.hp = gameState.player.maxHp;
            gameState.player.mp = gameState.player.maxMp;
            alert('You rest at the inn and recover fully!');
            showTown();
        }

        function showInventory() {
            const p = gameState.player;
            const screen = document.getElementById('mainScreen');
            
            let invHtml = `
                <div class="location-header">INVENTORY</div>
                ${renderPlayerStats()}
                <div style="margin: 20px 0;">
                    <h3 style="color: var(--highlight-color);">WEAPONS</h3>
                    <div class="inventory-grid">
            `;

            p.inventory.filter(item => WEAPONS[item]).forEach(key => {
                const weapon = WEAPONS[key];
                const equipped = p.weapon === key;
                const qualityColor = QUALITY_CONFIG[weapon.quality].color;
                const qualityBonus = QUALITY_CONFIG[weapon.quality].bonus;
                const totalDmg = weapon.baseDamage + qualityBonus;
                const totalMag = weapon.baseMagicDamage + qualityBonus;
                
                invHtml += `
                    <div class="item-card ${equipped ? 'equipped' : ''}">
                        <div style="color: ${qualityColor};">${weapon.name}</div>
                        <div>DMG: ${totalDmg} | MAG: ${totalMag}</div>
                        ${equipped ? '<div style="color: var(--border-color);">EQUIPPED</div>' : 
                          `<button onclick="equipItem('weapon', '${key}')">EQUIP</button>`}
                    </div>
                `;
            });

            invHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">ARMOR</h3>
                    <div class="inventory-grid">
            `;

            p.inventory.filter(item => ARMOR[item]).forEach(key => {
                const armor = ARMOR[key];
                const equipped = p.armor === key;
                const qualityColor = QUALITY_CONFIG[armor.quality].color;
                const qualityBonus = QUALITY_CONFIG[armor.quality].bonus;
                const totalDef = armor.baseDefense + qualityBonus;
                const totalMag = (armor.baseMagicBonus || 0) + (qualityBonus > 0 ? Math.floor(qualityBonus / 2) : 0);
                
                invHtml += `
                    <div class="item-card ${equipped ? 'equipped' : ''}">
                        <div style="color: ${qualityColor};">${armor.name}</div>
                        <div>DEF: ${totalDef}</div>
                        ${totalMag > 0 ? `<div>MAG+: ${totalMag}</div>` : ''}
                        ${equipped ? '<div style="color: var(--border-color);">EQUIPPED</div>' : 
                          `<button onclick="equipItem('armor', '${key}')">EQUIP</button>`}
                    </div>
                `;
            });

            invHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">SPELLS</h3>
                    <div class="inventory-grid">
            `;

            if (p.knownSpells.length === 0) {
                invHtml += '<div class="message">No spells learned yet.</div>';
            } else {
                p.knownSpells.forEach(spellKey => {
                    const spell = SPELLS[spellKey];
                    invHtml += `
                        <div class="item-card">
                            <div style="color: var(--highlight-color);">${spell.name}</div>
                            <div>MP Cost: ${spell.mpCost}</div>
                            <div>Power: ${spell.power}</div>
                            <div>${spell.description}</div>
                        </div>
                    `;
                });
            }

            invHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">CONSUMABLES & ITEMS</h3>
                    <div class="inventory-grid">
            `;

            // Count and display items
            const itemCounts = {};
            p.inventory.filter(item => ITEMS[item]).forEach(key => {
                itemCounts[key] = (itemCounts[key] || 0) + 1;
            });

            if (Object.keys(itemCounts).length === 0) {
                invHtml += '<div class="message">No items.</div>';
            } else {
                Object.keys(itemCounts).forEach(itemKey => {
                    const item = ITEMS[itemKey];
                    const count = itemCounts[itemKey];
                    const color = item.type === 'sellable' ? '#FFD700' : 
                                 item.subtype === 'heal_hp' ? '#FF0000' :
                                 item.subtype === 'heal_mp' ? '#0000FF' : '#00FF00';
                    
                    invHtml += `
                        <div class="item-card">
                            <div style="color: ${color};">${item.name} x${count}</div>
                            <div style="font-size: 16px;">${item.description}</div>
                            ${item.sellValue ? `<div style="color: var(--border-color);">Value: ${item.sellValue}G</div>` : ''}
                        </div>
                    `;
                });
            }

            invHtml += `
                    </div>
                </div>
                <button onclick="showTown()">BACK</button>
            `;

            screen.innerHTML = invHtml;
        }

        function equipItem(type, key) {
            if (type === 'weapon') {
                gameState.player.weapon = key;
            } else {
                gameState.player.armor = key;
            }
            
            // ğŸ’¾ AUTO-SAVE after equipping
            saveGame();
            
            showInventory();
        }

        function showExplore() {
            const screen = document.getElementById('mainScreen');
            const p = gameState.player;
            
            // Auto-unlock zones that don't require masters (just level requirement)
            Object.keys(LOCATIONS).forEach(key => {
                const loc = LOCATIONS[key];
                if (key !== 'town' && !loc.locked && loc.requiredLevel && p.level >= loc.requiredLevel) {
                    if (!p.unlockedAreas.includes(key)) {
                        p.unlockedAreas.push(key);
                    }
                }
            });
            
            let exploreHtml = `
                <div class="location-header">WORLD MAP</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>Where would you like to explore?</p>
                </div>
                <div style="margin: 20px 0;">
            `;

            Object.keys(LOCATIONS).forEach(key => {
                const loc = LOCATIONS[key];
                if (key !== 'town') {
                    const levelInfo = loc.enemyLevelRange ? 
                        ` (Lv ${loc.enemyLevelRange[0]}-${loc.enemyLevelRange[1]})` : '';
                    
                    const isUnlocked = p.unlockedAreas.includes(key);
                    const canChallengeMaster = !isUnlocked && p.level >= loc.requiredLevel;
                    
                    if (isUnlocked) {
                        // Unlocked area - can explore
                        exploreHtml += `
                            <div class="menu-option" onclick="exploreLocation('${key}')">
                                â–º ${loc.name}${levelInfo} <span style="color: var(--border-color);">âœ“ UNLOCKED</span>
                            </div>
                        `;
                        
                        // Show master challenge option if available
                        const masterKey = `${p.class}_master_${key}`;
                        if (CLASS_MASTERS[masterKey] && !p.defeatedMasters.includes(masterKey)) {
                            const master = CLASS_MASTERS[masterKey];
                            if (p.level >= master.requiredLevel) {
                                exploreHtml += `
                                    <div class="menu-option" onclick="challengeMaster('${masterKey}')" style="border-color: var(--highlight-color); background: rgba(255, 255, 0, 0.1);">
                                        âš”ï¸ CHALLENGE MASTER: ${master.name} (Lv ${master.level})
                                    </div>
                                `;
                            }
                        }
                    } else {
                        // Locked area
                        if (canChallengeMaster) {
                            // Can challenge master to unlock
                            const masterKey = getMasterKeyForArea(key);
                            const master = CLASS_MASTERS[masterKey];
                            
                            if (master) {
                                exploreHtml += `
                                    <div class="menu-option" style="opacity: 0.6; cursor: default;" onclick="alert('${loc.unlockMessage}')">
                                        ğŸ”’ ${loc.name}${levelInfo} - LOCKED
                                    </div>
                                    <div class="menu-option" onclick="challengeMaster('${masterKey}')" style="border-color: var(--error-color); background: rgba(255, 0, 0, 0.1);">
                                        âš”ï¸ CHALLENGE MASTER: ${master.name} (Lv ${master.level}) TO UNLOCK!
                                    </div>
                                `;
                            } else {
                                // No master for this zone, just show locked
                                exploreHtml += `
                                    <div class="menu-option" style="opacity: 0.6; cursor: default;" onclick="alert('${loc.unlockMessage || 'Reach level ' + loc.requiredLevel + ' to unlock this area!'}')">
                                        ğŸ”’ ${loc.name}${levelInfo} - LOCKED (Need Lv ${loc.requiredLevel})
                                    </div>
                                `;
                            }
                        } else {
                            // Level too low
                            exploreHtml += `
                                <div class="menu-option" style="opacity: 0.6; cursor: default;" onclick="alert('You need to reach level ${loc.requiredLevel} first!')">
                                    ğŸ”’ ${loc.name}${levelInfo} - LOCKED (Need Lv ${loc.requiredLevel})
                                </div>
                            `;
                        }
                    }
                }
            });

            exploreHtml += `
                </div>
                <button onclick="showTown()">RETURN TO TOWN</button>
            `;

            screen.innerHTML = exploreHtml;
        }

        function getMasterKeyForArea(areaKey) {
            // Find which area unlocks this one
            const areaOrder = ['forest', 'plains', 'cave', 'crypt', 'volcano'];
            const index = areaOrder.indexOf(areaKey);
            if (index > 0) {
                const previousArea = areaOrder[index - 1];
                return `${gameState.player.class}_master_${previousArea}`;
            }
            return null;
        }

        function challengeMaster(masterKey) {
            const master = CLASS_MASTERS[masterKey];
            if (!master) {
                alert('Master not found!');
                return;
            }
            
            const p = gameState.player;
            
            // Check if already defeated
            if (p.defeatedMasters.includes(masterKey)) {
                alert('You have already defeated this master!');
                return;
            }
            
            // Check level requirement
            if (p.level < master.requiredLevel) {
                alert(`You need to be level ${master.requiredLevel} to challenge this master!`);
                return;
            }
            
            // Show master challenge screen
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">âš”ï¸ MASTER CHALLENGE âš”ï¸</div>
                ${renderPlayerStats()}
                <div class="message" style="border-color: var(--error-color); background: rgba(255, 0, 0, 0.1);">
                    <p style="color: var(--highlight-color); font-size: 24px;">${master.name}</p>
                    <p style="color: var(--text-color); margin: 10px 0;">${master.description}</p>
                    <p style="color: var(--border-color);">Level: ${master.level} | HP: ${master.baseHp} | Defense: ${master.baseDefense}</p>
                    <p style="color: var(--error-color); margin-top: 15px;">âš ï¸ THIS IS A BOSS FIGHT! âš ï¸</p>
                    <p>Defeating this master will unlock: <span style="color: var(--highlight-color);">${LOCATIONS[master.unlocks].name}</span></p>
                </div>
                <div class="message" style="border-color: var(--highlight-color);">
                    <p style="color: var(--highlight-color);">GUARANTEED REWARDS:</p>
                    ${master.guaranteedDrops.map(item => `<p>â€¢ ${getItemName(item)}</p>`).join('')}
                    <p style="margin-top: 10px;">+ ${master.xp} XP and ${master.gold} Gold</p>
                </div>
                <div style="margin: 20px 0;">
                    <button onclick="startMasterBattle('${masterKey}')" style="background: var(--error-color); font-size: 22px;">âš”ï¸ BEGIN BATTLE âš”ï¸</button>
                    <button onclick="showExplore()">RETREAT</button>
                </div>
            `;
        }

        function startMasterBattle(masterKey) {
            const master = CLASS_MASTERS[masterKey];
            const masterMonster = {
                key: masterKey, name: master.name, rarity: 'epic',
                rarityColor: RARITY_CONFIG.epic.color,
                hp: master.baseHp, maxHp: master.baseHp,
                damage: master.baseDamage, defense: master.baseDefense,
                xp: master.xp, gold: master.gold, level: master.level,
                possibleDrops: master.possibleDrops, dropRates: master.dropRates,
                isMaster: true, masterKey: masterKey,
                guaranteedDrops: master.guaranteedDrops
            };
            const maxHits   = calcPlayerHits(gameState.player);
            const pipTimers = [];
            for (let i = 0; i < maxHits; i++) {
                pipTimers.push(10);
            }
            gameState.combatState = {
                monsters: [masterMonster], currentTarget: 0,
                messages: [], defeatedMonsters: [],
                pipTimers:     pipTimers,
                pipAvailable:  pipTimers.map(() => true),
                enemyTimer:    18,
                enemyDelay:    18,
                enemyHits:     3,
                enemyHitsLeft: 3
            };
            // Open the terminal view (clear it fresh for a boss)
            openTerminalView(gameState.currentLocation);
            // stream the boss-intro line; show cards + start timer only after it finishes
            termAppend(`<span style="color:${RARITY_CONFIG.epic.color}; font-size:22px;">âš”ï¸ ${master.name} challenges you to an honorable duel! âš”ï¸</span>`, 'term-highlight', () => {
                renderEnemyCards();
                renderActionBar();
                startCombatTimer();
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // HUD â€“ write once, update in place
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function initHud() {
            updateHud();
        }
        function updateHud() {
    const p = gameState.player;

    // â”€â”€ HUD may be opened before character exists â”€â”€
    if (!p) {
        const hudName = document.getElementById('hudName');
        if (!hudName) return;

        hudName.textContent = 'â€” No Adventurer â€”';
        document.getElementById('hudGold').textContent   = 'ğŸ’° 0 g';
        document.getElementById('hudHpNums').textContent = 'â¤ï¸ HP: â€”';
        document.getElementById('hudMpNums').textContent = 'âœ¨ MP: â€”';
        document.getElementById('hudXpNums').textContent = 'â­ XP: â€”';
        return;
    }

    document.getElementById('hudName').textContent =
        `${p.name} â€“ Lv ${p.level} ${p.className}`;

    document.getElementById('hudGold').textContent =
        `ğŸ’° ${p.gold} g`;

    document.getElementById('hudHpNums').textContent =
        `â¤ï¸ HP: ${p.hp} / ${p.maxHp}`;

    document.getElementById('hudMpNums').textContent =
        `âœ¨ MP: ${p.mp} / ${p.maxMp}`;

    document.getElementById('hudXpNums').textContent =
        `â­ XP: ${p.xp} / ${p.xpToNext}`;
}


        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TERMINAL VIEW helpers
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
function openTerminalView(locKey) {
    // Add terminal-mode class to body
    document.body.classList.add('terminal-mode');
    
    document.getElementById('mainScreen').style.display = 'none';

    const hud = document.getElementById('hud');
    const term = document.getElementById('terminalWindow');
    const ab = document.getElementById('actionBar');

    hud.style.display = 'block';
    term.style.display = 'block';

  // ğŸ”‘ RESET terminal scroll position on open
requestAnimationFrame(() => {
    const tw = document.getElementById('terminalWindow');
    tw.style.display = 'block';
    tw.offsetHeight;
    tw.scrollTop = 0;
});


// Dungeon always uses the action bar for movement
ab.style.display = 'block';

    initHud();

    if (!gameState._terminalOpen) {
        term.innerHTML = '';
        term.scrollTop = 0;
       

        gameState._terminalOpen = true;
        gameState._currentExploreArea = locKey;

        if (LOCATIONS?.[locKey]) {
            termAppend(`â”€â”€ ${LOCATIONS[locKey].name} â”€â”€`, 'term-separator');
        }
    }

    updateTerminalSafeArea();

}


function stabilizeTerminalLayout() {
    const tw = document.getElementById('terminalWindow');
    if (!tw) return;

    // Force flexbox to resolve height again
    tw.style.display = 'block';
    tw.offsetHeight;

    // Reassert scrolling
    tw.style.overflowY = 'auto';
}



        function closeTerminalView() {
            document.getElementById('mainScreen').style.display    = 'block';
            document.getElementById('hud').style.display           = 'none';
            document.getElementById('terminalWindow').style.display = 'none';
            document.getElementById('actionBar').style.display     = 'none';
            gameState._terminalOpen = false;
            gameState._currentExploreArea = null;
        }
        // â”€â”€ modem-style line queue â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const termQueue   = [];          // pending { html, extraClass, onDone }
        let   termBusy    = false;       // true while a line is mid-stream



        function termAppend(html, extraClass, onDone) {
            termQueue.push({ html, extraClass, onDone: onDone || null });
            if (!termBusy) termDrain();
        }

        function scrollTerminalToBottom() {
    const tw = document.getElementById('terminalWindow');
    if (!tw) return;

    tw.scrollTop = tw.scrollHeight;
    
}


 function termDrain() {
    if (termQueue.length === 0) {
        termBusy = false;
        return;
    }

    termBusy = true;
    const { html, extraClass, onDone } = termQueue.shift();
    const tw = document.getElementById('terminalWindow');

    // âœ… Decide ONCE whether we should auto-scroll
    const shouldAutoScroll =
        tw.scrollHeight <= tw.clientHeight + 5 ||
        tw.scrollHeight - tw.scrollTop - tw.clientHeight < 40;

    const line = document.createElement('div');
    line.className = 'term-line' + (extraClass ? ' ' + extraClass : '');
    tw.appendChild(line);

    // separator or empty lines
    if (extraClass === 'term-separator' || html === '') {
        line.innerHTML = html;
        if (shouldAutoScroll) {
            tw.scrollTop = tw.scrollHeight;
        }
        if (onDone) onDone();
        termDrain();
        return;
    }

    // instant mode
    if (currentModemSpeed === 'instant') {
        line.innerHTML = html;
        if (shouldAutoScroll) {
            tw.scrollTop = tw.scrollHeight;
        }
        if (onDone) onDone();
        termDrain();
        return;
    }

    // streaming mode
    const charsPerTick = MODEM_SPEEDS[currentModemSpeed];
    let visibleCount = 0;
    let totalVisible = 0;

    // count visible characters (ignore HTML tags)
    {
        let inTag = false;
        for (let i = 0; i < html.length; i++) {
            if (html[i] === '<') inTag = true;
            else if (html[i] === '>') inTag = false;
            else if (!inTag) totalVisible++;
        }
    }

    const ticker = setInterval(() => {
        visibleCount += charsPerTick;

        if (visibleCount >= totalVisible) {
            clearInterval(ticker);
            line.innerHTML = html;

            // âœ… scroll ONLY after line completes
            if (shouldAutoScroll) {
                tw.scrollTop = tw.scrollHeight;
            }

            if (onDone) onDone();
            termDrain();
        } else {
            line.innerHTML =
                sliceToVisible(html, visibleCount) +
                '<span style="animation:blink 1s infinite;">_</span>';
        }
    }, 16);
}



            function sliceToVisible(html, n) {
    let vis = 0;
    let inTag = false;

    for (let i = 0; i < html.length; i++) {
        if (html[i] === '<') inTag = true;
        else if (html[i] === '>') inTag = false;
        else if (!inTag) {
            vis++;
            if (vis >= n) return html.slice(0, i + 1);
        }
    }
    return html;
}


     

       function termClear() {
    const tw = document.getElementById('terminalWindow');
    tw.innerHTML = '';
    tw.scrollTop = 0;  // ğŸ”¥ RESET SCROLL TO TOP
}


        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EXPLORE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function exploreLocation(locKey) {
            document.body.classList.add("terminal-mode");

            const location = LOCATIONS[locKey];
            const p = gameState.player;
            if (!p.unlockedAreas.includes(locKey)) {
    document.body.classList.remove("terminal-mode"); // ğŸ‘ˆ ADD THIS
    alert(location.unlockMessage || 'This area is locked!');
    showExplore();
    return;
}

            gameState.currentLocation = locKey;
            
            // Start regeneration when exploring (normal speed)
            startMpRegen(false);
            startResting(false);

            // If we just arrived (from town / map), open the terminal fresh
            if (!gameState._terminalOpen || gameState._currentExploreArea !== locKey) {
                gameState._terminalOpen = false;   // force fresh open
                openTerminalView(locKey);
            } else {
                // Already in this area â€“ just add a separator
                termAppend('', 'term-separator');
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ROLL FOR RANDOM ADVENTURE (if adventure system is loaded)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof rollForAdventure !== 'undefined') {
                const adventureRoll = Math.random();
                const adventureThreshold = location.adventureChance = .05; // FORCE 100% = 1 FOR TESTING
                
                if (adventureRoll < adventureThreshold) {
                    const adventure = rollForAdventure(p.level);
                    if (adventure) {
                        startAdventure(adventure);
                        return; // Adventure takes over, no normal combat
                    }
                }
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // NORMAL COMBAT ENCOUNTER
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (Math.random() < 0.7) {
                const numMonsters = rollMonsterCount();
                const enemyKeys = [];
                for (let i = 0; i < numMonsters; i++) {
                    enemyKeys.push(location.encounters[Math.floor(Math.random() * location.encounters.length)]);
                }
                startCombat(enemyKeys);
            } else {
                termAppend(`You explore the areaâ€¦ but find nothing.`, 'term-dim');
                renderActionBar();   // show "Continue / Town" buttons
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COMBAT â€“ start / spawn / rarity
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function rollMonsterCount() {
            const r = Math.random() * 100;
            if (r < 70) return 1;
            if (r < 95) return 2;
            return 3;
        }
        function startCombat(enemyKeys) {
            // Stop resting when combat starts
            stopResting();
            
            if (!Array.isArray(enemyKeys)) enemyKeys = [enemyKeys];
            const monsters = enemyKeys.map(k => spawnMonsterWithRarity(k, true)); // true = use zone level

            let msg;
            if (monsters.length === 1)
                msg = `A wild <span style="color:${monsters[0].rarityColor};">${monsters[0].name}</span> appears!`;
            else {
                const names = monsters.map(m => `<span style="color:${m.rarityColor};">${m.name}</span>`).join(', ');
                msg = `${monsters.length} enemies appear: ${names}!`;
            }

            // enemy multi-hit based on rarity of first monster
            const rar0 = monsters[0].rarity;
            let eHits = 1;
            if      (rar0==='rare')      eHits = Math.random()<0.5 ? 2 : 1;
            else if (rar0==='epic')      eHits = 2;
            else if (rar0==='legendary') eHits = 2 + (Math.random()<0.5 ? 1 : 0);
            else if (rar0==='mythic')    eHits = 3;

            const enemyDelay = 15 + Math.floor(Math.random()*6);  // 15-20s, fixed for this combat
            const maxHits    = calcPlayerHits(gameState.player);
            const pipTimers  = [];
            for (let i = 0; i < maxHits; i++) {
                pipTimers.push(10);  // each pip starts at 10s
            }
            gameState.combatState = {
                monsters, currentTarget: 0,
                messages: [], defeatedMonsters: [],
                pipTimers:     pipTimers,    // array of timers, one per pip
                pipAvailable:  pipTimers.map(() => true),  // which pips are ready
                enemyTimer:    enemyDelay,
                enemyDelay:    enemyDelay,
                enemyHits:     eHits,
                enemyHitsLeft: eHits
            };
            // stream the encounter line; show cards + start timer only after it finishes
            termAppend(msg, 'term-enemy', () => {
                renderEnemyCards();
                renderActionBar();
                startCombatTimer();
            });
        }

        function spawnMonsterWithRarity(enemyKey, zoneLevel = null) {
            const template = ENEMIES[enemyKey];
            const rarity   = rollRarity();
            const mult     = RARITY_CONFIG[rarity].multiplier;
            
            // Determine monster level (use zone level if provided, otherwise template level)
            let monsterLevel = template.level;
            if (zoneLevel !== null) {
                // Random level within zone range
                const location = LOCATIONS[gameState.currentLocation];
                if (location && location.enemyLevelRange) {
                    const [minLvl, maxLvl] = location.enemyLevelRange;
                    monsterLevel = minLvl + Math.floor(Math.random() * (maxLvl - minLvl + 1));
                }
            }
            
            // Scale stats based on monster level
            const levelMult = 1 + (monsterLevel - 1) * 0.15; // 15% increase per level
            
            const monster = {
                key: enemyKey, 
                name: template.name, 
                rarity, 
                rarityColor: RARITY_CONFIG[rarity].color,
                hp: Math.floor(template.baseHp * mult * levelMult), 
                maxHp: Math.floor(template.baseHp * mult * levelMult),
                damage: Math.floor(template.baseDamage * mult * levelMult), 
                defense: Math.floor(template.baseDefense * mult * levelMult),
                xp: Math.floor(template.baseXp * mult * levelMult), // Base XP, will be scaled on defeat
                gold: Math.floor(template.baseGold * mult * levelMult),
                level: monsterLevel, 
                possibleDrops: template.possibleDrops, 
                dropRates: template.dropRates
            };
            
            return monster;
        }
        
        function calculateXpReward(monster, playerLevel) {
            // Dynamic XP based on level difference and rarity
            const levelDiff = monster.level - playerLevel;
            
            // Base XP from monster
            let xp = monster.xp;
            
            // Level difference multiplier
            // Same level: 100%
            // 1 level higher: 120%
            // 2 levels higher: 140%
            // 1 level lower: 80%
            // 5+ levels lower: 10%
            let levelMult = 1.0;
            
            if (levelDiff >= 5) {
                levelMult = 2.0; // Huge bonus for fighting much stronger enemies
            } else if (levelDiff >= 3) {
                levelMult = 1.6;
            } else if (levelDiff >= 1) {
                levelMult = 1.0 + (levelDiff * 0.2);
            } else if (levelDiff === 0) {
                levelMult = 1.0;
            } else if (levelDiff >= -2) {
                levelMult = 1.0 + (levelDiff * 0.1); // 90%, 80%
            } else if (levelDiff >= -5) {
                levelMult = 0.5;
            } else {
                levelMult = 0.1; // Killing gray mobs gives almost nothing
            }
            
            // Rarity bonus (already in base XP, but add a small extra)
            const rarityBonus = RARITY_CONFIG[monster.rarity].multiplier * 0.1;
            
            xp = Math.floor(xp * levelMult * (1 + rarityBonus));
            
            // Minimum 1 XP
            return Math.max(1, xp);
        }
        
        function rollRarity() {
            const roll = Math.random() * 100;
            let cum = 0;
            for (const [rarity, config] of Object.entries(RARITY_CONFIG)) {
                cum += config.spawnWeight;
                if (roll < cum) return rarity;
            }
            return 'common';
        }
        function getRarityText(rarity) {
            return `<span style="color:${RARITY_CONFIG[rarity].color}; font-weight:bold;">${RARITY_CONFIG[rarity].name}</span>`;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ENEMY CARDS â€“ rendered into terminal, updated in place
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function renderEnemyCards() {
            // Enemy info is now shown only in terminal messages - no visual cards needed
            // This function is still called for compatibility but does nothing
        }
        function updateEnemyCards() {
            // No longer needed - enemy info shown in terminal only
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ACTION BAR â€“ combat buttons / explore buttons / spell & potion menus
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
       // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       // DUNGEON MAP SYSTEM
       // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       
       function showDungeonMap() {
           const ds = gameState.dungeon;
           if (!ds) return;
           
           if (typeof DUNGEONS === 'undefined') {
               alert('Dungeon data not loaded!');
               return;
           }
           
           const dungeon = DUNGEONS[ds.dungeonKey];
           const floor = dungeon.floors[ds.floor];
           
           // Build ASCII map
           const mapAscii = generateAsciiMap(floor, ds.currentRoom, ds.discoveredRooms);
           
           // Show map in terminal
           const term = document.getElementById('terminalWindow');
           term.innerHTML = `
               <div style="font-family: monospace; white-space: pre; line-height: 1.2; color: var(--text-color);">
                   <div style="text-align: center; margin-bottom: 10px; color: var(--highlight-color);">
                       === ${dungeon.name} - Floor ${ds.floor} ===
                   </div>
                   <div style="text-align: center; margin-bottom: 15px; color: #8aaa8a; font-size: 14px;">
                       Legend: [@] = You | [ ] = Room | [?] = Undiscovered
                   </div>
${mapAscii}
               </div>
           `;
           
           // Update action bar
           const ab = document.getElementById('actionBar');
           ab.innerHTML = '<button onclick="hideDungeonMap()">â¬… BACK TO DUNGEON</button>';
       }
       
       function hideDungeonMap() {
           const ds = gameState.dungeon;
           if (!ds) return;
           
           // Store combat state before clearing
           const wasInCombat = !!gameState.combatState;
           
           termClear();
           
           // Redraw current room
           const dungeon = DUNGEONS[ds.dungeonKey];
           const floor = dungeon.floors[ds.floor];
           const room = floor.rooms[ds.currentRoom];
           
           termAppend('', 'term-separator');
           termAppend(`<strong>${room.name}</strong>`);
           termAppend(room.description, 'term-dim');
           
           const exits = Object.keys(room.exits).map(d => d.toUpperCase()).join(', ');
           termAppend(`You see exits: ${exits}.`, 'term-dim');
           
           // If there was combat before viewing map, show enemy cards again
           if (wasInCombat) {
               renderEnemyCards();
           } else {
               // Check for enemies in room (if not already in combat)
               checkEnemiesInRoom(ds.currentRoom);
           }
           
           renderDungeonActionBar();
       }
       
       function generateAsciiMap(floor, currentRoom, discoveredRooms) {
           const rooms = floor.rooms;
           
           // Find map bounds
           let minX = Infinity, maxX = -Infinity;
           let minY = Infinity, maxY = -Infinity;
           
           Object.keys(rooms).forEach(roomId => {
               const room = rooms[roomId];
               if (room.map && discoveredRooms.has(roomId)) {
                   minX = Math.min(minX, room.map.x);
                   maxX = Math.max(maxX, room.map.x);
                   minY = Math.min(minY, room.map.y);
                   maxY = Math.max(maxY, room.map.y);
               }
           });
           
           // Create grid (each room takes 4 chars wide, 2 chars tall for spacing)
           const cellWidth = 4;
           const cellHeight = 2;
           const width = (maxX - minX + 1) * cellWidth + 1;
           const height = (maxY - minY + 1) * cellHeight + 1;
           const grid = Array(height).fill(null).map(() => Array(width).fill(' '));
           
           // Helper to get grid position
           const toGridX = (mapX) => (mapX - minX) * cellWidth;
           const toGridY = (mapY) => (mapY - minY) * cellHeight;
           
           // First pass: Draw all connections
           Object.keys(rooms).forEach(roomId => {
               const room = rooms[roomId];
               if (!room.map || !discoveredRooms.has(roomId)) return;
               
               const x = toGridX(room.map.x);
               const y = toGridY(room.map.y);
               
               // Draw connections to discovered rooms
               Object.keys(room.exits).forEach(dir => {
                   const targetId = room.exits[dir];
                   const targetRoom = rooms[targetId];
                   
                   if (!targetRoom || !targetRoom.map || !discoveredRooms.has(targetId)) return;
                   
                   const direction = dir.toLowerCase();
                   
                   if (direction === 'n') {
                       grid[y - 1][x + 1] = '|';
                   } else if (direction === 's') {
                       grid[y + 2][x + 1] = '|';
                   } else if (direction === 'e') {
                       grid[y + 1][x + 3] = '-';
                   } else if (direction === 'w') {
                       grid[y + 1][x - 1] = '-';
                   } else if (direction === 'ne') {
                       grid[y][x + 2] = '/';
                   } else if (direction === 'nw') {
                       grid[y][x] = '\\';
                   } else if (direction === 'se') {
                       grid[y + 2][x + 2] = '\\';
                   } else if (direction === 'sw') {
                       grid[y + 2][x] = '/';
                   }
               });
           });
           
           // Second pass: Draw rooms (overwrites connections at room positions)
           Object.keys(rooms).forEach(roomId => {
               const room = rooms[roomId];
               if (!room.map || !discoveredRooms.has(roomId)) return;
               
               const x = toGridX(room.map.x);
               const y = toGridY(room.map.y);
               
               // Draw room
               const isPlayer = roomId === currentRoom;
               if (isPlayer) {
                   grid[y + 1][x] = '[';
                   grid[y + 1][x + 1] = '@';
                   grid[y + 1][x + 2] = ']';
               } else {
                   grid[y + 1][x] = '[';
                   grid[y + 1][x + 1] = ' ';
                   grid[y + 1][x + 2] = ']';
               }
           });
           
           // Convert grid to string with proper coloring
           let result = '';
           for (let y = 0; y < height; y++) {
               let line = '';
               for (let x = 0; x < width; x++) {
                   const char = grid[y][x];
                   if (char === '@') {
                       line += `<span style="color:var(--highlight-color);">${char}</span>`;
                   } else if (char === '[' || char === ']') {
                       line += `<span style="color:var(--border-color);">${char}</span>`;
                   } else {
                       line += char;
                   }
               }
               result += line + '\n';
           }
           
           return result;
       }

       function renderDungeonActionBar() {
    const ab = document.getElementById('actionBar');

    function updateTerminalSafeArea() {
        const term = document.getElementById('terminalWindow');
        const bar  = document.getElementById('actionBar');
        if (!term || !bar) return;

        const barHeight = bar.offsetHeight;
        term.style.paddingBottom = barHeight + 'px';
    }

    // Clear action bar
    ab.innerHTML = '';
    ab.style.display = 'block';

    const ds = gameState.dungeon;
    if (!ds) return;

    // Safety check for DUNGEONS
    if (typeof DUNGEONS === 'undefined') {
        console.error('âš ï¸ DUNGEONS not loaded!');
        ab.innerHTML = '<button onclick="returnToTown()">âš ï¸ ERROR - Return to Town</button>';
        return;
    }

    const dungeon = DUNGEONS[ds.dungeonKey];
    const floor = dungeon.floors[ds.floor];
    const room = floor.rooms[ds.currentRoom];

    const cs = gameState.combatState;
    
    // â•â•â• COMBAT BUTTONS (if in combat) â•â•â•
if (cs) {
    const maxHits  = cs.pipAvailable
        ? cs.pipAvailable.length
        : calcPlayerHits(gameState.player);

    const hitsLeft = cs.pipAvailable
        ? cs.pipAvailable.filter(x => x).length
        : maxHits;

    const canAct = hitsLeft > 0;
    const pips = 'â—'.repeat(hitsLeft) + 'â—‹'.repeat(maxHits - hitsLeft);
    const mode = cs.actionMode || 'main';

    const combatDiv = document.createElement('div');
    combatDiv.style.cssText =
        'border-bottom:1px solid var(--border-color);padding-bottom:6px;margin-bottom:6px;';

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ MAIN COMBAT MENU â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    if (mode === 'main') {
        combatDiv.innerHTML = `
            <div style="color:var(--highlight-color);font-size:16px;margin-bottom:4px;text-align:center;">
                âš”ï¸ <span style="letter-spacing:2px;">${pips}</span>
                <span style="color:#8aaa8a;font-size:13px;">(${hitsLeft}/${maxHits})</span>
            </div>
            <div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:center;">
                <button onclick="showAttackMenu()" ${!canAct ? 'disabled' : ''}>âš”ï¸</button>
                <button onclick="showSpellMenu()"  ${!canAct ? 'disabled' : ''}>âœ¨</button>
                <button onclick="showPotionMenu()" ${!canAct ? 'disabled' : ''}>ğŸ§ª</button>
                <button onclick="playerDefend()"   ${!canAct ? 'disabled' : ''}>ğŸ›¡ï¸</button>
                <button onclick="attemptFlee()"    ${!canAct ? 'disabled' : ''}>ğŸƒ</button>
            </div>
        `;
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ATTACK TYPE MENU â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    else if (mode === 'attack_type') {
        const normalCost = 1;
        const heavyCost  = 2;

        combatDiv.innerHTML = `
            <div style="color:var(--highlight-color);font-size:14px;margin-bottom:4px;text-align:center;">
                ATTACK TYPE
            </div>
            <div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:center;">
                <button onclick="selectAttackType('normal')" ${hitsLeft < normalCost ? 'disabled' : ''}>
                    âš”ï¸ Normal
                </button>
                <button onclick="selectAttackType('heavy')" ${hitsLeft < heavyCost ? 'disabled' : ''}>
                    ğŸ’¥ Heavy
                </button>
                <button onclick="selectAttackType('special')" ${hitsLeft < 1 ? 'disabled' : ''}>
                    â­ Special
                </button>
                <button onclick="cancelAction()">âŒ</button>
            </div>
        `;
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ TARGET SELECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    else if (mode === 'target_attack' || mode === 'target_spell') {
        const targetBtns = cs.monsters.map((m, i) => `
            <button onclick="executeTargetedAction(${i})">
                #${i + 1} ${m.name}<br>
                <span style="font-size:11px;">HP ${m.hp}/${m.maxHp}</span>
            </button>
        `).join('');

        combatDiv.innerHTML = `
            <div style="color:var(--highlight-color);font-size:14px;margin-bottom:4px;text-align:center;">
                TARGET
            </div>
            <div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:center;">
                ${targetBtns}
                <button onclick="cancelAction()">âŒ</button>
            </div>
        `;
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ SPELL LIST â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    else if (mode === 'spell_list') {
        const spells = gameState.player.knownSpells || [];

        const spellBtns = spells.map(sk => {
            const spell = SPELLS[sk];
            const disabled = !canAct || gameState.player.mp < spell.mpCost;
            return `
                <button onclick="selectSpell('${sk}')" ${disabled ? 'disabled' : ''}>
                    ${spell.name}<br>
                    <span style="font-size:11px;">${spell.mpCost} MP</span>
                </button>
            `;
        }).join('');

        combatDiv.innerHTML = `
            <div style="color:var(--highlight-color);font-size:14px;margin-bottom:4px;text-align:center;">
                SPELL
            </div>
            <div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:center;">
                ${spellBtns}
                <button onclick="cancelAction()">âŒ</button>
            </div>
        `;
    }

    actionBar.appendChild(combatDiv);
}


    // â•â•â• NAVIGATION BUTTONS (always visible) â•â•â•
    const canMove = !cs || !cs.pipAvailable || cs.pipAvailable.every(x => x);
    
    // Show pip status if in combat/recovery
    if (cs && cs.pipAvailable && !canMove) {
        const available = cs.pipAvailable.filter(x => x).length;
        const total = cs.pipAvailable.length;
        const pips = 'â—'.repeat(available) + 'â—‹'.repeat(total - available);
        
        const statusDiv = document.createElement('div');
        statusDiv.style.cssText = 'color:#8aaa8a;font-size:12px;margin-bottom:4px;text-align:center;';
        statusDiv.innerHTML = `â³ Resting to move: ${pips} (${available}/${total})`;
        ab.appendChild(statusDiv);
    }

    // Create compact button container
    const btnContainer = document.createElement('div');
    btnContainer.style.cssText = 'display:flex;flex-wrap:wrap;gap:4px;justify-content:center;';

    // Entrance exit button (always enabled)
    if (ds.currentRoom === floor.startRoom) {
        const exitBtn = document.createElement('button');
        exitBtn.textContent = 'â¬… Town';
        exitBtn.onclick = returnToTown;
        exitBtn.style.cssText = 'min-width:55px;padding:6px 8px;font-size:13px;';
        btnContainer.appendChild(exitBtn);
    }
    
    // MAP button (always enabled)
    const mapBtn = document.createElement('button');
    mapBtn.textContent = 'ğŸ—ºï¸';
    mapBtn.onclick = showDungeonMap;
    mapBtn.style.cssText = 'min-width:40px;padding:6px 8px;font-size:13px;border-color:var(--highlight-color);';
    btnContainer.appendChild(mapBtn);

    // Direction buttons (can be disabled)
    const directionOrder = ['n', 'ne', 'e', 'se', 's', 'sw', 'w', 'nw'];
    const directionLabels = {
        'n': 'N',
        'ne': 'NE', 
        'e': 'E',
        'se': 'SE',
        's': 'S',
        'sw': 'SW',
        'w': 'W',
        'nw': 'NW'
    };
    
    directionOrder.forEach(dir => {
        if (room.exits[dir]) {
            const btn = document.createElement('button');
            btn.textContent = directionLabels[dir];
            btn.onclick = () => moveInDungeon(dir);
            btn.disabled = !canMove;
            btn.style.cssText = 'min-width:42px;padding:6px 4px;font-size:13px;font-weight:bold;';
            if (!canMove) {
                btn.style.opacity = '0.4';
                btn.style.cursor = 'not-allowed';
            }
            btnContainer.appendChild(btn);
        }
    });

    ab.appendChild(btnContainer);
}







        
        
        function renderActionBar() {
            const ab = document.getElementById('actionBar');
            showActionBar();
            
            // If in dungeon, always use dungeon action bar with combat overlay
            if (gameState.dungeon) {
                renderDungeonActionBar();
                return;
            }
            
            if (gameState.combatState) {
                const cs       = gameState.combatState;
                const monsters = cs.monsters;
                const p        = gameState.player;
                const maxHits  = cs.pipAvailable ? cs.pipAvailable.length : calcPlayerHits(p);
                const hitsLeft = cs.pipAvailable ? cs.pipAvailable.filter(x => x).length : maxHits;
                const canAct   = hitsLeft > 0;

                // attack-charge pips  â—â—â—‹
                const pips = 'â—'.repeat(hitsLeft) + 'â—‹'.repeat(maxHits - hitsLeft);

                // Check what menu mode we're in
                const mode = cs.actionMode || 'main';

                if (mode === 'main') {
                    // Main combat menu
                    ab.innerHTML = `
                        <div style="color:var(--highlight-color);font-size:10px;margin-bottom:6px;">
                            ATTACKS: <span style="letter-spacing:3px;">${pips}</span>
                            <span style="color:#8aaa8a;font-size:15px;"> (${hitsLeft}/${maxHits})</span>
                        </div>
                        <div style="display:flex;flex-wrap:wrap;gap:6px;">
                            <button onclick="showAttackMenu()" ${!canAct?'disabled':''} class="action-icon-btn" title="Attack">âš”ï¸ Attack</button>
                            <button onclick="showSpellMenu()"  ${!canAct?'disabled':''} class="action-icon-btn" title="Cast Spell">âœ¨ Spell</button>
                            <button onclick="showPotionMenu()" ${!canAct?'disabled':''} class="action-icon-btn" title="Use Potion">ğŸ§ª Potion</button>
                            <button onclick="playerDefend()"   ${!canAct?'disabled':''} class="action-icon-btn" title="Defend">ğŸ›¡ï¸ Defend</button>
                            <button onclick="attemptFlee()"    ${!canAct?'disabled':''} class="action-icon-btn" title="Flee">ğŸƒ Flee</button>
                        </div>
                    `;
                } else if (mode === 'attack_type') {
                    // Attack type selection menu
                    const normalCost = 1;
                    const heavyCost = 2;
                    const specialCost = hitsLeft; // Uses all pips
                    
                    ab.innerHTML = `
    <div style="color:var(--highlight-color);font-size:18px;margin-bottom:6px;">
        CHOOSE ATTACK TYPE:
    </div>
    <div style="display:flex;flex-wrap:wrap;gap:6px;">
        <button onclick="selectAttackType('normal')" ${hitsLeft < normalCost ? 'disabled' : ''} class="action-icon-btn">
            âš”ï¸ Normal
        </button>
        <button onclick="selectAttackType('heavy')" ${hitsLeft < heavyCost ? 'disabled' : ''} class="action-icon-btn">
            ğŸ’¥ Heavy
        </button>
        <button onclick="selectAttackType('special')" ${hitsLeft < 1 ? 'disabled' : ''} class="action-icon-btn">
            â­ Special
        </button>
        <button onclick="cancelAction()" class="action-icon-btn">
            âŒ Back
        </button>
    </div>


                    `;
                } else if (mode === 'target_attack' || mode === 'target_spell' || mode === 'target_staff_melee') {
                    // Target selection menu
                    let actionName;
                    if (mode === 'target_spell') {
                        actionName = cs.pendingSpell?.name || 'Spell';
                    } else if (mode === 'target_staff_melee') {
                        actionName = 'Staff Melee';
                    } else {
                        actionName = 'Attack';
                    }
                    
                    const targetBtns = monsters.map((m, i) => {
    return `<button onclick="executeTargetedAction(${i})"
        class="target-btn">
        #${i + 1} ${m.name}
    </button>`;
}).join('');

                    
                    ab.innerHTML = `
                        <div style="color:var(--highlight-color);font-size:10px;margin-bottom:6px;">
                            SELECT TARGET FOR ${actionName.toUpperCase()}:
                        </div>
                        <div style="display:flex;flex-wrap:wrap;gap:6px;">
                            ${targetBtns}
                            <button onclick="cancelAction()" class="action-icon-btn">âŒ Back</button>
                        </div>
                    `;
                } else if (mode === 'spell_list') {
                    // Spell selection menu
                    const spellBtns = p.knownSpells.map(sk => {
                        const spell = SPELLS[sk];
                        const canCast = p.mp >= spell.mpCost;
                        return `<button onclick="selectSpell('${sk}')" ${!canCast?'disabled':''} class="spell-btn">
                            ${spell.name}<br>
                            <span style="font-size:12px;">${spell.mpCost} MP</span>
                        </button>`;
                    }).join('');
                    
                    // Check if player has a staff weapon
                    const weapon = WEAPONS[p.weapon];
                    const hasStaff = weapon && (weapon.name.toLowerCase().includes('staff') || weapon.baseMagicDamage > 0);
                    
                    // Add melee attack option if player has staff (can bonk enemies with it!)
                    const meleeOption = hasStaff ? 
                        `<button onclick="staffMeleeAttack()" class="spell-btn" style="border-color:#FF8800;">
                            âš”ï¸ Staff Melee<br>
                            <span style="font-size:12px;">Bonk! (No MP)</span>
                        </button>` : '';
                    
                    ab.innerHTML = `
                        <div style="color:var(--highlight-color);font-size:10px;margin-bottom:6px;">
                            SELECT SPELL:
                        </div>
                        <div style="display:flex;flex-wrap:wrap;gap:6px;">
                            ${spellBtns}
                            ${meleeOption}
                            <button onclick="cancelAction()" class="action-icon-btn">âŒ Back</button>
                        </div>
                    `;
                }
            } else {
                ab.innerHTML = `
                    <button onclick="exploreLocation('${gameState.currentLocation}')">ğŸ” CONTINUE EXPLORING</button>
                    <button onclick="goBackToTown()">ğŸ˜ï¸ RETURN TO TOWN</button>
                `;
            }
        }
        function goBackToTown() {
            closeTerminalView();
            showTown();
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // NEW DYNAMIC COMBAT MENU SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function showAttackMenu() {
            const cs = gameState.combatState;
            if (!cs) return;
            cs.actionMode = 'attack_type';
            renderActionBar();
        }
        
        function selectAttackType(type) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            cs.pendingAttackType = type;
            cs.actionMode = 'target_attack';
            renderActionBar();
        }
        
        function cancelAction() {
            const cs = gameState.combatState;
            if (!cs) return;
            cs.actionMode = 'main';
            cs.pendingAttackType = null;
            cs.pendingSpell = null;
            renderActionBar();
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STAFF MELEE ATTACK (for mages out of MP)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function staffMeleeAttack() {
            const cs = gameState.combatState;
            if (!cs) return;
            
            // Switch to target selection for staff melee
            cs.actionMode = 'target_staff_melee';
            renderActionBar();
        }
        
        function executeStaffMelee(targetIndex) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            const p = gameState.player;
            const enemy = cs.monsters[targetIndex];
            const weapon = WEAPONS[p.weapon];
            
            // Consume 1 pip
            const consumed = consumePips(cs, 1, getPipCooldown(p));
            if (consumed < 1) {
                termAppend('Not enough action points!', 'term-error');
                return;
            }
            
            // Staff melee does reduced damage (50% of normal + small magic bonus)
            // Formula: (weapon base damage Ã— 0.5) + (STR Ã— 0.3) + (magic damage Ã— 0.3)
            let baseDamage = Math.floor((weapon.baseDamage || 1) * 0.5);
            const strBonus = Math.floor((p.str || p.strength || 0) * 0.3);
            const magicBonus = Math.floor((weapon.baseMagicDamage || 0) * 0.3);
            
            // Total damage
            let totalDamage = baseDamage + strBonus + magicBonus;
            
            // Apply class damage multiplier (if evolved)
            const classMult = getClassDamageMultiplier(p);
            totalDamage = Math.floor(totalDamage * classMult);
            
            // Calculate final damage with enemy defense
            const result = calculateDamage({
                attacker: p,
                defender: enemy,
                base: totalDamage,
                type: 'physical',
                critChance: calcCritChance(p.lck || 0) / 100,
                dodgeChance: enemy.dodge || 0,
                armorPiercing: 0
            });
            
            const tName = cs.monsters.length > 1
                ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${targetIndex+1}</span>`
                : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;
            
            if (result.dodged) {
                termAppend(`You swing your staff at ${tName} but they <span style="color:#88ff88;">DODGE!</span>`);
            } else {
                const critTag = result.crit ? ' <span style="color:#FFD700;">â˜… CRITICAL HIT!</span>' : '';
                enemy.hp -= result.damage;
                termAppend(
                    `You <span style="color:#FF8800;">BONK</span> ${tName} with your staff for <span class="dmg-enemy">${result.damage} damage!</span>${critTag}`,
                    null,
                    () => {
                        checkCombatEnd();
                        updateEnemyCards();
                        updateHud();
                    }
                );
            }
            
            // Return to main combat menu
            cs.actionMode = 'main';
            renderActionBar();
        }
        
        function executeTargetedAction(targetIndex) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            cs.currentTarget = targetIndex;
            
            if (cs.actionMode === 'target_attack') {
                executeAttack(cs.pendingAttackType);
            } else if (cs.actionMode === 'target_spell') {
                castSpellOnTarget(cs.pendingSpell);
            } else if (cs.actionMode === 'target_staff_melee') {
                executeStaffMelee(targetIndex);
            }
            
            // Reset to main menu
            cs.actionMode = 'main';
            cs.pendingAttackType = null;
            cs.pendingSpell = null;
        }
        
        function selectSpell(spellKey) {
            const cs = gameState.combatState;
            if (!cs) return;
            
            cs.pendingSpell = SPELLS[spellKey];
            cs.pendingSpellKey = spellKey;
            cs.actionMode = 'target_spell';
            renderActionBar();
        }
        
        // Update showSpellMenu to use the new system
        function showSpellMenuOld() {
            const cs = gameState.combatState;
            if (!cs) return;
            
            cs.actionMode = 'spell_list';
            renderActionBar();
        }
        

        function tryExploreLocation(locKey) {
            if (!isFullyRested()) {
                termAppend('<span style="color:var(--error-color);">You are too exhausted to continue! Wait for your charges to restoreâ€¦</span>', 'term-error');
                return;
            }
            // Clear old combat state now that we're starting fresh
            gameState.combatState = null;
            exploreLocation(locKey);
        }
        
        function tryGoBackToTown() {
            if (!isFullyRested()) {
                termAppend('<span style="color:var(--error-color);">You are too exhausted to travel! Wait for your charges to restoreâ€¦</span>', 'term-error');
                return;
            }
            // Clear combat state now that we're leaving
            gameState.combatState = null;
            goBackToTown();
        }
        
        function tryViewWorldMap() {
            if (!isFullyRested()) {
                termAppend('<span style="color:var(--error-color);">You are too exhausted to travel! Wait for your charges to restoreâ€¦</span>', 'term-error');
                return;
            }
            // Clear combat state now that we're leaving
            gameState.combatState = null;
            closeTerminalView();
            showExplore();
        }
        
        function selectTarget(index) {
            const cs = gameState.combatState;
            if (!cs || !cs.monsters || index < 0 || index >= cs.monsters.length) return;
            cs.currentTarget = index;
            updateEnemyCards();
            renderActionBar();
        }

        function isFullyRested() {
            const cs = gameState.combatState;
            if (!cs || !cs.pipAvailable) return true;
            // all pips must be available
            return cs.pipAvailable.every(x => x);
        }


      function startCombatTimer() {
    if (gameState.combatTimer) clearInterval(gameState.combatTimer);

    gameState.combatTimer = setInterval(() => {
        const cs = gameState.combatState;

        // No combat state at all â†’ stop timer
        if (!cs) {
            clearInterval(gameState.combatTimer);
            gameState.combatTimer = null;
            return;
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // PIP RECOVERY (always runs)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let anyRestored = false;

        for (let i = 0; i < cs.pipTimers.length; i++) {
            if (!cs.pipAvailable[i] && cs.pipTimers[i] > 0) {
                cs.pipTimers[i]--;
                if (cs.pipTimers[i] <= 0) {
                    cs.pipAvailable[i] = true;
                    cs.pipTimers[i] = 10;
                    anyRestored = true;
                }
            }
        }

        if (anyRestored) {
            renderActionBar();
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // POST-COMBAT RECOVERY CLEANUP
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (cs.combatOver) {
            // Once ALL pips are restored, exit recovery
            if (cs.pipAvailable.every(p => p)) {
                gameState.postCombatRecovery = false;
                gameState.combatState = null;

                renderActionBar();
                clearInterval(gameState.combatTimer);
                gameState.combatTimer = null;
            }
            return; // No enemy actions during recovery
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // ENEMY TIMER + INTENT TELEGRAPHING
        // (only while combat is active)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (cs.enemyTimer > 0) cs.enemyTimer--;

        // Telegraph intent 1 second before attack
        if (cs.enemyTimer === 1 && !cs.enemyIntent) {
            const enemy = cs.monsters[cs.currentTarget];
            if (enemy) {
                cs.enemyIntent = selectEnemyIntent(enemy);
                termAppend(
                    `<span style="color:${enemy.rarityColor};">${enemy.name}</span> ${cs.enemyIntent.telegraph}`,
                    'term-dim'
                );
            }
        }

        // Execute enemy attack
        if (cs.enemyTimer <= 0) {
            clearInterval(gameState.combatTimer);
            gameState.combatTimer = null;
            enemyAttackSingle();
        }

    }, 1000);
}


 // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLAYER ACTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function checkRoomEncounter(room) {
    if (!room || !room.encounter) return;

    const ds = gameState.dungeon;
    if (!ds.activeEnemies) ds.activeEnemies = [];

    // prevent re-triggering
    if (room.encounter.resolved) return;

    const enemyDef = ENEMIES[room.encounter.monsterId];
    if (!enemyDef) {
        console.warn('Enemy not found:', room.encounter.monsterId);
        return;
    }

    const enemyInstance = {
        id: crypto.randomUUID(),
        monsterId: room.encounter.monsterId,
        name: enemyDef.name,
        currentRoom: ds.currentRoom,
        leash: enemyDef.isBoss ? 6 : 3,
        roomsFollowed: 0
    };

    ds.activeEnemies.push(enemyInstance);
    room.encounter.resolved = true;

    termAppend(
        `âš ï¸ <strong>${enemyInstance.name}</strong> steps out of the shadows!`,
        'term-warning'
    );
}


function updateDungeonEnemies() {
    const ds = gameState.dungeon;
    if (!ds || !ds.activeEnemies) return;

    const dungeon = DUNGEONS[ds.dungeonKey];
    const floor = dungeon.floors[ds.floor];

    ds.activeEnemies.forEach(enemy => {
        const enemyRoom = floor.rooms[enemy.currentRoom];
        if (!enemyRoom) return;

        // ğŸ§  START chase ONLY when player enters enemy's room
        if (!enemy.isChasing && enemy.currentRoom === ds.currentRoom) {
            enemy.isChasing = true;
            enemy.roomsFollowed = 0;

            //  IF THE ENEMY IS CHASING YOU, PRINT THIS MESSAGE
         //   termAppend(
         //       `ğŸ‘ï¸ <strong>${enemy.name}</strong> begins to pursue youâ€¦`,
         //       'term-warning'
         //   );
         //   return;
        }

        // âŒ not chasing â†’ do nothing
        if (!enemy.isChasing) return;

        // ğŸ›‘ leash exhausted â†’ STOP and STAY
        if (enemy.roomsFollowed >= enemy.leash) {
            enemy.isChasing = false;

            termAppend(
                `ğŸ›‘ <strong>${enemy.name}</strong> stops the chase.`,
                'term-dim'
            );
            return; // â›” ABSOLUTELY REQUIRED
        }

        // ğŸ‘£ follow ONLY while chasing
        const exits = enemyRoom.exits || {};
for (const dir in exits) {
    if (exits[dir] === ds.currentRoom) {
        enemy.currentRoom = ds.currentRoom;
enemy.roomsFollowed++;
enemy.justArrived = true; // ğŸ‘ˆ add this

const fromDir = OPPOSITE_DIR[dir] || dir;

termAppend(
    `âš ï¸ <strong>${enemy.name}</strong> enters from the <em>${fromDir}</em>.`,
    'term-warning'
);

return;

    }
}

    });
}




function moveInDungeon(direction) {
    // Check if player has full pips (required for movement)
    const cs = gameState.combatState;
    if (cs && cs.pipAvailable) {
        const hasFullPips = cs.pipAvailable.every(x => x);
        if (!hasFullPips) {
            const available = cs.pipAvailable.filter(x => x).length;
            const total = cs.pipAvailable.length;
            termAppend(`âš¡ You're too exhausted to move! (${available}/${total} pips restored)`, 'term-error');
            return;
        }
    }

    if (!gameState.dungeon) {
        console.warn('Not in a dungeon');
        return;
    }

    const ds = gameState.dungeon;
    const dungeon = DUNGEONS[ds.dungeonKey];
    const floor = dungeon.floors[ds.floor];
    const currentRoom = floor.rooms[ds.currentRoom];

    const nextRoomId = currentRoom.exits[direction];
    if (!nextRoomId) {
        termAppend(`You cannot go that way.`, 'term-dim');
        return;
    }

    const nextRoom = floor.rooms[nextRoomId];

    ds.currentRoom = nextRoomId;
    ds.discoveredRooms.add(nextRoomId);
    nextRoom.flags.discovered = true;

    termAppend('', 'term-separator');
    termAppend(`<strong>${nextRoom.name}</strong>`);
    termAppend(nextRoom.description, 'term-dim');

   // ğŸ”¥ Spawn encounter (once)
checkRoomEncounter(nextRoom);

// ğŸ‘£ Move any active enemies that can follow
updateDungeonEnemies();

// âš”ï¸ combat trigger (AFTER enemies move)
//const enemyHere = getEnemyInRoom(ds.currentRoom);
//if (enemyHere) {
//    gameState.inCombat = true; // ğŸ‘ˆ HERE

    //termAppend(
    //    `âš”ï¸ <strong>${enemyHere.name}</strong> confronts you!`,
    //    'term-warning'
    // );

    //return;
// }

// ğŸ‘ï¸ enemies already present (no combat)
checkEnemiesInRoom(nextRoomId);

    const exits = Object.keys(nextRoom.exits)
        .map(d => d.toUpperCase())
        .join(', ');

    termAppend(`You see exits: ${exits}.`, 'term-dim');

    // ğŸ’¾ AUTO-SAVE after moving in dungeon (prevent cheating!)
    saveGame();

    // ğŸ”‘ update buttons for new room
    renderDungeonActionBar();
}


function getEnemyInRoom(roomId) {
    const ds = gameState.dungeon;
    if (!ds || !ds.activeEnemies) return null;

    return ds.activeEnemies.find(enemy => enemy.currentRoom === roomId) || null;
}



function checkEnemiesInRoom(roomId) {
    const ds = gameState.dungeon;
    if (!ds || !ds.activeEnemies) return;

    // Find enemy in current room
    const enemyHere = ds.activeEnemies.find(e => e.currentRoom === roomId);
    
    if (enemyHere) {
        // AUTO-ENGAGE COMBAT!
        termAppend(
            `âš”ï¸ <strong>${enemyHere.name}</strong> confronts you!`,
            'term-warning'
        );
        
        // Start combat with this dungeon enemy
        startDungeonCombat(enemyHere);
    }
}

function startDungeonCombat(dungeonEnemy) {
    // Use the enemy's monsterId to start combat
    if (!dungeonEnemy.monsterId) {
        console.error('Dungeon enemy missing monsterId:', dungeonEnemy);
        return;
    }
    
    // Start normal combat using the monsterId
    startCombat([dungeonEnemy.monsterId]);
    
    // Link combat to dungeon enemy for persistence
    if (gameState.combatState) {
        gameState.combatState.dungeonEnemyId = dungeonEnemy.id;
        
        // If this enemy has saved HP, restore it to the combat monster
        if (dungeonEnemy.hp !== undefined && dungeonEnemy.hp < dungeonEnemy.maxHp) {
            const monster = gameState.combatState.monsters[0];
            if (monster) {
                monster.hp = dungeonEnemy.hp;
                monster.maxHp = dungeonEnemy.maxHp;
                console.log(`Restored dungeon enemy HP: ${monster.hp}/${monster.maxHp}`);
            }
        }
    }
    
    // ğŸ’¾ Save combat state
    saveGame();
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TEMP: DUNGEON TEST HARNESS (SAFE)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function returnToTown() {
    console.log('â¬… returnToTown() called');

    // Clear dungeon state
    gameState.dungeon = null;
    gameState.combatState = null;
    gameState.postCombatRecovery = false;
    
    // Clear combat timer
    if (gameState.combatTimer) {
        clearInterval(gameState.combatTimer);
        gameState.combatTimer = null;
    }

    // Clear terminal mode and content
    document.body.classList.remove("terminal-mode");
    termClear();

    // Hide terminal elements
    document.getElementById('terminalWindow').style.display = 'none';
    document.getElementById('hud').style.display = 'none';
    
    const ab = document.getElementById('actionBar');
    ab.innerHTML = '';
    ab.style.display = 'none';
    
    // CRITICAL: Show mainScreen
    document.getElementById('mainScreen').style.display = 'block';

    // Reset terminal state
    gameState._terminalOpen = false;
    gameState._currentExploreArea = null;
    
    // Show town menu
    showTown();
}

function testDungeon() {
    document.body.classList.add("terminal-mode");
    
    // Start regeneration in dungeon (normal speed)
    startMpRegen(false);
    startResting(false);
    
    const dungeonKey = 'whisperingCrypt';
    const dungeon = DUNGEONS[dungeonKey];
    const floor = dungeon.floors[1];

    // ğŸ” reset encounter flags for testing
Object.values(floor.rooms).forEach(r => {
    if (r.encounter) {
        delete r.encounter.resolved;
    }
});


    gameState.dungeon = {
        dungeonKey,
        floor: 1,
        currentRoom: floor.startRoom,
        discoveredRooms: new Set([floor.startRoom]),
        activeEnemies: []   // ğŸ‘ˆ THIS WAS MISSING
    };

    openTerminalView(dungeonKey);

    const room = floor.rooms[floor.startRoom];
    room.flags.discovered = true;

    termAppend('', 'term-separator');
    termAppend(`<strong>${room.name}</strong>`);
    termAppend(room.description, 'term-dim');

    const exits = Object.keys(room.exits)
        .map(d => d.toUpperCase())
        .join(', ');

    termAppend(`You see exits: ${exits}.`, 'term-dim');

    // ğŸ’¾ AUTO-SAVE when entering dungeon (track dungeon state!)
    saveGame();

    renderDungeonActionBar();
}



const BASE_PIP_COOLDOWN = 10;
const MIN_PIP_COOLDOWN = 3;

function getPipCooldown(player){
    return Math.max(
        MIN_PIP_COOLDOWN,
        Math.floor(BASE_PIP_COOLDOWN - (player.speed || 0) * 0.25)
    );
}



function selectEnemyIntent(enemy) {
    // Default / basic attack
    let intent = {
        type: 'basic',
        damageMult: 1,
        armorPiercing: 0,
        telegraph: 'prepares to strike...'
    };

    // Bosses and elites sometimes wind up a heavy hit
    if (enemy.isBoss && Math.random() < 0.4) {
        intent = {
            type: 'heavy',
            damageMult: 1.75,
            armorPiercing: 0.3,
            telegraph: 'draws in power for a devastating attack!'
        };
    }

    return intent;
}


function consumePips(cs, amount, cooldown) {
    let used = 0;

    for (let i = 0; i < cs.pipAvailable.length && used < amount; i++) {
        if (cs.pipAvailable[i]) {
            cs.pipAvailable[i] = false;
            cs.pipTimers[i] = cooldown;
            used++;
        }
    }
}




        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DAMAGE SCALING (Rebalanced for harder early game)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const DAMAGE_SCALING = {
            // Reduce player starting damage by 30%
            playerStarterWeaponMult: 0.7,
            // Increase monster damage by 30%
            monsterDamageMult: 1.3
        };

        function calculateDamage({
  attacker,
  defender,
  base,
  type = 'physical', // 'physical' | 'magic'
  critChance = 0,
  critMult = 1.5,
  dodgeChance = 0,
  armorPiercing = 0,
  isSpecial = false
}) {
  // Dodge check
  if (Math.random() < dodgeChance) {
    return { damage: 0, dodged: true, crit: false };
  }

  // Base damage roll
  let damage = base;

  // Defense mitigation
  let defense =
    type === 'magic'
      ? (defender.magicDefense || 0)
      : (defender.defense || 0);

  defense *= (1 - armorPiercing);
  damage = Math.max(1, Math.floor(damage - defense));

  // Crit check
  let crit = false;
  if (Math.random() < critChance) {
    damage = Math.floor(damage * critMult);
    crit = true;
  }

  return { damage, dodged: false, crit };
}

        
     function executeAttack(attackType) {
    const cs = gameState.combatState;
    if (!cs) return;

    const p  = gameState.player;
    const ti = cs.currentTarget;
    const enemy = cs.monsters[ti];
    let weapon = WEAPONS[p.weapon];
    
    // Safety check: if weapon doesn't exist, use a default weapon
    if (!weapon) {
        console.error(`âŒ Weapon '${p.weapon}' not found in WEAPONS! Using default weapon.`);
        p.weapon = 'iron_sword'; // Default to iron sword
        weapon = WEAPONS[p.weapon];
        if (!weapon) {
            termAppend('ERROR: No weapons available! Please contact sysop.', 'term-error');
            return;
        }
    }
    
    const qBonus = QUALITY_CONFIG[weapon.quality].bonus;

    // Determine pip cost and damage multiplier
    let pipCost = 1;
    let damageMultiplier = 1;
    let attackName = 'attacks';
    let armorPiercing = 0;

    if (attackType === 'normal') {
        pipCost = 1;
    } 
    else if (attackType === 'heavy') {
        pipCost = 2;
        damageMultiplier = 1.75;
        attackName = 'unleashes a <span style="color:#FF8800;">HEAVY STRIKE</span>';
        armorPiercing = 0.2;
    } 
    else if (attackType === 'special') {
        const availablePips = cs.pipAvailable.filter(x => x).length;
        pipCost = availablePips;
        damageMultiplier = 1 + (availablePips * 0.5);
        attackName = `unleashes a <span style="color:#FFD700;">â­ SPECIAL ATTACK â­</span> (${availablePips} pips)`;
        armorPiercing = 0.3;
    }

    // Check pip availability
    const availablePips = cs.pipAvailable.filter(x => x).length;
    if (availablePips < pipCost) {
        termAppend('Not enough attack charges!', 'term-error');
        return;
    }

    // Consume pips
    consumePips(cs, pipCost, getPipCooldown(p));

    // Calculate base damage
    let weaponDamage = weapon.baseDamage + qBonus;

    if (p.level <= 5) {
        weaponDamage = Math.floor(
            weaponDamage * DAMAGE_SCALING.playerStarterWeaponMult
        );
    }

    const physicalBase =
        weaponDamage + (p.strength || 0) + (p.str || 0);

    const magicBase =
        (weapon.baseMagicDamage + qBonus) +
        Math.floor((p.magic || 0) / 2);

    let totalBase = Math.floor(
        (physicalBase + magicBase) * damageMultiplier
    );

    const classMult = getClassDamageMultiplier(p);
    totalBase = Math.floor(totalBase * classMult);

    // Resolve damage
    const result = calculateDamage({
        attacker: p,
        defender: enemy,
        base: totalBase,
        type: magicBase > physicalBase ? 'magic' : 'physical',
        critChance: calcCritChance(p.lck || 0) / 100,
        dodgeChance: enemy.dodge || 0,
        armorPiercing
    });

    const tName = cs.monsters.length > 1
        ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${ti + 1}</span>`
        : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;

    if (result.dodged) {
        termAppend(
            `You ${attackName} but ${tName} <span style="color:#88ff88;">DODGES!</span>`
        );
    } 
    else {
        const critTag = result.crit
            ? ' <span style="color:#FFD700;">â˜… CRITICAL HIT!</span>'
            : '';

        enemy.hp -= result.damage;

        // Calculate condition text
        const hpPct = Math.max(0, (enemy.hp / enemy.maxHp) * 100);
        let condition = 'healthy';
        if (hpPct < 75) condition = 'injured';
        if (hpPct < 50) condition = 'wounded';
        if (hpPct < 25) condition = 'severely wounded';
        if (hpPct < 10) condition = 'barely standing';

        termAppend(
            `You ${attackName} ${tName} for <span class="dmg-enemy">${result.damage} damage!</span>${critTag}`,
            null,
            () => {

                if (enemy.hp > 0) {
                    termAppend(
                        `â†’ ${tName} is <span style="color:#8aaa8a;">${condition}</span>`,
                        'term-dim'
                    );
                }

                updateEnemyCards();
                updateHud();
                renderActionBar();
                checkCombatEnd();
            }
        );
    }

    // Immediate UI update for responsiveness
    updateEnemyCards();
    updateHud();
    renderActionBar();
}



       // Legacy function kept for compatibility
       function playerAttack() {
    executeAttack('normal');
}

        


            function showSpellMenu() {
            const cs = gameState.combatState;
            if (!cs) return;
            const anyAvail = cs.pipAvailable && cs.pipAvailable.some(x => x);
            if (!anyAvail) return;
            const p = gameState.player;
            if (p.knownSpells.length === 0) {
                termAppend('You have no spells!', 'term-error');
                renderActionBar();
                return;
            }
            
            cs.actionMode = 'spell_list';
            renderActionBar();
        }




            function castSpellOnTarget(spell) {
            const p  = gameState.player;
            const cs = gameState.combatState;
            const spellKey = cs.pendingSpellKey;
            
            if (p.mp < spell.mpCost) {
                termAppend('Not enough MP!', 'term-error');
                return;
            }
            

// --- Pip check for spells ---
const availablePips = cs.pipAvailable.filter(x => x).length;

if (availablePips < (spell.pipCost || 1)) {
    termAppend('Not enough spell charges!', 'term-error');
    return;
}

// Consume spell pips
consumePips(cs, spell.pipCost || 1, getPipCooldown(p));



            p.mp -= spell.mpCost;

            if (spell.type === 'heal') {
                const heal = spell.power + Math.floor(p.magic * 1.5) + (p.wis || 0);
                p.hp = Math.min(p.maxHp, p.hp + heal);
                updateHud();
                renderActionBar();
                termAppend(`You cast ${spell.name} and restore <span style="color:#88ff88;">${heal} HP!</span>`);
            } else {
                const ti    = cs.currentTarget;
                const enemy = cs.monsters[ti];
                let   dmg   = Math.max(1, (spell.power + p.magic + (p.wis||0)) - Math.floor(enemy.defense / 2));
                let crit = false;
                if (Math.random()*100 < calcCritChance(p.lck||0)) { dmg = Math.floor(dmg*1.75); crit = true; }
                enemy.hp -= dmg;
                
                const tName = cs.monsters.length > 1
                    ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${ti+1}</span>`
                    : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;
              
                const critTag = crit ? ' <span style="color:#FFD700;">â˜… CRIT!</span>' : '';
                const hpPct = Math.max(0, (enemy.hp / enemy.maxHp) * 100);
                let condition = 'healthy';
                if (hpPct < 75) condition = 'injured';
                if (hpPct < 50) condition = 'wounded';
                if (hpPct < 25) condition = 'severely wounded';
                if (hpPct < 10) condition = 'barely standing';
                termAppend(`You cast ${spell.name} on ${tName} for <span class="dmg-enemy">${dmg} damage!</span>${critTag}`, null, () => {
                    if (enemy.hp > 0) {
                        termAppend(`â†’ ${tName} is <span style="color:#8aaa8a;">${condition}</span>`, 'term-dim');
                    }
                    checkCombatEnd();
                });
            }
              updateEnemyCards();
                updateHud();
                renderActionBar();
            
            cs.pendingSpellKey = null;
        }

        // Legacy function for backward compatibility
        function castSpell(spellKey) {
            const spell = SPELLS[spellKey];
            castSpellOnTarget(spell);
        }

        function playerDefend() {
            const cs = gameState.combatState;
            if (!cs || cs.hitsLeft <= 0) return;
            cs.defending = true;
            cs.hitsLeft  = 0;            // end player's turn
            renderActionBar();
            termAppend('You brace for impactâ€¦');  // timer keeps ticking â†’ enemy phase
        }

        function attemptFlee() {
            const cs = gameState.combatState;
            if (!cs) return;
            
            // find first available pip
            let pipIndex = -1;
            for (let i = 0; i < cs.pipAvailable.length; i++) {
                if (cs.pipAvailable[i]) {
                    pipIndex = i;
                    break;
                }
            }
            if (pipIndex === -1) return;

            clearInterval(gameState.combatTimer);
            const p        = gameState.player;
            const fleePct  = Math.min(70, 30 + (p.dex||0)*3);
            if (Math.random()*100 < fleePct) {
                gameState.combatState = null;
                termAppend('You successfully fled!', 'term-highlight', () => {
                    renderActionBar();
                });
            } else {
                cs.pipAvailable[pipIndex] = false;
                cs.pipTimers[pipIndex] = 10;
                renderActionBar();
                termAppend('Failed to escape!', 'term-error');
                startCombatTimer();
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // POTION MENU (in action bar)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function showPotionMenu() {
            const cs = gameState.combatState;
            if (!cs) return;
            const anyAvail = cs.pipAvailable && cs.pipAvailable.some(x => x);
            if (!anyAvail) return;
            const p = gameState.player;
            const potions = {};
            p.inventory.forEach(ik => {
                if (ITEMS[ik] && ['heal_hp','heal_mp','full_restore'].includes(ITEMS[ik].subtype)) {
                    if (!potions[ik]) potions[ik] = { item: ITEMS[ik], count: 0 };
                    potions[ik].count++;
                }
            });
            const keys = Object.keys(potions);
            if (keys.length === 0) {
                termAppend('You have no potions!', 'term-error');
                renderActionBar();
                return;
            }
            const ab = document.getElementById('actionBar');
            let html = '<div class="action-label">USE POTION:</div>';
            keys.forEach(pk => {
                const pd  = potions[pk];
                const col = pd.item.subtype==='heal_hp' ? '#ff4444' : pd.item.subtype==='heal_mp' ? '#4488ff' : '#FFD700';
                html += `<button onclick="usePotion('${pk}')" style="color:${col};">${pd.item.name} x${pd.count} â€“ ${pd.item.description}</button> `;
            });
            html += `<br><button onclick="renderActionBar();">â† BACK</button>`;
            ab.innerHTML = html;
        }

        function usePotion(potionKey) {
            const potion = ITEMS[potionKey];
            const p      = gameState.player;
            let msg;
            if (potion.subtype === 'heal_hp') {
                const actual = Math.min(p.maxHp - p.hp, potion.power);
                p.hp = Math.min(p.maxHp, p.hp + potion.power);
                msg = `Used ${potion.name} â€“ restored <span style="color:#88ff88;">${actual} HP!</span>`;
            } else if (potion.subtype === 'heal_mp') {
                const actual = Math.min(p.maxMp - p.mp, potion.power);
                p.mp = Math.min(p.maxMp, p.mp + potion.power);
                msg = `Used ${potion.name} â€“ restored <span style="color:#88ff88;">${actual} MP!</span>`;
            } else if (potion.subtype === 'full_restore') {
                const hpR = p.maxHp - p.hp, mpR = p.maxMp - p.mp;
                p.hp = p.maxHp; p.mp = p.maxMp;
                msg = `Used ${potion.name} â€“ fully restored <span style="color:#88ff88;">${hpR} HP & ${mpR} MP!</span>`;
            }
            const idx = p.inventory.indexOf(potionKey);
            if (idx !== -1) p.inventory.splice(idx, 1);
            updateHud();
            renderActionBar();
            termAppend(msg);   // no callback â€“ timer keeps ticking, player can still act
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ENEMY ATTACK
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       function enemyAttackSingle() {
    // Enemy uses ONE charge, attacks once, then resets its own timer
    const cs       = gameState.combatState;
    const monsters = cs.monsters;
    const p        = gameState.player;

    // Defensive stats
    let armor = ARMOR[p.armor];
    
    // Safety check: if armor doesn't exist, use default armor
    if (!armor) {
        console.error(`âŒ Armor '${p.armor}' not found in ARMOR! Using default armor.`);
        p.armor = 'leather_vest'; // Default to leather vest
        armor = ARMOR[p.armor];
        if (!armor) {
            console.error('âŒ CRITICAL: No armor available!');
            armor = { baseDefense: 0, quality: 'poor' }; // Emergency fallback
        }
    }
    
    const qBonus   = QUALITY_CONFIG[armor.quality].bonus;
    let totalDef   = p.defense + armor.baseDefense + qBonus + (p.con || 0);

    if (cs.defending) {
        totalDef *= 2;
        cs.defending = false;
    }

    // Pull intent (or fallback)
    const intent = cs.enemyIntent || {
        type: 'basic',
        damageMult: 1,
        armorPiercing: 0
    };

    // Each monster in the pack gets ONE hit
    const hits = [];

    monsters.forEach((enemy, i) => {
        const eName = monsters.length > 1
            ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${i + 1}</span>`
            : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;

        // God mode bypass
        if (p.godMode) {
            hits.push({ eName, godMode: true });
            return;
        }

        const result = calculateDamage({
            attacker: enemy,
            defender: {
                defense: totalDef,
                magicDefense: totalDef
            },
            base: Math.floor(enemy.damage * intent.damageMult * DAMAGE_SCALING.monsterDamageMult),
            type: enemy.magicAttack ? 'magic' : 'physical',
            dodgeChance: calcDodgeChance(p.dex || 0) / 100,
            armorPiercing: intent.armorPiercing
        });

        if (result.dodged) {
            hits.push({ eName, dodged: true });
            return;
        }

        p.hp -= result.damage;

        // â”€â”€ Passive hooks (future-safe) â”€â”€
        // if (enemy.passives?.includes('lifedrain')) {
        //     enemy.hp = Math.min(enemy.maxHp, enemy.hp + Math.floor(result.damage * 0.3));
        // }

        hits.push({
            eName,
            dmg: result.damage,
            crit: result.crit
        });
    });

    updateHud();

    // After attack messages stream, reset enemy timer and resume
    const afterAttack = () => {
        cs.enemyIntent = null; // clear intent after execution

        if (p.hp <= 0 && !p.godMode) {
            endCombat(false);
        } else {
            cs.enemyTimer = cs.enemyDelay;
            renderActionBar();
            startCombatTimer();
        }
    };

    hits.forEach((hit, i) => {
        const isLast = (i === hits.length - 1);

        if (hit.godMode) {
            termAppend(
                `${hit.eName} attacks but you are <span class="term-highlight">INVINCIBLE!</span>`,
                null,
                isLast ? afterAttack : null
            );
        } else if (hit.dodged) {
            termAppend(
                `${hit.eName} attacksâ€¦ <span style="color:#88ff88;">DODGED!</span>`,
                null,
                isLast ? afterAttack : null
            );
        } else {
            const critTag = hit.crit
                ? ' <span style="color:#FFD700;">â˜… CRIT!</span>'
                : '';

            termAppend(
                `${hit.eName} attacks for <span class="dmg-player">${hit.dmg} damage!</span>${critTag}`,
                null,
                isLast ? afterAttack : null
            );
        }
    });
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHECK / END COMBAT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function checkCombatEnd() {
    const cs = gameState.combatState;
    if (!cs || !cs.monsters || cs.monsters.length === 0) return;

    let ti = cs.currentTarget;

    // Clamp target index (important after splicing)
    if (ti < 0 || ti >= cs.monsters.length) {
        cs.currentTarget = 0;
        ti = 0;
    }

    const target = cs.monsters[ti];
    if (!target) return;

    if (!cs.defeatedMonsters) cs.defeatedMonsters = [];

    if (target.hp <= 0) {
        const dead = target;

        cs.defeatedMonsters.push(dead);
        cs.monsters.splice(ti, 1);

        // Adjust target again after removal
        if (cs.currentTarget >= cs.monsters.length) {
            cs.currentTarget = Math.max(0, cs.monsters.length - 1);
        }

        termAppend(
            `<span style="color:${dead.rarityColor};">${dead.name}</span> has been defeated!`,
            'term-victory',
            () => {
                if (cs.monsters.length === 0) {
                    endCombat(true);
                } else {
                    renderEnemyCards();
                }
            }
        );
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// END COMBAT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function endCombat(victory) {

    // â”€â”€ defeat â”€â”€
    if (!victory) {
        clearInterval(gameState.combatTimer);
        gameState.combatTimer = null;

        const p = gameState.player;
        const inDungeon = !!gameState.dungeon;

        // Restore HP/MP
        p.hp = p.maxHp;
        p.mp = p.maxMp;

        if (inDungeon) {
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // HARSH DUNGEON DEATH PENALTY
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // Lose 10% of TOTAL XP earned
            const currentLevelXp = getXpForLevel(p.class, p.level);
            const totalXpEarned = currentLevelXp + p.xp;
            const xpLost = Math.floor(totalXpEarned * 0.10);
            
            // Calculate new total XP
            let newTotalXp = totalXpEarned - xpLost;
            if (newTotalXp < 0) newTotalXp = 0;
            
            // Find new level based on XP
            let newLevel = 1;
            for (let lvl = 25; lvl >= 1; lvl--) {
                if (newTotalXp >= getXpForLevel(p.class, lvl)) {
                    newLevel = lvl;
                    break;
                }
            }
            
            const levelsLost = p.level - newLevel;
            
            // Apply level loss
            if (levelsLost > 0) {
                for (let i = 0; i < levelsLost; i++) {
                    p.level--;
                    
                    // Reduce stats from level loss
                    p.maxHp = Math.max(20, p.maxHp - 15 - (p.con || 0));
                    p.maxMp = Math.max(10, p.maxMp - 10);
                    p.strength = Math.max(1, p.strength - 2);
                    p.defense = Math.max(1, p.defense - 2);
                    p.magic = Math.max(1, p.magic - 2);
                    p.speed = Math.max(1, p.speed - 1);
                    
                    if (p.str !== undefined) {
                        p.str = Math.max(1, p.str - 1);
                        p.dex = Math.max(1, p.dex - 1);
                        p.wis = Math.max(1, p.wis - 1);
                        p.cha = Math.max(1, p.cha - 1);
                        p.con = Math.max(1, p.con - 1);
                        p.lck = Math.max(1, p.lck - 1);
                    }
                }
            }
            
            // Set XP to remainder after new level
            const newLevelBaseXp = getXpForLevel(p.class, newLevel);
            p.xp = newTotalXp - newLevelBaseXp;
            p.xpToNext = getXpToNextLevel(p.class, newLevel);
            
            // Ensure XP doesn't go negative
            if (p.xp < 0) p.xp = 0;
            
            // Lose ALL carried gold (bank is safe)
            const goldLost = p.gold;
            p.gold = 0;
            
            // Clear dungeon state - you're kicked out
            gameState.dungeon = null;
            
            gameState.combatState = null;
            gameState.postCombatRecovery = false;

            updateHud();
            
            // Dramatic death message
            let deathMsg = `<span style="color:var(--error-color);font-size:20px;">ğŸ’€ YOU HAVE DIED ğŸ’€</span><br><br>`;
            deathMsg += `<span style="color:#ff6666;">XP Lost: ${xpLost.toLocaleString()}</span><br>`;
            if (levelsLost > 0) {
                deathMsg += `<span style="color:#ff3333;">LEVELS LOST: ${levelsLost}!</span><br>`;
            }
            deathMsg += `<span style="color:#ffaa00;">Gold Lost: ${goldLost} (Bank is safe)</span><br><br>`;
            deathMsg += `<span style="color:#888;">You wake up in town, broken and defeated...</span>`;
            
            termAppend(deathMsg, 'term-error', () => {
                setTimeout(() => { 
                    closeTerminalView(); 
                    showTown();
                    // Auto-save the harsh penalty
                    saveGame();
                }, 3000);
            });
        } else {
            // Standard overworld death - just lose 50% gold
            p.gold = Math.floor(p.gold / 2);
            
            gameState.combatState = null;
            gameState.postCombatRecovery = false;

            updateHud();
            termAppend(
                'You have been defeatedâ€¦ You wake up in town.',
                'term-error',
                () => setTimeout(() => { closeTerminalView(); showTown(); }, 1200)
            );
        }
        return;
    }

    // â”€â”€ victory â”€â”€
    const defeated   = gameState.combatState.defeatedMonsters || [];
    const isMaster   = defeated.some(m => m.isMaster);
    let masterData   = null;
    let unlockedArea = null;

    if (isMaster) {
        const m = defeated.find(d => d.isMaster);
        masterData   = CLASS_MASTERS[m.masterKey];
        unlockedArea = masterData.unlocks;

        if (!gameState.player.defeatedMasters.includes(m.masterKey))
            gameState.player.defeatedMasters.push(m.masterKey);

        if (!gameState.player.unlockedAreas.includes(unlockedArea))
            gameState.player.unlockedAreas.push(unlockedArea);

        masterData.guaranteedDrops.forEach(ik => {
            if (!defeated[0].possibleDrops) defeated[0].possibleDrops = [];
            if (!defeated[0].possibleDrops.includes(ik))
                defeated[0].possibleDrops.push(ik);

            if (!defeated[0].dropRates) defeated[0].dropRates = {};
            defeated[0].dropRates[
                (WEAPONS[ik] || ARMOR[ik]) ? getItemQuality(ik) : 'common'
            ] = 1.0;
        });
    }

    let totalXp = 0, totalGold = 0, allLoot = [];
    defeated.forEach(e => {
        // Calculate XP based on level difference and rarity
        const xpReward = calculateXpReward(e, gameState.player.level);
        totalXp   += xpReward;
        totalGold += e.gold;
        allLoot    = allLoot.concat(rollLoot(e));
    });

    gameState.player.xp   += totalXp;
    gameState.player.gold += totalGold;

    // â”€â”€ Remove defeated dungeon enemy â”€â”€
    if (gameState.dungeon && gameState.combatState?.dungeonEnemyId) {
        const dungeonEnemyId = gameState.combatState.dungeonEnemyId;
        gameState.dungeon.activeEnemies = gameState.dungeon.activeEnemies.filter(
            e => e.id !== dungeonEnemyId
        );
        console.log(`ğŸ—‘ï¸ Removed dungeon enemy: ${dungeonEnemyId}`);
    }

    // â”€â”€ terminal output â”€â”€
    termAppend('', 'term-separator');

    if (isMaster) {
        termAppend(`ğŸ† ${masterData.name} HAS BEEN DEFEATED! ğŸ†`, 'term-victory');
        termAppend(`âœ¨ ${LOCATIONS[unlockedArea].name} IS NOW UNLOCKED! âœ¨`, 'term-loot');
    }

    if (defeated.length === 1) {
        termAppend(
            `You defeated <span style="color:${defeated[0].rarityColor};">${defeated[0].name}</span>!`,
            'term-highlight'
        );
    } else {
        termAppend(`You defeated ${defeated.length} enemies!`, 'term-highlight');
        defeated.forEach(e =>
            termAppend(`  â€¢ <span style="color:${e.rarityColor};">${e.name}</span>`)
        );
    }

    termAppend(
        `Gained <span style="color:#FFD700;">${totalXp} XP</span> and ` +
        `<span style="color:#FFD700;">${totalGold} Gold</span>!`
    );

    if (allLoot.length > 0) {
        termAppend('âš¡ LOOT:', 'term-loot');
        allLoot.forEach(ik => {
            gameState.player.inventory.push(ik);
            termAppend(
                `  + <span style="color:${getItemColor(ik)};">${getItemName(ik)}</span>`,
                'term-loot'
            );
        });
    } else {
        termAppend('No items droppedâ€¦', 'term-dim');
    }

    // Check for level-up (possibly multiple levels)
    while (gameState.player.xp >= gameState.player.xpToNext && gameState.player.level < 25) {
        levelUp();
        termAppend(`â¬†ï¸ LEVEL UP! You are now level ${gameState.player.level}!`, 'term-victory');
        
        // Check for class evolution announcement
        if (gameState.player._justEvolved) {
            termAppend('', 'term-separator');
            termAppend(`<span style="color:#FF00FF;font-size:24px;font-weight:bold;">âš¡ CLASS EVOLUTION! âš¡</span>`, 'term-victory');
            termAppend(gameState.player._evolutionMessage, 'term-victory');
            termAppend(`<span style="color:#FFD700;">Your power has DOUBLED!</span>`, 'term-loot');
            gameState.player._justEvolved = false;
            gameState.player._evolutionMessage = null;
        }
    }
    
    // Max level message
    if (gameState.player.level >= 25 && gameState.player.xp >= gameState.player.xpToNext) {
        termAppend(`ğŸŒŸ You have reached MAX LEVEL! (25)`, 'term-victory');
        gameState.player.xp = gameState.player.xpToNext; // Cap XP
    }

    updateHud();
    
    // ğŸ’¾ AUTO-SAVE after victory
    saveGame();

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // âœ… EXIT COMBAT, ENTER EXHAUSTION
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Mark combat as finished, but keep state for timers & UI
gameState.combatState.combatOver = true;
gameState.postCombatRecovery = true;

    // Resume regeneration after combat (normal speed - you're still in the field)
    startMpRegen(false);
    startResting(false);

    const ab = document.getElementById('actionBar');
    
    // Check if we're in a dungeon
    if (gameState.dungeon) {
        // Dungeon handles its own buttons - just render them
        renderDungeonActionBar();
    } else if (isMaster) {
        ab.innerHTML = `
            <button onclick="tryViewWorldMap()">ğŸ—ºï¸ VIEW WORLD MAP</button>
            <button onclick="tryGoBackToTown()">ğŸ˜ï¸ RETURN TO TOWN</button>`;
        renderActionBar();
    } else {
        ab.innerHTML = `
            <button onclick="tryExploreLocation('${gameState.currentLocation}')">ğŸ” CONTINUE EXPLORING</button>
            <button onclick="tryGoBackToTown()">ğŸ˜ï¸ RETURN TO TOWN</button>`;
        renderActionBar();

        stabilizeTerminalLayout();
    }

    if (!gameState.combatTimer) {
        startCombatTimer();
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POST-COMBAT EXHAUSTION CHECK
// (used by navigation actions)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function continueDungeonExploration() {
    // Clear combat state and show dungeon navigation
    gameState.combatState = null;
    gameState.postCombatRecovery = false;
    
    // Clear combat timer
    if (gameState.combatTimer) {
        clearInterval(gameState.combatTimer);
        gameState.combatTimer = null;
    }
    
    // Return to dungeon navigation
    renderDungeonActionBar();
}

function playerIsExhausted() {
    if (!gameState.postCombatRecovery) return false;

    const cs = gameState.combatState;
    if (!cs || !cs.pipAvailable) return false;

    return cs.pipAvailable.some(p => !p);
}
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ADVANCED CLASS EVOLUTION (Level 20)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const ADVANCED_CLASSES = {
            warrior: {
                advancedClass: 'warlord',
                advancedName: 'Warlord',
                description: 'Master of all weapons and combat. Unstoppable in battle.',
                damageMultiplier: 2.0,
                bonusStats: { str: 10, con: 10, dex: 5 },
                newSpells: ['battle_fury', 'titan_strike'],
                announcement: 'âš”ï¸ You have mastered the art of war! You are now a WARLORD!'
            },
            rogue: {
                advancedClass: 'shadowmaster',
                advancedName: 'Shadowmaster',
                description: 'Master assassin who strikes from the void itself.',
                damageMultiplier: 2.5,
                bonusStats: { dex: 15, lck: 10, str: 5 },
                newSpells: ['shadow_strike', 'void_step'],
                announcement: 'ğŸ—¡ï¸ You have become one with the shadows! You are now a SHADOWMASTER!'
            },
            acolyte: {
                advancedClass: 'high_priest',
                advancedName: 'High Priest',
                description: 'Chosen of the divine, wielding ultimate holy power.',
                damageMultiplier: 2.0,
                bonusStats: { wis: 15, cha: 10, con: 5 },
                newSpells: ['divine_judgment', 'mass_resurrection', 'holy_nova'],
                announcement: 'âœ¨ The gods have chosen you! You are now a HIGH PRIEST!'
            },
            necrolyte: {
                advancedClass: 'lich',
                advancedName: 'Lich',
                description: 'Immortal master of death itself. Reality bends to your will.',
                damageMultiplier: 2.0,
                bonusStats: { wis: 15, magic: 10, con: 5 },
                newSpells: ['death_wave', 'summon_undead_army', 'soul_drain'],
                announcement: 'ğŸ’€ You have transcended mortality! You are now a LICH!'
            },
            archer: {
                advancedClass: 'deadeye',
                advancedName: 'Deadeye',
                description: 'Perfect marksman whose arrows never miss their mark.',
                damageMultiplier: 2.3,
                bonusStats: { dex: 15, lck: 10, str: 5 },
                newSpells: ['piercing_shot', 'rain_of_arrows'],
                announcement: 'ğŸ¹ Your aim is now perfect! You are now a DEADEYE!'
            },
            druid: {
                advancedClass: 'archdruid',
                advancedName: 'Archdruid',
                description: 'Master of nature and the primal forces of creation.',
                damageMultiplier: 2.0,
                bonusStats: { wis: 15, con: 10, str: 5 },
                newSpells: ['natures_wrath', 'wild_shape', 'earthquake'],
                announcement: 'ğŸŒ¿ Nature itself answers your call! You are now an ARCHDRUID!'
            },
            sorceror: {
                advancedClass: 'archmage',
                advancedName: 'Archmage',
                description: 'Master of all magic. Reality itself obeys your command.',
                damageMultiplier: 2.5,
                bonusStats: { wis: 20, magic: 15, cha: 5 },
                newSpells: ['apocalypse', 'time_stop', 'disintegrate'],
                announcement: 'ğŸ”® You have mastered all magic! You are now an ARCHMAGE!'
            },
            hunter: {
                advancedClass: 'beastlord',
                advancedName: 'Beastlord',
                description: 'Master of beasts and the wild. Animals bow to your command.',
                damageMultiplier: 2.2,
                bonusStats: { dex: 12, str: 8, con: 8, wis: 5 },
                newSpells: ['beast_stampede', 'primal_bond'],
                announcement: 'ğŸº All beasts obey you! You are now a BEASTLORD!'
            },
            rogue: {
                advancedClass: 'shadowmaster',
                advancedName: 'Shadowmaster',
                description: 'Master assassin who strikes from the void itself.',
                damageMultiplier: 2.5,
                bonusStats: { dex: 15, lck: 10, str: 5 },
                newSpells: ['shadow_strike', 'void_step'],
                announcement: 'ğŸ—¡ï¸ You have become one with the shadows! You are now a SHADOWMASTER!'
            },
            paladin: {
                advancedClass: 'crusader',
                advancedName: 'Crusader',
                description: 'Holy warrior blessed by the gods themselves.',
                damageMultiplier: 2.2,
                bonusStats: { str: 10, wis: 10, con: 8, cha: 5 },
                newSpells: ['holy_crusade', 'divine_shield', 'smite_evil'],
                announcement: 'âš¡ The heavens bless your crusade! You are now a CRUSADER!'
            }
        };

        function evolveClass(player) {
            if (player.level !== 20) return false;
            if (player.hasEvolved) return false; // Already evolved
            
            const baseClass = player.class;
            const evolution = ADVANCED_CLASSES[baseClass];
            
            if (!evolution) return false;
            
            // Store original class
            player.baseClass = baseClass;
            player.class = evolution.advancedClass;
            player.className = evolution.advancedName;
            player.hasEvolved = true;
            
            // Apply bonus stats
            Object.keys(evolution.bonusStats).forEach(stat => {
                if (player[stat] !== undefined) {
                    player[stat] += evolution.bonusStats[stat];
                }
            });
            
            // Apply damage multiplier
            player.advancedClassMultiplier = evolution.damageMultiplier;
            
            // Add new spells
            evolution.newSpells.forEach(spell => {
                if (!player.knownSpells.includes(spell)) {
                    player.knownSpells.push(spell);
                }
            });
            
            // Heal to full and boost HP/MP
            player.maxHp = Math.floor(player.maxHp * 1.5);
            player.maxMp = Math.floor(player.maxMp * 1.5);
            player.hp = player.maxHp;
            player.mp = player.maxMp;
            
            return true;
        }

        function getAdvancedClassName(player) {
            if (player.hasEvolved && ADVANCED_CLASSES[player.baseClass]) {
                return ADVANCED_CLASSES[player.baseClass].advancedName;
            }
            return player.className || player.class;
        }

        function getClassDamageMultiplier(player) {
            return player.advancedClassMultiplier || 1.0;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // END ADVANCED CLASS SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function levelUp() {
            const p = gameState.player;
            
            // Cap at level 25
            if (p.level >= 25) {
                p.xp = p.xpToNext; // Keep at max
                return;
            }
            
            p.level++;
            p.xp -= p.xpToNext;
            
            // Update xpToNext using class-specific table
            p.xpToNext = getXpToNextLevel(p.baseClass || p.class, p.level);

            // legacy base stats
            p.maxHp += 15 + (p.con||0);   // CON scales HP gain
            p.hp     = p.maxHp;
            p.maxMp += 10;
            p.mp     = p.maxMp;
            p.strength += 2;
            p.defense  += 2;
            p.magic    += 2;
            p.speed    += 1;

            // new stat-block: +1 each
            if (p.str !== undefined) {
                p.str++; p.dex++; p.wis++; p.cha++; p.con++; p.lck++;
                // paladin bonus: extra +1 to both STR and WIS
                if (p.class === 'paladin' || p.baseClass === 'paladin') { p.str++; p.wis++; }
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CHECK FOR CLASS EVOLUTION AT LEVEL 20
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (p.level === 20 && evolveClass(p)) {
                const evolution = ADVANCED_CLASSES[p.baseClass];
                // Evolution message will be shown in endCombat
                p._justEvolved = true;
                p._evolutionMessage = evolution.announcement;
            }

            // Learn new spells
            const spellLevels = {
                2: ['fireball', 'heal'],
                3: ['holy_light'],
                4: ['lightning'],
                5: ['greater_heal'],
                6: ['ice_storm'],
                8: ['meteor']
            };

            if (spellLevels[p.level]) {
                spellLevels[p.level].forEach(spellKey => {
                    if (!p.knownSpells.includes(spellKey)) {
                        p.knownSpells.push(spellKey);
                    }
                });
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // LOOT DROP SYSTEM (Phase 1)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function rollLoot(monster) {
            const loot = [];
            const rarityBonus = RARITY_CONFIG[monster.rarity].dropBonus || 0;
            
            if (!monster.possibleDrops || monster.possibleDrops.length === 0) {
                return loot;
            }
            
            monster.possibleDrops.forEach(itemKey => {
                let dropChance = 0;
                
                // Determine base drop chance
                if (ITEMS[itemKey]) {
                    // Consumable/sellable items use common drop rate
                    dropChance = monster.dropRates.common || 0.3;
                } else if (WEAPONS[itemKey] || ARMOR[itemKey]) {
                    // Equipment uses quality-based drop rates
                    const quality = getItemQuality(itemKey);
                    dropChance = monster.dropRates[quality] || 0.05;
                }
                
                // Apply rarity bonus + player LCK luck bonus
                const lckBonus = gameState.player ? calcLootBonus(gameState.player.lck || 0) / 100 : 0;
                const adjustedChance = Math.min(0.95, dropChance * (1 + rarityBonus * 0.1 + lckBonus));
                
                if (Math.random() < adjustedChance) {
                    loot.push(itemKey);
                }
            });
            
            // SPECIAL: Magical Butterknife check (Red Dragons only!)
            if (monster.key === 'red_dragon' && Math.random() < 0.000001) {
                loot.push('magical_butterknife');
                // Alert SYSOP terminal if active
                if (gameState.sysop && gameState.sysop.authenticated) {
                    terminalPrint('âš ï¸âš ï¸âš ï¸ ULTRA RARE DROP: MAGICAL BUTTERKNIFE! âš ï¸âš ï¸âš ï¸', 'success');
                }
            }
            
            return loot;
        }

        function getItemName(itemKey) {
            if (WEAPONS[itemKey]) return WEAPONS[itemKey].name;
            if (ARMOR[itemKey]) return ARMOR[itemKey].name;
            if (ITEMS[itemKey]) return ITEMS[itemKey].name;
            if (SPELLS[itemKey]) return SPELLS[itemKey].name;
            return itemKey;
        }

        function getItemColor(itemKey) {
            if (WEAPONS[itemKey]) {
                return QUALITY_CONFIG[WEAPONS[itemKey].quality].color;
            }
            if (ARMOR[itemKey]) {
                return QUALITY_CONFIG[ARMOR[itemKey].quality].color;
            }
            // Default green for items
            return '#00FF00';
        }

        function getItemQualityText(itemKey) {
            if (WEAPONS[itemKey]) {
                const quality = WEAPONS[itemKey].quality;
                return `[${QUALITY_CONFIG[quality].name}]`;
            }
            if (ARMOR[itemKey]) {
                const quality = ARMOR[itemKey].quality;
                return `[${QUALITY_CONFIG[quality].name}]`;
            }
            return '';
        }

        function getItemQuality(itemKey) {
            if (WEAPONS[itemKey]) return WEAPONS[itemKey].quality;
            if (ARMOR[itemKey]) return ARMOR[itemKey].quality;
            return 'normal';
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // END LOOT DROP SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


        function respawn() {
            gameState.player.hp = gameState.player.maxHp;
            gameState.player.mp = gameState.player.maxMp;
            gameState.player.gold = Math.floor(gameState.player.gold / 2);
            gameState.combatState = null;
            showTown();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ADVENTURE SYSTEM (Choose-Your-Own-Adventure encounters)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function startAdventure(adventure) {
    // Deep clone so we don't mutate ADVENTURES template
    gameState.currentAdventure = JSON.parse(JSON.stringify(adventure));
    const current = gameState.currentAdventure;
    
    termAppend('', 'term-separator');
    termAppend(`<span style="color:#FFD700;font-size:20px;">âœ¨ ${current.name}! âœ¨</span>`, 'term-highlight');
    termAppend('', 'term-separator');
    termAppend(current.intro, 'term-dim');
    termAppend('', 'term-separator');
    termAppend('<span style="color:var(--highlight-color);">What do you do?</span>');
    termAppend('', 'term-separator');
    
    // Show choices
    current.choices.forEach((choice, index) => {
        termAppend(
            `<span style="color:var(--highlight-color);">${index + 1}.</span> ${choice.text}`,
            'term-highlight'
        );
    });
    
    renderAdventureActionBar();
}

        
        function renderAdventureActionBar() {
            const adventure = gameState.currentAdventure;
            if (!adventure) return;
            
            const ab = document.getElementById('actionBar');
            ab.style.display = 'flex';
            ab.innerHTML = '';
            
            adventure.choices.forEach((choice, index) => {
                const btn = document.createElement('button');
                btn.textContent = `${index + 1}. ${choice.text.substring(0, 30)}${choice.text.length > 30 ? '...' : ''}`;
                btn.style.fontSize = '12px';
                btn.style.padding = '6px';
                btn.onclick = () => chooseAdventurePath(index);
                ab.appendChild(btn);
            });
        }
        
       function chooseAdventurePath(choiceIndex) {
    const adventure = gameState.currentAdventure;
    if (!adventure || !adventure.choices) return;

    const choice = adventure.choices[choiceIndex];
    if (!choice) return;

    termAppend('', 'term-separator');
    termAppend(
        `<span style="color:var(--text-color);">â–º You choose: ${choice.text}</span>`,
        'term-highlight'
    );
    termAppend('', 'term-separator');

    // Roll weighted outcome
    let totalWeight = 0;
    choice.outcomes.forEach(o => totalWeight += o.weight);

    let roll = Math.random() * totalWeight;
    let selectedOutcome = choice.outcomes[0];

    for (const outcome of choice.outcomes) {
        roll -= outcome.weight;
        if (roll <= 0) {
            selectedOutcome = outcome;
            break;
        }
    }

    // Show outcome text
    if (selectedOutcome.text) {
        termAppend(selectedOutcome.text, 'term-highlight');
    }

    // Apply rewards
    if (selectedOutcome.rewards) {
        applyAdventureRewards(selectedOutcome.rewards);
    }

    // Combat immediately ends the adventure
    if (selectedOutcome.combat) {
        termAppend('', 'term-separator');
        gameState.currentAdventure = null;
        startCombat(selectedOutcome.combat);
        return;
    }

    // âœ… Handle nested choices correctly
    if (selectedOutcome.nextChoices && selectedOutcome.nextChoices.length) {
        adventure.choices = selectedOutcome.nextChoices;

        termAppend('', 'term-separator');
        termAppend(
            '<span style="color:var(--highlight-color);">What do you do?</span>',
            'term-highlight'
        );
        termAppend('', 'term-separator');

        // Re-render adventure buttons (NOT normal action bar)
        renderAdventureActionBar();
        return;
    }

    // Adventure ends normally
    gameState.currentAdventure = null;
    termAppend('', 'term-separator');
    renderActionBar();
}



        
        function applyAdventureRewards(rewards) {
            const p = gameState.player;
            
            if (rewards.gold) {
                p.gold = Math.max(0, p.gold + rewards.gold);
                if (rewards.gold > 0) {
                    termAppend(`<span style="color:#FFD700;">ğŸ’° +${rewards.gold} Gold!</span>`, 'term-loot');
                } else {
                    termAppend(`<span style="color:#FF6666;">ğŸ’° ${rewards.gold} Gold (paid)</span>`, 'term-error');
                }
            }
            
            if (rewards.xp) {
                p.xp += rewards.xp;
                termAppend(`<span style="color:#88FF88;">â­ +${rewards.xp} XP!</span>`, 'term-loot');
                
                // Check for level up
                while (p.xp >= p.xpToNext && p.level < 25) {
                    levelUp();
                    termAppend(`â¬†ï¸ LEVEL UP! You are now level ${p.level}!`, 'term-victory');
                    
                    // Check for class evolution
                    if (p._justEvolved) {
                        termAppend('', 'term-separator');
                        termAppend(`<span style="color:#FF00FF;font-size:24px;font-weight:bold;">âš¡ CLASS EVOLUTION! âš¡</span>`, 'term-victory');
                        termAppend(p._evolutionMessage, 'term-victory');
                        termAppend(`<span style="color:#FFD700;">Your power has DOUBLED!</span>`, 'term-loot');
                        p._justEvolved = false;
                        p._evolutionMessage = null;
                    }
                }
            }
            
            if (rewards.damage) {
                p.hp -= rewards.damage;
                termAppend(`<span style="color:#FF6666;">ğŸ’” Took ${rewards.damage} damage!</span>`, 'term-error');
                if (p.hp <= 0) {
                    p.hp = 1; // Can't die from adventure damage
                    termAppend(`<span style="color:#FFAA00;">You barely survive!</span>`, 'term-warning');
                }
            }
            
            if (rewards.heal === 'full') {
                p.hp = p.maxHp;
                p.mp = p.maxMp;
                termAppend(`<span style="color:#00FF00;">âœ¨ Fully restored!</span>`, 'term-victory');
            }
            
            if (rewards.items) {
                rewards.items.forEach(itemKey => {
                    p.inventory.push(itemKey);
                    const item = ITEMS[itemKey] || WEAPONS[itemKey] || ARMOR[itemKey];
                    if (item) {
                        termAppend(`<span style="color:#00FFFF;">ğŸ Received: ${item.name}!</span>`, 'term-loot');
                    } else {
                        termAppend(`<span style="color:#00FFFF;">ğŸ Received: ${itemKey}!</span>`, 'term-loot');
                    }
                });
            }
            
            if (rewards.spell) {
                if (!p.knownSpells.includes(rewards.spell)) {
                    p.knownSpells.push(rewards.spell);
                    termAppend(`<span style="color:#FF00FF;">ğŸ“– Learned spell: ${rewards.spell}!</span>`, 'term-victory');
                }
            }
            
            updateHud();
            saveGame();
        }


        // Start the game
        initGame();



    </script>
</body>
</html>