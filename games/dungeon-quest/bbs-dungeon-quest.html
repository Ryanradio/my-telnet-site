<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚öîÔ∏è DUNGEON QUEST BBS ‚öîÔ∏è</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&family=Press+Start+2P&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-bg: #000080;
            --secondary-bg: #000000;
            --text-color: #00FF00;
            --highlight-color: #FFFF00;
            --error-color: #FF0000;
            --border-color: #00FFFF;
            --menu-color: #FFFFFF;
        }

        body {
            background: var(--primary-bg);
            color: var(--text-color);
            font-family: 'VT323', monospace;
            font-size: 20px;
            line-height: 1.4;
            overflow-x: hidden;
        }

        .scanline {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                transparent 50%,
                rgba(0, 0, 0, 0.25) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 1000;
            animation: flicker 0.15s infinite;
        }

        @keyframes flicker {
            0% { opacity: 0.95; }
            50% { opacity: 1; }
            100% { opacity: 0.95; }
        }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }

        @keyframes flashOrange {
            0%, 100% { color: #FF8C00; text-shadow: 0 0 6px #FF8C00; }
            50%      { color: #FFD700; text-shadow: 0 0 14px #FFD700; }
        }

        @keyframes flashRed {
            0%, 100% { color: #FF0000; text-shadow: 0 0 6px #FF0000; }
            50%      { color: #FF4444; text-shadow: 0 0 14px #FF4444; }
        }

        .dmg-player {
            animation: flashOrange 0.6s ease-in-out infinite;
            font-weight: bold;
        }

        .dmg-enemy {
            animation: flashRed 0.6s ease-in-out infinite;
            font-weight: bold;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            border: 3px double var(--border-color);
            padding: 15px;
            margin-bottom: 20px;
            background: var(--secondary-bg);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .header h1 {
            font-family: 'Press Start 2P', monospace;
            font-size: 24px;
            color: var(--highlight-color);
            text-shadow: 2px 2px var(--error-color);
            margin-bottom: 10px;
            animation: titlePulse 2s infinite;
        }

        @keyframes titlePulse {
            0%, 100% { text-shadow: 2px 2px var(--error-color); }
            50% { text-shadow: 2px 2px var(--error-color), 0 0 10px var(--highlight-color); }
        }

        /* ‚îÄ‚îÄ‚îÄ main screen used by town / shop / menus ‚îÄ‚îÄ‚îÄ */
        .screen {
            background: var(--secondary-bg);
            border: 2px solid var(--border-color);
            padding: 20px;
            min-height: 400px;
            margin-bottom: 20px;
            box-shadow: inset 0 0 50px rgba(0, 255, 0, 0.1);
        }
        .menu-option {
            color: var(--menu-color);
            cursor: pointer;
            padding: 8px;
            margin: 5px 0;
            transition: all 0.1s;
        }
        .menu-option:hover {
            background: var(--primary-bg);
            color: var(--highlight-color);
            padding-left: 20px;
        }

        /* ‚îÄ‚îÄ‚îÄ static HUD ‚îÄ‚îÄ‚îÄ */
        #hud {
            display: none;
            background: var(--secondary-bg);
            border: 2px solid var(--border-color);
            border-bottom: none;
            padding: 10px 14px;
            box-shadow: inset 0 0 30px rgba(0,255,0,0.08);
        }
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 6px;
        }
        .hud-top .hud-name { color: var(--highlight-color); font-size: 22px; }
        .hud-top .hud-gold { color: #FFD700; font-size: 20px; }
        .hud-bars {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
        }
        .hud-bar-group label {
            color: var(--highlight-color);
            font-size: 18px;
            display: block;
            margin-bottom: 2px;
        }
        .hud-bar-group .bar-nums { color: var(--text-color); font-size: 17px; }
        .progress-bar {
            width: 100%;
            height: 18px;
            background: #111;
            border: 1px solid var(--border-color);
            margin-top: 3px;
        }
        .progress-fill { height: 100%; transition: width 0.35s ease; }
        .hp-bar { background: var(--error-color); }
        .mp-bar { background: #4488ff; }
        .xp-bar { background: var(--text-color); }

        /* ‚îÄ‚îÄ‚îÄ scrolling terminal ‚îÄ‚îÄ‚îÄ */
        #terminalWindow {
            display: none;
            background: var(--secondary-bg);
            border: 2px solid var(--border-color);
            border-top: 1px solid #333;
            padding: 12px 14px;
            height: 360px;
            overflow-y: auto;
            box-shadow: inset 0 0 40px rgba(0,255,0,0.07);
            scroll-behavior: smooth;
        }
        .term-line {
            padding: 3px 0;
            font-size: 19px;
            color: var(--text-color);
            line-height: 1.35;
        }
        .term-line.term-dim       { color: #3a7a3a; }
        .term-line.term-highlight { color: var(--highlight-color); }
        .term-line.term-enemy     { color: var(--border-color); font-size: 20px; }
        .term-line.term-victory   { color: var(--border-color); font-size: 22px; }
        .term-line.term-loot      { color: #FFD700; }
        .term-line.term-error     { color: var(--error-color); }
        .term-line.term-separator { border-top: 1px solid #2a5a2a; margin: 6px 0 4px; padding-top: 4px; }
        .enemy-card {
            border: 2px solid var(--error-color);
            padding: 8px 12px;
            margin: 6px 0;
            background: rgba(255,0,0,0.05);
            display: inline-block;
            min-width: 260px;
            vertical-align: top;
        }
        .enemy-card.is-target { border-color: var(--highlight-color); }
        .enemy-card .ec-name  { font-size: 21px; margin-bottom: 4px; }
        .enemy-card .ec-hp    { font-size: 18px; color: var(--text-color); }

        /* ‚îÄ‚îÄ‚îÄ action bar ‚îÄ‚îÄ‚îÄ */
        #actionBar {
            display: none;
            background: var(--secondary-bg);
            border: 2px solid var(--border-color);
            border-top: 1px solid #444;
            padding: 10px 14px 12px;
        }
        #actionBar .action-label { color: var(--highlight-color); font-size: 18px; margin-bottom: 6px; }
        #actionBar .timer-line   { color: var(--highlight-color); font-size: 19px; margin-bottom: 4px; }

        /* ‚îÄ‚îÄ‚îÄ legacy helpers for shop / inventory / town ‚îÄ‚îÄ‚îÄ */
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid var(--border-color);
            background: rgba(0,128,0,0.1);
        }
        .stat       { color: var(--text-color); }
        .stat-label { color: var(--highlight-color); }
        .message {
            padding: 10px;
            margin: 10px 0;
            border-left: 3px solid var(--border-color);
        }
        .combat-message  { color: var(--highlight-color); font-weight: bold; }
        .error-message   { color: var(--error-color); }
        .success-message { color: var(--border-color); }

        button {
            background: var(--secondary-bg);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            padding: 10px 20px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) {
            background: var(--primary-bg);
            color: var(--highlight-color);
            box-shadow: 0 0 10px var(--border-color);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        input {
            background: var(--secondary-bg);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            padding: 10px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            width: 100%;
            margin: 10px 0;
        }

        .character-select {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .class-card {
            border: 2px solid var(--border-color);
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--secondary-bg);
        }

        .class-card:hover {
            background: var(--primary-bg);
            box-shadow: 0 0 15px var(--border-color);
            transform: scale(1.05);
        }

        .class-card.selected {
            border-color: var(--highlight-color);
            background: var(--primary-bg);
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .item-card {
            border: 1px solid var(--border-color);
            padding: 10px;
            background: rgba(0, 128, 0, 0.05);
        }

        .equipped {
            border-color: var(--highlight-color);
            background: rgba(255, 255, 0, 0.1);
        }

        .cursor {
            display: inline-block;
            width: 10px;
            height: 20px;
            background: var(--text-color);
            animation: blink 1s infinite;
            margin-left: 5px;
        }

        .location-header {
            font-family: 'Press Start 2P', monospace;
            font-size: 16px;
            color: var(--border-color);
            text-align: center;
            padding: 10px;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: 15px;
        }

        .enemy-display {
            text-align: center;
            padding: 20px;
            border: 2px solid var(--error-color);
            margin: 15px 0;
            background: rgba(255, 0, 0, 0.05);
        }

        .ascii-art {
            font-family: monospace;
            font-size: 14px;
            line-height: 1.2;
            white-space: pre;
            color: var(--text-color);
        }

        /* SYSOP Terminal Styles */
        .terminal-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--secondary-bg);
            border-top: 3px solid var(--error-color);
            padding: 10px 20px;
            z-index: 999;
            max-height: 300px;
            overflow-y: auto;
            display: none;
            box-shadow: 0 -5px 20px rgba(255, 0, 0, 0.5);
        }

        .terminal-container.active {
            display: block;
            animation: terminalSlideUp 0.3s;
        }

        @keyframes terminalSlideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        .terminal-header {
            color: var(--error-color);
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            margin-bottom: 10px;
            text-align: center;
            border-bottom: 1px solid var(--error-color);
            padding-bottom: 5px;
        }

        .terminal-output {
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
            color: var(--text-color);
        }

        .terminal-line {
            margin: 3px 0;
        }

        .terminal-error {
            color: var(--error-color);
        }

        .terminal-success {
            color: var(--border-color);
        }

        .terminal-warning {
            color: var(--highlight-color);
        }

        .terminal-input-line {
            display: flex;
            align-items: center;
        }

        .terminal-prompt {
            color: var(--error-color);
            margin-right: 10px;
        }

        .terminal-input {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--text-color);
            font-family: 'VT323', monospace;
            font-size: 20px;
            outline: none;
        }

        .sysop-badge {
            position: fixed;
            top: 10px;
            right: 10px;
            background: var(--error-color);
            color: var(--secondary-bg);
            padding: 5px 10px;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            border: 2px solid var(--highlight-color);
            z-index: 998;
            display: none;
            animation: badgePulse 2s infinite;
        }

        .sysop-badge.active {
            display: block;
        }

        @keyframes badgePulse {
            0%, 100% { box-shadow: 0 0 5px var(--error-color); }
            50% { box-shadow: 0 0 20px var(--error-color); }
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1001;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: var(--secondary-bg);
            border: 3px solid var(--error-color);
            padding: 20px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 30px var(--error-color);
        }
    </style>
</head>
<body>
    <div class="scanline"></div>
    
    <div class="container">
        <div class="header">
            <h1>‚öîÔ∏è DUNGEON QUEST BBS ‚öîÔ∏è</h1>
            <div style="color: var(--border-color);">‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</div>
            <div style="color: var(--menu-color); font-size: 16px;">A Classic Text Adventure</div>
        </div>

        <div class="screen" id="mainScreen">
            <!-- Content will be dynamically loaded here -->
        </div>

        <!-- ‚îÄ‚îÄ static HUD (hidden except during explore/combat) ‚îÄ‚îÄ -->
        <div id="hud">
            <div class="hud-top">
                <span class="hud-name" id="hudName">Hero ‚Äì Lv 1 Warrior</span>
                <span class="hud-gold" id="hudGold">üí∞ 100 g</span>
            </div>
            <div class="hud-bars">
                <div class="hud-bar-group">
                    <label>HP <span class="bar-nums" id="hudHpNums">120 / 120</span></label>
                    <div class="progress-bar"><div class="progress-fill hp-bar" id="hudHpBar" style="width:100%"></div></div>
                </div>
                <div class="hud-bar-group">
                    <label>MP <span class="bar-nums" id="hudMpNums">20 / 20</span></label>
                    <div class="progress-bar"><div class="progress-fill mp-bar" id="hudMpBar" style="width:100%"></div></div>
                </div>
                <div class="hud-bar-group">
                    <label>XP <span class="bar-nums" id="hudXpNums">0 / 100</span></label>
                    <div class="progress-bar"><div class="progress-fill xp-bar" id="hudXpBar" style="width:0%"></div></div>
                </div>
            </div>
        </div>

        <!-- ‚îÄ‚îÄ scrolling terminal log ‚îÄ‚îÄ -->
        <div id="terminalWindow"></div>

        <!-- ‚îÄ‚îÄ action buttons / timer (combat or explore) ‚îÄ‚îÄ -->
        <div id="actionBar"></div>
    </div>

    <!-- SYSOP Terminal -->
    <div class="sysop-badge" id="sysopBadge">‚ö† SYSOP MODE ‚ö†</div>
    <div class="terminal-container" id="terminalContainer">
        <div class="terminal-header">‚ïê‚ïê‚ïê SYSOP TERMINAL ‚ïê‚ïê‚ïê</div>
        <div class="terminal-output" id="terminalOutput"></div>
        <div class="terminal-input-line">
            <span class="terminal-prompt">root@dungeon:~#</span>
            <input type="text" class="terminal-input" id="terminalInput" autocomplete="off">
        </div>
    </div>

    <!-- Modal for forms -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal-content" id="modalContent"></div>
    </div>

    <!-- External Game Data Files -->
    <script src="monsters.js"></script>
    <script src="weapons.js"></script>
    <script src="armor.js"></script>
    <script src="items.js"></script>
    <script src="class-masters.js"></script>

    <script>
        // Game Data Structures
        const CLASSES = {
            warrior: {
                name: 'Warrior',
                hp: 120,
                mp: 20,
                strength: 15,
                defense: 12,
                magic: 3,
                speed: 7,
                description: 'Master of melee combat with high HP and defense',
                startWeapon: 'iron_sword',
                startArmor: 'leather_armor'
            },
            rogue: {
                name: 'Rogue',
                hp: 80,
                mp: 30,
                strength: 10,
                defense: 6,
                magic: 5,
                speed: 15,
                description: 'Swift and deadly, strikes first with critical hits',
                startWeapon: 'dagger',
                startArmor: 'cloth_armor'
            },
            paladin: {
                name: 'Paladin',
                hp: 100,
                mp: 50,
                strength: 12,
                defense: 10,
                magic: 8,
                speed: 8,
                description: 'Holy warrior with healing magic and strong defense',
                startWeapon: 'mace',
                startArmor: 'chainmail'
            },
            mage: {
                name: 'Mage',
                hp: 60,
                mp: 100,
                strength: 5,
                defense: 4,
                magic: 18,
                speed: 9,
                description: 'Powerful spellcaster with devastating magic',
                startWeapon: 'staff',
                startArmor: 'robes'
            },
            cleric: {
                name: 'Cleric',
                hp: 90,
                mp: 70,
                strength: 8,
                defense: 8,
                magic: 12,
                speed: 7,
                description: 'Divine healer with support spells and moderate combat',
                startWeapon: 'mace',
                startArmor: 'leather_armor'
            },
            ranger: {
                name: 'Ranger',
                hp: 85,
                mp: 40,
                strength: 11,
                defense: 7,
                magic: 6,
                speed: 13,
                description: 'Skilled archer with nature magic and tracking',
                startWeapon: 'bow',
                startArmor: 'leather_armor'
            }
        };


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // STAT SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const STAT_BUDGET  = 30;
        const STAT_NAMES   = ['str','dex','wis','cha','con','lck'];
        const STAT_LABELS  = { str:'STR', dex:'DEX', wis:'WIS', cha:'CHA', con:'CON', lck:'LCK' };
        const STAT_DESCS   = {
            str:'Physical damage & multi-hit',
            dex:'Dodge chance & flee success',
            wis:'Spell power & magic resist',
            cha:'Shop prices & negotiation',
            con:'Max HP bonus & defense',
            lck:'Crit chance & loot luck'
        };
        // Opposed pairs: reroll engine biases against extremes in both.
        // Paladin is EXEMPT from str<->wis opposition.
        const OPPOSED_PAIRS = [['str','wis'],['dex','cha'],['con','lck']];

        const CLASS_STAT_PRESETS = {
            warrior : { str:10, dex:4, wis:2, cha:2, con:8, lck:4 },
            rogue   : { str:4,  dex:10,wis:2, cha:4, con:4, lck:6 },
            paladin : { str:7,  dex:3, wis:7, cha:4, con:6, lck:3 },
            mage    : { str:2,  dex:3, wis:10,cha:3, con:4, lck:8 },
            cleric  : { str:3,  dex:2, wis:9, cha:6, con:6, lck:4 },
            ranger  : { str:5,  dex:8, wis:3, cha:3, con:5, lck:6 }
        };
        const CLASS_AFFINITIES = {
            warrior :['str','con'],
            rogue   :['dex','lck'],
            paladin :['str','wis','cha'],
            mage    :['wis','lck'],
            cleric  :['wis','cha'],
            ranger  :['dex','lck']
        };

        // ‚îÄ‚îÄ derived-stat helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function calcPlayerHits(p) {
            let h = 1;
            if (p.class === 'rogue') h++;           // rogue class bonus
            h += Math.floor((p.level || 1) / 4);    // +1 every 4 levels
            h += Math.floor(Math.max(0, (p.str||0) - 8) / 6);  // STR scaling
            return h;
        }
        function calcChaDiscount(cha) { return Math.min(30, (cha||0) * 2); }   // buy %  off
        function calcChaSellBonus(cha){ return Math.min(15, (cha||0) * 1); }   // sell %  bonus
        function calcInnCost(cha)     { return Math.max(20, 50 - (cha||0)); }
        function calcCritChance(lck)  { return Math.min(30,  5 + (lck||0)); }  // %
        function calcDodgeChance(dex) { return Math.min(40, (dex||0) * 2); }   // %
        function calcLootBonus(lck)   { return Math.min(25, (lck||0) * 2); }   // extra %

        // random reroll: scatter STAT_BUDGET among 6 stats (min 1 each)
        function rerollStats(classKey) {
            const s = { str:1, dex:1, wis:1, cha:1, con:1, lck:1 };
            let rem = STAT_BUDGET - 6;
            while (rem-- > 0) s[STAT_NAMES[Math.floor(Math.random()*6)]]++;
            return s;
        }

        const SPELLS = {
            heal: { name: 'Heal', mpCost: 15, power: 30, type: 'heal', level: 1, description: 'Restore HP' },
            fireball: { name: 'Fireball', mpCost: 20, power: 35, type: 'attack', level: 2, description: 'Fiery attack' },
            lightning: { name: 'Lightning', mpCost: 25, power: 45, type: 'attack', level: 4, description: 'Electric damage' },
            greater_heal: { name: 'Greater Heal', mpCost: 30, power: 60, type: 'heal', level: 5, description: 'Major healing' },
            ice_storm: { name: 'Ice Storm', mpCost: 35, power: 55, type: 'attack', level: 6, description: 'Freezing assault' },
            holy_light: { name: 'Holy Light', mpCost: 20, power: 25, type: 'attack', level: 3, description: 'Divine damage' },
            meteor: { name: 'Meteor', mpCost: 50, power: 80, type: 'attack', level: 8, description: 'Devastating spell' }
        };

        const LOCATIONS = {
            town: {
                name: 'Silverdale Town',
                description: 'A peaceful town with shops and an inn. Your adventure begins here.',
                canRest: true,
                hasShop: true
            },
            forest: {
                name: 'Whispering Forest',
                description: 'A dark forest filled with minor creatures.',
                enemyLevelRange: [1, 3],
                encounters: ['goblin', 'wolf', 'giant_spider'],
                requiredLevel: 1,
                locked: false
            },
            plains: {
                name: 'Endless Plains',
                description: 'Open grasslands with roaming beasts.',
                enemyLevelRange: [2, 5],
                encounters: ['orc', 'dire_wolf', 'bandit'],
                requiredLevel: 3,
                locked: true,
                unlockMessage: 'Defeat your class master in the forest to unlock this area!'
            },
            cave: {
                name: 'Shadow Cavern',
                description: 'A dungeon filled with dangerous monsters.',
                enemyLevelRange: [4, 7],
                encounters: ['troll', 'skeleton_warrior', 'dark_mage'],
                requiredLevel: 6,
                locked: true,
                unlockMessage: 'Defeat your class master in the plains to unlock this area!'
            },
            crypt: {
                name: 'Ancient Crypt',
                description: 'An ancient tomb haunted by the undead.',
                enemyLevelRange: [6, 9],
                encounters: ['lich', 'death_knight', 'wraith'],
                requiredLevel: 9,
                locked: true,
                unlockMessage: 'Defeat your class master in the cave to unlock this area!'
            },
            volcano: {
                name: 'Fire Mountain',
                description: 'A volcanic peak home to fierce creatures.',
                enemyLevelRange: [8, 12],
                encounters: ['fire_elemental', 'red_dragon', 'demon'],
                requiredLevel: 12,
                locked: true,
                unlockMessage: 'Defeat your class master in the crypt to unlock this area!'
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // MODEM SPEED SIMULATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const MODEM_SPEEDS = {
            '56k': 7,      // ~7 characters per frame (56k modem)
            '28.8k': 4,    // ~4 characters per frame (28.8k modem)
            '14.4k': 2,    // ~2 characters per frame (14.4k modem)
            'instant': -1  // No delay
        };
        
        let currentModemSpeed = '28.8k'; // Default to 28.8k modem
        let isStreaming = false;
        let streamCancelled = false;
        
        function streamText(element, html, callback) {
            if (currentModemSpeed === 'instant') {
                element.innerHTML = html;
                if (callback) callback();
                return;
            }
            
            isStreaming = true;
            streamCancelled = false;
            
            // Strip HTML tags for character counting but keep them for display
            const charsPerFrame = MODEM_SPEEDS[currentModemSpeed];
            let currentIndex = 0;
            
            const interval = setInterval(() => {
                if (streamCancelled) {
                    clearInterval(interval);
                    element.innerHTML = html;
                    isStreaming = false;
                    if (callback) callback();
                    return;
                }
                
                currentIndex += charsPerFrame;
                
                if (currentIndex >= html.length) {
                    clearInterval(interval);
                    element.innerHTML = html;
                    isStreaming = false;
                    if (callback) callback();
                } else {
                    // Display partial HTML up to current index
                    element.innerHTML = html.substring(0, currentIndex) + '<span style="animation: blink 1s infinite;">_</span>';
                }
            }, 16); // ~60fps
        }
        
        function cancelStream() {
            streamCancelled = true;
        }

        // Game State
        let gameState = {
            player: null,
            currentLocation: 'town',
            combatState: null,
            combatTimer: null,
            lastAction: null,
            sysop: {
                authenticated: false,
                username: null,
                terminalActive: false,
                commandHistory: []
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SYSOP TERMINAL SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        const SYSOP_CREDENTIALS = {
            username: 'sysop',
            password: 'Radojcsics'
        };

        // Toggle terminal with ~ key
        document.addEventListener('keydown', (e) => {
            if (e.key === '~' || e.key === '`') {
                e.preventDefault();
                toggleTerminal();
            }
            if (e.key === 'Escape' && gameState.sysop.terminalActive) {
                toggleTerminal();
            }
        });

        function toggleTerminal() {
            const terminal = document.getElementById('terminalContainer');
            const input = document.getElementById('terminalInput');
            
            gameState.sysop.terminalActive = !gameState.sysop.terminalActive;
            
            if (gameState.sysop.terminalActive) {
                terminal.classList.add('active');
                input.focus();
                if (!gameState.sysop.authenticated) {
                    terminalPrint('Terminal activated. Type /login <username> <password> to authenticate.', 'warning');
                }
            } else {
                terminal.classList.remove('active');
            }
        }

        function terminalPrint(message, type = 'normal') {
            const output = document.getElementById('terminalOutput');
            const line = document.createElement('div');
            line.className = `terminal-line ${type === 'error' ? 'terminal-error' : ''} ${type === 'success' ? 'terminal-success' : ''} ${type === 'warning' ? 'terminal-warning' : ''}`;
            line.textContent = message;
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
        }

        function clearTerminal() {
            document.getElementById('terminalOutput').innerHTML = '';
        }

        // Terminal input handler
        document.getElementById('terminalInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const input = e.target.value.trim();
                e.target.value = '';
                
                if (input) {
                    terminalPrint(`root@dungeon:~# ${input}`, 'normal');
                    gameState.sysop.commandHistory.push(input);
                    executeCommand(input);
                }
            }
        });

        function executeCommand(input) {
            const parts = input.split(' ');
            const command = parts[0].toLowerCase();
            const args = parts.slice(1);

            // Login command (always available)
            if (command === '/login') {
                handleLogin(args);
                return;
            }

            // Check authentication for all other commands
            if (!gameState.sysop.authenticated) {
                terminalPrint('ERROR: Authentication required. Use /login <username> <password>', 'error');
                return;
            }

            // Execute authenticated commands
            switch(command) {
                case '/help':
                    showHelp();
                    break;
                case '/logout':
                    handleLogout();
                    break;
                case '/clear':
                    clearTerminal();
                    break;
                case '/give':
                    handleGive(args);
                    break;
                case '/addmonster':
                    openAddMonsterForm();
                    break;
                case '/addweapon':
                    openAddWeaponForm();
                    break;
                case '/addarmor':
                    openAddArmorForm();
                    break;
                case '/additem':
                    openAddItemForm();
                    break;
                case '/listmonsters':
                    listMonsters();
                    break;
                case '/listweapons':
                    listWeapons();
                    break;
                case '/listarmor':
                    listArmor();
                    break;
                case '/listitems':
                    listItems();
                    break;
                case '/setlevel':
                    handleSetLevel(args);
                    break;
                case '/setgold':
                    handleSetGold(args);
                    break;
                case '/heal':
                    handleHeal();
                    break;
                case '/godmode':
                    handleGodMode(args);
                    break;
                case '/teleport':
                    handleTeleport(args);
                    break;
                case '/killmonster':
                    handleKillMonster();
                    break;
                case '/export':
                    handleExport(args);
                    break;
                default:
                    terminalPrint(`ERROR: Unknown command '${command}'. Type /help for available commands.`, 'error');
            }
        }

        function handleLogin(args) {
            if (args.length < 2) {
                terminalPrint('ERROR: Usage: /login <username> <password>', 'error');
                return;
            }

            const username = args[0];
            const password = args[1];

            if (username === SYSOP_CREDENTIALS.username && password === SYSOP_CREDENTIALS.password) {
                gameState.sysop.authenticated = true;
                gameState.sysop.username = username;
                document.getElementById('sysopBadge').classList.add('active');
                terminalPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'success');
                terminalPrint('  AUTHENTICATION SUCCESSFUL', 'success');
                terminalPrint('  Welcome, SYSOP ' + username, 'success');
                terminalPrint('  Type /help for available commands', 'success');
                terminalPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'success');
            } else {
                terminalPrint('ERROR: Authentication failed. Invalid credentials.', 'error');
            }
        }

        function handleLogout() {
            gameState.sysop.authenticated = false;
            gameState.sysop.username = null;
            document.getElementById('sysopBadge').classList.remove('active');
            terminalPrint('Logged out. Terminal locked.', 'warning');
        }

        function showHelp() {
            terminalPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'warning');
            terminalPrint('SYSOP COMMANDS:', 'warning');
            terminalPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'warning');
            terminalPrint('');
            terminalPrint('AUTHENTICATION:');
            terminalPrint('  /login <user> <pass>  - Authenticate as sysop');
            terminalPrint('  /logout               - End sysop session');
            terminalPrint('');
            terminalPrint('PLAYER COMMANDS:');
            terminalPrint('  /give <type> <id>     - Give item (weapon/armor/item/spell)');
            terminalPrint('  /setlevel <level>     - Set player level');
            terminalPrint('  /setgold <amount>     - Set gold amount');
            terminalPrint('  /heal                 - Fully heal player');
            terminalPrint('  /godmode <on/off>     - Toggle invincibility');
            terminalPrint('');
            terminalPrint('GAME CONTENT:');
            terminalPrint('  /addmonster           - Add new monster (opens form)');
            terminalPrint('  /addweapon            - Add new weapon (opens form)');
            terminalPrint('  /addarmor             - Add new armor (opens form)');
            terminalPrint('  /additem              - Add new item (opens form)');
            terminalPrint('');
            terminalPrint('LISTING:');
            terminalPrint('  /listmonsters         - Show all monsters');
            terminalPrint('  /listweapons          - Show all weapons');
            terminalPrint('  /listarmor            - Show all armor');
            terminalPrint('  /listitems            - Show all items');
            terminalPrint('');
            terminalPrint('UTILITIES:');
            terminalPrint('  /teleport <location>  - Teleport to area');
            terminalPrint('  /killmonster          - Instantly kill current enemy');
            terminalPrint('  /export <type>        - Export data (monsters/weapons/armor/items)');
            terminalPrint('  /clear                - Clear terminal output');
            terminalPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'warning');
        }

        function handleGive(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            if (args.length < 2) {
                terminalPrint('ERROR: Usage: /give <type> <id>', 'error');
                terminalPrint('Types: weapon, armor, item, spell', 'error');
                return;
            }

            const type = args[0].toLowerCase();
            const id = args[1].toLowerCase();

            switch(type) {
                case 'weapon':
                    if (WEAPONS[id]) {
                        if (!gameState.player.inventory.includes(id)) {
                            gameState.player.inventory.push(id);
                        }
                        terminalPrint(`SUCCESS: Gave weapon '${WEAPONS[id].name}' to player`, 'success');
                    } else {
                        terminalPrint(`ERROR: Weapon '${id}' not found`, 'error');
                    }
                    break;
                case 'armor':
                    if (ARMOR[id]) {
                        if (!gameState.player.inventory.includes(id)) {
                            gameState.player.inventory.push(id);
                        }
                        terminalPrint(`SUCCESS: Gave armor '${ARMOR[id].name}' to player`, 'success');
                    } else {
                        terminalPrint(`ERROR: Armor '${id}' not found`, 'error');
                    }
                    break;
                case 'item':
                    if (ITEMS[id]) {
                        if (!gameState.player.inventory.includes(id)) {
                            gameState.player.inventory.push(id);
                        }
                        terminalPrint(`SUCCESS: Gave item '${ITEMS[id].name}' to player`, 'success');
                    } else {
                        terminalPrint(`ERROR: Item '${id}' not found`, 'error');
                    }
                    break;
                case 'spell':
                    if (SPELLS[id]) {
                        if (!gameState.player.knownSpells.includes(id)) {
                            gameState.player.knownSpells.push(id);
                        }
                        terminalPrint(`SUCCESS: Taught spell '${SPELLS[id].name}' to player`, 'success');
                    } else {
                        terminalPrint(`ERROR: Spell '${id}' not found`, 'error');
                    }
                    break;
                default:
                    terminalPrint(`ERROR: Invalid type '${type}'`, 'error');
            }
        }

        function handleSetLevel(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const level = parseInt(args[0]);
            if (isNaN(level) || level < 1 || level > 99) {
                terminalPrint('ERROR: Invalid level. Use 1-99', 'error');
                return;
            }

            gameState.player.level = level;
            gameState.player.xpToNext = Math.floor(100 * Math.pow(1.5, level - 1));
            terminalPrint(`SUCCESS: Set player level to ${level}`, 'success');
        }

        function handleSetGold(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const gold = parseInt(args[0]);
            if (isNaN(gold) || gold < 0) {
                terminalPrint('ERROR: Invalid gold amount', 'error');
                return;
            }

            gameState.player.gold = gold;
            terminalPrint(`SUCCESS: Set gold to ${gold}`, 'success');
        }

        function handleHeal() {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            gameState.player.hp = gameState.player.maxHp;
            gameState.player.mp = gameState.player.maxMp;
            terminalPrint('SUCCESS: Player fully healed', 'success');
        }

        function handleGodMode(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const mode = args[0]?.toLowerCase();
            if (mode === 'on') {
                gameState.player.godMode = true;
                terminalPrint('SUCCESS: God Mode ENABLED - Player is invincible', 'success');
            } else if (mode === 'off') {
                gameState.player.godMode = false;
                terminalPrint('SUCCESS: God Mode DISABLED', 'success');
            } else {
                terminalPrint('ERROR: Usage: /godmode <on/off>', 'error');
            }
        }

        function handleTeleport(args) {
            if (!gameState.player) {
                terminalPrint('ERROR: No active player character', 'error');
                return;
            }

            const location = args[0]?.toLowerCase();
            if (LOCATIONS[location]) {
                gameState.currentLocation = location;
                if (location === 'town') {
                    showTown();
                } else {
                    exploreLocation(location);
                }
                terminalPrint(`SUCCESS: Teleported to ${LOCATIONS[location].name}`, 'success');
            } else {
                terminalPrint(`ERROR: Unknown location '${location}'`, 'error');
                terminalPrint('Available: ' + Object.keys(LOCATIONS).join(', '), 'warning');
            }
        }

        function handleKillMonster() {
            if (!gameState.combatState) {
                terminalPrint('ERROR: Not in combat', 'error');
                return;
            }

            gameState.combatState.enemy.hp = 0;
            terminalPrint('SUCCESS: Enemy eliminated', 'success');
            checkCombatEnd();
        }

        function listMonsters() {
            terminalPrint('‚ïê‚ïê‚ïê ALL MONSTERS ‚ïê‚ïê‚ïê', 'warning');
            Object.keys(ENEMIES).forEach(key => {
                const m = ENEMIES[key];
                terminalPrint(`${key}: ${m.name} (Lv${m.level}, HP:${m.hp}, DMG:${m.damage})`);
            });
        }

        function listWeapons() {
            terminalPrint('‚ïê‚ïê‚ïê ALL WEAPONS ‚ïê‚ïê‚ïê', 'warning');
            Object.keys(WEAPONS).forEach(key => {
                const w = WEAPONS[key];
                terminalPrint(`${key}: ${w.name} (Lv${w.level}, DMG:${w.damage}, MAG:${w.magicDamage})`);
            });
        }

        function listArmor() {
            terminalPrint('‚ïê‚ïê‚ïê ALL ARMOR ‚ïê‚ïê‚ïê', 'warning');
            Object.keys(ARMOR).forEach(key => {
                const a = ARMOR[key];
                terminalPrint(`${key}: ${a.name} (Lv${a.level}, DEF:${a.defense})`);
            });
        }

        function listItems() {
            terminalPrint('‚ïê‚ïê‚ïê ALL ITEMS ‚ïê‚ïê‚ïê', 'warning');
            Object.keys(ITEMS).forEach(key => {
                const i = ITEMS[key];
                terminalPrint(`${key}: ${i.name} (${i.type}, Lv${i.level})`);
            });
        }

        function openAddMonsterForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW MONSTER</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Monster ID (lowercase, underscores):</label>
                    <input type="text" id="monsterId" placeholder="fire_dragon">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="monsterName" placeholder="Fire Dragon">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">HP:</label>
                    <input type="number" id="monsterHp" value="100">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Damage:</label>
                    <input type="number" id="monsterDamage" value="20">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Defense:</label>
                    <input type="number" id="monsterDefense" value="10">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">XP Reward:</label>
                    <input type="number" id="monsterXp" value="100">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Gold Reward:</label>
                    <input type="number" id="monsterGold" value="80">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level:</label>
                    <input type="number" id="monsterLevel" value="5">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="monsterDesc" placeholder="A fearsome creature">
                </div>
                <button onclick="submitAddMonster()">ADD MONSTER</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddMonster() {
            const id = document.getElementById('monsterId').value.trim().toLowerCase();
            const name = document.getElementById('monsterName').value.trim();
            const hp = parseInt(document.getElementById('monsterHp').value);
            const damage = parseInt(document.getElementById('monsterDamage').value);
            const defense = parseInt(document.getElementById('monsterDefense').value);
            const xp = parseInt(document.getElementById('monsterXp').value);
            const gold = parseInt(document.getElementById('monsterGold').value);
            const level = parseInt(document.getElementById('monsterLevel').value);
            const description = document.getElementById('monsterDesc').value.trim();

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            ENEMIES[id] = {
                name: name,
                hp: hp,
                damage: damage,
                defense: defense,
                xp: xp,
                gold: gold,
                level: level,
                description: description
            };

            closeModal();
            terminalPrint(`SUCCESS: Added monster '${name}' with ID '${id}'`, 'success');
            terminalPrint('Remember to add it to a location\'s encounter list!', 'warning');
        }

        function openAddWeaponForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW WEAPON</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Weapon ID:</label>
                    <input type="text" id="weaponId" placeholder="flame_sword">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="weaponName" placeholder="Flame Sword">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Damage:</label>
                    <input type="number" id="weaponDamage" value="30">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Magic Damage:</label>
                    <input type="number" id="weaponMagic" value="10">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Cost:</label>
                    <input type="number" id="weaponCost" value="200">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level Requirement:</label>
                    <input type="number" id="weaponLevel" value="5">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="weaponDesc" placeholder="A blazing weapon">
                </div>
                <button onclick="submitAddWeapon()">ADD WEAPON</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddWeapon() {
            const id = document.getElementById('weaponId').value.trim().toLowerCase();
            const name = document.getElementById('weaponName').value.trim();
            const damage = parseInt(document.getElementById('weaponDamage').value);
            const magicDamage = parseInt(document.getElementById('weaponMagic').value);
            const cost = parseInt(document.getElementById('weaponCost').value);
            const level = parseInt(document.getElementById('weaponLevel').value);
            const description = document.getElementById('weaponDesc').value.trim();

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            WEAPONS[id] = {
                name: name,
                damage: damage,
                magicDamage: magicDamage,
                cost: cost,
                level: level,
                description: description
            };

            closeModal();
            terminalPrint(`SUCCESS: Added weapon '${name}' with ID '${id}'`, 'success');
        }

        function openAddArmorForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW ARMOR</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Armor ID:</label>
                    <input type="text" id="armorId" placeholder="dragon_mail">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="armorName" placeholder="Dragon Mail">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Defense:</label>
                    <input type="number" id="armorDefense" value="25">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Magic Bonus:</label>
                    <input type="number" id="armorMagic" value="0">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Cost:</label>
                    <input type="number" id="armorCost" value="300">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level Requirement:</label>
                    <input type="number" id="armorLevel" value="6">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="armorDesc" placeholder="Strong protective armor">
                </div>
                <button onclick="submitAddArmor()">ADD ARMOR</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddArmor() {
            const id = document.getElementById('armorId').value.trim().toLowerCase();
            const name = document.getElementById('armorName').value.trim();
            const defense = parseInt(document.getElementById('armorDefense').value);
            const magicBonus = parseInt(document.getElementById('armorMagic').value);
            const cost = parseInt(document.getElementById('armorCost').value);
            const level = parseInt(document.getElementById('armorLevel').value);
            const description = document.getElementById('armorDesc').value.trim();

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            ARMOR[id] = {
                name: name,
                defense: defense,
                magicBonus: magicBonus,
                cost: cost,
                level: level,
                description: description
            };

            closeModal();
            terminalPrint(`SUCCESS: Added armor '${name}' with ID '${id}'`, 'success');
        }

        function openAddItemForm() {
            const modal = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            content.innerHTML = `
                <div class="location-header">ADD NEW ITEM</div>
                <div style="margin: 20px 0;">
                    <label style="color: var(--highlight-color);">Item ID:</label>
                    <input type="text" id="itemId" placeholder="super_potion">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Display Name:</label>
                    <input type="text" id="itemName" placeholder="Super Potion">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Type:</label>
                    <select id="itemType" style="width: 100%; background: var(--secondary-bg); color: var(--text-color); border: 2px solid var(--border-color); padding: 10px; font-family: 'VT323', monospace; font-size: 18px;">
                        <option value="consumable">Consumable</option>
                        <option value="quest">Quest</option>
                        <option value="permanent">Permanent</option>
                        <option value="utility">Utility</option>
                        <option value="passive">Passive</option>
                    </select>
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Subtype:</label>
                    <input type="text" id="itemSubtype" placeholder="heal_hp">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Power:</label>
                    <input type="number" id="itemPower" value="50">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Cost:</label>
                    <input type="number" id="itemCost" value="30">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Level:</label>
                    <input type="number" id="itemLevel" value="1">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">Description:</label>
                    <input type="text" id="itemDesc" placeholder="Restores HP">
                    
                    <label style="color: var(--highlight-color); margin-top: 10px; display: block;">
                        <input type="checkbox" id="itemStackable" checked> Stackable
                    </label>
                </div>
                <button onclick="submitAddItem()">ADD ITEM</button>
                <button onclick="closeModal()">CANCEL</button>
            `;
            
            modal.classList.add('active');
        }

        function submitAddItem() {
            const id = document.getElementById('itemId').value.trim().toLowerCase();
            const name = document.getElementById('itemName').value.trim();
            const type = document.getElementById('itemType').value;
            const subtype = document.getElementById('itemSubtype').value.trim();
            const power = parseInt(document.getElementById('itemPower').value);
            const cost = parseInt(document.getElementById('itemCost').value);
            const level = parseInt(document.getElementById('itemLevel').value);
            const description = document.getElementById('itemDesc').value.trim();
            const stackable = document.getElementById('itemStackable').checked;

            if (!id || !name) {
                alert('ID and Name are required!');
                return;
            }

            ITEMS[id] = {
                name: name,
                type: type,
                subtype: subtype,
                power: power,
                cost: cost,
                level: level,
                description: description,
                stackable: stackable
            };

            closeModal();
            terminalPrint(`SUCCESS: Added item '${name}' with ID '${id}'`, 'success');
        }

        function closeModal() {
            document.getElementById('modalOverlay').classList.remove('active');
        }

        function handleExport(args) {
            const type = args[0]?.toLowerCase();
            let data;
            let filename;

            switch(type) {
                case 'monsters':
                    data = JSON.stringify(ENEMIES, null, 2);
                    filename = 'monsters.json';
                    break;
                case 'weapons':
                    data = JSON.stringify(WEAPONS, null, 2);
                    filename = 'weapons.json';
                    break;
                case 'armor':
                    data = JSON.stringify(ARMOR, null, 2);
                    filename = 'armor.json';
                    break;
                case 'items':
                    data = JSON.stringify(ITEMS, null, 2);
                    filename = 'items.json';
                    break;
                default:
                    terminalPrint('ERROR: Usage: /export <monsters/weapons/armor/items>', 'error');
                    return;
            }

            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);

            terminalPrint(`SUCCESS: Exported ${type} to ${filename}`, 'success');
        }

        // Make functions global for onclick handlers
        window.submitAddMonster = submitAddMonster;
        window.submitAddWeapon = submitAddWeapon;
        window.submitAddArmor = submitAddArmor;
        window.submitAddItem = submitAddItem;
        window.closeModal = closeModal;

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // END SYSOP TERMINAL SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        // Initialize Game
        function initGame() {
            showMainMenu();
        }

        function showMainMenu() {
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">MAIN MENU</div>
                <div style="text-align: center; margin: 30px 0;">
                    <div class="ascii-art" style="color: var(--highlight-color);">
    ‚öîÔ∏è ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ‚öîÔ∏è
       ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
       ‚ïë   DUNGEON QUEST AWAITS!   ‚ïë
       ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    üó°Ô∏è ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê üó°Ô∏è
                    </div>
                </div>
                <div style="max-width: 400px; margin: 0 auto;">
                    <div class="menu-option" onclick="newGame()">‚ñ∫ NEW GAME</div>
                    <div class="menu-option" onclick="loadGame()">‚ñ∫ LOAD GAME</div>
                    <div class="menu-option" onclick="showInstructions()">‚ñ∫ INSTRUCTIONS</div>
                </div>
            `;
        }

        function showInstructions() {
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">INSTRUCTIONS</div>
                <div class="message">
                    <p><span class="stat-label">OBJECTIVE:</span> Explore dungeons, defeat monsters, level up, and become legendary!</p>
                    <br>
                    <p><span class="stat-label">COMBAT:</span> Combat is turn-based with a timer. Choose your action before time runs out!</p>
                    <br>
                    <p><span class="stat-label">EXPLORATION:</span> Travel to different locations, each with stronger monsters.</p>
                    <br>
                    <p><span class="stat-label">PROGRESSION:</span> Gain XP, level up, buy better equipment, and learn new spells.</p>
                    <br>
                    <p><span class="stat-label">SAVING:</span> Save your game at any time from the town menu.</p>
                </div>
                <button onclick="showMainMenu()">BACK TO MENU</button>
            `;
        }

        function newGame() {
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">CHARACTER CREATION</div>
                <div class="message">
                    <p>Enter your character name:</p>
                    <input type="text" id="playerName" maxlength="20" placeholder="Hero Name">
                </div>
                <div class="message">
                    <p><span class="stat-label">Choose your class:</span></p>
                </div>
                <div class="character-select" id="classSelect"></div>
                <button onclick="goToStatAlloc()" id="createBtn" disabled>ALLOCATE STATS ‚Üí</button>
                <button onclick="showMainMenu()">CANCEL</button>
            `;

            const classSelect = document.getElementById('classSelect');
            window._selectedClass = null;

            Object.keys(CLASSES).forEach(classKey => {
                const cd   = CLASSES[classKey];
                const card = document.createElement('div');
                card.className = 'class-card';
                card.innerHTML = `
                    <div style="color:var(--highlight-color);font-size:22px;margin-bottom:8px;">${cd.name}</div>
                    <div style="font-size:16px;margin-bottom:8px;">${cd.description}</div>
                    <div class="stat">HP: ${cd.hp} | MP: ${cd.mp}</div>
                    <div class="stat" style="color:#8aaa8a;">STR/DEF/MAG/SPD set at creation</div>
                `;
                card.onclick = () => {
                    document.querySelectorAll('.class-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    window._selectedClass = classKey;
                    document.getElementById('createBtn').disabled = false;
                };
                classSelect.appendChild(card);
            });
        }

        // ‚îÄ‚îÄ stat allocation screen ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        window._pendingStats = null;
        window._pendingName  = '';

        function goToStatAlloc() {
            const name = document.getElementById('playerName').value.trim();
            if (!name)                { alert('Please enter a character name!'); return; }
            if (!window._selectedClass) { alert('Please select a class!');       return; }
            window._pendingName  = name;
            window._pendingStats = Object.assign({}, CLASS_STAT_PRESETS[window._selectedClass]);
            renderStatAllocScreen();
        }

        function renderStatAllocScreen() {
            const classKey   = window._selectedClass;
            const classData  = CLASSES[classKey];
            const stats      = window._pendingStats;
            const spent      = STAT_NAMES.reduce((a,k) => a + stats[k], 0);
            const remaining  = STAT_BUDGET - spent;
            const affinities = CLASS_AFFINITIES[classKey];
            const screen     = document.getElementById('mainScreen');

            // preview derived values
            const previewHp   = classData.hp + stats.con * 5;
            const previewHits = (function(){
                let h=1;
                if(classKey==='rogue') h++;
                h += Math.floor(Math.max(0, stats.str-8)/6);
                return h;
            })();

            let rows = '';
            STAT_NAMES.forEach(s => {
                const isAff   = affinities.includes(s);
                const canUp   = remaining > 0 && stats[s] < 15;
                const canDown = stats[s] > 1;
                rows += `
                <div style="display:flex;align-items:center;gap:8px;padding:5px 0;border-bottom:1px solid #1a4a1a;">
                    <span style="width:36px;color:${isAff?'var(--highlight-color)':'var(--text-color)'};font-weight:bold;">${STAT_LABELS[s]}</span>
                    <span style="flex:1;font-size:16px;color:#8aaa8a;">${STAT_DESCS[s]}${isAff?' ‚òÖ':''}</span>
                    <button onclick="statAdj('${s}',-1)" ${canDown?'':'disabled'} style="width:30px;padding:2px 0;margin:0;font-size:20px;">‚àí</button>
                    <span style="width:28px;text-align:center;color:var(--highlight-color);font-size:22px;">${stats[s]}</span>
                    <button onclick="statAdj('${s}',+1)" ${canUp ?'':'disabled'} style="width:30px;padding:2px 0;margin:0;font-size:20px;">+</button>
                </div>`;
            });

            screen.innerHTML = `
                <div class="location-header">ALLOCATE STATS ‚Äì ${classData.name}</div>
                <div class="message" style="border-color:var(--highlight-color);">
                    <span style="color:var(--highlight-color);">Points remaining: </span>
                    <span style="color:${remaining>0?'var(--text-color)':'var(--error-color)'};font-size:22px;">${remaining}</span>
                    <span style="color:#8aaa8a;font-size:15px;"> (‚òÖ = class affinity)</span>
                </div>
                <div style="max-width:520px;margin:0 auto;">${rows}</div>
                <div class="message" style="border-color:#005500;margin-top:12px;">
                    <span style="color:#8aaa8a;">PREVIEW: </span>
                    <span style="color:var(--highlight-color);">HP ${previewHp}</span>
                    <span style="color:var(--border-color);"> | Attacks/round: ${previewHits}</span>
                    <span style="color:#8aaa8a;"> | Crit ${calcCritChance(stats.lck)}% | Dodge ${calcDodgeChance(stats.dex)}%</span>
                </div>
                <div style="margin-top:14px;display:flex;flex-wrap:wrap;gap:8px;">
                    <button onclick="window._pendingStats=Object.assign({},CLASS_STAT_PRESETS['${classKey}']);renderStatAllocScreen();">üìã CLASS PRESET</button>
                    <button onclick="window._pendingStats=rerollStats('${classKey}');renderStatAllocScreen();">üé≤ REROLL</button>
                </div>
                <div style="margin-top:14px;">
                    <button onclick="finaliseCharacter()" ${remaining===0?'':'disabled'} style="font-size:20px;">‚öîÔ∏è BEGIN ADVENTURE ‚öîÔ∏è</button>
                    <button onclick="newGame()">‚Üê BACK</button>
                </div>
            `;
        }

        window.statAdj = function(stat, dir) {
            const stats = window._pendingStats;
            const spent = STAT_NAMES.reduce((a,k) => a + stats[k], 0);
            if (dir > 0 && spent >= STAT_BUDGET) return;
            if (dir < 0 && stats[stat] <= 1)      return;
            stats[stat] += dir;
            renderStatAllocScreen();
        };

        function finaliseCharacter() {
            const classKey  = window._selectedClass;
            const classData = CLASSES[classKey];
            const stats     = window._pendingStats;

            gameState.player = {
                name: window._pendingName,
                class: classKey,  className: classData.name,
                level: 1,  xp: 0,  xpToNext: 100,
                hp: classData.hp + stats.con * 5,
                maxHp: classData.hp + stats.con * 5,
                mp: classData.mp,  maxMp: classData.mp,
                strength: classData.strength,   // legacy weapon-calc field
                defense:  classData.defense,
                magic:    classData.magic,
                speed:    classData.speed,
                gold: 100,
                weapon: classData.startWeapon,
                armor:  classData.startArmor,
                inventory:  [classData.startWeapon, classData.startArmor],
                knownSpells: getStartingSpells(classKey),
                defeatedMasters: [],
                unlockedAreas:  ['forest'],
                // ‚îÄ‚îÄ new stat block ‚îÄ‚îÄ
                str: stats.str,  dex: stats.dex,  wis: stats.wis,
                cha: stats.cha,  con: stats.con,  lck: stats.lck
            };
            gameState.currentLocation = 'town';
            showTown();
        }

        function getStartingSpells(classKey) {
            const spellMap = {
                mage: ['fireball'],
                cleric: ['heal'],
                paladin: ['heal', 'holy_light'],
                ranger: [],
                warrior: [],
                rogue: []
            };
            return spellMap[classKey] || [];
        }

        function showTown() {
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">${LOCATIONS.town.name}</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>${LOCATIONS.town.description}</p>
                    <p style="color: var(--border-color); font-size: 14px;">Modem Speed: ${currentModemSpeed}</p>
                </div>
                <div style="margin: 20px 0;">
                    <div class="menu-option" onclick="showShop()">‚ñ∫ VISIT SHOP</div>
                    <div class="menu-option" onclick="restAtInn()">‚ñ∫ REST AT INN (${calcInnCost(gameState.player.cha)} Gold)</div>
                    <div class="menu-option" onclick="showInventory()">‚ñ∫ INVENTORY</div>
                    <div class="menu-option" onclick="showExplore()">‚ñ∫ EXPLORE WORLD</div>
                    <div class="menu-option" onclick="showModemSettings()">‚ñ∫ MODEM SETTINGS</div>
                    <div class="menu-option" onclick="saveGame()">‚ñ∫ SAVE GAME</div>
                    <div class="menu-option" onclick="showMainMenu()">‚ñ∫ QUIT TO MENU</div>
                </div>
            `;
        }

        function showModemSettings() {
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">üìû MODEM SETTINGS üìû</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>Select your connection speed:</p>
                    <p style="font-size: 14px; color: var(--border-color);">Current: ${currentModemSpeed}</p>
                </div>
                <div style="margin: 20px 0;">
                    <div class="menu-option ${currentModemSpeed === '14.4k' ? 'equipped' : ''}" onclick="setModemSpeed('14.4k')">
                        ‚ñ∫ 14.4k MODEM (Slowest - Most Authentic)
                    </div>
                    <div class="menu-option ${currentModemSpeed === '28.8k' ? 'equipped' : ''}" onclick="setModemSpeed('28.8k')">
                        ‚ñ∫ 28.8k MODEM (Slow - Classic BBS Feel)
                    </div>
                    <div class="menu-option ${currentModemSpeed === '56k' ? 'equipped' : ''}" onclick="setModemSpeed('56k')">
                        ‚ñ∫ 56k MODEM (Medium - Faster Loading)
                    </div>
                    <div class="menu-option ${currentModemSpeed === 'instant' ? 'equipped' : ''}" onclick="setModemSpeed('instant')">
                        ‚ñ∫ INSTANT (No Delay - Modern)
                    </div>
                </div>
                <div class="message" style="border-color: var(--highlight-color);">
                    <p style="color: var(--highlight-color);">‚ÑπÔ∏è INFO</p>
                    <p style="font-size: 14px;">Modem speed affects how quickly text appears on screen.</p>
                    <p style="font-size: 14px;">Lower speeds = more authentic 1990s BBS experience!</p>
                    <p style="font-size: 14px;">Combat timer won't start until screen finishes loading.</p>
                </div>
                <button onclick="showTown()">BACK TO TOWN</button>
            `;
        }

        function setModemSpeed(speed) {
            currentModemSpeed = speed;
            showModemSettings();
        }

        function renderPlayerStats() {
            const p = gameState.player;
            const hpPercent = (p.hp / p.maxHp) * 100;
            const mpPercent = (p.mp / p.maxMp) * 100;
            const xpPercent = (p.xp / p.xpToNext) * 100;

            return `
                <div class="stats-bar">
                    <div>
                        <span class="stat-label">${p.name}</span> - Level ${p.level} ${p.className}
                    </div>
                    <div>
                        <span class="stat-label">Gold:</span> ${p.gold}
                    </div>
                </div>
                <div class="stats-bar">
                    <div>
                        <span class="stat-label">HP:</span> ${p.hp}/${p.maxHp}
                        <div class="progress-bar">
                            <div class="progress-fill hp-bar" style="width: ${hpPercent}%"></div>
                        </div>
                    </div>
                    <div>
                        <span class="stat-label">MP:</span> ${p.mp}/${p.maxMp}
                        <div class="progress-bar">
                            <div class="progress-fill mp-bar" style="width: ${mpPercent}%"></div>
                        </div>
                    </div>
                    <div>
                        <span class="stat-label">XP:</span> ${p.xp}/${p.xpToNext}
                        <div class="progress-bar">
                            <div class="progress-fill xp-bar" style="width: ${xpPercent}%"></div>
                        </div>
                    </div>
                </div>
            `;
        }

        function showShop() {
            const screen = document.getElementById('mainScreen');
            
            let shopHtml = `
                <div class="location-header">MERCHANT SHOP</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>Welcome to my shop! What can I do for you?</p>
                </div>
                <div style="margin: 20px 0;">
                    <button onclick="showShopBuy()" style="margin-right: 10px;">üí∞ BUY ITEMS</button>
                    <button onclick="showShopSell()">üíé SELL ITEMS</button>
                </div>
                <div id="shopContent"></div>
                <button onclick="showTown()">LEAVE SHOP</button>
            `;
            
            screen.innerHTML = shopHtml;
            showShopBuy(); // Default to buy tab
        }

        function showShopBuy() {
            let shopHtml = `
                <div style="margin: 20px 0;">
                    <h3 style="color: var(--highlight-color);">WEAPONS</h3>
                    <div class="inventory-grid">
            `;

            Object.keys(WEAPONS).forEach(key => {
                const weapon = WEAPONS[key];
                if (weapon.level <= gameState.player.level + 2) {
                    const owned = gameState.player.inventory.includes(key);
                    const equipped = gameState.player.weapon === key;
                    const qualityColor = QUALITY_CONFIG[weapon.quality].color;
                    const qualityBonus = QUALITY_CONFIG[weapon.quality].bonus;
                    const totalDmg = weapon.baseDamage + qualityBonus;
                    const totalMag = weapon.baseMagicDamage + qualityBonus;
                    
                    shopHtml += `
                        <div class="item-card ${equipped ? 'equipped' : ''}">
                            <div style="color: ${qualityColor};">${weapon.name}</div>
                            <div>DMG: ${totalDmg} | MAG: ${totalMag}</div>
                            <div>Level: ${weapon.level}</div>
                            ${owned ? '<div style="color: var(--border-color);">OWNED</div>' : 
                              `<button onclick="buyItem('weapon', '${key}', ${weapon.cost})">Buy ${weapon.cost}G</button>`}
                            ${gameState.player.cha ? '<div style="color:#8aaa8a;font-size:15px;">CHA disc: ' + calcChaDiscount(gameState.player.cha) + '%</div>' : ''}
                        </div>
                    `;
                }
            });

            shopHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">ARMOR</h3>
                    <div class="inventory-grid">
            `;

            Object.keys(ARMOR).forEach(key => {
                const armor = ARMOR[key];
                if (armor.level <= gameState.player.level + 2) {
                    const owned = gameState.player.inventory.includes(key);
                    const equipped = gameState.player.armor === key;
                    const qualityColor = QUALITY_CONFIG[armor.quality].color;
                    const qualityBonus = QUALITY_CONFIG[armor.quality].bonus;
                    const totalDef = armor.baseDefense + qualityBonus;
                    const totalMag = (armor.baseMagicBonus || 0) + (qualityBonus > 0 ? Math.floor(qualityBonus / 2) : 0);
                    
                    shopHtml += `
                        <div class="item-card ${equipped ? 'equipped' : ''}">
                            <div style="color: ${qualityColor};">${armor.name}</div>
                            <div>DEF: ${totalDef}</div>
                            ${totalMag > 0 ? `<div>MAG+: ${totalMag}</div>` : ''}
                            <div>Level: ${armor.level}</div>
                            ${owned ? '<div style="color: var(--border-color);">OWNED</div>' : 
                              `<button onclick="buyItem('armor', '${key}', ${armor.cost})">Buy ${armor.cost}G</button>`}
                            ${gameState.player.cha ? '<div style="color:#8aaa8a;font-size:15px;">CHA disc: ' + calcChaDiscount(gameState.player.cha) + '%</div>' : ''}
                        </div>
                    `;
                }
            });

            shopHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">POTIONS</h3>
                    <div class="inventory-grid">
            `;

            // Add potions to shop
            const potionsForSale = ['health_potion', 'greater_health_potion', 'superior_health_potion',
                                   'mana_potion', 'greater_mana_potion', 'superior_mana_potion', 'elixir'];
            
            potionsForSale.forEach(key => {
                if (ITEMS[key]) {
                    const item = ITEMS[key];
                    shopHtml += `
                        <div class="item-card">
                            <div style="color: var(--highlight-color);">${item.name}</div>
                            <div>${item.description}</div>
                            <div>Power: ${item.power || 'Full'}</div>
                            <button onclick="buyItem('item', '${key}', ${item.cost})">Buy ${item.cost}G</button>
                            ${gameState.player.cha ? '<div style="color:#8aaa8a;font-size:15px;">CHA disc: ' + calcChaDiscount(gameState.player.cha) + '%</div>' : ''}
                        </div>
                    `;
                }
            });

            shopHtml += `
                    </div>
                </div>
            `;
            
            document.getElementById('shopContent').innerHTML = shopHtml;
        }

        function showShopSell() {
            const p = gameState.player;
            
            // Get all sellable items
            const sellableItems = p.inventory.filter(itemKey => {
                // Items with sellValue
                if (ITEMS[itemKey] && ITEMS[itemKey].sellValue > 0) return true;
                // Duplicate weapons/armor (not currently equipped)
                if (WEAPONS[itemKey] && itemKey !== p.weapon) return true;
                if (ARMOR[itemKey] && itemKey !== p.armor) return true;
                return false;
            });
            
            let sellHtml = '<h3 style="color: var(--highlight-color);">YOUR SELLABLE ITEMS</h3>';
            sellHtml += '<div class="inventory-grid">';
            
            if (sellableItems.length === 0) {
                sellHtml += '<div class="message">You have nothing to sell.</div>';
            } else {
                sellableItems.forEach(itemKey => {
                    let itemName, itemColor, sellValue, itemDesc;
                    
                    if (ITEMS[itemKey]) {
                        const item = ITEMS[itemKey];
                        itemName = item.name;
                        itemColor = '#00FF00';
                        sellValue = item.sellValue;
                        itemDesc = item.description;
                    } else if (WEAPONS[itemKey]) {
                        const weapon = WEAPONS[itemKey];
                        itemName = weapon.name;
                        itemColor = QUALITY_CONFIG[weapon.quality].color;
                        sellValue = Math.floor(weapon.cost * 0.5); // 50% of purchase price
                        const qualityBonus = QUALITY_CONFIG[weapon.quality].bonus;
                        itemDesc = `DMG: ${weapon.baseDamage + qualityBonus} | MAG: ${weapon.baseMagicDamage + qualityBonus}`;
                    } else if (ARMOR[itemKey]) {
                        const armor = ARMOR[itemKey];
                        itemName = armor.name;
                        itemColor = QUALITY_CONFIG[armor.quality].color;
                        sellValue = Math.floor(armor.cost * 0.5); // 50% of purchase price
                        const qualityBonus = QUALITY_CONFIG[armor.quality].bonus;
                        itemDesc = `DEF: ${armor.baseDefense + qualityBonus}`;
                    }
                    
                    sellHtml += `
                        <div class="item-card">
                            <div style="color: ${itemColor};">${itemName}</div>
                            <div style="font-size: 16px;">${itemDesc}</div>
                            <div style="color: var(--border-color); margin-top: 10px;">Sell for: ${sellValue}G</div>
                            <button onclick="sellItem('${itemKey}', ${sellValue})">SELL</button>
                        </div>
                    `;
                });
            }
            
            sellHtml += '</div>';
            document.getElementById('shopContent').innerHTML = sellHtml;
        }

        function sellItem(itemKey, baseValue) {
            const index = gameState.player.inventory.indexOf(itemKey);
            if (index === -1) { alert('Item not found!'); return; }
            const bonus = calcChaSellBonus(gameState.player.cha);
            const value = Math.floor(baseValue * (1 + bonus/100));
            gameState.player.inventory.splice(index, 1);
            gameState.player.gold += value;
            const itemName = getItemName(itemKey);
            alert(`Sold ${itemName} for ${value}g!` + (bonus > 0 ? ` (+${bonus}% CHA bonus)` : ''));
            showShopSell();
        }

        function buyItem(type, key, baseCost) {
            const disc   = calcChaDiscount(gameState.player.cha);
            const cost   = Math.max(1, Math.floor(baseCost * (1 - disc/100)));
            if (gameState.player.gold < cost) {
                alert('Not enough gold!');
                return;
            }
            gameState.player.gold -= cost;
            gameState.player.inventory.push(key);
            let itemName;
            if (type === 'weapon') itemName = WEAPONS[key].name;
            else if (type === 'armor') itemName = ARMOR[key].name;
            else if (type === 'item') itemName = ITEMS[key].name;
            alert(`Purchased ${itemName} for ${cost}g!` + (disc > 0 ? ` (${disc}% CHA discount)` : ''));
            showShopBuy();
        }

        function restAtInn() {
            const cost = calcInnCost(gameState.player.cha);
            if (gameState.player.gold < cost) {
                alert('Not enough gold!');
                return;
            }
            gameState.player.gold -= cost;
            gameState.player.hp = gameState.player.maxHp;
            gameState.player.mp = gameState.player.maxMp;
            alert('You rest at the inn and recover fully!');
            showTown();
        }

        function showInventory() {
            const p = gameState.player;
            const screen = document.getElementById('mainScreen');
            
            let invHtml = `
                <div class="location-header">INVENTORY</div>
                ${renderPlayerStats()}
                <div style="margin: 20px 0;">
                    <h3 style="color: var(--highlight-color);">WEAPONS</h3>
                    <div class="inventory-grid">
            `;

            p.inventory.filter(item => WEAPONS[item]).forEach(key => {
                const weapon = WEAPONS[key];
                const equipped = p.weapon === key;
                const qualityColor = QUALITY_CONFIG[weapon.quality].color;
                const qualityBonus = QUALITY_CONFIG[weapon.quality].bonus;
                const totalDmg = weapon.baseDamage + qualityBonus;
                const totalMag = weapon.baseMagicDamage + qualityBonus;
                
                invHtml += `
                    <div class="item-card ${equipped ? 'equipped' : ''}">
                        <div style="color: ${qualityColor};">${weapon.name}</div>
                        <div>DMG: ${totalDmg} | MAG: ${totalMag}</div>
                        ${equipped ? '<div style="color: var(--border-color);">EQUIPPED</div>' : 
                          `<button onclick="equipItem('weapon', '${key}')">EQUIP</button>`}
                    </div>
                `;
            });

            invHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">ARMOR</h3>
                    <div class="inventory-grid">
            `;

            p.inventory.filter(item => ARMOR[item]).forEach(key => {
                const armor = ARMOR[key];
                const equipped = p.armor === key;
                const qualityColor = QUALITY_CONFIG[armor.quality].color;
                const qualityBonus = QUALITY_CONFIG[armor.quality].bonus;
                const totalDef = armor.baseDefense + qualityBonus;
                const totalMag = (armor.baseMagicBonus || 0) + (qualityBonus > 0 ? Math.floor(qualityBonus / 2) : 0);
                
                invHtml += `
                    <div class="item-card ${equipped ? 'equipped' : ''}">
                        <div style="color: ${qualityColor};">${armor.name}</div>
                        <div>DEF: ${totalDef}</div>
                        ${totalMag > 0 ? `<div>MAG+: ${totalMag}</div>` : ''}
                        ${equipped ? '<div style="color: var(--border-color);">EQUIPPED</div>' : 
                          `<button onclick="equipItem('armor', '${key}')">EQUIP</button>`}
                    </div>
                `;
            });

            invHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">SPELLS</h3>
                    <div class="inventory-grid">
            `;

            if (p.knownSpells.length === 0) {
                invHtml += '<div class="message">No spells learned yet.</div>';
            } else {
                p.knownSpells.forEach(spellKey => {
                    const spell = SPELLS[spellKey];
                    invHtml += `
                        <div class="item-card">
                            <div style="color: var(--highlight-color);">${spell.name}</div>
                            <div>MP Cost: ${spell.mpCost}</div>
                            <div>Power: ${spell.power}</div>
                            <div>${spell.description}</div>
                        </div>
                    `;
                });
            }

            invHtml += `
                    </div>
                    <h3 style="color: var(--highlight-color); margin-top: 20px;">CONSUMABLES & ITEMS</h3>
                    <div class="inventory-grid">
            `;

            // Count and display items
            const itemCounts = {};
            p.inventory.filter(item => ITEMS[item]).forEach(key => {
                itemCounts[key] = (itemCounts[key] || 0) + 1;
            });

            if (Object.keys(itemCounts).length === 0) {
                invHtml += '<div class="message">No items.</div>';
            } else {
                Object.keys(itemCounts).forEach(itemKey => {
                    const item = ITEMS[itemKey];
                    const count = itemCounts[itemKey];
                    const color = item.type === 'sellable' ? '#FFD700' : 
                                 item.subtype === 'heal_hp' ? '#FF0000' :
                                 item.subtype === 'heal_mp' ? '#0000FF' : '#00FF00';
                    
                    invHtml += `
                        <div class="item-card">
                            <div style="color: ${color};">${item.name} x${count}</div>
                            <div style="font-size: 16px;">${item.description}</div>
                            ${item.sellValue ? `<div style="color: var(--border-color);">Value: ${item.sellValue}G</div>` : ''}
                        </div>
                    `;
                });
            }

            invHtml += `
                    </div>
                </div>
                <button onclick="showTown()">BACK</button>
            `;

            screen.innerHTML = invHtml;
        }

        function equipItem(type, key) {
            if (type === 'weapon') {
                gameState.player.weapon = key;
            } else {
                gameState.player.armor = key;
            }
            showInventory();
        }

        function showExplore() {
            const screen = document.getElementById('mainScreen');
            const p = gameState.player;
            
            let exploreHtml = `
                <div class="location-header">WORLD MAP</div>
                ${renderPlayerStats()}
                <div class="message">
                    <p>Where would you like to explore?</p>
                </div>
                <div style="margin: 20px 0;">
            `;

            Object.keys(LOCATIONS).forEach(key => {
                const loc = LOCATIONS[key];
                if (key !== 'town') {
                    const levelInfo = loc.enemyLevelRange ? 
                        ` (Lv ${loc.enemyLevelRange[0]}-${loc.enemyLevelRange[1]})` : '';
                    
                    const isUnlocked = p.unlockedAreas.includes(key);
                    const canChallengeMaster = !isUnlocked && p.level >= loc.requiredLevel;
                    
                    if (isUnlocked) {
                        // Unlocked area - can explore
                        exploreHtml += `
                            <div class="menu-option" onclick="exploreLocation('${key}')">
                                ‚ñ∫ ${loc.name}${levelInfo} <span style="color: var(--border-color);">‚úì UNLOCKED</span>
                            </div>
                        `;
                        
                        // Show master challenge option if available
                        const masterKey = `${p.class}_master_${key}`;
                        if (CLASS_MASTERS[masterKey] && !p.defeatedMasters.includes(masterKey)) {
                            const master = CLASS_MASTERS[masterKey];
                            if (p.level >= master.requiredLevel) {
                                exploreHtml += `
                                    <div class="menu-option" onclick="challengeMaster('${masterKey}')" style="border-color: var(--highlight-color); background: rgba(255, 255, 0, 0.1);">
                                        ‚öîÔ∏è CHALLENGE MASTER: ${master.name} (Lv ${master.level})
                                    </div>
                                `;
                            }
                        }
                    } else {
                        // Locked area
                        if (canChallengeMaster) {
                            // Can challenge master to unlock
                            const masterKey = getMasterKeyForArea(key);
                            const master = CLASS_MASTERS[masterKey];
                            exploreHtml += `
                                <div class="menu-option" style="opacity: 0.6; cursor: default;" onclick="alert('${loc.unlockMessage}')">
                                    üîí ${loc.name}${levelInfo} - LOCKED
                                </div>
                                <div class="menu-option" onclick="challengeMaster('${masterKey}')" style="border-color: var(--error-color); background: rgba(255, 0, 0, 0.1);">
                                    ‚öîÔ∏è CHALLENGE MASTER: ${master.name} (Lv ${master.level}) TO UNLOCK!
                                </div>
                            `;
                        } else {
                            // Level too low
                            exploreHtml += `
                                <div class="menu-option" style="opacity: 0.6; cursor: default;" onclick="alert('You need to reach level ${loc.requiredLevel} first!')">
                                    üîí ${loc.name}${levelInfo} - LOCKED (Need Lv ${loc.requiredLevel})
                                </div>
                            `;
                        }
                    }
                }
            });

            exploreHtml += `
                </div>
                <button onclick="showTown()">RETURN TO TOWN</button>
            `;

            screen.innerHTML = exploreHtml;
        }

        function getMasterKeyForArea(areaKey) {
            // Find which area unlocks this one
            const areaOrder = ['forest', 'plains', 'cave', 'crypt', 'volcano'];
            const index = areaOrder.indexOf(areaKey);
            if (index > 0) {
                const previousArea = areaOrder[index - 1];
                return `${gameState.player.class}_master_${previousArea}`;
            }
            return null;
        }

        function challengeMaster(masterKey) {
            const master = CLASS_MASTERS[masterKey];
            if (!master) {
                alert('Master not found!');
                return;
            }
            
            const p = gameState.player;
            
            // Check if already defeated
            if (p.defeatedMasters.includes(masterKey)) {
                alert('You have already defeated this master!');
                return;
            }
            
            // Check level requirement
            if (p.level < master.requiredLevel) {
                alert(`You need to be level ${master.requiredLevel} to challenge this master!`);
                return;
            }
            
            // Show master challenge screen
            const screen = document.getElementById('mainScreen');
            screen.innerHTML = `
                <div class="location-header">‚öîÔ∏è MASTER CHALLENGE ‚öîÔ∏è</div>
                ${renderPlayerStats()}
                <div class="message" style="border-color: var(--error-color); background: rgba(255, 0, 0, 0.1);">
                    <p style="color: var(--highlight-color); font-size: 24px;">${master.name}</p>
                    <p style="color: var(--text-color); margin: 10px 0;">${master.description}</p>
                    <p style="color: var(--border-color);">Level: ${master.level} | HP: ${master.baseHp} | Defense: ${master.baseDefense}</p>
                    <p style="color: var(--error-color); margin-top: 15px;">‚ö†Ô∏è THIS IS A BOSS FIGHT! ‚ö†Ô∏è</p>
                    <p>Defeating this master will unlock: <span style="color: var(--highlight-color);">${LOCATIONS[master.unlocks].name}</span></p>
                </div>
                <div class="message" style="border-color: var(--highlight-color);">
                    <p style="color: var(--highlight-color);">GUARANTEED REWARDS:</p>
                    ${master.guaranteedDrops.map(item => `<p>‚Ä¢ ${getItemName(item)}</p>`).join('')}
                    <p style="margin-top: 10px;">+ ${master.xp} XP and ${master.gold} Gold</p>
                </div>
                <div style="margin: 20px 0;">
                    <button onclick="startMasterBattle('${masterKey}')" style="background: var(--error-color); font-size: 22px;">‚öîÔ∏è BEGIN BATTLE ‚öîÔ∏è</button>
                    <button onclick="showExplore()">RETREAT</button>
                </div>
            `;
        }

        function startMasterBattle(masterKey) {
            const master = CLASS_MASTERS[masterKey];
            const masterMonster = {
                key: masterKey, name: master.name, rarity: 'epic',
                rarityColor: RARITY_CONFIG.epic.color,
                hp: master.baseHp, maxHp: master.baseHp,
                damage: master.baseDamage, defense: master.baseDefense,
                xp: master.xp, gold: master.gold, level: master.level,
                possibleDrops: master.possibleDrops, dropRates: master.dropRates,
                isMaster: true, masterKey: masterKey,
                guaranteedDrops: master.guaranteedDrops
            };
            gameState.combatState = {
                monsters: [masterMonster], currentTarget: 0,
                messages: [], defeatedMonsters: [],
                playerTimer:   10,
                enemyTimer:    18,   // bosses always get 18 s
                enemyDelay:    18,   // base delay for boss
                hitsLeft:      calcPlayerHits(gameState.player),
                enemyHits:     3,
                enemyHitsLeft: 3
            };
            // Open the terminal view (clear it fresh for a boss)
            openTerminalView(gameState.currentLocation);
            // stream the boss-intro line; show cards + start timer only after it finishes
            termAppend(`<span style="color:${RARITY_CONFIG.epic.color}; font-size:22px;">‚öîÔ∏è ${master.name} challenges you to an honorable duel! ‚öîÔ∏è</span>`, 'term-highlight', () => {
                renderEnemyCards();
                renderActionBar();
                startCombatTimer();
            });
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // HUD ‚Äì write once, update in place
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function initHud() {
            const p = gameState.player;
            document.getElementById('hudName').textContent = `${p.name} ‚Äì Lv ${p.level} ${p.className}`;
            updateHud();
        }
        function updateHud() {
            const p = gameState.player;
            document.getElementById('hudName').textContent  = `${p.name} ‚Äì Lv ${p.level} ${p.className}`;
            document.getElementById('hudGold').textContent  = `üí∞ ${p.gold} g`;
            document.getElementById('hudHpNums').textContent = `${p.hp} / ${p.maxHp}`;
            document.getElementById('hudMpNums').textContent = `${p.mp} / ${p.maxMp}`;
            document.getElementById('hudXpNums').textContent = `${p.xp} / ${p.xpToNext}`;
            document.getElementById('hudHpBar').style.width = ((p.hp / p.maxHp) * 100) + '%';
            document.getElementById('hudMpBar').style.width = ((p.mp / p.maxMp) * 100) + '%';
            document.getElementById('hudXpBar').style.width = ((p.xp / p.xpToNext) * 100) + '%';
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // TERMINAL VIEW helpers
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function openTerminalView(locKey) {
            // hide the mainScreen .screen div, show hud + terminal + actionBar
            document.getElementById('mainScreen').style.display  = 'none';
            document.getElementById('hud').style.display          = 'block';
            document.getElementById('terminalWindow').style.display = 'block';
            document.getElementById('actionBar').style.display    = 'block';
            initHud();
            // clear terminal if this is a fresh entry (not mid-explore)
            if (!gameState._terminalOpen) {
                document.getElementById('terminalWindow').innerHTML = '';
                gameState._terminalOpen = true;
                gameState._currentExploreArea = locKey;
                // print location header once
                termAppend(`‚îÄ‚îÄ ${LOCATIONS[locKey].name} ‚îÄ‚îÄ`, 'term-separator');
            }
        }
        function closeTerminalView() {
            document.getElementById('mainScreen').style.display    = 'block';
            document.getElementById('hud').style.display           = 'none';
            document.getElementById('terminalWindow').style.display = 'none';
            document.getElementById('actionBar').style.display     = 'none';
            gameState._terminalOpen = false;
            gameState._currentExploreArea = null;
        }
        // ‚îÄ‚îÄ modem-style line queue ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const termQueue   = [];          // pending { html, extraClass, onDone }
        let   termBusy    = false;       // true while a line is mid-stream

        function termAppend(html, extraClass, onDone) {
            termQueue.push({ html, extraClass, onDone: onDone || null });
            if (!termBusy) termDrain();
        }

        function termDrain() {
            if (termQueue.length === 0) { termBusy = false; return; }
            termBusy = true;
            const { html, extraClass, onDone } = termQueue.shift();

            const tw   = document.getElementById('terminalWindow');
            const line = document.createElement('div');
            line.className = 'term-line' + (extraClass ? ' ' + extraClass : '');
            tw.appendChild(line);
            tw.scrollTop = tw.scrollHeight;

            // separator lines & empty lines: instant
            if (extraClass === 'term-separator' || html === '') {
                line.innerHTML = html;
                if (onDone) onDone();
                termDrain();                // next item
                return;
            }

            // instant mode ‚Äì skip streaming
            if (currentModemSpeed === 'instant') {
                line.innerHTML = html;
                if (onDone) onDone();
                termDrain();
                return;
            }

            // ‚îÄ‚îÄ stream visible characters one-by-one ‚îÄ‚îÄ
            // Walk through the raw HTML but only "count" characters
            // that are NOT inside a tag.  Tags stay intact; reveal
            // feels character-accurate to the player.
            const charsPerTick = MODEM_SPEEDS[currentModemSpeed];   // 2 / 4 / 7
            let visibleCount   = 0;        // how many visible chars shown so far
            let totalVisible   = 0;        // total visible chars in the string

            // pre-count total visible chars
            { let inTag = false;
              for (let i = 0; i < html.length; i++) {
                  if   (html[i] === '<') inTag = true;
                  else if (html[i] === '>') inTag = false;
                  else if (!inTag) totalVisible++;
              }
            }

            function sliceToVisible(n) {
                // return the shortest prefix of html that contains exactly n visible chars
                let vis = 0, inTag = false;
                for (let i = 0; i < html.length; i++) {
                    if   (html[i] === '<') inTag = true;
                    else if (html[i] === '>') inTag = false;
                    else if (!inTag) { vis++; if (vis >= n) return html.slice(0, i + 1); }
                }
                return html;   // fallback: whole string
            }

            const ticker = setInterval(() => {
                visibleCount += charsPerTick;
                if (visibleCount >= totalVisible) {
                    clearInterval(ticker);
                    line.innerHTML = html;      // final: full html (closes all tags cleanly)
                    if (onDone) onDone();
                    termDrain();                // next queued line
                } else {
                    // show partial + blinking cursor
                    line.innerHTML = sliceToVisible(visibleCount) + '<span style="animation:blink 1s infinite;">_</span>';
                }
            }, 16);   // ~60 fps tick
        }

        function termClear() {
            document.getElementById('terminalWindow').innerHTML = '';
            termQueue.length = 0;   // also flush any pending lines
            termBusy = false;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // EXPLORE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function exploreLocation(locKey) {
            const location = LOCATIONS[locKey];
            const p = gameState.player;
            if (!p.unlockedAreas.includes(locKey)) {
                alert(location.unlockMessage || 'This area is locked!');
                showExplore();
                return;
            }
            gameState.currentLocation = locKey;

            // If we just arrived (from town / map), open the terminal fresh
            if (!gameState._terminalOpen || gameState._currentExploreArea !== locKey) {
                gameState._terminalOpen = false;   // force fresh open
                openTerminalView(locKey);
            } else {
                // Already in this area ‚Äì just add a separator
                termAppend('', 'term-separator');
            }

            if (Math.random() < 0.7) {
                const numMonsters = rollMonsterCount();
                const enemyKeys = [];
                for (let i = 0; i < numMonsters; i++) {
                    enemyKeys.push(location.encounters[Math.floor(Math.random() * location.encounters.length)]);
                }
                startCombat(enemyKeys);
            } else {
                termAppend(`You explore the area‚Ä¶ but find nothing.`, 'term-dim');
                renderActionBar();   // show "Continue / Town" buttons
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // COMBAT ‚Äì start / spawn / rarity
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function rollMonsterCount() {
            const r = Math.random() * 100;
            if (r < 70) return 1;
            if (r < 95) return 2;
            return 3;
        }
        function startCombat(enemyKeys) {
            if (!Array.isArray(enemyKeys)) enemyKeys = [enemyKeys];
            const monsters = enemyKeys.map(k => spawnMonsterWithRarity(k));

            let msg;
            if (monsters.length === 1)
                msg = `A wild <span style="color:${monsters[0].rarityColor};">${monsters[0].name}</span> appears!`;
            else {
                const names = monsters.map(m => `<span style="color:${m.rarityColor};">${m.name}</span>`).join(', ');
                msg = `${monsters.length} enemies appear: ${names}!`;
            }

            // enemy multi-hit based on rarity of first monster
            const rar0 = monsters[0].rarity;
            let eHits = 1;
            if      (rar0==='rare')      eHits = Math.random()<0.5 ? 2 : 1;
            else if (rar0==='epic')      eHits = 2;
            else if (rar0==='legendary') eHits = 2 + (Math.random()<0.5 ? 1 : 0);
            else if (rar0==='mythic')    eHits = 3;

            const enemyDelay = 15 + Math.floor(Math.random()*6);  // 15-20s, fixed for this combat
            gameState.combatState = {
                monsters, currentTarget: 0,
                messages: [], defeatedMonsters: [],
                playerTimer:   10,       // current countdown for next player action
                enemyTimer:    enemyDelay,  // current countdown for next enemy action
                enemyDelay:    enemyDelay,  // base delay for enemy (reused on reset)
                hitsLeft:      calcPlayerHits(gameState.player),
                enemyHits:     eHits,
                enemyHitsLeft: eHits
            };
            // stream the encounter line; show cards + start timer only after it finishes
            termAppend(msg, 'term-enemy', () => {
                renderEnemyCards();
                renderActionBar();
                startCombatTimer();
            });
        }

        function spawnMonsterWithRarity(enemyKey) {
            const template = ENEMIES[enemyKey];
            const rarity   = rollRarity();
            const mult     = RARITY_CONFIG[rarity].multiplier;
            return {
                key: enemyKey, name: template.name, rarity, rarityColor: RARITY_CONFIG[rarity].color,
                hp: Math.floor(template.baseHp * mult), maxHp: Math.floor(template.baseHp * mult),
                damage: Math.floor(template.baseDamage * mult), defense: Math.floor(template.baseDefense * mult),
                xp: Math.floor(template.baseXp * mult), gold: Math.floor(template.baseGold * mult),
                level: template.level, possibleDrops: template.possibleDrops, dropRates: template.dropRates
            };
        }
        function rollRarity() {
            const roll = Math.random() * 100;
            let cum = 0;
            for (const [rarity, config] of Object.entries(RARITY_CONFIG)) {
                cum += config.spawnWeight;
                if (roll < cum) return rarity;
            }
            return 'common';
        }
        function getRarityText(rarity) {
            return `<span style="color:${RARITY_CONFIG[rarity].color}; font-weight:bold;">${RARITY_CONFIG[rarity].name}</span>`;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ENEMY CARDS ‚Äì rendered into terminal, updated in place
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function renderEnemyCards() {
            // Remove any existing enemy-cards block, then append fresh
            const old = document.getElementById('enemy-cards-block');
            if (old) old.remove();

            const combat  = gameState.combatState;
            const tw      = document.getElementById('terminalWindow');
            const block   = document.createElement('div');
            block.id      = 'enemy-cards-block';
            block.style.margin = '8px 0';

            combat.monsters.forEach((enemy, i) => {
                const isTarget = (i === combat.currentTarget);
                const hpPct    = Math.max(0, (enemy.hp / enemy.maxHp) * 100);
                const card     = document.createElement('div');
                card.className = 'enemy-card' + (isTarget ? ' is-target' : '');
                card.id        = 'enemy-card-' + i;
                card.onclick   = () => selectTarget(i);
                card.style.cursor = 'pointer';
                card.innerHTML = `
                    <div class="ec-name">
                        <span style="color:${enemy.rarityColor};">${enemy.name}</span>
                        <span style="color:#aaa;"> (Lv ${enemy.level})</span>
                        ${combat.monsters.length > 1 ? `<span style="color:var(--highlight-color);"> #${i+1}</span>` : ''}
                        ${isTarget && combat.monsters.length > 1 ? ' <span style="color:var(--highlight-color);">‚óÑ TARGET</span>' : ''}
                    </div>
                    <div class="ec-hp" id="ec-hp-${i}">HP: ${enemy.hp} / ${enemy.maxHp}</div>
                    <div class="progress-bar" style="height:14px; margin-top:4px;">
                        <div class="progress-fill hp-bar" id="ec-bar-${i}" style="width:${hpPct}%"></div>
                    </div>`;
                block.appendChild(card);
            });
            tw.appendChild(block);
            tw.scrollTop = tw.scrollHeight;
        }
        function updateEnemyCards() {
            const combat = gameState.combatState;
            combat.monsters.forEach((enemy, i) => {
                const card  = document.getElementById('enemy-card-' + i);
                const hp    = document.getElementById('ec-hp-' + i);
                const bar   = document.getElementById('ec-bar-' + i);
                if (!card) return;
                // update target highlight
                card.className = 'enemy-card' + (i === combat.currentTarget ? ' is-target' : '');
                // update hp text & bar
                const hpPct = Math.max(0, (enemy.hp / enemy.maxHp) * 100);
                hp.textContent  = `HP: ${enemy.hp} / ${enemy.maxHp}`;
                bar.style.width = hpPct + '%';
            });
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ACTION BAR ‚Äì combat buttons / explore buttons / spell & potion menus
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function renderActionBar() {
            const ab = document.getElementById('actionBar');
            if (gameState.combatState) {
                const cs       = gameState.combatState;
                const monsters = cs.monsters;
                const p        = gameState.player;
                const maxHits  = calcPlayerHits(p);
                const hitsLeft = cs.hitsLeft !== undefined ? cs.hitsLeft : maxHits;
                const canAct   = hitsLeft > 0;

                // target buttons (multi-enemy)
                let targetBtns = '';
                if (monsters.length > 1) {
                    targetBtns = monsters.map((m, i) => {
                        const active = i === cs.currentTarget;
                        return `<button onclick="selectTarget(${i})" style="${active ? 'border-color:var(--highlight-color);color:var(--highlight-color);' : ''}" ${!canAct?'disabled':''}>
                            #${i+1} ${m.name}
                        </button>`;
                    }).join('');
                }

                // attack-charge pips  ‚óè‚óè‚óã
                const pips = '‚óè'.repeat(hitsLeft) + '‚óã'.repeat(maxHits - hitsLeft);
                const atkOff = hitsLeft <= 0;

                // status label
                let statusTag = '';
                if (hitsLeft === 0) statusTag = `<div style="color:#8aaa8a;font-size:17px;margin-bottom:4px;">‚è≥ Waiting for enemy attack‚Ä¶</div>`;

                ab.innerHTML = `
                    ${statusTag}
                    <div style="color:var(--highlight-color);font-size:18px;margin-bottom:4px;">
                        ATTACKS: <span style="letter-spacing:3px;">${pips}</span>
                        <span style="color:#8aaa8a;font-size:15px;"> (${hitsLeft}/${maxHits})</span>
                    </div>
                    ${targetBtns ? '<div class="action-label">TARGET:</div>' + targetBtns : ''}
                    <div class="action-label">ACTION:</div>
                    <button onclick="playerAttack()" ${atkOff?'disabled':''}>‚öîÔ∏è ATTACK</button>
                    <button onclick="showSpellMenu()"  ${!canAct?'disabled':''}>‚ú® CAST SPELL</button>
                    <button onclick="showPotionMenu()" ${!canAct?'disabled':''}>üß™ USE POTION</button>
                    <button onclick="playerDefend()"   ${!canAct?'disabled':''}>üõ°Ô∏è DEFEND</button>
                    <button onclick="attemptFlee()"    ${!canAct?'disabled':''}>üèÉ FLEE</button>
                `;
            } else {
                ab.innerHTML = `
                    <button onclick="exploreLocation('${gameState.currentLocation}')">üîç CONTINUE EXPLORING</button>
                    <button onclick="goBackToTown()">üèòÔ∏è RETURN TO TOWN</button>
                `;
            }
        }
        function goBackToTown() {
            closeTerminalView();
            showTown();
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // COMBAT TIMER
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function startCombatTimer() {
            if (gameState.combatTimer) clearInterval(gameState.combatTimer);
            gameState.combatTimer = setInterval(() => {
                const cs = gameState.combatState;
                if (!cs) { clearInterval(gameState.combatTimer); return; }
                
                // count down both timers independently
                if (cs.playerTimer > 0) cs.playerTimer--;
                if (cs.enemyTimer > 0)  cs.enemyTimer--;
                
                // player timer expired: lose 1 charge
                if (cs.playerTimer <= 0 && cs.hitsLeft > 0) {
                    cs.hitsLeft--;
                    cs.playerTimer = 10;  // reset for next charge
                    renderActionBar();
                    if (cs.hitsLeft > 0) {
                        termAppend('<span style="color:#8aaa8a;">Charge expired, next charge ready‚Ä¶</span>', 'term-dim');
                    } else {
                        termAppend('<span style="color:#8aaa8a;">All charges expired.</span>', 'term-dim');
                    }
                }
                
                // enemy timer expired: use 1 charge and attack
                if (cs.enemyTimer <= 0 && cs.enemyHitsLeft > 0) {
                    clearInterval(gameState.combatTimer);
                    enemyAttackSingle();  // fire one attack, then reset timer
                }
            }, 1000);
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PLAYER ACTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function playerAttack() {
            const cs = gameState.combatState;
            if (!cs || cs.hitsLeft <= 0) return;

            const p      = gameState.player;
            const ti     = cs.currentTarget;
            const enemy  = cs.monsters[ti];
            const weapon = WEAPONS[p.weapon];
            const qBonus = QUALITY_CONFIG[weapon.quality].bonus;
            let   total  = (weapon.baseDamage + qBonus) + p.strength
                         + (weapon.baseMagicDamage + qBonus)
                         + Math.floor(p.magic / 2) + (p.str || 0);
            let   dmg    = Math.max(1, total - enemy.defense);

            // crit check
            let crit = false;
            if (Math.random()*100 < calcCritChance(p.lck || 0)) {
                dmg  = Math.floor(dmg * 1.75);
                crit = true;
            }
            enemy.hp -= dmg;
            cs.hitsLeft--;
            cs.playerTimer = 10;  // reset timer for next charge

            const tName = cs.monsters.length > 1
                ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${ti+1}</span>`
                : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;
            updateEnemyCards();
            updateHud();
            renderActionBar();

            const critTag = crit ? ' <span style="color:#FFD700;">‚òÖ CRIT!</span>' : '';
            termAppend(`You attack ${tName} for <span class="dmg-enemy">${dmg} damage!</span>${critTag}`, null, () => {
                checkCombatEnd();
            });
        }

        function showSpellMenu() {
            const cs = gameState.combatState;
            if (!cs || cs.hitsLeft <= 0) return;
            const p = gameState.player;
            if (p.knownSpells.length === 0) {
                termAppend('You have no spells!', 'term-error');
                renderActionBar();
                return;
            }
            const ab = document.getElementById('actionBar');
            let html = '<div class="action-label">SELECT SPELL:</div>';
            p.knownSpells.forEach(sk => {
                const sp  = SPELLS[sk];
                const can = p.mp >= sp.mpCost;
                html += `<button onclick="castSpell('${sk}')" ${can?'':'disabled'}>${sp.name} (${sp.mpCost} MP) ‚Äì ${sp.description}</button> `;
            });
            html += `<br><button onclick="renderActionBar();">‚Üê BACK</button>`;
            ab.innerHTML = html;
        }

        function castSpell(spellKey) {
            const spell = SPELLS[spellKey];
            const p     = gameState.player;
            const cs    = gameState.combatState;
            p.mp -= spell.mpCost;

            if (spell.type === 'heal') {
                const heal = spell.power + Math.floor(p.magic * 1.5) + (p.wis || 0);
                p.hp = Math.min(p.maxHp, p.hp + heal);
                updateHud();
                renderActionBar();
                // heal does NOT trigger enemy or consume a hit ‚Äì timer keeps ticking
                termAppend(`You cast ${spell.name} and restore <span style="color:#88ff88;">${heal} HP!</span>`);
            } else {
                const ti    = cs.currentTarget;
                const enemy = cs.monsters[ti];
                let   dmg   = Math.max(1, (spell.power + p.magic + (p.wis||0)) - Math.floor(enemy.defense / 2));
                let crit = false;
                if (Math.random()*100 < calcCritChance(p.lck||0)) { dmg = Math.floor(dmg*1.75); crit = true; }
                enemy.hp -= dmg;
                cs.playerTimer = 10;  // spells don't consume charges but reset timer
                const tName = cs.monsters.length > 1
                    ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${ti+1}</span>`
                    : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;
                updateEnemyCards();
                updateHud();
                renderActionBar();
                const critTag = crit ? ' <span style="color:#FFD700;">‚òÖ CRIT!</span>' : '';
                termAppend(`You cast ${spell.name} on ${tName} for <span class="dmg-enemy">${dmg} damage!</span>${critTag}`, null, () => {
                    checkCombatEnd();
                });
            }
        }

        function playerDefend() {
            const cs = gameState.combatState;
            if (!cs || cs.hitsLeft <= 0) return;
            cs.defending = true;
            cs.hitsLeft  = 0;            // end player's turn
            renderActionBar();
            termAppend('You brace for impact‚Ä¶');  // timer keeps ticking ‚Üí enemy phase
        }

        function attemptFlee() {
            const cs = gameState.combatState;
            if (!cs || cs.hitsLeft <= 0) return;
            clearInterval(gameState.combatTimer);
            const p        = gameState.player;
            const fleePct  = Math.min(70, 30 + (p.dex||0)*3);
            if (Math.random()*100 < fleePct) {
                gameState.combatState = null;
                termAppend('You successfully fled!', 'term-highlight', () => {
                    renderActionBar();
                });
            } else {
                cs.hitsLeft--;       // burn one charge
                cs.playerTimer = 10; // reset
                renderActionBar();
                termAppend('Failed to escape!', 'term-error');
                startCombatTimer();  // resume
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // POTION MENU (in action bar)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function showPotionMenu() {
            const cs = gameState.combatState;
            if (!cs || cs.hitsLeft <= 0) return;
            const p = gameState.player;
            const potions = {};
            p.inventory.forEach(ik => {
                if (ITEMS[ik] && ['heal_hp','heal_mp','full_restore'].includes(ITEMS[ik].subtype)) {
                    if (!potions[ik]) potions[ik] = { item: ITEMS[ik], count: 0 };
                    potions[ik].count++;
                }
            });
            const keys = Object.keys(potions);
            if (keys.length === 0) {
                termAppend('You have no potions!', 'term-error');
                renderActionBar();
                return;
            }
            const ab = document.getElementById('actionBar');
            let html = '<div class="action-label">USE POTION:</div>';
            keys.forEach(pk => {
                const pd  = potions[pk];
                const col = pd.item.subtype==='heal_hp' ? '#ff4444' : pd.item.subtype==='heal_mp' ? '#4488ff' : '#FFD700';
                html += `<button onclick="usePotion('${pk}')" style="color:${col};">${pd.item.name} x${pd.count} ‚Äì ${pd.item.description}</button> `;
            });
            html += `<br><button onclick="renderActionBar();">‚Üê BACK</button>`;
            ab.innerHTML = html;
        }

        function usePotion(potionKey) {
            const potion = ITEMS[potionKey];
            const p      = gameState.player;
            let msg;
            if (potion.subtype === 'heal_hp') {
                const actual = Math.min(p.maxHp - p.hp, potion.power);
                p.hp = Math.min(p.maxHp, p.hp + potion.power);
                msg = `Used ${potion.name} ‚Äì restored <span style="color:#88ff88;">${actual} HP!</span>`;
            } else if (potion.subtype === 'heal_mp') {
                const actual = Math.min(p.maxMp - p.mp, potion.power);
                p.mp = Math.min(p.maxMp, p.mp + potion.power);
                msg = `Used ${potion.name} ‚Äì restored <span style="color:#88ff88;">${actual} MP!</span>`;
            } else if (potion.subtype === 'full_restore') {
                const hpR = p.maxHp - p.hp, mpR = p.maxMp - p.mp;
                p.hp = p.maxHp; p.mp = p.maxMp;
                msg = `Used ${potion.name} ‚Äì fully restored <span style="color:#88ff88;">${hpR} HP & ${mpR} MP!</span>`;
            }
            const idx = p.inventory.indexOf(potionKey);
            if (idx !== -1) p.inventory.splice(idx, 1);
            updateHud();
            renderActionBar();
            termAppend(msg);   // no callback ‚Äì timer keeps ticking, player can still act
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ENEMY ATTACK
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function enemyAttackSingle() {
            // Enemy uses ONE charge, attacks once, then resets its own timer
            const cs       = gameState.combatState;
            const monsters = cs.monsters;
            const p        = gameState.player;
            const armor    = ARMOR[p.armor];
            const qBonus   = QUALITY_CONFIG[armor.quality].bonus;
            let   totalDef = p.defense + armor.baseDefense + qBonus + (p.con || 0);
            if (cs.defending) { totalDef *= 2; cs.defending = false; }

            const dodgePct = calcDodgeChance(p.dex || 0);

            // Each monster in the pack gets ONE hit
            const hits = [];
            monsters.forEach((enemy, i) => {
                const eName = monsters.length > 1
                    ? `<span style="color:${enemy.rarityColor};">${enemy.name} #${i+1}</span>`
                    : `<span style="color:${enemy.rarityColor};">${enemy.name}</span>`;
                
                if (!p.godMode && Math.random()*100 < dodgePct) {
                    hits.push({ eName, dodged: true });
                } else {
                    const dmg = Math.max(1, enemy.damage - totalDef);
                    if (!p.godMode) p.hp -= dmg;
                    hits.push({ eName, dmg, dodged: false, godMode: p.godMode });
                }
            });
            
            cs.enemyHitsLeft--;
            updateHud();

            // after attack messages stream, reset enemy timer and resume
            const afterAttack = () => {
                if (p.hp <= 0 && !p.godMode) {
                    endCombat(false);
                } else {
                    // reset enemy timer for next charge (keep using same base delay)
                    cs.enemyTimer = cs.enemyDelay;
                    renderActionBar();
                    startCombatTimer();
                }
            };

            hits.forEach((hit, i) => {
                const isLast = (i === hits.length - 1);
                if (hit.godMode) {
                    termAppend(`${hit.eName} attacks but you are INVINCIBLE!`, 'term-highlight', isLast ? afterAttack : null);
                } else if (hit.dodged) {
                    termAppend(`${hit.eName} attacks‚Ä¶ <span style="color:#88ff88;">DODGED!</span>`, null, isLast ? afterAttack : null);
                } else {
                    termAppend(`${hit.eName} attacks for <span class="dmg-player">${hit.dmg} damage!</span>`, null, isLast ? afterAttack : null);
                }
            });
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CHECK / END COMBAT
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function checkCombatEnd() {
            const monsters = gameState.combatState.monsters;
            const ti       = gameState.combatState.currentTarget;
            if (!gameState.combatState.defeatedMonsters) gameState.combatState.defeatedMonsters = [];

            if (monsters[ti].hp <= 0) {
                const dead = monsters[ti];
                gameState.combatState.defeatedMonsters.push(dead);
                monsters.splice(ti, 1);
                if (gameState.combatState.currentTarget >= monsters.length)
                    gameState.combatState.currentTarget = Math.max(0, monsters.length - 1);

                // stream the "defeated" line, then decide what's next
                termAppend(`<span style="color:${dead.rarityColor};">${dead.name}</span> has been defeated!`, 'term-victory', () => {
                    if (monsters.length === 0) {
                        endCombat(true);
                    } else {
                        renderEnemyCards();
                        // remaining enemies still alive ‚Äì player keeps acting
                    }
                });
            } else {
                // target not dead ‚Äì do nothing, timer keeps ticking
            }
        }

        function endCombat(victory) {
            clearInterval(gameState.combatTimer);
            gameState.combatTimer = null;

            if (!victory) {
                gameState.player.hp   = gameState.player.maxHp;
                gameState.player.mp   = gameState.player.maxMp;
                gameState.player.gold = Math.floor(gameState.player.gold / 2);
                gameState.combatState = null;
                updateHud();
                termAppend('You have been defeated‚Ä¶ You wake up in town.', 'term-error', () => {
                    setTimeout(() => { closeTerminalView(); showTown(); }, 1200);
                });
                return;
            }

            // ‚îÄ‚îÄ victory ‚îÄ‚îÄ
            const defeated     = gameState.combatState.defeatedMonsters || [];
            const isMaster     = defeated.some(m => m.isMaster);
            let masterData     = null, unlockedArea = null;

            if (isMaster) {
                const m = defeated.find(d => d.isMaster);
                masterData  = CLASS_MASTERS[m.masterKey];
                unlockedArea = masterData.unlocks;
                if (!gameState.player.defeatedMasters.includes(m.masterKey))
                    gameState.player.defeatedMasters.push(m.masterKey);
                if (!gameState.player.unlockedAreas.includes(unlockedArea))
                    gameState.player.unlockedAreas.push(unlockedArea);
                // guarantee drops
                masterData.guaranteedDrops.forEach(ik => {
                    if (!defeated[0].possibleDrops) defeated[0].possibleDrops = [];
                    if (!defeated[0].possibleDrops.includes(ik)) defeated[0].possibleDrops.push(ik);
                    if (!defeated[0].dropRates) defeated[0].dropRates = {};
                    defeated[0].dropRates[WEAPONS[ik] || ARMOR[ik] ? getItemQuality(ik) : 'common'] = 1.0;
                });
            }

            let totalXp = 0, totalGold = 0, allLoot = [];
            defeated.forEach(e => {
                totalXp  += e.xp;
                totalGold += e.gold;
                allLoot   = allLoot.concat(rollLoot(e));
            });
            gameState.player.xp   += totalXp;
            gameState.player.gold += totalGold;

            // ‚îÄ‚îÄ print results into terminal ‚îÄ‚îÄ
            termAppend('', 'term-separator');
            if (isMaster) {
                termAppend(`üèÜ ${masterData.name} HAS BEEN DEFEATED! üèÜ`, 'term-victory');
                termAppend(`‚ú® ${LOCATIONS[unlockedArea].name} IS NOW UNLOCKED! ‚ú®`, 'term-loot');
            }
            if (defeated.length === 1)
                termAppend(`You defeated <span style="color:${defeated[0].rarityColor};">${defeated[0].name}</span>!`, 'term-highlight');
            else {
                termAppend(`You defeated ${defeated.length} enemies!`, 'term-highlight');
                defeated.forEach(e => termAppend(`  ‚Ä¢ <span style="color:${e.rarityColor};">${e.name}</span>`));
            }
            termAppend(`Gained <span style="color:#FFD700;">${totalXp} XP</span> and <span style="color:#FFD700;">${totalGold} Gold</span>!`);

            if (allLoot.length > 0) {
                termAppend('‚ö° LOOT:', 'term-loot');
                allLoot.forEach(ik => {
                    gameState.player.inventory.push(ik);
                    termAppend(`  + <span style="color:${getItemColor(ik)};">${getItemName(ik)}</span>`, 'term-loot');
                });
            } else {
                termAppend('No items dropped‚Ä¶', 'term-dim');
            }

            // level-up check
            if (gameState.player.xp >= gameState.player.xpToNext) {
                levelUp();
                termAppend(`‚¨ÜÔ∏è LEVEL UP! You are now level ${gameState.player.level}!`, 'term-victory');
            }

            updateHud();
            gameState.combatState = null;

            // show continue / town / map buttons
            const ab = document.getElementById('actionBar');
            if (isMaster) {
                ab.innerHTML = `
                    <button onclick="closeTerminalView(); showExplore();">üó∫Ô∏è VIEW WORLD MAP</button>
                    <button onclick="goBackToTown()">üèòÔ∏è RETURN TO TOWN</button>`;
            } else {
                ab.innerHTML = `
                    <button onclick="exploreLocation('${gameState.currentLocation}')">üîç CONTINUE EXPLORING</button>
                    <button onclick="goBackToTown()">üèòÔ∏è RETURN TO TOWN</button>`;
            }
        }

        function levelUp() {
            const p = gameState.player;
            p.level++;
            p.xp -= p.xpToNext;
            p.xpToNext = Math.floor(p.xpToNext * 1.5);

            // legacy base stats
            p.maxHp += 15 + (p.con||0);   // CON scales HP gain
            p.hp     = p.maxHp;
            p.maxMp += 10;
            p.mp     = p.maxMp;
            p.strength += 2;
            p.defense  += 2;
            p.magic    += 2;
            p.speed    += 1;

            // new stat-block: +1 each
            if (p.str !== undefined) {
                p.str++; p.dex++; p.wis++; p.cha++; p.con++; p.lck++;
                // paladin bonus: extra +1 to both STR and WIS
                if (p.class === 'paladin') { p.str++; p.wis++; }
            }

            // Learn new spells
            const spellLevels = {
                2: ['fireball', 'heal'],
                3: ['holy_light'],
                4: ['lightning'],
                5: ['greater_heal'],
                6: ['ice_storm'],
                8: ['meteor']
            };

            if (spellLevels[p.level]) {
                spellLevels[p.level].forEach(spellKey => {
                    if (!p.knownSpells.includes(spellKey)) {
                        p.knownSpells.push(spellKey);
                    }
                });
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // LOOT DROP SYSTEM (Phase 1)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function rollLoot(monster) {
            const loot = [];
            const rarityBonus = RARITY_CONFIG[monster.rarity].dropBonus || 0;
            
            if (!monster.possibleDrops || monster.possibleDrops.length === 0) {
                return loot;
            }
            
            monster.possibleDrops.forEach(itemKey => {
                let dropChance = 0;
                
                // Determine base drop chance
                if (ITEMS[itemKey]) {
                    // Consumable/sellable items use common drop rate
                    dropChance = monster.dropRates.common || 0.3;
                } else if (WEAPONS[itemKey] || ARMOR[itemKey]) {
                    // Equipment uses quality-based drop rates
                    const quality = getItemQuality(itemKey);
                    dropChance = monster.dropRates[quality] || 0.05;
                }
                
                // Apply rarity bonus + player LCK luck bonus
                const lckBonus = gameState.player ? calcLootBonus(gameState.player.lck || 0) / 100 : 0;
                const adjustedChance = Math.min(0.95, dropChance * (1 + rarityBonus * 0.1 + lckBonus));
                
                if (Math.random() < adjustedChance) {
                    loot.push(itemKey);
                }
            });
            
            // SPECIAL: Magical Butterknife check (Red Dragons only!)
            if (monster.key === 'red_dragon' && Math.random() < 0.000001) {
                loot.push('magical_butterknife');
                // Alert SYSOP terminal if active
                if (gameState.sysop && gameState.sysop.authenticated) {
                    terminalPrint('‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è ULTRA RARE DROP: MAGICAL BUTTERKNIFE! ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è', 'success');
                }
            }
            
            return loot;
        }

        function getItemName(itemKey) {
            if (WEAPONS[itemKey]) return WEAPONS[itemKey].name;
            if (ARMOR[itemKey]) return ARMOR[itemKey].name;
            if (ITEMS[itemKey]) return ITEMS[itemKey].name;
            if (SPELLS[itemKey]) return SPELLS[itemKey].name;
            return itemKey;
        }

        function getItemColor(itemKey) {
            if (WEAPONS[itemKey]) {
                return QUALITY_CONFIG[WEAPONS[itemKey].quality].color;
            }
            if (ARMOR[itemKey]) {
                return QUALITY_CONFIG[ARMOR[itemKey].quality].color;
            }
            // Default green for items
            return '#00FF00';
        }

        function getItemQualityText(itemKey) {
            if (WEAPONS[itemKey]) {
                const quality = WEAPONS[itemKey].quality;
                return `[${QUALITY_CONFIG[quality].name}]`;
            }
            if (ARMOR[itemKey]) {
                const quality = ARMOR[itemKey].quality;
                return `[${QUALITY_CONFIG[quality].name}]`;
            }
            return '';
        }

        function getItemQuality(itemKey) {
            if (WEAPONS[itemKey]) return WEAPONS[itemKey].quality;
            if (ARMOR[itemKey]) return ARMOR[itemKey].quality;
            return 'normal';
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // END LOOT DROP SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


        function respawn() {
            gameState.player.hp = gameState.player.maxHp;
            gameState.player.mp = gameState.player.maxMp;
            gameState.player.gold = Math.floor(gameState.player.gold / 2);
            gameState.combatState = null;
            showTown();
        }

        function saveGame() {
            try {
                const saveData = {
                    player: gameState.player,
                    currentLocation: gameState.currentLocation,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('dungeonQuestSave', JSON.stringify(saveData));
                alert('Game saved successfully!');
            } catch (e) {
                alert('Error saving game!');
            }
        }

        function loadGame() {
            try {
                const saveData = localStorage.getItem('dungeonQuestSave');
                if (!saveData) {
                    alert('No saved game found!');
                    return;
                }

                const data = JSON.parse(saveData);
                gameState.player = data.player;
                gameState.currentLocation = data.currentLocation;
                showTown();
            } catch (e) {
                alert('Error loading game!');
            }
        }

        // Start the game
        initGame();
    </script>
</body>
</html>